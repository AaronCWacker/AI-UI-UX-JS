<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>üå± Living Terrain Networks ‚Äî Generative Geometry Ecosystem</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#0a0e14;font-family:system-ui,Segoe UI,Inter,Arial}
    #ui{
      position:fixed;left:10px;top:10px;z-index:10;color:#fff;
      background:rgba(10,14,20,.88);border:1px solid rgba(100,200,150,.25);
      border-radius:12px;padding:12px;min-width:320px;backdrop-filter:blur(8px)
    }
    #ui .row{display:flex;justify-content:space-between;gap:10px;font-size:13px;margin:4px 0}
    #ui .big{font-weight:900;letter-spacing:.6px;margin-bottom:6px;color:#64c896}
    #ui .small{opacity:.85;font-size:11px;line-height:1.4;margin-top:8px;color:#a8d5ba}
    #controls{
      position:fixed;right:10px;top:10px;z-index:10;color:#fff;
      background:rgba(10,14,20,.88);border:1px solid rgba(100,200,150,.25);
      border-radius:12px;padding:12px;min-width:280px;backdrop-filter:blur(8px)
    }
    button{
      width:100%;margin:6px 0;padding:10px 10px;border-radius:10px;border:1px solid rgba(100,200,150,.3);
      background:rgba(40,80,60,.35);color:#a8d5ba;cursor:pointer;font-weight:750;
      transition:all 0.2s ease
    }
    button:hover{background:rgba(100,200,150,.25);color:#fff;border-color:#64c896}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(100,200,150,.2);border:1px solid rgba(100,200,150,.4);font-size:11px}
    #hint{
      position:fixed;left:10px;bottom:10px;z-index:10;color:#a8d5ba;
      background:rgba(10,14,20,.75);border:1px solid rgba(100,200,150,.2);
      border-radius:12px;padding:10px;font-family:ui-monospace,Consolas,monospace;font-size:11px;opacity:.92;backdrop-filter:blur(6px)
    }
    #legend{
      position:fixed;right:10px;bottom:10px;z-index:10;color:#a8d5ba;
      background:rgba(10,14,20,.75);border:1px solid rgba(100,200,150,.2);
      border-radius:12px;padding:10px;max-width:350px;
      font-size:11px;line-height:1.4;opacity:.92;backdrop-filter:blur(6px)
    }
    .dot{display:inline-block;width:10px;height:10px;border-radius:3px;margin-right:6px;vertical-align:-1px}
    .terrain-layer{margin:3px 0;padding-left:8px}
  </style>
</head>
<body>
  <div id="ui">
    <div class="big">üå± Living Terrain Networks <span class="pill">GENERATIVE</span></div>
    <div class="row"><span>Networks Active</span><span id="networks">0</span></div>
    <div class="row"><span>Vehicles</span><span id="vehicles">0</span></div>
    <div class="row"><span>Terrain Vertices</span><span id="vertices">0</span></div>
    <div class="row"><span>Grass Patches</span><span id="grass">0</span></div>
    <div class="row"><span>Flowers</span><span id="flowers">0</span></div>
    <div class="row"><span>Trees</span><span id="trees">0</span></div>
    <div class="row"><span>Life Cycles/sec</span><span id="cycles">0</span></div>
    <div class="row"><span>Camera</span><span id="camLabel">ORBIT</span></div>
    <div class="row"><span>FPS</span><span id="fps">0</span></div>
    <div class="small">
      üåç Each network reshapes terrain through movement. <b>Convoy groups</b> carve smooth roads with grass borders.
      <b>Explorer groups</b> create wild paths with flowers. <b>Mentor networks</b> build elevated terraces with trees.
      <br/>üîÑ Life cycles: vehicles spawn/despawn based on network health, vegetation grows/dies with terrain age.
    </div>
  </div>

  <div id="controls">
    <button id="pauseBtn">‚è∏Ô∏è Pause Simulation</button>
    <button id="camBtn">üé• Camera: Orbit</button>
    <button id="spawnNetBtn">‚ûï Spawn Network (5 vehicles)</button>
    <button id="spawnLargeBtn">‚ûï Spawn Large Network (15 vehicles)</button>
    <button id="evolveBtn">üß¨ Evolve Terrain</button>
    <button id="clearBtn">üåä Flood & Reset Terrain</button>
    <button id="resetBtn">‚ôªÔ∏è Full Reset</button>
  </div>

  <div id="hint">
    <b>Interaction</b>: Click terrain to spawn network seed ‚Ä¢ C = Camera ‚Ä¢ Space = Pause<br/>
    <b>Networks</b>: Form organically, reshape terrain through collective movement, spawn contextual life
  </div>

  <div id="legend">
    <div><b>üé® Terrain Layers (Concentric):</b></div>
    <div class="terrain-layer"><span class="dot" style="background:#2a3540"></span>Core Roads: High traffic paths</div>
    <div class="terrain-layer"><span class="dot" style="background:#3a5a4a"></span>Grass Border: Medium activity zones</div>
    <div class="terrain-layer"><span class="dot" style="background:#5a8a6a"></span>Wildflowers: Low traffic areas</div>
    <div class="terrain-layer"><span class="dot" style="background:#4a6a5a"></span>Forest Edge: Undisturbed regions</div>
    <div style="margin-top:8px"><b>üöó Network Types:</b></div>
    <div class="terrain-layer"><span class="dot" style="background:#ff6b9d"></span>Convoy: Smooth terrain shapers</div>
    <div class="terrain-layer"><span class="dot" style="background:#ffd93d"></span>Explorers: Wild path creators</div>
    <div class="terrain-layer"><span class="dot" style="background:#6bcf7f"></span>Mentors: Elevation builders</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
  (() => {
    // =========================================================
    // LIVING TERRAIN NETWORKS - GENERATIVE GEOMETRY ECOSYSTEM
    // =========================================================
    // Vehicle networks organically reshape terrain through movement
    // Each network type creates different terrain features
    // Concentric layers: roads ‚Üí grass ‚Üí flowers ‚Üí trees
    // Life cycles: spawn/despawn based on context
    // Terrain deforms with smooth interpolation
    // =========================================================

    const CFG = {
      TERRAIN_SIZE: 180,        // terrain grid size
      TERRAIN_RES: 80,          // vertices per side
      WORLD_SIZE: 800,

      INFLUENCE_RADIUS: 28,     // how far vehicles influence terrain
      ROAD_DEPTH: 2.5,          // how much roads depress terrain
      GRASS_RAISE: 0.8,         // grass border elevation
      FLOWER_HEIGHT: 1.2,
      TREE_HEIGHT: 2.0,

      VEHICLE_SPEED: 18,
      TURN_RATE: 2.2,
      
      NETWORK_MIN_SIZE: 3,
      NETWORK_MAX_SIZE: 20,
      SPAWN_INTERVAL: 8000,     // ms between auto-spawns
      DESPAWN_CHANCE: 0.002,    // per frame chance to despawn idle vehicle

      GRASS_SPAWN_RATE: 0.15,
      FLOWER_SPAWN_RATE: 0.08,
      TREE_SPAWN_RATE: 0.03,

      LIFE_CYCLE_RATE: 2,       // cycles per second
      MAX_GRASS: 800,
      MAX_FLOWERS: 400,
      MAX_TREES: 150,

      DT_CLAMP: 0.05
    };

    // ---------------- UI ----------------
    const $ = (id) => document.getElementById(id);
    let paused = false;

    // ---------------- THREE ----------------
    let scene, camera, renderer, clock;
    const CAM = { ORBIT:0, TOP:1, FOLLOW:2 };
    let camMode = CAM.ORBIT;
    let camAngle = 0;

    // ---------------- TERRAIN ----------------
    let terrainMesh;
    let terrainGeom;
    let terrainHeights = []; // 2D array of height values
    let terrainInfluence = []; // influence map for shaping
    let terrainAge = []; // age for vegetation spawning

    function initTerrain() {
      const res = CFG.TERRAIN_RES;
      terrainHeights = [];
      terrainInfluence = [];
      terrainAge = [];

      for (let i = 0; i <= res; i++) {
        terrainHeights[i] = [];
        terrainInfluence[i] = [];
        terrainAge[i] = [];
        for (let j = 0; j <= res; j++) {
          // initial random rolling hills
          const noise = (Math.sin(i * 0.1) + Math.cos(j * 0.15)) * 1.2;
          terrainHeights[i][j] = noise;
          terrainInfluence[i][j] = 0;
          terrainAge[i][j] = 0;
        }
      }

      // create mesh
      terrainGeom = new THREE.PlaneGeometry(
        CFG.TERRAIN_SIZE, 
        CFG.TERRAIN_SIZE, 
        res, 
        res
      );
      terrainGeom.rotateX(-Math.PI / 2);

      const mat = new THREE.MeshLambertMaterial({ 
        vertexColors: true,
        flatShading: false
      });

      terrainMesh = new THREE.Mesh(terrainGeom, mat);
      scene.add(terrainMesh);

      updateTerrainGeometry();
    }

    function updateTerrainGeometry() {
      const res = CFG.TERRAIN_RES;
      const positions = terrainGeom.attributes.position.array;
      const colors = new Float32Array(positions.length);

      for (let i = 0; i <= res; i++) {
        for (let j = 0; j <= res; j++) {
          const idx = (i * (res + 1) + j) * 3;
          const height = terrainHeights[i][j];
          const influence = terrainInfluence[i][j];
          const age = terrainAge[i][j];

          positions[idx + 1] = height;

          // color based on height and influence
          const color = getTerrainColor(height, influence, age);
          colors[idx] = color.r;
          colors[idx + 1] = color.g;
          colors[idx + 2] = color.b;
        }
      }

      terrainGeom.attributes.position.needsUpdate = true;
      terrainGeom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      terrainGeom.computeVertexNormals();

      $('vertices').textContent = (res + 1) * (res + 1);
    }

    function getTerrainColor(height, influence, age) {
      const color = new THREE.Color();
      
      // Core road (high influence, low height)
      if (influence > 0.7 && height < 0) {
        color.setRGB(0.16, 0.20, 0.25); // dark gray road
      }
      // Grass border (medium influence)
      else if (influence > 0.4) {
        const greenness = 0.3 + age * 0.15;
        color.setRGB(0.22 + greenness * 0.1, 0.35 + greenness * 0.2, 0.29 + greenness * 0.1);
      }
      // Wildflower zone (low influence, positive height)
      else if (influence > 0.15 && height > 0.5) {
        const bloom = Math.sin(age * 3) * 0.3 + 0.5;
        color.setRGB(0.35 + bloom * 0.2, 0.54 + bloom * 0.1, 0.41 + bloom * 0.15);
      }
      // Forest/wild (no influence)
      else {
        const wild = 0.25 + Math.random() * 0.1;
        color.setRGB(wild * 0.9, wild * 1.3, wild);
      }

      return color;
    }

    function worldToTerrain(wx, wz) {
      const res = CFG.TERRAIN_RES;
      const half = CFG.TERRAIN_SIZE / 2;
      const i = Math.floor(((wx + half) / CFG.TERRAIN_SIZE) * res);
      const j = Math.floor(((wz + half) / CFG.TERRAIN_SIZE) * res);
      return { i: clamp(i, 0, res), j: clamp(j, 0, res) };
    }

    function terrainToWorld(i, j) {
      const res = CFG.TERRAIN_RES;
      const half = CFG.TERRAIN_SIZE / 2;
      const x = (i / res) * CFG.TERRAIN_SIZE - half;
      const z = (j / res) * CFG.TERRAIN_SIZE - half;
      return { x, z };
    }

    // ---------------- VEHICLES ----------------
    let vehicles = [];
    let vehicleInst = null;

    class Vehicle {
      constructor(x, z, networkId, type) {
        this.pos = new THREE.Vector3(x, 0, z);
        this.vel = new THREE.Vector3((Math.random()-0.5)*4, 0, (Math.random()-0.5)*4);
        this.yaw = Math.random() * Math.PI * 2;
        this.networkId = networkId;
        this.type = type; // 'convoy', 'explorer', 'mentor'
        this.age = 0;
        this.idleTime = 0;
        this.influenceStrength = type === 'mentor' ? 1.5 : type === 'explorer' ? 0.7 : 1.0;
      }

      update(dt) {
        this.age += dt;

        // simple steering toward network center
        const network = networks.get(this.networkId);
        if (network) {
          const center = network.getCenter();
          const toCenter = new THREE.Vector3().subVectors(center, this.pos);
          toCenter.y = 0;
          
          if (toCenter.length() > 2) {
            toCenter.normalize();
            const fwd = new THREE.Vector3(Math.sin(this.yaw), 0, Math.cos(this.yaw));
            const crossY = fwd.x * toCenter.z - fwd.z * toCenter.x;
            this.yaw += crossY * dt * CFG.TURN_RATE;
          }
        }

        // forward movement
        const fwd = new THREE.Vector3(Math.sin(this.yaw), 0, Math.cos(this.yaw));
        this.vel.lerp(fwd.multiplyScalar(CFG.VEHICLE_SPEED), 0.1);

        // add some noise
        this.vel.x += (Math.random() - 0.5) * 2;
        this.vel.z += (Math.random() - 0.5) * 2;

        this.pos.add(this.vel.clone().multiplyScalar(dt));

        // bounds wrap
        const b = CFG.WORLD_SIZE / 2;
        if (this.pos.x > b) this.pos.x = -b;
        if (this.pos.x < -b) this.pos.x = b;
        if (this.pos.z > b) this.pos.z = -b;
        if (this.pos.z < -b) this.pos.z = b;

        // height from terrain
        this.pos.y = getTerrainHeight(this.pos.x, this.pos.z) + 1.2;

        // influence terrain
        this.influenceTerrain(dt);

        // idle detection
        if (this.vel.length() < 2) {
          this.idleTime += dt;
        } else {
          this.idleTime = 0;
        }
      }

      influenceTerrain(dt) {
        const tc = worldToTerrain(this.pos.x, this.pos.z);
        const res = CFG.TERRAIN_RES;
        const radius = Math.floor((CFG.INFLUENCE_RADIUS / CFG.TERRAIN_SIZE) * res);

        for (let di = -radius; di <= radius; di++) {
          for (let dj = -radius; dj <= radius; dj++) {
            const i = tc.i + di;
            const j = tc.j + dj;
            
            if (i < 0 || i > res || j < 0 || j > res) continue;

            const dist = Math.sqrt(di * di + dj * dj);
            if (dist > radius) continue;

            const falloff = 1 - (dist / radius);
            const strength = falloff * this.influenceStrength * dt * 0.8;

            // different effects based on type
            if (this.type === 'convoy') {
              // flatten and depress for roads
              terrainHeights[i][j] = lerp(terrainHeights[i][j], -CFG.ROAD_DEPTH, strength * 0.3);
              terrainInfluence[i][j] = Math.min(1, terrainInfluence[i][j] + strength * 0.4);
            } else if (this.type === 'explorer') {
              // gentle paths with varied height
              const noise = Math.sin(i * 0.5 + j * 0.5) * 0.5;
              terrainHeights[i][j] = lerp(terrainHeights[i][j], noise, strength * 0.15);
              terrainInfluence[i][j] = Math.min(1, terrainInfluence[i][j] + strength * 0.2);
            } else if (this.type === 'mentor') {
              // build up elevated terraces
              terrainHeights[i][j] = lerp(terrainHeights[i][j], CFG.TREE_HEIGHT, strength * 0.25);
              terrainInfluence[i][j] = Math.min(1, terrainInfluence[i][j] + strength * 0.3);
            }

            terrainAge[i][j] += dt * 0.1;
          }
        }
      }
    }

    function getTerrainHeight(wx, wz) {
      const tc = worldToTerrain(wx, wz);
      const res = CFG.TERRAIN_RES;
      if (tc.i >= 0 && tc.i <= res && tc.j >= 0 && tc.j <= res) {
        return terrainHeights[tc.i][tc.j];
      }
      return 0;
    }

    function rebuildVehicleInst() {
      if (vehicleInst) scene.remove(vehicleInst);

      const geom = new THREE.BoxGeometry(1, 0.6, 2);
      const mat = new THREE.MeshLambertMaterial({ vertexColors: true });
      vehicleInst = new THREE.InstancedMesh(geom, mat, vehicles.length);
      vehicleInst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      const colors = [];
      const color = new THREE.Color();
      
      for (let i = 0; i < vehicles.length; i++) {
        const v = vehicles[i];
        if (v.type === 'convoy') color.setRGB(1, 0.42, 0.62);
        else if (v.type === 'explorer') color.setRGB(1, 0.85, 0.24);
        else color.setRGB(0.42, 0.81, 0.50);
        
        colors.push(color.r, color.g, color.b);
      }

      vehicleInst.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(colors), 3);
      scene.add(vehicleInst);
    }

    function updateVehicleInstances() {
      if (!vehicleInst) return;
      
      const dummy = new THREE.Object3D();
      for (let i = 0; i < vehicles.length; i++) {
        const v = vehicles[i];
        dummy.position.copy(v.pos);
        dummy.rotation.set(0, v.yaw, 0);
        dummy.scale.set(1, 1, 1);
        dummy.updateMatrix();
        vehicleInst.setMatrixAt(i, dummy.matrix);
      }
      vehicleInst.instanceMatrix.needsUpdate = true;
    }

    // ---------------- NETWORKS ----------------
    const networks = new Map();
    let nextNetworkId = 0;

    class Network {
      constructor(id, type) {
        this.id = id;
        this.type = type;
        this.vehicles = [];
        this.createdAt = performance.now();
      }

      addVehicle(v) {
        this.vehicles.push(v);
      }

      getCenter() {
        if (this.vehicles.length === 0) return new THREE.Vector3();
        const sum = new THREE.Vector3();
        for (const v of this.vehicles) {
          sum.add(v.pos);
        }
        return sum.multiplyScalar(1 / this.vehicles.length);
      }

      update() {
        // remove dead vehicles
        this.vehicles = this.vehicles.filter(v => vehicles.includes(v));
      }

      isAlive() {
        return this.vehicles.length >= CFG.NETWORK_MIN_SIZE;
      }
    }

    function spawnNetwork(x, z, size, type) {
      const id = nextNetworkId++;
      const network = new Network(id, type);

      for (let i = 0; i < size; i++) {
        const jitter = 8;
        const vx = x + (Math.random() - 0.5) * jitter;
        const vz = z + (Math.random() - 0.5) * jitter;
        const vehicle = new Vehicle(vx, vz, id, type);
        vehicles.push(vehicle);
        network.addVehicle(vehicle);
      }

      networks.set(id, network);
      rebuildVehicleInst();
      $('vehicles').textContent = vehicles.length;
      $('networks').textContent = networks.size;
    }

    function updateNetworks() {
      for (const [id, network] of networks) {
        network.update();
        if (!network.isAlive()) {
          networks.delete(id);
        }
      }
      $('networks').textContent = networks.size;
    }

    // ---------------- VEGETATION ----------------
    let grassInst = null;
    let flowerInst = null;
    let treeInst = null;

    let grassPatches = [];
    let flowers = [];
    let trees = [];

    function initVegetation() {
      // Grass
      const grassGeom = new THREE.PlaneGeometry(1.5, 1.5);
      const grassMat = new THREE.MeshLambertMaterial({ 
        color: 0x4a7c59,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.8
      });
      grassInst = new THREE.InstancedMesh(grassGeom, grassMat, CFG.MAX_GRASS);
      grassInst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      scene.add(grassInst);

      // Flowers
      const flowerGeom = new THREE.ConeGeometry(0.3, 0.8, 6);
      const flowerMat = new THREE.MeshLambertMaterial({ 
        vertexColors: true 
      });
      flowerInst = new THREE.InstancedMesh(flowerGeom, flowerMat, CFG.MAX_FLOWERS);
      flowerInst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      
      const flowerColors = [];
      const flowerColor = new THREE.Color();
      for (let i = 0; i < CFG.MAX_FLOWERS; i++) {
        const hue = Math.random();
        flowerColor.setHSL(hue, 0.8, 0.6);
        flowerColors.push(flowerColor.r, flowerColor.g, flowerColor.b);
      }
      flowerInst.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(flowerColors), 3);
      scene.add(flowerInst);

      // Trees
      const treeGeom = new THREE.CylinderGeometry(0.5, 0.8, 4, 8);
      const treeMat = new THREE.MeshLambertMaterial({ color: 0x3a5a4a });
      treeInst = new THREE.InstancedMesh(treeGeom, treeMat, CFG.MAX_TREES);
      treeInst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
      scene.add(treeInst);
    }

    function spawnGrass(x, z) {
      if (grassPatches.length >= CFG.MAX_GRASS) return;
      const height = getTerrainHeight(x, z);
      grassPatches.push({ 
        pos: new THREE.Vector3(x, height + 0.3, z),
        age: 0,
        rotation: Math.random() * Math.PI
      });
    }

    function spawnFlower(x, z) {
      if (flowers.length >= CFG.MAX_FLOWERS) return;
      const height = getTerrainHeight(x, z);
      flowers.push({ 
        pos: new THREE.Vector3(x, height + 0.4, z),
        age: 0,
        hue: Math.random()
      });
    }

    function spawnTree(x, z) {
      if (trees.length >= CFG.MAX_TREES) return;
      const height = getTerrainHeight(x, z);
      trees.push({ 
        pos: new THREE.Vector3(x, height + 2, z),
        age: 0,
        scale: 0.5 + Math.random() * 0.5
      });
    }

    function updateVegetation(dt) {
      const dummy = new THREE.Object3D();

      // Update grass
      for (let i = grassPatches.length - 1; i >= 0; i--) {
        const g = grassPatches[i];
        g.age += dt;
        g.pos.y = getTerrainHeight(g.pos.x, g.pos.z) + 0.3;

        // die if on road
        const tc = worldToTerrain(g.pos.x, g.pos.z);
        if (terrainInfluence[tc.i] && terrainInfluence[tc.i][tc.j] > 0.7) {
          grassPatches.splice(i, 1);
          continue;
        }

        // die of old age
        if (g.age > 60 && Math.random() < 0.001) {
          grassPatches.splice(i, 1);
          continue;
        }

        dummy.position.copy(g.pos);
        dummy.rotation.set(-Math.PI/2, 0, g.rotation);
        dummy.scale.set(1, 1, 1);
        dummy.updateMatrix();
        grassInst.setMatrixAt(i, dummy.matrix);
      }
      grassInst.count = grassPatches.length;
      grassInst.instanceMatrix.needsUpdate = true;

      // Update flowers
      for (let i = flowers.length - 1; i >= 0; i--) {
        const f = flowers[i];
        f.age += dt;
        f.pos.y = getTerrainHeight(f.pos.x, f.pos.z) + 0.4;

        // die if too much influence
        const tc = worldToTerrain(f.pos.x, f.pos.z);
        if (terrainInfluence[tc.i] && terrainInfluence[tc.i][tc.j] > 0.5) {
          flowers.splice(i, 1);
          continue;
        }

        if (f.age > 40 && Math.random() < 0.002) {
          flowers.splice(i, 1);
          continue;
        }

        dummy.position.copy(f.pos);
        dummy.rotation.set(0, f.age * 0.5, 0);
        dummy.scale.set(1, 1, 1);
        dummy.updateMatrix();
        flowerInst.setMatrixAt(i, dummy.matrix);
      }
      flowerInst.count = flowers.length;
      flowerInst.instanceMatrix.needsUpdate = true;

      // Update trees
      for (let i = trees.length - 1; i >= 0; i--) {
        const t = trees[i];
        t.age += dt;
        t.pos.y = getTerrainHeight(t.pos.x, t.pos.z) + 2;

        // die if disturbed
        const tc = worldToTerrain(t.pos.x, t.pos.z);
        if (terrainInfluence[tc.i] && terrainInfluence[tc.i][tc.j] > 0.3) {
          trees.splice(i, 1);
          continue;
        }

        if (t.age > 80 && Math.random() < 0.0005) {
          trees.splice(i, 1);
          continue;
        }

        dummy.position.copy(t.pos);
        dummy.rotation.set(0, 0, 0);
        dummy.scale.set(t.scale, t.scale, t.scale);
        dummy.updateMatrix();
        treeInst.setMatrixAt(i, dummy.matrix);
      }
      treeInst.count = trees.length;
      treeInst.instanceMatrix.needsUpdate = true;

      $('grass').textContent = grassPatches.length;
      $('flowers').textContent = flowers.length;
      $('trees').textContent = trees.length;
    }

    function runLifeCycles() {
      // Spawn vegetation based on terrain properties
      const res = CFG.TERRAIN_RES;
      
      for (let k = 0; k < 3; k++) { // spawn a few per cycle
        const i = Math.floor(Math.random() * res);
        const j = Math.floor(Math.random() * res);
        const world = terrainToWorld(i, j);
        const influence = terrainInfluence[i][j];
        const age = terrainAge[i][j];
        const height = terrainHeights[i][j];

        // Grass: medium influence areas
        if (influence > 0.3 && influence < 0.7 && Math.random() < CFG.GRASS_SPAWN_RATE) {
          spawnGrass(world.x, world.z);
        }

        // Flowers: low influence, positive height
        if (influence > 0.1 && influence < 0.5 && height > 0.3 && Math.random() < CFG.FLOWER_SPAWN_RATE) {
          spawnFlower(world.x, world.z);
        }

        // Trees: very low influence, aged terrain
        if (influence < 0.2 && age > 5 && Math.random() < CFG.TREE_SPAWN_RATE) {
          spawnTree(world.x, world.z);
        }
      }

      // Despawn idle vehicles
      for (let i = vehicles.length - 1; i >= 0; i--) {
        const v = vehicles[i];
        if (v.idleTime > 10 && Math.random() < CFG.DESPAWN_CHANCE) {
          vehicles.splice(i, 1);
        }
      }

      if (vehicles.length !== vehicleInst?.count) {
        rebuildVehicleInst();
        $('vehicles').textContent = vehicles.length;
      }
    }

    // ---------------- INPUT ----------------
    const key = {};
    let mousePos = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();

    function setupInput() {
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        key[k] = true;
        if (k === 'c') cycleCamera();
        if (k === ' ') togglePause();
      });
      window.addEventListener('keyup', (e) => key[e.key.toLowerCase()] = false);

      window.addEventListener('click', (e) => {
        mousePos.x = (e.clientX / window.innerWidth) * 2 - 1;
        mousePos.y = -(e.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mousePos, camera);
        const intersects = raycaster.intersectObject(terrainMesh);

        if (intersects.length > 0) {
          const point = intersects[0].point;
          spawnNetworkAtPoint(point.x, point.z);
        }
      });
    }

    function spawnNetworkAtPoint(x, z) {
      const types = ['convoy', 'explorer', 'mentor'];
      const type = types[Math.floor(Math.random() * types.length)];
      const size = 5 + Math.floor(Math.random() * 6);
      spawnNetwork(x, z, size, type);
    }

    function cycleCamera() {
      camMode = (camMode + 1) % 3;
      const labels = ['ORBIT', 'TOP', 'FOLLOW'];
      $('camLabel').textContent = labels[camMode];
      $('camBtn').textContent = `üé• Camera: ${labels[camMode]}`;
    }

    function togglePause() {
      paused = !paused;
      $('pauseBtn').textContent = paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
    }

    // ---------------- SCENE ----------------
    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0e14);
      scene.fog = new THREE.Fog(0x0a0e14, 200, 600);

      camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1500);
      camera.position.set(120, 80, 120);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      document.body.appendChild(renderer.domElement);

      const amb = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(amb);

      const sun = new THREE.DirectionalLight(0xffffee, 0.8);
      sun.position.set(150, 200, 100);
      scene.add(sun);

      const hemi = new THREE.HemisphereLight(0x87ceeb, 0x3a5a4a, 0.4);
      scene.add(hemi);

      clock = new THREE.Clock();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function updateCamera(dt) {
      if (camMode === CAM.ORBIT) {
        camAngle += dt * 0.15;
        const radius = 140;
        camera.position.x = Math.cos(camAngle) * radius;
        camera.position.z = Math.sin(camAngle) * radius;
        camera.position.y = 90;
        camera.lookAt(0, 0, 0);
      } else if (camMode === CAM.TOP) {
        camera.position.lerp(new THREE.Vector3(0, 180, 0), 0.05);
        camera.lookAt(0, 0, 0);
      } else if (camMode === CAM.FOLLOW && vehicles.length > 0) {
        const target = vehicles[0].pos.clone();
        target.y += 15;
        target.z -= 25;
        camera.position.lerp(target, 0.1);
        camera.lookAt(vehicles[0].pos);
      }
    }

    // ---------------- UI BUTTONS ----------------
    function setupUI() {
      $('pauseBtn').onclick = () => togglePause();
      $('camBtn').onclick = () => cycleCamera();
      
      $('spawnNetBtn').onclick = () => {
        const types = ['convoy', 'explorer', 'mentor'];
        const type = types[Math.floor(Math.random() * types.length)];
        const x = (Math.random() - 0.5) * 60;
        const z = (Math.random() - 0.5) * 60;
        spawnNetwork(x, z, 5, type);
      };

      $('spawnLargeBtn').onclick = () => {
        const types = ['convoy', 'explorer', 'mentor'];
        const type = types[Math.floor(Math.random() * types.length)];
        const x = (Math.random() - 0.5) * 60;
        const z = (Math.random() - 0.5) * 60;
        spawnNetwork(x, z, 15, type);
      };

      $('evolveBtn').onclick = () => {
        // Add random noise to terrain for evolution
        const res = CFG.TERRAIN_RES;
        for (let i = 0; i <= res; i++) {
          for (let j = 0; j <= res; j++) {
            terrainHeights[i][j] += (Math.random() - 0.5) * 0.5;
          }
        }
        updateTerrainGeometry();
      };

      $('clearBtn').onclick = () => {
        // Reset terrain to water level
        const res = CFG.TERRAIN_RES;
        for (let i = 0; i <= res; i++) {
          for (let j = 0; j <= res; j++) {
            terrainHeights[i][j] = lerp(terrainHeights[i][j], -1, 0.5);
            terrainInfluence[i][j] *= 0.3;
            terrainAge[i][j] = 0;
          }
        }
        updateTerrainGeometry();
      };

      $('resetBtn').onclick = () => {
        vehicles = [];
        networks.clear();
        grassPatches = [];
        flowers = [];
        trees = [];
        initTerrain();
        rebuildVehicleInst();
        $('vehicles').textContent = 0;
        $('networks').textContent = 0;
      };
    }

    // ---------------- AUTO SPAWN ----------------
    let lastAutoSpawn = 0;

    function autoSpawn(now) {
      if (now - lastAutoSpawn > CFG.SPAWN_INTERVAL && networks.size < 8) {
        lastAutoSpawn = now;
        const types = ['convoy', 'explorer', 'mentor'];
        const type = types[Math.floor(Math.random() * types.length)];
        const x = (Math.random() - 0.5) * 100;
        const z = (Math.random() - 0.5) * 100;
        const size = 4 + Math.floor(Math.random() * 8);
        spawnNetwork(x, z, size, type);
      }
    }

    // ---------------- SIMULATION LOOP ----------------
    let fpsS = { frames: 0, t0: performance.now(), fps: 0 };
    let lastLifeCycle = 0;
    let lifeCyclesPerSec = 0;
    let cycleCount = 0;

    function step(dt) {
      const now = performance.now();

      // Auto spawn networks
      autoSpawn(now);

      // Update all vehicles
      for (const v of vehicles) {
        v.update(dt);
      }

      // Update networks
      updateNetworks();

      // Update vehicle instances
      updateVehicleInstances();

      // Life cycles
      if (now - lastLifeCycle > (1000 / CFG.LIFE_CYCLE_RATE)) {
        runLifeCycles();
        lastLifeCycle = now;
        cycleCount++;
      }

      // Update vegetation
      updateVegetation(dt);

      // Update terrain geometry
      if (Math.random() < 0.1) { // 10% chance per frame to update geometry (expensive)
        updateTerrainGeometry();
      }

      // Update camera
      updateCamera(dt);

      // FPS
      if (now - fpsS.t0 > 1000) {
        lifeCyclesPerSec = cycleCount;
        cycleCount = 0;
        fpsS.t0 = now;
      }
      $('cycles').textContent = lifeCyclesPerSec;
    }

    function animate() {
      requestAnimationFrame(animate);

      fpsS.frames++;
      const now = performance.now();
      if (now - fpsS.t0 > 600) {
        fpsS.fps = Math.round((fpsS.frames * 1000) / (now - fpsS.t0));
        fpsS.frames = 0;
        $('fps').textContent = fpsS.fps;
      }

      const dt = Math.min(clock.getDelta(), CFG.DT_CLAMP);
      if (!paused) step(dt);

      renderer.render(scene, camera);
    }

    // ---------------- UTILS ----------------
    function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }
    function lerp(a, b, t) { return a + (b - a) * t; }

    // ---------------- BOOTSTRAP ----------------
    function boot() {
      initThree();
      initTerrain();
      initVegetation();
      setupInput();
      setupUI();

      // Spawn initial networks
      spawnNetwork(20, 20, 8, 'convoy');
      spawnNetwork(-30, 30, 6, 'explorer');
      spawnNetwork(30, -20, 5, 'mentor');

      animate();
    }

    boot();
  })();
  </script>
</body>
</html>
