<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>‚öì Maritime AI Commander ‚Äî Evolved Playable Sim</title>
<meta name="description" content="Playable POV naval sandbox with touch controls, cognitive cone, interaction pings, safe collisions, optional GLB animations, plus a stable world grid and procedural architecture."/>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;background:linear-gradient(to bottom,#001a33,#000);color:#0ff;overflow:hidden;touch-action:none;}
#canvas-container{width:100vw;height:100vh;position:relative;}

/* HUD */
#hud{position:absolute;top:14px;left:14px;background:linear-gradient(135deg,rgba(0,30,60,.92),rgba(0,50,80,.92));border:2px solid #00d4ff;padding:12px;border-radius:12px;min-width:300px;z-index:100;backdrop-filter:blur(6px);}
.hud-title{font-size:18px;font-weight:900;color:#00d4ff;text-shadow:0 0 10px #00d4ff;}
.hud-subtitle{font-size:10px;color:#88ccff;font-style:italic;margin-bottom:8px;}
.hud-stat{font-size:12px;color:#88ccff;border-bottom:1px solid rgba(0,212,255,.16);margin:4px 0;padding-bottom:3px;}
.hud-value{float:right;color:#00ff88;}

/* Panels */
.panel{position:absolute;background:rgba(10,10,25,.92);border-radius:12px;padding:12px;border:2px solid #ff00ff;z-index:101;backdrop-filter:blur(6px);}
#controls{bottom:14px;left:14px;width:300px;}
#shop{bottom:14px;right:14px;border-color:#ffaa00;width:300px;}
#memory{top:14px;right:14px;max-width:380px;max-height:440px;overflow:auto;}
#cameraPanel{top:240px;left:14px;width:310px;border-color:#00ff88;}

@media (max-width: 820px){
  #hud{min-width:260px}
  #memory{display:none;}
  #cameraPanel{top:210px; display:none;}
  #shop{top:14px; right:14px; bottom:auto; width:220px;}
}

/* Buttons */
.btn{display:block;width:100%;margin:4px 0;padding:10px 12px;border-radius:10px;cursor:pointer;border:2px solid #00d4ff;background:linear-gradient(135deg,#001a33,#003366);color:#00d4ff;font-weight:900;letter-spacing:.2px;user-select:none;}
.btn:hover{background:#00d4ff;color:#000;}
.btn.active{background:#ff00ff;color:#fff;border-color:#ff00ff;}
.btn.warn{border-color:#ff6600;color:#ff6600;}
.btn.warn:hover{background:#ff6600;color:#000;}
.btn.placement{border-color:#00ff88; color:#00ff88;}
.btn.placement:hover{background:#00ff88; color:#000;}
.row{display:flex;gap:8px;}
.row .btn{flex:1;}
.small{font-size:10px;color:#aee;}

/* Memory */
.memory-entry{font-size:11px;margin:4px 0;padding:6px;background:rgba(80,0,80,.45);border-left:3px solid #f0f;}

/* Touch UI */
#touchUI{position:absolute;inset:0;pointer-events:none;z-index:120;}
.pad{position:absolute;width:150px;height:150px;border-radius:18px;border:2px solid rgba(0,212,255,.55);background:rgba(0,20,40,.20);pointer-events:auto;touch-action:none;}
#movePad{left:16px;bottom:16px;}
#lookPad{right:16px;bottom:16px;border-color:rgba(255,0,255,.55);}
.stick{position:absolute;left:50%;top:50%;width:56px;height:56px;border-radius:16px;transform:translate(-50%,-50%);background:rgba(0,212,255,.35);border:2px solid rgba(0,212,255,.8);}
#lookStick{background:rgba(255,0,255,.25);border-color:rgba(255,0,255,.75);}
.hint{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:11px;color:rgba(170,230,255,.75);text-align:center;pointer-events:none;}
#lookHint{color:rgba(255,180,255,.75);}
.badge{position:absolute;bottom:-18px;left:0;right:0;font-size:10px;text-align:center;color:rgba(180,220,255,.75);}

/* Mini toast */
#toast{position:absolute;left:50%;top:12px;transform:translateX(-50%);padding:8px 12px;border-radius:10px;border:1px solid rgba(0,212,255,.5);background:rgba(0,20,40,.85);color:#bff;font-size:14px;font-weight:bold;z-index:200;backdrop-filter:blur(6px);display:none; text-shadow: 0 0 5px #0ff;}

/* Crosshair for placement */
#crosshair{position:absolute;left:50%;top:50%;width:20px;height:20px;transform:translate(-50%,-50%);pointer-events:none;display:none;z-index:150;}
#crosshair::before, #crosshair::after{content:'';position:absolute;background:#0f0;box-shadow:0 0 5px #0f0;}
#crosshair::before{top:9px;left:0;width:20px;height:2px;}
#crosshair::after{top:0;left:9px;width:2px;height:20px;}
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="crosshair"></div>
<div id="toast"></div>
<input id="glbFile" type="file" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" style="display:none" />

<div id="hud">
  <div class="hud-title">‚öì MARITIME AI COMMANDER</div>
  <div class="hud-subtitle">Procedural Arch + Defensive Towers + Sim</div>
  <div class="hud-stat">Credits <span class="hud-value" id="gold">$2000</span></div>
  <div class="hud-stat">Allies <span class="hud-value" id="allies">0</span></div>
  <div class="hud-stat">Enemies <span class="hud-value" id="enemies">0</span></div>
  <div class="hud-stat">Score <span class="hud-value" id="score">0</span></div>
  <div class="hud-stat">Generation <span class="hud-value" id="gen">0</span></div>
</div>

<div id="controls" class="panel">
  <div style="color:#ff00ff;font-weight:900;margin-bottom:6px;">üéÆ OPERATIONS</div>
  <button class="btn" id="wave">üåä‚ûï Wave (+1 Ally / +5 Enemies)</button>
  <div class="row">
    <button class="btn" id="battle">‚öîÔ∏è Combat: OFF</button>
    <button class="btn" id="autoplay">ü§ñ Autoplay: OFF</button>
  </div>
  <div class="row">
    <button class="btn" id="interactToggle">üìç Pings: ON</button>
    <button class="btn" id="resetCam">üß≠ Recenter</button>
  </div>
  <button class="btn warn" id="panic">üö® PANIC MODE</button>
</div>

<div id="shop" class="panel">
  <div style="color:#ffaa00;font-weight:900;">üèóÔ∏è ARCHITECTURAL DEFENSE</div>
  <div style="font-size:10px;color:#cc8800;font-style:italic;margin-bottom:8px;">Click to select, click on land to place.</div>
  <button class="btn placement" data-tower="cannon" data-cost="200">üí• Brutalist Cannon $200</button>
  <button class="btn placement" data-tower="harpoon" data-cost="350">‚öúÔ∏è Art Deco Spire $350</button>
  <button class="btn placement" data-tower="net" data-cost="500">üèõÔ∏è Neo-Gothic Grid $500</button>
  <button class="btn placement" data-tower="aegis" data-cost="800">‚öõÔ∏è Aegis Nexus $800</button>
  <button class="btn warn" id="cancelPlacement" style="display:none;">‚ùå Cancel Placement</button>
</div>

<div id="cameraPanel" class="panel">
  <div style="color:#00ff88;font-weight:900;margin-bottom:6px;">üé• SYSTEM PANEL</div>
  <div class="row">
    <button class="btn" data-cam="orbit">üõ∞Ô∏è Orbit</button>
    <button class="btn" data-cam="chase">üèéÔ∏è Chase</button>
    <button class="btn" data-cam="free">ü™Ç Free</button>
  </div>
  <div class="row">
    <button class="btn" id="coneToggle">üß† Cone: ON</button>
    <button class="btn" id="gridToggle">üß≠ Grid: ON</button>
  </div>
</div>

<div id="memory" class="panel">
  <div style="color:#f0f;font-weight:900;">üß† VETERAN DOCTRINE</div>
  <div id="log"></div>
</div>

<div id="touchUI">
  <div id="movePad" class="pad">
    <div class="stick" id="moveStick"></div>
    <div class="hint">üïπÔ∏è MOVE</div>
  </div>
  <div id="lookPad" class="pad">
    <div class="stick" id="lookStick"></div>
    <div class="hint" id="lookHint">üëÜ LOOK</div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
<script>
const PLAYER_GLB_URL = "";
const PLAYER_GLB_SCALE = 1.0;

const clamp01 = v => Math.max(0, Math.min(1, v));
const lerp = (a,b,t)=>a+(b-a)*t;
const damp = (current, target, lambda, dt)=> lerp(current, target, 1 - Math.exp(-lambda*dt));
const toast = (msg)=>{
  const el = document.getElementById('toast');
  if(!el) return;
  el.textContent = msg;
  el.style.display = 'block';
  clearTimeout(toast._t);
  toast._t = setTimeout(()=> el.style.display='none', 2000);
};
const log = (msg)=>{
  const l = document.getElementById('log');
  if(!l) return;
  const e=document.createElement('div');
  e.className='memory-entry';
  e.textContent=`[${new Date().toLocaleTimeString()}] ${msg}`;
  l.prepend(e);
  while(l.children.length>26) l.removeChild(l.lastChild);
};

const game = {
  gold: 2000,
  score: 0,
  allies: [],
  enemies: [],
  towers: [],
  projectiles: [],
  battle: false,
  autoplay: false,
  profile: 'balanced',
  generation: 0,
};
const doctrine = { aggression:.5, focus:.5, kiting:.5 };

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x001a33, 70, 650);
scene.background = new THREE.Color(0x001226);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1800);
camera.position.set(0, 18, 42);

const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputEncoding = THREE.sRGBEncoding;
document.getElementById('canvas-container').appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0x405070, 0.6));
const hemi = new THREE.HemisphereLight(0x9ad6ff, 0x001018, 0.4);
scene.add(hemi);

const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(140, 240, 90);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
sun.shadow.camera.near = 10;
sun.shadow.camera.far = 800;
sun.shadow.camera.left = -260;
sun.shadow.camera.right = 260;
sun.shadow.camera.top = 260;
sun.shadow.camera.bottom = -260;
scene.add(sun);

const fill = new THREE.DirectionalLight(0x88ccff, 0.4);
fill.position.set(-140, 110, -70);
scene.add(fill);

const WATER_Y = 0;
const waterMat = new THREE.MeshStandardMaterial({
  color:0x004466, transparent:true, opacity:0.85, emissive:0x001018,
  roughness:0.2, metalness:0.8, polygonOffset:true, polygonOffsetFactor:1, polygonOffsetUnits:1
});
const water = new THREE.Mesh(new THREE.PlaneGeometry(1000,1000,1,1), waterMat);
water.rotation.x = -Math.PI/2;
water.receiveShadow = true;
scene.add(water);

const land = new THREE.Group();
scene.add(land);

function makeIsland(x,z,r,h){
  const geo = new THREE.ConeGeometry(r, h, 24, 1);
  geo.translate(0, h*0.5, 0);
  const mat = new THREE.MeshStandardMaterial({color:0x1a3322, roughness:0.9, metalness:0.1});
  const m = new THREE.Mesh(geo, mat);
  m.position.set(x, WATER_Y - 1, z);
  m.castShadow = true;
  m.receiveShadow = true;
  land.add(m);

  const rim = new THREE.Mesh(
    new THREE.TorusGeometry(r*0.75, r*0.15, 12, 32),
    new THREE.MeshStandardMaterial({color:0x443322, roughness:1, metalness:0})
  );
  rim.rotation.x = Math.PI/2;
  rim.position.set(x, WATER_Y + 0.2, z);
  rim.receiveShadow = true;
  land.add(rim);

  m.userData.collider = { x, z, r: r*0.78 };
}
makeIsland( 40,  20, 35, 10);
makeIsland(-60, -10, 45, 14);
makeIsland(  5, -70, 28, 8);
makeIsland( 80, -80, 50, 18);

let gridOn = true;
let grid = new THREE.GridHelper(1000, 200, 0x00ffff, 0x004455);
grid.position.y = WATER_Y + 0.1;
grid.material.transparent = true;
grid.material.opacity = 0.15;
scene.add(grid);

const matLib = {
  brutalMetal: new THREE.MeshStandardMaterial({color: 0x222222, roughness: 0.7, metalness: 0.8}),
  decoGold: new THREE.MeshStandardMaterial({color: 0xffaa00, roughness: 0.3, metalness: 0.9}),
  decoStone: new THREE.MeshStandardMaterial({color: 0xeeeeee, roughness: 0.9, metalness: 0.1}),
  neonBlue: new THREE.MeshStandardMaterial({color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 1.5}),
  gothicDark: new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.8, metalness: 0.3}),
  neonGreen: new THREE.MeshStandardMaterial({color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 2.0}),
  nexusWhite: new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.1, metalness: 0.5}),
  neonPurple: new THREE.MeshStandardMaterial({color: 0xaa00ff, emissive: 0xaa00ff, emissiveIntensity: 2.5}),
};

function createProceduralTowerMesh(type) {
  const group = new THREE.Group();
  let turretMesh = null;
  let animMeshes = [];

  if (type === 'cannon') {
    const baseGeo = new THREE.CylinderGeometry(3, 4, 4, 6);
    const base = new THREE.Mesh(baseGeo, matLib.brutalMetal);
    base.position.y = 2;
    base.castShadow = true; base.receiveShadow = true;
    group.add(base);

    const midGeo = new THREE.CylinderGeometry(2, 2.5, 3, 6);
    const mid = new THREE.Mesh(midGeo, matLib.brutalMetal);
    mid.position.y = 5.5;
    mid.castShadow = true; mid.receiveShadow = true;
    group.add(mid);

    turretMesh = new THREE.Group();
    turretMesh.position.y = 7.5;
    const tBox = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 4), matLib.brutalMetal);
    tBox.castShadow = true;
    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 5, 8), matLib.brutalMetal);
    barrel.rotation.x = Math.PI/2;
    barrel.position.set(0, 0, 2.5);
    const glowRing = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.1, 8, 16), matLib.neonBlue);
    glowRing.position.set(0, 0, 4.5);
    turretMesh.add(tBox, barrel, glowRing);
    group.add(turretMesh);
  } 
  else if (type === 'harpoon') {
    const b1 = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 2, 16), matLib.decoStone);
    b1.position.y = 1; b1.castShadow = true; b1.receiveShadow = true;
    const b2 = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 2, 16), matLib.decoStone);
    b2.position.y = 3; b2.castShadow = true; b2.receiveShadow = true;
    const b3 = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 4, 16), matLib.decoStone);
    b3.position.y = 6; b3.castShadow = true; b3.receiveShadow = true;
    group.add(b1, b2, b3);

    for(let i=0; i<4; i++){
      const col = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 8, 8), matLib.decoGold);
      const angle = (i/4)*Math.PI*2 + Math.PI/4;
      col.position.set(Math.cos(angle)*2.2, 4, Math.sin(angle)*2.2);
      col.castShadow = true;
      group.add(col);
    }

    const trim = new THREE.Mesh(new THREE.TorusGeometry(2.1, 0.15, 8, 32), matLib.decoGold);
    trim.position.y = 8; trim.rotation.x = Math.PI/2;
    group.add(trim);

    turretMesh = new THREE.Group();
    turretMesh.position.y = 8;
    const spire = new THREE.Mesh(new THREE.ConeGeometry(0.8, 6, 8), matLib.decoGold);
    spire.position.y = 3;
    spire.rotation.x = Math.PI/2;
    spire.position.set(0, 1, 2);
    turretMesh.add(spire);
    group.add(turretMesh);
  }
  else if (type === 'net') {
    const base = new THREE.Mesh(new THREE.CylinderGeometry(4, 5, 2, 8), matLib.gothicDark);
    base.position.y = 1; base.castShadow = true; base.receiveShadow = true;
    group.add(base);

    for(let i=0; i<8; i++){
      const p = new THREE.Mesh(new THREE.BoxGeometry(0.6, 8, 0.6), matLib.gothicDark);
      const a = (i/8)*Math.PI*2;
      p.position.set(Math.cos(a)*3, 6, Math.sin(a)*3);
      p.castShadow = true;
      group.add(p);
    }

    const ringTop = new THREE.Mesh(new THREE.TorusGeometry(3, 0.4, 8, 8), matLib.gothicDark);
    ringTop.position.y = 10; ringTop.rotation.x = Math.PI/2;
    group.add(ringTop);

    turretMesh = new THREE.Group();
    turretMesh.position.y = 6;
    const core = new THREE.Mesh(new THREE.IcosahedronGeometry(1.5, 0), matLib.neonGreen);
    turretMesh.add(core);
    animMeshes.push({mesh: core, rotSpeed: new THREE.Vector3(1, 2, 0.5)});
    group.add(turretMesh);
  }
  else if (type === 'aegis') {
    const dome = new THREE.Mesh(new THREE.SphereGeometry(4, 32, 16, 0, Math.PI*2, 0, Math.PI/2), matLib.nexusWhite);
    dome.position.y = 0; dome.castShadow = true; dome.receiveShadow = true;
    group.add(dome);

    const core = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), matLib.neonPurple);
    core.position.y = 7;
    group.add(core);

    turretMesh = new THREE.Group();
    turretMesh.position.y = 7;
    const r1 = new THREE.Mesh(new THREE.TorusGeometry(3, 0.2, 16, 64), matLib.nexusWhite);
    const r2 = new THREE.Mesh(new THREE.TorusGeometry(4, 0.1, 16, 64), matLib.neonPurple);
    r1.rotation.x = Math.PI/2; r2.rotation.y = Math.PI/2;
    turretMesh.add(r1, r2);
    animMeshes.push({mesh: r1, rotSpeed: new THREE.Vector3(0.5, 1, 0)});
    animMeshes.push({mesh: r2, rotSpeed: new THREE.Vector3(1, 0, 0.5)});
    group.add(turretMesh);
  }

  return { root: group, turret: turretMesh, anims: animMeshes };
}

class Tower {
  constructor(type, position) {
    this.type = type;
    this.pos = position.clone();
    this.range = type==='harpoon'? 60 : type==='aegis'? 80 : 45;
    this.cooldownMax = type==='cannon'? 1.5 : type==='harpoon'? 2.5 : type==='net'? 0.5 : 0.8;
    this.cooldown = 0;
    this.damage = type==='cannon'? 30 : type==='harpoon'? 80 : type==='net'? 5 : 15;
    
    const proc = createProceduralTowerMesh(type);
    this.mesh = proc.root;
    this.turret = proc.turret;
    this.anims = proc.anims;
    
    this.mesh.position.copy(this.pos);
    scene.add(this.mesh);
  }

  update(dt) {
    this.anims.forEach(a => {
      a.mesh.rotation.x += a.rotSpeed.x * dt;
      a.mesh.rotation.y += a.rotSpeed.y * dt;
      a.mesh.rotation.z += a.rotSpeed.z * dt;
    });

    if(this.cooldown > 0) this.cooldown -= dt;

    if(!game.battle) return;

    let target = null;
    let minDist = this.range;

    game.enemies.forEach(e => {
      const d = this.pos.distanceTo(e.pos);
      if(d < minDist) { minDist = d; target = e; }
    });

    if(target && this.turret && this.type !== 'net' && this.type !== 'aegis') {
      const toTarget = target.pos.clone().sub(this.pos);
      this.turret.rotation.y = Math.atan2(toTarget.x, toTarget.z);
    }

    if(target && this.cooldown <= 0) {
      this.cooldown = this.cooldownMax;
      const tPos = target.pos.clone().add(new THREE.Vector3(0,1,0));
      const sPos = this.turret ? this.mesh.position.clone().add(this.turret.position) : this.pos.clone().add(new THREE.Vector3(0,5,0));
      
      const col = this.type==='cannon'? 0x00ffff : this.type==='harpoon'? 0xffaa00 : this.type==='net'? 0x00ff00 : 0xaa00ff;
      game.projectiles.push(new Projectile(sPos, tPos, target, this.damage, col));
    }
  }
}

class Projectile {
  constructor(start, targetPos, targetEntity, damage, color) {
    this.pos = start.clone();
    this.targetPos = targetPos.clone();
    this.targetEntity = targetEntity;
    this.damage = damage;
    this.speed = 80;
    this.mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.4, 8, 8),
      new THREE.MeshBasicMaterial({color: color})
    );
    this.mesh.position.copy(this.pos);
    scene.add(this.mesh);
    this.active = true;
  }
  update(dt) {
    if(!this.active) return;
    if(this.targetEntity && this.targetEntity.hp > 0) {
      this.targetPos.copy(this.targetEntity.pos).add(new THREE.Vector3(0,1,0));
    }
    const dir = this.targetPos.clone().sub(this.pos);
    const dist = dir.length();
    if(dist < this.speed * dt) {
      this.pos.copy(this.targetPos);
      if(this.targetEntity) this.targetEntity.hp -= this.damage;
      this.destroy();
    } else {
      this.pos.add(dir.normalize().multiplyScalar(this.speed * dt));
      this.mesh.position.copy(this.pos);
    }
  }
  destroy() {
    this.active = false;
    scene.remove(this.mesh);
    this.mesh.geometry.dispose();
    this.mesh.material.dispose();
  }
}

class Ship{
  constructor(x,z,team){
    this.team = team;
    this.pos = new THREE.Vector3(x, 1, z);
    this.vel = new THREE.Vector3();
    this.hp = 100;
    this.maxHp = 100;
    this.mesh = new THREE.Mesh(
      new THREE.BoxGeometry(3,1,6),
      new THREE.MeshStandardMaterial({ color: team==='enemy'?0xff0000:0x00ff88, roughness:0.55, metalness:0.15 })
    );
    this.mesh.position.copy(this.pos);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = true;
    scene.add(this.mesh);

    const label = team==='enemy' ? '‚ò†Ô∏è' : 'üõü';
    const col = team==='enemy' ? 'rgba(255,60,60,0.95)' : 'rgba(0,255,160,0.95)';
    this.ping = makePingSprite(label, col);
  }
  update(dt){
    if(this.hp <= 0) return;
    if(game.battle) {
      const target = (this.team==='enemy') ? game.allies[0] : game.enemies[0];
      if(target && target.hp > 0){
        const dir = target.pos.clone().sub(this.pos).normalize();
        const accel = (this.team==='enemy') ? 1.5 : 1.0;
        this.vel.addScaledVector(dir, accel * dt);
      }
    }
    
    this.vel.clampLength(0, 8);
    this.pos.addScaledVector(this.vel, dt);
    this.vel.multiplyScalar(Math.max(0, 1 - 2*dt));
    this.mesh.position.copy(this.pos);
    if(this.vel.lengthSq() > 0.1) this.mesh.rotation.y = Math.atan2(this.vel.x, this.vel.z);
  }
  destroy(){
    scene.remove(this.mesh);
    this.mesh.geometry.dispose();
    this.mesh.material.dispose();
    if(this.ping) scene.remove(this.ping);
  }
}

const player = {
  root: new THREE.Group(),
  body: null,
  pos: new THREE.Vector3(0, 2, 0),
  vel: new THREE.Vector3(),
  yaw: 0, pitch: 0, speed: 0, onLand: false,
  goal: new THREE.Vector3(50, WATER_Y, 30),
  colliderR: 1.0,
};
scene.add(player.root);

function makeFallbackPlayer(){
  const g = new THREE.Group();
  const radius = 0.9, bodyH = 1.2;
  const mat = new THREE.MeshStandardMaterial({color:0x00ff88, roughness:0.55, metalness:0.2, emissive:0x001c10, emissiveIntensity:0.25});
  const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, bodyH, 16, 1), mat);
  cylinder.castShadow = true; cylinder.receiveShadow = true;
  const top = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 12), mat);
  top.castShadow = true; top.receiveShadow = true; top.position.y = bodyH/2;
  const bot = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 12), mat);
  bot.castShadow = true; bot.receiveShadow = true; bot.position.y = -bodyH/2;
  g.add(cylinder, top, bot);
  g.position.y = 1.6;
  player.root.add(g);
  player.body = g;
  player.colliderR = radius;
}
makeFallbackPlayer();

const coneVis = new THREE.Group();
scene.add(coneVis);
let coneOn = true;
let pingsOn = true;

const coneGeo = new THREE.ConeGeometry(10, 26, 18, 1, true);
coneGeo.translate(0, -13, 0);
const coneMat = new THREE.MeshBasicMaterial({color:0x00ff88, transparent:true, opacity:0.10, side:THREE.DoubleSide, depthWrite:false});
const coneMesh = new THREE.Mesh(coneGeo, coneMat);
coneVis.add(coneMesh);
const ring = new THREE.Mesh(new THREE.RingGeometry(3.5, 4.2, 32), new THREE.MeshBasicMaterial({color:0x00ff88, transparent:true, opacity:0.25, side:THREE.DoubleSide, depthWrite:false}));
ring.rotation.x = -Math.PI/2;
ring.position.set(0, 0.05, 0);
coneVis.add(ring);

function makePingTexture(label, color){
  const c = document.createElement('canvas');
  c.width = 256; c.height = 128;
  const g = c.getContext('2d');
  g.clearRect(0,0,c.width,c.height);
  g.fillStyle = 'rgba(0,20,40,0.70)';
  g.strokeStyle = color; g.lineWidth = 6;
  g.beginPath(); g.roundRect(16, 16, 224, 80, 18);
  g.fill(); g.stroke();
  g.fillStyle = '#dff'; g.font = 'bold 42px ui-monospace, monospace';
  g.textAlign = 'center'; g.textBaseline = 'middle';
  g.fillText(label, 128, 56);
  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter; tex.anisotropy = 2;
  return tex;
}
function makePingSprite(label, color){
  const mat = new THREE.SpriteMaterial({ map: makePingTexture(label, color), transparent:true, depthWrite:false });
  const s = new THREE.Sprite(mat);
  s.scale.set(7, 3.5, 1);
  s.visible = false;
  scene.add(s);
  return s;
}

function spawnWave(){
  game.generation++;
  document.getElementById('gen').textContent = game.generation;
  const ally = new Ship(Math.random()*10-5, Math.random()*10-5, 'ally');
  game.allies.push(ally);
  for(let i=0;i<5;i++){
    const e = new Ship(Math.random()*140-70, Math.random()*140-70, 'enemy');
    game.enemies.push(e);
  }
  log(`üåä Wave ${game.generation}: +1 Ally / +5 Enemies`);
}

function mutateDoctrine(){
  const chaos = ({calm:.002, balanced:.006, chaos:.015})[game.profile] ?? .006;
  doctrine.aggression = clamp01(doctrine.aggression + (Math.random()-.5)*chaos);
  doctrine.focus = clamp01(doctrine.focus + (Math.random()-.5)*chaos);
  doctrine.kiting = clamp01(doctrine.kiting + (Math.random()-.5)*chaos);
}

const raycaster = new THREE.Raycaster();
const down = new THREE.Vector3(0,-1,0);

function getLandHeightAt(x,z){
  raycaster.set(new THREE.Vector3(x, 400, z), down);
  const hits = raycaster.intersectObjects(land.children, true);
  if(!hits.length) return null;
  return hits[0].point.y;
}
function computeSurfaceY(x,z){
  const landY = getLandHeightAt(x,z);
  if(landY === null) return { y: WATER_Y + 0.8, onLand:false };
  return { y: landY + 1.2, onLand:true };
}
function pushOutFromIslands(){
  for(const obj of land.children){
    const c = obj.userData.collider;
    if(!c) continue;
    const dx = player.pos.x - c.x;
    const dz = player.pos.z - c.z;
    const d = Math.hypot(dx,dz) || 1;
    const min = c.r + player.colliderR;
    if(d < min){
      const k = (min - d);
      player.pos.x += (dx/d) * k;
      player.pos.z += (dz/d) * k;
      const vn = (player.vel.x*(dx/d) + player.vel.z*(dz/d));
      if(vn < 0){
        player.vel.x -= (dx/d) * vn;
        player.vel.z -= (dz/d) * vn;
      }
    }
  }
}

const input = { forward: 0, right: 0, lookX: 0, lookY: 0, mouseDown: false, freeCam: { yaw:0, pitch:0 } };
let placementMode = null;
let placementCost = 0;

window.addEventListener('keydown', (e)=>{
  if(e.key === 'w' || e.key === 'ArrowUp') input.forward = 1;
  if(e.key === 's' || e.key === 'ArrowDown') input.forward = -1;
  if(e.key === 'a' || e.key === 'ArrowLeft') input.right = -1;
  if(e.key === 'd' || e.key === 'ArrowRight') input.right = 1;
});
window.addEventListener('keyup', (e)=>{
  if(['w','s','ArrowUp','ArrowDown'].includes(e.key)) input.forward = 0;
  if(['a','d','ArrowLeft','ArrowRight'].includes(e.key)) input.right = 0;
});

renderer.domElement.addEventListener('pointerdown', (e)=>{
  if(placementMode) {
    const rect = renderer.domElement.getBoundingClientRect();
    const mouse = new THREE.Vector2(
      ((e.clientX - rect.left) / rect.width) * 2 - 1,
      -((e.clientY - rect.top) / rect.height) * 2 + 1
    );
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(land.children, true);
    
    if(intersects.length > 0) {
      game.gold -= placementCost;
      const tower = new Tower(placementMode, intersects[0].point);
      game.towers.push(tower);
      log(`üèóÔ∏è Built ${placementMode.toUpperCase()} at [${Math.round(intersects[0].point.x)}, ${Math.round(intersects[0].point.z)}]`);
      toast(`üèóÔ∏è ${placementMode.toUpperCase()} Built!`);
      endPlacement();
    } else {
      toast('‚ùå Must place on land!');
    }
    return;
  }
  input.mouseDown = true; 
});
window.addEventListener('pointerup', ()=>{ input.mouseDown = false; });
window.addEventListener('pointermove', (e)=>{
  if(!input.mouseDown || placementMode) return;
  if(CAM.mode === 'free'){
    input.freeCam.yaw   += e.movementX * 0.0022;
    input.freeCam.pitch += e.movementY * 0.0018;
    input.freeCam.pitch = THREE.MathUtils.clamp(input.freeCam.pitch, -1.2, 1.1);
  }else{
    input.lookX += e.movementX * 0.0022;
    input.lookY += e.movementY * 0.0018;
  }
});

function setupPad(padEl, stickEl, onMove){
  let activeId = null; let cx=0, cy=0; const max = 46;
  padEl.addEventListener('pointerdown', (e)=>{
    activeId = e.pointerId; padEl.setPointerCapture(activeId);
    const r = padEl.getBoundingClientRect();
    cx = r.left + r.width/2; cy = r.top  + r.height/2;
  });
  padEl.addEventListener('pointermove', (e)=>{
    if(e.pointerId !== activeId) return;
    const dx = e.clientX - cx; const dy = e.clientY - cy;
    const len = Math.hypot(dx,dy) || 1; const k = Math.min(max, len)/len;
    stickEl.style.transform = `translate(${dx*k-28}px, ${dy*k-28}px)`;
    onMove((dx*k)/max, (dy*k)/max);
  });
  const end = (e)=>{ if(activeId===null||(e&&e.pointerId!==activeId))return; activeId=null; stickEl.style.transform=`translate(-50%,-50%)`; onMove(0,0); };
  padEl.addEventListener('pointerup', end); padEl.addEventListener('pointercancel', end); padEl.addEventListener('lostpointercapture', end);
}
setupPad(document.getElementById('movePad'), document.getElementById('moveStick'), (x,y)=>{ input.right=x; input.forward=-y; });
setupPad(document.getElementById('lookPad'), document.getElementById('lookStick'), (x,y)=>{ input.lookX+=x*0.06; input.lookY+=y*0.04; });

const CAM = { mode:'orbit', dist:36, height:14, smooth:0.12 };
function setCameraMode(m){
  CAM.mode = m;
  document.querySelectorAll('[data-cam]').forEach(b=>b.classList.toggle('active', b.dataset.cam===m));
  if(m==='free'){ input.freeCam.yaw = player.yaw; input.freeCam.pitch = 0; }
}
document.querySelectorAll('[data-cam]').forEach(b=>b.addEventListener('click', ()=> setCameraMode(b.dataset.cam)));
setCameraMode('orbit');

function pickNewGoal(){
  const choices = [ new THREE.Vector3(40, WATER_Y, 20), new THREE.Vector3(-60, WATER_Y, -10), new THREE.Vector3(5, WATER_Y, -70), new THREE.Vector3(Math.random()*340-170, WATER_Y, Math.random()*340-170) ];
  player.goal.copy(choices[(Math.random()*choices.length)|0]);
}

function autoplaySteer(dt){
  const to = player.goal.clone().sub(player.pos);
  const dist = to.length();
  if(dist < 6) pickNewGoal();
  let dy = Math.atan2(to.x, to.z) - player.yaw;
  while(dy > Math.PI) dy -= Math.PI*2; while(dy < -Math.PI) dy += Math.PI*2;
  player.yaw += dy * dt * lerp(0.8, 2.2, doctrine.focus);
  const throttle = clamp01(dist / 40);
  input.forward = lerp(input.forward, 0.6 + 0.4*throttle, 0.08);
  input.right   = lerp(input.right,   0.0, 0.12);
}

function updatePlayer(dt){
  player.yaw += input.lookX;
  player.pitch = THREE.MathUtils.clamp(player.pitch + input.lookY, -0.85, 0.65);
  input.lookX = 0; input.lookY = 0;

  const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.sin(player.yaw + Math.PI/2), 0, Math.cos(player.yaw + Math.PI/2));
  const move = new THREE.Vector3().addScaledVector(forward, input.forward).addScaledVector(right, input.right);
  if(move.lengthSq() > 0.0001) move.normalize();

  player.vel.addScaledVector(move, 34*dt);
  const hv = new THREE.Vector3(player.vel.x, 0, player.vel.z);
  hv.clampLength(0, 18 * (player.onLand ? 1.0 : 0.92));
  player.vel.x = hv.x; player.vel.z = hv.z;
  player.vel.multiplyScalar(Math.max(0, 1 - 9*dt));
  player.pos.addScaledVector(player.vel, dt);

  pushOutFromIslands();
  const surf = computeSurfaceY(player.pos.x, player.pos.z);
  player.onLand = surf.onLand;
  player.pos.y = damp(player.pos.y, surf.y, 10, dt);

  player.root.position.copy(player.pos);
  player.root.rotation.y = player.yaw;

  if(coneOn){
    coneVis.visible = true;
    coneVis.position.set(player.pos.x, WATER_Y + 0.05, player.pos.z);
    coneVis.rotation.set(0, player.yaw, 0);
    coneMesh.rotation.set(Math.PI/2, 0, 0);
    coneMesh.position.set(0, 0.1, 12);
    ring.position.set(0, 0.05, 6);
  }else coneVis.visible = false;
}

const camTarget = new THREE.Vector3();
const camPos = new THREE.Vector3(0, 18, 42);
const tmp = new THREE.Vector3();

function recenterCamera(){
  camPos.copy(camera.position);
  input.freeCam.yaw = player.yaw; input.freeCam.pitch = 0;
  toast('üß≠ Recentered');
}

function updateCamera(dt){
  const p = player.pos;
  const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.sin(player.yaw + Math.PI/2), 0, Math.cos(player.yaw + Math.PI/2));

  camTarget.copy(p).addScaledVector(forward, 6).add(new THREE.Vector3(0, 2.6, 0));

  if(CAM.mode === 'free'){
    const f = new THREE.Vector3(Math.sin(input.freeCam.yaw)*Math.cos(input.freeCam.pitch), Math.sin(input.freeCam.pitch), Math.cos(input.freeCam.yaw)*Math.cos(input.freeCam.pitch)).normalize();
    const r = new THREE.Vector3().crossVectors(f, new THREE.Vector3(0,1,0)).normalize();
    camPos.addScaledVector(f, input.forward * 22 * dt);
    camPos.addScaledVector(r, input.right * 22 * dt);
    camera.position.lerp(camPos, 0.18);
    camera.lookAt(camTarget);
    return;
  }
  if(CAM.mode === 'orbit'){
    tmp.copy(p).addScaledVector(forward, -CAM.dist).add(new THREE.Vector3(0, CAM.height, 0));
    camera.position.lerp(tmp, CAM.smooth);
    camera.lookAt(p.x, p.y + 2.2, p.z);
    return;
  }
  if(CAM.mode === 'chase'){
    tmp.copy(p).addScaledVector(forward, -18).add(new THREE.Vector3(0, 7.2, 0));
    camera.position.lerp(tmp, 0.18);
    camera.lookAt(camTarget);
    return;
  }
}

function isInCone(entityPos){
  const v = entityPos.clone().sub(player.pos); v.y = 0;
  const dist = v.length();
  if(dist > 32) return false;
  const f = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  return (dist>0) ? v.normalize().dot(f) > 0.45 : true;
}

function updatePings(){
  const all = game.allies.concat(game.enemies);
  for(const s of all){
    if(!s.ping) continue;
    if(!pingsOn || !coneOn){ s.ping.visible = false; continue; }
    const near = s.pos.distanceTo(player.pos) < 34;
    s.ping.visible = near && isInCone(s.pos);
    if(s.ping.visible){
      s.ping.position.set(s.pos.x, s.pos.y + 5.5, s.pos.z);
      const k = THREE.MathUtils.clamp(1.2 - s.pos.distanceTo(player.pos)/45, 0.65, 1.2);
      s.ping.scale.set(7*k, 3.5*k, 1);
    }
  }
}

document.querySelectorAll('.btn.placement').forEach(btn => {
  btn.addEventListener('click', () => {
    const cost = parseInt(btn.dataset.cost);
    if(game.gold >= cost) {
      placementMode = btn.dataset.tower;
      placementCost = cost;
      document.getElementById('crosshair').style.display = 'block';
      document.getElementById('cancelPlacement').style.display = 'block';
      toast(`Select land to build ${placementMode.toUpperCase()}`);
    } else {
      toast('‚ùå Not enough credits!');
    }
  });
});

function endPlacement() {
  placementMode = null;
  document.getElementById('crosshair').style.display = 'none';
  document.getElementById('cancelPlacement').style.display = 'none';
}

document.getElementById('cancelPlacement').onclick = endPlacement;
document.getElementById('wave').onclick = spawnWave;
document.getElementById('battle').onclick = ()=>{ game.battle = !game.battle; document.getElementById('battle').textContent = game.battle ? '‚öîÔ∏è Combat: ON' : '‚öîÔ∏è Combat: OFF'; };
document.getElementById('autoplay').onclick = ()=>{ game.autoplay = !game.autoplay; document.getElementById('autoplay').textContent = `ü§ñ Autoplay: ${game.autoplay?'ON':'OFF'}`; if(game.autoplay)pickNewGoal(); };
document.getElementById('panic').onclick = ()=>{ for(let i=0;i<3;i++) spawnWave(); doctrine.aggression=.9; doctrine.focus=.9; doctrine.kiting=.9; };
document.getElementById('coneToggle').onclick = ()=>{ coneOn = !coneOn; document.getElementById('coneToggle').textContent = `üß† Cone: ${coneOn?'ON':'OFF'}`; };
document.getElementById('interactToggle').onclick = ()=>{ pingsOn = !pingsOn; };
document.getElementById('resetCam').onclick = recenterCamera;
document.getElementById('gridToggle').onclick = ()=>{ gridOn = !gridOn; grid.visible = gridOn; document.getElementById('gridToggle').textContent = `üß≠ Grid: ${gridOn?'ON':'OFF'}`; };

let lastT = performance.now();
let lastDoctrine = performance.now();

function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min(0.033, (now - lastT)/1000);
  lastT = now;

  if(game.autoplay){ autoplaySteer(dt); if((now - lastDoctrine) > 4200){ mutateDoctrine(); if(game.enemies.length < 4) spawnWave(); lastDoctrine = now; } }

  updatePlayer(dt);
  updateCamera(dt);

  game.towers.forEach(t => t.update(dt));
  
  for(let i=game.projectiles.length-1; i>=0; i--){
    game.projectiles[i].update(dt);
    if(!game.projectiles[i].active) game.projectiles.splice(i, 1);
  }

  game.allies.forEach(s=>s.update(dt));
  game.enemies.forEach(s=>s.update(dt));

  for(let i=game.allies.length-1; i>=0; i--) { if(game.allies[i].hp <= 0) { game.allies[i].destroy(); game.allies.splice(i,1); } }
  for(let i=game.enemies.length-1; i>=0; i--) { if(game.enemies[i].hp <= 0) { game.score+=10; game.gold+=25; game.enemies[i].destroy(); game.enemies.splice(i,1); } }

  updatePings();

  document.getElementById('gold').textContent = '$' + game.gold;
  document.getElementById('allies').textContent = game.allies.length;
  document.getElementById('enemies').textContent = game.enemies.length;
  document.getElementById('score').textContent = game.score;

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
