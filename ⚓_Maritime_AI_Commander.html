<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>‚öì Maritime AI Commander ‚Äî Evolved Playable Sim</title>
<meta name="description" content="Playable POV naval sandbox with touch controls, cognitive cone, interaction pings, safe collisions, optional GLB animations, plus a stable world grid."/>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;background:linear-gradient(to bottom,#001a33,#000);color:#0ff;overflow:hidden;touch-action:none;}
#canvas-container{width:100vw;height:100vh;position:relative;}

/* HUD */
#hud{position:absolute;top:14px;left:14px;background:linear-gradient(135deg,rgba(0,30,60,.92),rgba(0,50,80,.92));border:2px solid #00d4ff;padding:12px;border-radius:12px;min-width:300px;z-index:100;backdrop-filter:blur(6px);}
.hud-title{font-size:18px;font-weight:900;color:#00d4ff;text-shadow:0 0 10px #00d4ff;}
.hud-subtitle{font-size:10px;color:#88ccff;font-style:italic;margin-bottom:8px;}
.hud-stat{font-size:12px;color:#88ccff;border-bottom:1px solid rgba(0,212,255,.16);margin:4px 0;padding-bottom:3px;}
.hud-value{float:right;color:#00ff88;}

/* Panels */
.panel{position:absolute;background:rgba(10,10,25,.92);border-radius:12px;padding:12px;border:2px solid #ff00ff;z-index:101;backdrop-filter:blur(6px);}
#controls{bottom:14px;left:14px;width:300px;}
#shop{bottom:14px;right:14px;border-color:#ffaa00;width:300px;}
#memory{top:14px;right:14px;max-width:380px;max-height:440px;overflow:auto;}
#cameraPanel{top:240px;left:14px;width:310px;border-color:#00ff88;}

@media (max-width: 820px){
  #hud{min-width:260px}
  #memory{display:none;}
  #cameraPanel{top:210px}
  #shop{display:none;} /* phones: prioritize play space */
}

/* Buttons */
.btn{display:block;width:100%;margin:4px 0;padding:10px 12px;border-radius:10px;cursor:pointer;border:2px solid #00d4ff;background:linear-gradient(135deg,#001a33,#003366);color:#00d4ff;font-weight:900;letter-spacing:.2px;user-select:none;}
.btn:hover{background:#00d4ff;color:#000;}
.btn.active{background:#ff00ff;color:#fff;border-color:#ff00ff;}
.btn.warn{border-color:#ff6600;color:#ff6600;}
.btn.warn:hover{background:#ff6600;color:#000;}
.row{display:flex;gap:8px;}
.row .btn{flex:1;}
.small{font-size:10px;color:#aee;}

/* Memory */
.memory-entry{font-size:11px;margin:4px 0;padding:6px;background:rgba(80,0,80,.45);border-left:3px solid #f0f;}

/* Touch UI */
#touchUI{position:absolute;inset:0;pointer-events:none;z-index:120;}
.pad{position:absolute;width:150px;height:150px;border-radius:18px;border:2px solid rgba(0,212,255,.55);background:rgba(0,20,40,.20);pointer-events:auto;touch-action:none;}
#movePad{left:16px;bottom:16px;}
#lookPad{right:16px;bottom:16px;border-color:rgba(255,0,255,.55);}
.stick{position:absolute;left:50%;top:50%;width:56px;height:56px;border-radius:16px;transform:translate(-50%,-50%);background:rgba(0,212,255,.35);border:2px solid rgba(0,212,255,.8);}
#lookStick{background:rgba(255,0,255,.25);border-color:rgba(255,0,255,.75);}
.hint{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:11px;color:rgba(170,230,255,.75);text-align:center;pointer-events:none;}
#lookHint{color:rgba(255,180,255,.75);}
.badge{position:absolute;bottom:-18px;left:0;right:0;font-size:10px;text-align:center;color:rgba(180,220,255,.75);}

/* Mini toast */
#toast{position:absolute;left:50%;top:12px;transform:translateX(-50%);padding:8px 12px;border-radius:10px;border:1px solid rgba(0,212,255,.5);background:rgba(0,20,40,.55);color:#bff;font-size:12px;z-index:200;backdrop-filter:blur(6px);display:none;}
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="toast"></div>
<input id="glbFile" type="file" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" style="display:none" />

<!-- HUD -->
<div id="hud">
  <div class="hud-title">‚öì MARITIME AI COMMANDER</div>
  <div class="hud-subtitle">POV + Touch + Cone + Pings + Safe Collisions + Grid + GLB Anim</div>
  <div class="hud-stat">Credits <span class="hud-value" id="gold">$1000</span></div>
  <div class="hud-stat">Allies <span class="hud-value" id="allies">0</span></div>
  <div class="hud-stat">Enemies <span class="hud-value" id="enemies">0</span></div>
  <div class="hud-stat">Score <span class="hud-value" id="score">0</span></div>
  <div class="hud-stat">Generation <span class="hud-value" id="gen">0</span></div>
  <div class="hud-stat">Camera <span class="hud-value" id="camLabel">ORBIT</span></div>
</div>

<!-- Controls -->
<div id="controls" class="panel">
  <div style="color:#ff00ff;font-weight:900;margin-bottom:6px;">üéÆ OPERATIONS</div>
  <button class="btn" id="wave">üåä‚ûï Wave (+1 Ally / +5 Enemies)</button>
  <div class="row">
    <button class="btn" id="battle">‚öîÔ∏è Combat: OFF</button>
    <button class="btn" id="autoplay">ü§ñ Autoplay: OFF</button>
  </div>

  <div style="margin-top:6px;font-size:11px;color:#88ccff;">ü§ñ Autoplay Profile</div>
  <div class="row">
    <button class="btn" data-profile="calm">üå±</button>
    <button class="btn" data-profile="balanced">‚öñÔ∏è</button>
    <button class="btn" data-profile="chaos">üî•</button>
  </div>

  <div class="row">
    <button class="btn" id="interactToggle">üìç Pings: ON</button>
    <button class="btn" id="resetCam">üß≠ Recenter</button>
  </div>

  <button class="btn warn" id="panic">üö® PANIC MODE</button>
  <div class="small" style="margin-top:6px;">PC/Mac: WASD + mouse drag. Mobile: pads. Tap POV buttons to inspect close interactions.</div>
</div>

<!-- Shop (hidden on phones by CSS) -->
<div id="shop" class="panel">
  <div style="color:#ffaa00;font-weight:900;">üè≠ DEFENSE SYSTEMS</div>
  <div style="font-size:10px;color:#cc8800;font-style:italic;">‚ÄúWe tried nothing and we‚Äôre all out of ideas.‚Äù</div>
  <button class="btn" data-tower="cannon" data-cost="100">üî• Cannon $100</button>
  <button class="btn" data-tower="harpoon" data-cost="150">üéØ Harpoon $150</button>
  <button class="btn" data-tower="net" data-cost="200">üï∏Ô∏è Net $200</button>
</div>

<!-- Camera Panel -->
<div id="cameraPanel" class="panel">
  <div style="color:#00ff88;font-weight:900;margin-bottom:6px;">üé• POV PANEL</div>
  <div class="row">
    <button class="btn" data-cam="orbit">üõ∞Ô∏è Orbit</button>
    <button class="btn" data-cam="chase">üèéÔ∏è Chase</button>
    <button class="btn" data-cam="shoulder">üßç Shoulder</button>
  </div>
  <div class="row">
    <button class="btn" data-cam="head">üëÅÔ∏è Head</button>
    <button class="btn" data-cam="cinematic">üé¨ Cine</button>
    <button class="btn" data-cam="free">ü™Ç Free</button>
  </div>
  <div class="row">
    <button class="btn" id="coneToggle">üß†üî¶ Cone: ON</button>
    <button class="btn" id="qualityToggle">‚ú® Quality: HIGH</button>
  </div>
  <div class="row">
    <button class="btn" id="gridToggle">üß≠ Grid: ON</button>
    <button class="btn" id="resetGrid">üß± Grid: Rebuild</button>
  </div>
  <div class="row">
    <button class="btn" id="uploadGLB">üì¶ Upload GLB</button>
    <button class="btn" id="resetGLB">üßπ Reset Model</button>
  </div>
  <div class="small">Grid floats above water (no z-fight). Cone = attention volume. Pings highlight nearby entities inside the cone.</div>
</div>

<!-- Memory -->
<div id="memory" class="panel">
  <div style="color:#f0f;font-weight:900;">üß† VETERAN DOCTRINE</div>
  <div style="font-size:10px;color:#aaa;">(Ships arguing loudly but learning anyway)</div>
  <div id="log"></div>
</div>

<!-- Touch UI -->
<div id="touchUI">
  <div id="movePad" class="pad">
    <div class="stick" id="moveStick"></div>
    <div class="hint">üïπÔ∏è MOVE</div>
    <div class="badge">left pad</div>
  </div>
  <div id="lookPad" class="pad">
    <div class="stick" id="lookStick"></div>
    <div class="hint" id="lookHint">üëÜ LOOK</div>
    <div class="badge">right pad</div>
  </div>
</div>

<!-- Three r128 + matching loader (same CDN family) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
<script>
/* ===================================================
   CONFIG ‚úÖ
=================================================== */
const PLAYER_GLB_URL = "";      // optional remote .glb URL
const PLAYER_GLB_SCALE = 1.0;   // tweak if your GLB is huge/tiny

/* ===================================================
   UTIL üß∞
=================================================== */
const clamp01 = v => Math.max(0, Math.min(1, v));
const lerp = (a,b,t)=>a+(b-a)*t;
const damp = (current, target, lambda, dt)=> lerp(current, target, 1 - Math.exp(-lambda*dt));
const toast = (msg)=>{
  const el = document.getElementById('toast');
  if(!el) return;
  el.textContent = msg;
  el.style.display = 'block';
  clearTimeout(toast._t);
  toast._t = setTimeout(()=> el.style.display='none', 1600);
};
const log = (msg)=>{
  const l = document.getElementById('log');
  if(!l) return;
  const e=document.createElement('div');
  e.className='memory-entry';
  e.textContent=`[${new Date().toLocaleTimeString()}] ${msg}`;
  l.prepend(e);
  while(l.children.length>26) l.removeChild(l.lastChild);
};

/* ===================================================
   GAME STATE üéÆ
=================================================== */
const game = {
  gold: 1000,
  score: 0,
  allies: [],
  enemies: [],
  battle: false,
  autoplay: false,
  profile: 'balanced',
  generation: 0,
};
const doctrine = { aggression:.5, focus:.5, kiting:.5 };

/* ===================================================
   THREE SETUP üåå
=================================================== */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x001a33, 70, 650);
scene.background = new THREE.Color(0x001226);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1800);
camera.position.set(0, 18, 42);

const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputEncoding = THREE.sRGBEncoding;
document.getElementById('canvas-container').appendChild(renderer.domElement);

// lights üí°
scene.add(new THREE.AmbientLight(0x405070, 0.52));
const hemi = new THREE.HemisphereLight(0x9ad6ff, 0x001018, 0.35);
scene.add(hemi);

const sun = new THREE.DirectionalLight(0xffffff, 1.02);
sun.position.set(140, 240, 90);
sun.castShadow = true;
sun.shadow.mapSize.set(1024,1024);
sun.shadow.camera.near = 10;
sun.shadow.camera.far = 800;
sun.shadow.camera.left = -260;
sun.shadow.camera.right = 260;
sun.shadow.camera.top = 260;
sun.shadow.camera.bottom = -260;
scene.add(sun);

const fill = new THREE.DirectionalLight(0x88ccff, 0.32);
fill.position.set(-140, 110, -70);
scene.add(fill);

/* ===================================================
   WORLD: water + land üèùÔ∏èüåä
=================================================== */
const WATER_Y = 0;
const waterMat = new THREE.MeshStandardMaterial({
  color:0x1E90FF,
  transparent:true,
  opacity:0.88,
  emissive:0x001018,
  emissiveIntensity:0.35,
  roughness:0.35,
  metalness:0.05
});
// Help overlays (grid) avoid flicker
waterMat.polygonOffset = true;
waterMat.polygonOffsetFactor = 1;
waterMat.polygonOffsetUnits = 1;

const water = new THREE.Mesh(
  new THREE.PlaneGeometry(1000,1000,1,1),
  waterMat
);
water.rotation.x = -Math.PI/2;
water.receiveShadow = true;
scene.add(water);

// Land group (raycast-able)
const land = new THREE.Group();
scene.add(land);

function makeIsland(x,z,r,h){
  const geo = new THREE.ConeGeometry(r, h, 18, 1);
  geo.translate(0, h*0.5, 0);
  const mat = new THREE.MeshStandardMaterial({color:0x0b4d2a, roughness:0.95, metalness:0.02});
  const m = new THREE.Mesh(geo, mat);
  m.position.set(x, WATER_Y, z);
  m.castShadow = true;
  m.receiveShadow = true;
  land.add(m);

  // sandy rim
  const rim = new THREE.Mesh(
    new THREE.TorusGeometry(r*0.75, r*0.12, 10, 28),
    new THREE.MeshStandardMaterial({color:0x9c8b5a, roughness:1, metalness:0})
  );
  rim.rotation.x = Math.PI/2;
  rim.position.set(x, WATER_Y + 0.15, z);
  rim.receiveShadow = true;
  land.add(rim);

  // simple collider proxy (circle in XZ)
  m.userData.collider = { x, z, r: r*0.78 };
}
makeIsland(  40,  20, 30, 12);
makeIsland( -60, -10, 38, 16);
makeIsland(   5, -70, 24, 10);

// Buoys (spatial cue)
for(let i=0;i<16;i++){
  const buoy = new THREE.Mesh(
    new THREE.CylinderGeometry(0.4,0.6,2.2,10),
    new THREE.MeshStandardMaterial({color:0xff33aa, emissive:0x220012, emissiveIntensity:0.35, roughness:0.5})
  );
  buoy.position.set((Math.random()*760-380), WATER_Y+1.1, (Math.random()*760-380));
  buoy.castShadow = true;
  scene.add(buoy);
}

/* ===================================================
   WORLD GRID üß≠ (stable visibility)
=================================================== */
let gridOn = true;
let grid = null;
function rebuildGrid(){
  if(grid){
    scene.remove(grid);
    grid.geometry?.dispose?.();
    grid.material?.dispose?.();
    grid = null;
  }
  grid = new THREE.GridHelper(1000, 200, 0x00ffff, 0x004455);
  grid.position.y = WATER_Y + 0.06; // lift above water to avoid z-fighting
  grid.material.transparent = true;
  grid.material.opacity = 0.28;
  grid.renderOrder = 999;
  grid.frustumCulled = false;
  grid.visible = gridOn;
  scene.add(grid);
}
rebuildGrid();

function setGrid(on){
  gridOn = on;
  if(grid) grid.visible = on;
  document.getElementById('gridToggle').textContent = `üß≠ Grid: ${on ? 'ON' : 'OFF'}`;
  toast(on ? 'üß≠ Grid on' : 'üß≠ Grid off');
}

/* ===================================================
   PLAYER: GLB + fallback + animations üßç‚Äç‚ôÇÔ∏èüéûÔ∏è
=================================================== */
const player = {
  root: new THREE.Group(),
  body: null,
  pos: new THREE.Vector3(0, 2, 0),
  vel: new THREE.Vector3(),
  yaw: 0,
  pitch: 0,
  speed: 0,
  onLand: false,
  goal: new THREE.Vector3(50, WATER_Y, 30),
  mixer: null,
  clips: {},
  activeAction: null,
  actionName: 'idle',
  colliderR: 1.0,
};
scene.add(player.root);

function clearPlayerModel(){
  if(player.mixer){
    try{ player.mixer.stopAllAction(); }catch(_){ }
  }
  player.mixer = null;
  player.clips = {};
  player.activeAction = null;
  player.actionName = 'idle';

  for(let i=player.root.children.length-1;i>=0;i--){
    const ch = player.root.children[i];
    player.root.remove(ch);
    ch.traverse?.(o=>{
      if(o.isMesh){
        o.geometry?.dispose?.();
        const m = o.material;
        if(Array.isArray(m)) m.forEach(mm=>mm?.dispose?.());
        else m?.dispose?.();
      }
    });
  }
  player.body = null;
}

function makeFallbackCapsuleMesh(){
  // r128 does NOT guarantee CapsuleGeometry ‚Üí build from primitives.
  const g = new THREE.Group();

  const radius = 0.9;
  const bodyH = 1.2;

  const mat = new THREE.MeshStandardMaterial({
    color:0x00ff88,
    roughness:0.55,
    metalness:0.2,
    emissive:0x001c10,
    emissiveIntensity:0.25
  });

  const cylinder = new THREE.Mesh(
    new THREE.CylinderGeometry(radius, radius, bodyH, 16, 1),
    mat
  );
  cylinder.castShadow = true;
  cylinder.receiveShadow = true;
  cylinder.position.y = 0;
  g.add(cylinder);

  const top = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 12), mat);
  top.castShadow = true;
  top.receiveShadow = true;
  top.position.y = bodyH/2;
  g.add(top);

  const bot = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 12), mat);
  bot.castShadow = true;
  bot.receiveShadow = true;
  bot.position.y = -bodyH/2;
  g.add(bot);

  return { group:g, radius };
}

function makeFallbackPlayer(){
  clearPlayerModel();
  const { group, radius } = makeFallbackCapsuleMesh();
  group.position.y = 1.6; // lift off surface
  player.root.add(group);
  player.body = group;
  player.colliderR = radius;
  log('üßç Using fallback capsule (Upload GLB to swap).');
}

function chooseClipNameByHeuristic(names){
  const pick = (patterns)=>{
    for(const p of patterns){
      const n = names.find(x=>String(x).toLowerCase().includes(p));
      if(n) return n;
    }
    return null;
  };
  return {
    idle: pick(['idle','stand','breath','rest']),
    walk: pick(['walk','stroll','move']),
    run:  pick(['run','sprint','jog']),
  };
}

function setAction(name){
  if(!player.mixer || !player.clips[name]) return;
  if(player.actionName === name) return;
  const next = player.clips[name];
  if(player.activeAction){
    next.reset();
    next.crossFadeFrom(player.activeAction, 0.18, true);
    next.play();
  }else{
    next.reset();
    next.play();
  }
  player.activeAction = next;
  player.actionName = name;
}

function applyLoadedPlayerGLTF(gltf){
  clearPlayerModel();

  const model = gltf.scene;
  model.traverse(o=>{
    if(o.isMesh){
      o.castShadow = true;
      o.receiveShadow = true;
      if(o.material){
        if(o.material.roughness !== undefined) o.material.roughness = Math.min(0.92, Math.max(0.12, o.material.roughness));
        if(o.material.metalness !== undefined) o.material.metalness = Math.min(0.9, o.material.metalness);
      }
    }
  });
  model.scale.setScalar(PLAYER_GLB_SCALE);
  model.position.y = 0;
  player.root.add(model);
  player.body = model;

  // capsule-ish collider radius (best-effort): derive from bbox
  try{
    const box = new THREE.Box3().setFromObject(model);
    const size = new THREE.Vector3();
    box.getSize(size);
    player.colliderR = Math.max(0.6, Math.min(2.5, Math.max(size.x, size.z) * 0.25));
  }catch(_){
    player.colliderR = 1.0;
  }

  if(gltf.animations && gltf.animations.length){
    player.mixer = new THREE.AnimationMixer(model);
    const names = gltf.animations.map(a=>a.name || 'clip');
    const guess = chooseClipNameByHeuristic(names);
    const mk = (anim)=> player.mixer.clipAction(anim);

    for(const a of gltf.animations){
      if(guess.idle && a.name === guess.idle) player.clips.idle = mk(a);
      if(guess.walk && a.name === guess.walk) player.clips.walk = mk(a);
      if(guess.run  && a.name === guess.run)  player.clips.run  = mk(a);
    }
    if(!player.clips.idle) player.clips.idle = mk(gltf.animations[0]);
    if(!player.clips.walk) player.clips.walk = player.clips.idle;
    if(!player.clips.run)  player.clips.run  = player.clips.walk;

    setAction('idle');
    log('‚úÖ Player model loaded + animations ready.');
  }else{
    log('‚úÖ Player model loaded (no animations detected).');
  }
}

async function loadPlayerGLB(url){
  return new Promise((resolve,reject)=>{
    const loader = new THREE.GLTFLoader();
    loader.load(url, gltf => resolve(gltf), undefined, err => reject(err));
  });
}

(async ()=>{
  if(!PLAYER_GLB_URL){ makeFallbackPlayer(); return; }
  try{
    const gltf = await loadPlayerGLB(PLAYER_GLB_URL);
    applyLoadedPlayerGLTF(gltf);
  }catch(e){
    console.warn(e);
    makeFallbackPlayer();
    log('‚ö†Ô∏è GLB failed; fallback capsule used.');
  }
})();

/* ===================================================
   COGNITIVE CONE üß†üî¶ + INTERACTION PINGS üìç
=================================================== */
const coneVis = new THREE.Group();
scene.add(coneVis);
let coneOn = true;
let pingsOn = true;

const coneGeo = new THREE.ConeGeometry(10, 26, 18, 1, true);
coneGeo.translate(0, -13, 0);
const coneMat = new THREE.MeshBasicMaterial({color:0x00ff88, transparent:true, opacity:0.10, side:THREE.DoubleSide, depthWrite:false});
const coneMesh = new THREE.Mesh(coneGeo, coneMat);
coneVis.add(coneMesh);

const ring = new THREE.Mesh(
  new THREE.RingGeometry(3.5, 4.2, 32),
  new THREE.MeshBasicMaterial({color:0x00ff88, transparent:true, opacity:0.25, side:THREE.DoubleSide, depthWrite:false})
);
ring.rotation.x = -Math.PI/2;
ring.position.set(0, 0.05, 0);
coneVis.add(ring);

function makePingTexture(label, color){
  const c = document.createElement('canvas');
  c.width = 256; c.height = 128;
  const g = c.getContext('2d');
  g.clearRect(0,0,c.width,c.height);

  // bubble
  g.fillStyle = 'rgba(0,20,40,0.70)';
  g.strokeStyle = color;
  g.lineWidth = 6;
  roundRect(g, 16, 16, 224, 80, 18);
  g.fill();
  g.stroke();

  // text
  g.fillStyle = '#dff';
  g.font = 'bold 42px ui-monospace, monospace';
  g.textAlign = 'center';
  g.textBaseline = 'middle';
  g.fillText(label, 128, 56);

  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.anisotropy = 2;
  return tex;

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }
}

function makePingSprite(label, color){
  const mat = new THREE.SpriteMaterial({ map: makePingTexture(label, color), transparent:true, depthWrite:false });
  const s = new THREE.Sprite(mat);
  s.scale.set(7, 3.5, 1);
  s.visible = false;
  scene.add(s);
  return s;
}

/* ===================================================
   SHIPS üö¢
=================================================== */
class Ship{
  constructor(x,z,team){
    this.team = team;
    this.pos = new THREE.Vector3(x, 1, z);
    this.vel = new THREE.Vector3();
    this.hp = 100;
    this.mesh = new THREE.Mesh(
      new THREE.BoxGeometry(3,1,6),
      new THREE.MeshStandardMaterial({ color: team==='enemy'?0xff0000:0x00ff88, roughness:0.55, metalness:0.15 })
    );
    this.mesh.position.copy(this.pos);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = true;
    scene.add(this.mesh);

    const label = team==='enemy' ? '‚ò†Ô∏è' : 'üõü';
    const col = team==='enemy' ? 'rgba(255,60,60,0.95)' : 'rgba(0,255,160,0.95)';
    this.ping = makePingSprite(label, col);
  }
  update(){
    const target = (this.team==='enemy') ? game.allies[0] : game.enemies[0];
    if(target){
      const dir = target.pos.clone().sub(this.pos).normalize();
      const accel = (this.team==='enemy') ? 0.03 : 0.02;
      this.vel.addScaledVector(dir, accel);
    }
    this.vel.clampLength(0, 0.55);
    this.pos.add(this.vel);
    this.vel.multiplyScalar(0.95);
    this.mesh.position.copy(this.pos);
  }
}

/* ===================================================
   SPAWN üåä
=================================================== */
function spawnWave(){
  game.generation++;
  document.getElementById('gen').textContent = game.generation;

  const ally = new Ship(Math.random()*10-5, Math.random()*10-5, 'ally');
  game.allies.push(ally);

  for(let i=0;i<5;i++){
    const e = new Ship(Math.random()*140-70, Math.random()*140-70, 'enemy');
    game.enemies.push(e);
  }
  log(`üåä Wave ${game.generation}: +1 Ally / +5 Enemies`);
}

/* ===================================================
   DOCTRINE MUTATION üß¨
=================================================== */
function mutateDoctrine(){
  const chaos = ({calm:.002, balanced:.006, chaos:.015})[game.profile] ?? .006;
  doctrine.aggression = clamp01(doctrine.aggression + (Math.random()-.5)*chaos);
  doctrine.focus      = clamp01(doctrine.focus      + (Math.random()-.5)*chaos);
  doctrine.kiting     = clamp01(doctrine.kiting     + (Math.random()-.5)*chaos);
  log(`üß¨ Doctrine mutated (A:${Math.round(doctrine.aggression*100)}% F:${Math.round(doctrine.focus*100)}%)`);
}

/* ===================================================
   SURFACE HEIGHT + SAFE COLLISION üöß
=================================================== */
const ray = new THREE.Raycaster();
const down = new THREE.Vector3(0,-1,0);

function getLandHeightAt(x,z){
  ray.set(new THREE.Vector3(x, 400, z), down);
  const hits = ray.intersectObjects(land.children, true);
  if(!hits.length) return null;
  return hits[0].point.y;
}

function computeSurfaceY(x,z){
  const landY = getLandHeightAt(x,z);
  if(landY === null) return { y: WATER_Y + 0.8, onLand:false };
  return { y: landY + 1.2, onLand:true };
}

function pushOutFromIslands(){
  for(const obj of land.children){
    const c = obj.userData.collider;
    if(!c) continue;
    const dx = player.pos.x - c.x;
    const dz = player.pos.z - c.z;
    const d = Math.hypot(dx,dz) || 1;
    const min = c.r + player.colliderR;
    if(d < min){
      const k = (min - d);
      player.pos.x += (dx/d) * k;
      player.pos.z += (dz/d) * k;
      const vn = (player.vel.x*(dx/d) + player.vel.z*(dz/d));
      if(vn < 0){
        player.vel.x -= (dx/d) * vn;
        player.vel.z -= (dz/d) * vn;
      }
    }
  }
}

/* ===================================================
   INPUT üéõÔ∏è (Keyboard/Mouse + Touch pads)
=================================================== */
const input = {
  forward: 0,
  right: 0,
  lookX: 0,
  lookY: 0,
  mouseDown: false,
  freeCam: { yaw:0, pitch:0 },
};

window.addEventListener('keydown', (e)=>{
  if(e.key === 'w' || e.key === 'ArrowUp') input.forward = 1;
  if(e.key === 's' || e.key === 'ArrowDown') input.forward = -1;
  if(e.key === 'a' || e.key === 'ArrowLeft') input.right = -1;
  if(e.key === 'd' || e.key === 'ArrowRight') input.right = 1;
});
window.addEventListener('keyup', (e)=>{
  if(['w','s','ArrowUp','ArrowDown'].includes(e.key)) input.forward = 0;
  if(['a','d','ArrowLeft','ArrowRight'].includes(e.key)) input.right = 0;
});

renderer.domElement.addEventListener('pointerdown', ()=>{ input.mouseDown = true; });
window.addEventListener('pointerup', ()=>{ input.mouseDown = false; });
window.addEventListener('pointermove', (e)=>{
  if(!input.mouseDown) return;
  // if free cam, rotate the free cam basis; otherwise rotate the player
  if(CAM.mode === 'free'){
    input.freeCam.yaw   += e.movementX * 0.0022;
    input.freeCam.pitch += e.movementY * 0.0018;
    input.freeCam.pitch = THREE.MathUtils.clamp(input.freeCam.pitch, -1.2, 1.1);
  }else{
    input.lookX += e.movementX * 0.0022;
    input.lookY += e.movementY * 0.0018;
  }
});

function setupPad(padEl, stickEl, onMove){
  let activeId = null;
  let cx=0, cy=0;
  const max = 46;
  const reset = ()=>{ stickEl.style.transform = `translate(-50%,-50%)`; onMove(0,0); };

  padEl.addEventListener('pointerdown', (e)=>{
    activeId = e.pointerId;
    padEl.setPointerCapture(activeId);
    const r = padEl.getBoundingClientRect();
    cx = r.left + r.width/2;
    cy = r.top  + r.height/2;
  });

  padEl.addEventListener('pointermove', (e)=>{
    if(e.pointerId !== activeId) return;
    const dx = e.clientX - cx;
    const dy = e.clientY - cy;
    const len = Math.hypot(dx,dy) || 1;
    const k = Math.min(max, len)/len;
    const sx = dx*k;
    const sy = dy*k;
    stickEl.style.transform = `translate(${sx-28}px, ${sy-28}px)`;
    onMove(sx/max, sy/max);
  });

  const end = (e)=>{
    if(activeId === null) return;
    if(e && e.pointerId !== activeId) return;
    activeId = null;
    reset();
  };
  padEl.addEventListener('pointerup', end);
  padEl.addEventListener('pointercancel', end);
  padEl.addEventListener('lostpointercapture', end);
}

setupPad(document.getElementById('movePad'), document.getElementById('moveStick'), (x,y)=>{
  input.right = x;
  input.forward = -y;
});
setupPad(document.getElementById('lookPad'), document.getElementById('lookStick'), (x,y)=>{
  // touch look always rotates player (simple + stable)
  input.lookX += x * 0.06;
  input.lookY += y * 0.04;
});

/* ===================================================
   CAMERA MODES üé•
=================================================== */
const CAM = { mode:'orbit', dist:36, height:14, smooth:0.12 };
function setCameraMode(m){
  CAM.mode = m;
  document.getElementById('camLabel').textContent = m.toUpperCase();
  document.querySelectorAll('[data-cam]').forEach(b=>b.classList.toggle('active', b.dataset.cam===m));
  if(m==='free'){
    input.freeCam.yaw = player.yaw;
    input.freeCam.pitch = 0;
  }
  log(`üé• Camera: ${m.toUpperCase()}`);
}

document.querySelectorAll('[data-cam]').forEach(b=>b.addEventListener('click', ()=> setCameraMode(b.dataset.cam)));
setCameraMode('orbit');

/* ===================================================
   AUTOPLAY ü§ñ
=================================================== */
function pickNewGoal(){
  const choices = [
    new THREE.Vector3(40, WATER_Y, 20),
    new THREE.Vector3(-60, WATER_Y, -10),
    new THREE.Vector3(5, WATER_Y, -70),
    new THREE.Vector3(Math.random()*340-170, WATER_Y, Math.random()*340-170)
  ];
  player.goal.copy(choices[(Math.random()*choices.length)|0]);
}

function autoplaySteer(dt){
  const to = player.goal.clone().sub(player.pos);
  const dist = to.length();
  if(dist < 6) pickNewGoal();

  const desiredYaw = Math.atan2(to.x, to.z);
  let dy = desiredYaw - player.yaw;
  while(dy > Math.PI) dy -= Math.PI*2;
  while(dy < -Math.PI) dy += Math.PI*2;

  player.yaw += dy * dt * lerp(0.8, 2.2, doctrine.focus);
  const throttle = clamp01(dist / 40);
  input.forward = lerp(input.forward, 0.6 + 0.4*throttle, 0.08);
  input.right   = lerp(input.right,   0.0, 0.12);
}

/* ===================================================
   PLAYER UPDATE üßç‚Äç‚ôÇÔ∏è
=================================================== */
function updatePlayer(dt){
  player.yaw += input.lookX;
  player.pitch = THREE.MathUtils.clamp(player.pitch + input.lookY, -0.85, 0.65);
  input.lookX = 0;
  input.lookY = 0;

  const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.sin(player.yaw + Math.PI/2), 0, Math.cos(player.yaw + Math.PI/2));

  const move = new THREE.Vector3()
    .addScaledVector(forward, input.forward)
    .addScaledVector(right, input.right);

  if(move.lengthSq() > 0.0001) move.normalize();

  const baseSpeed = 18;
  const accel = 34;
  const damping = 9;

  player.vel.addScaledVector(move, accel*dt);

  const hv = new THREE.Vector3(player.vel.x, 0, player.vel.z);
  const max = baseSpeed * (player.onLand ? 1.0 : 0.92);
  hv.clampLength(0, max);
  player.vel.x = hv.x;
  player.vel.z = hv.z;

  player.vel.multiplyScalar(Math.max(0, 1 - damping*dt));

  player.pos.addScaledVector(player.vel, dt);

  pushOutFromIslands();

  const surf = computeSurfaceY(player.pos.x, player.pos.z);
  player.onLand = surf.onLand;
  player.pos.y = damp(player.pos.y, surf.y, 10, dt);

  player.root.position.copy(player.pos);
  player.root.rotation.y = player.yaw;

  player.speed = hv.length();

  if(player.mixer){
    const s = player.speed;
    if(s < 0.6) setAction('idle');
    else if(s < 9.0) setAction('walk');
    else setAction('run');
    player.mixer.update(dt);
  }

  if(coneOn){
    coneVis.visible = true;
    coneVis.position.set(player.pos.x, WATER_Y + 0.05, player.pos.z);
    coneVis.rotation.set(0, player.yaw, 0);
    coneMesh.rotation.set(Math.PI/2, 0, 0);
    coneMesh.position.set(0, 0.1, 12);
    ring.position.set(0, 0.05, 6);
  }else{
    coneVis.visible = false;
  }
}

/* ===================================================
   CAMERA UPDATE üé•
=================================================== */
const camTarget = new THREE.Vector3();
const camPos = new THREE.Vector3(0, 18, 42);
const tmp = new THREE.Vector3();

function recenterCamera(){
  camPos.copy(camera.position);
  input.freeCam.yaw = player.yaw;
  input.freeCam.pitch = 0;
  toast('üß≠ Recentered');
}

function updateCamera(dt){
  const p = player.pos;
  const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.sin(player.yaw + Math.PI/2), 0, Math.cos(player.yaw + Math.PI/2));

  camTarget.copy(p).addScaledVector(forward, 6).add(new THREE.Vector3(0, 2.6, 0));

  if(CAM.mode === 'free'){
    const yaw = input.freeCam.yaw;
    const pitch = input.freeCam.pitch;
    const f = new THREE.Vector3(
      Math.sin(yaw) * Math.cos(pitch),
      Math.sin(pitch),
      Math.cos(yaw) * Math.cos(pitch)
    ).normalize();
    const r = new THREE.Vector3().crossVectors(f, new THREE.Vector3(0,1,0)).normalize();
    const sp = 22;
    camPos.addScaledVector(f, input.forward * sp * dt);
    camPos.addScaledVector(r, input.right   * sp * dt);
    camera.position.lerp(camPos, 0.18);
    camera.lookAt(camTarget);
    return;
  }

  if(CAM.mode === 'orbit'){
    tmp.copy(p).addScaledVector(forward, -CAM.dist).add(new THREE.Vector3(0, CAM.height, 0));
    camera.position.lerp(tmp, CAM.smooth);
    camera.lookAt(p.x, p.y + 2.2, p.z);
    return;
  }
  if(CAM.mode === 'chase'){
    tmp.copy(p).addScaledVector(forward, -18).add(new THREE.Vector3(0, 7.2, 0));
    camera.position.lerp(tmp, 0.18);
    camera.lookAt(camTarget);
    return;
  }
  if(CAM.mode === 'shoulder'){
    tmp.copy(p).addScaledVector(forward, -6.5).addScaledVector(right, 2.4).add(new THREE.Vector3(0, 3.4, 0));
    camera.position.lerp(tmp, 0.22);
    camera.lookAt(camTarget);
    return;
  }
  if(CAM.mode === 'head'){
    tmp.copy(p).addScaledVector(forward, 0.8).add(new THREE.Vector3(0, 3.0, 0));
    camera.position.lerp(tmp, 0.35);
    camera.lookAt(camTarget);
    return;
  }
  if(CAM.mode === 'cinematic'){
    const t = performance.now()*0.001;
    tmp.copy(p)
      .addScaledVector(forward, -26)
      .addScaledVector(right, Math.sin(t*0.6)*6)
      .add(new THREE.Vector3(0, 12 + Math.sin(t*0.9)*1.2, 0));
    camera.position.lerp(tmp, 0.07);
    camera.lookAt(p.x, p.y + 2.2, p.z);
    return;
  }
}

/* ===================================================
   INTERACTION PINGS üìç
=================================================== */
function isInCone(entityPos){
  const v = entityPos.clone().sub(player.pos);
  v.y = 0;
  const dist = v.length();
  if(dist > 32) return false;
  const f = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  const dot = (dist>0) ? v.normalize().dot(f) : 1;
  return dot > 0.45;
}

function updatePings(){
  const all = game.allies.concat(game.enemies);
  for(const s of all){
    if(!s.ping) continue;
    if(!pingsOn || !coneOn){ s.ping.visible = false; continue; }

    const near = s.pos.distanceTo(player.pos) < 34;
    const inCone = isInCone(s.pos);
    s.ping.visible = near && inCone;

    if(s.ping.visible){
      s.ping.position.set(s.pos.x, s.pos.y + 5.5, s.pos.z);
      const d = s.pos.distanceTo(player.pos);
      const k = THREE.MathUtils.clamp(1.2 - d/45, 0.65, 1.2);
      s.ping.scale.set(7*k, 3.5*k, 1);
    }
  }
}

/* ===================================================
   QUALITY TOGGLE ‚ú®
=================================================== */
let qualityHigh = true;
function setQuality(high){
  qualityHigh = high;
  renderer.setPixelRatio(Math.min(devicePixelRatio || 1, high ? 2 : 1));
  renderer.shadowMap.enabled = high;
  document.getElementById('qualityToggle').textContent = high ? '‚ú® Quality: HIGH' : '‚ö° Quality: FAST';
  toast(high ? '‚ú® High quality' : '‚ö° Fast mode');
}
setQuality(true);

/* ===================================================
   GLB UPLOAD üì¶
=================================================== */
const glbInput = document.getElementById('glbFile');
const uploadBtn = document.getElementById('uploadGLB');
const resetBtn  = document.getElementById('resetGLB');

uploadBtn?.addEventListener('click', ()=>{
  try{ glbInput.value = ''; }catch(_){ }
  glbInput.click();
});

resetBtn?.addEventListener('click', ()=>{
  if(PLAYER_GLB_URL){
    toast('üßπ Reset to URL model');
    loadPlayerGLB(PLAYER_GLB_URL).then(applyLoadedPlayerGLTF).catch(()=>makeFallbackPlayer());
  }else{
    toast('üßπ Reset to fallback');
    makeFallbackPlayer();
  }
});

glbInput?.addEventListener('change', (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;

  const name = (file.name||'').toLowerCase();
  if(name.endsWith('.gltf')){
    toast('‚ö†Ô∏è .gltf may miss textures ‚Äî .glb works best');
    log('‚ö†Ô∏è Loading .gltf ‚Äî if textures are missing, export as .glb (embedded).');
  }

  const url = URL.createObjectURL(file);
  const loader = new THREE.GLTFLoader();
  loader.load(url, (gltf)=>{
    applyLoadedPlayerGLTF(gltf);
    toast('‚úÖ Model loaded');
    log(`üì¶ Loaded local model: ${file.name}`);
    try{ URL.revokeObjectURL(url); }catch(_){ }
  }, undefined, (err)=>{
    console.warn(err);
    toast('‚ùå Failed to load model');
    log('‚ùå Failed to load local model');
    try{ URL.revokeObjectURL(url); }catch(_){ }
  });
});

/* ===================================================
   UI WIRING üß©
=================================================== */
document.getElementById('wave').onclick = spawnWave;

document.getElementById('battle').onclick = ()=>{
  game.battle = !game.battle;
  document.getElementById('battle').textContent = game.battle ? '‚öîÔ∏è Combat: ON' : '‚öîÔ∏è Combat: OFF';
  log(game.battle ? '‚öîÔ∏è Combat engaged' : 'üïäÔ∏è Combat disengaged');
};

document.getElementById('autoplay').onclick = ()=>{
  game.autoplay = !game.autoplay;
  document.getElementById('autoplay').textContent = `ü§ñ Autoplay: ${game.autoplay ? 'ON' : 'OFF'}`;
  log(game.autoplay ? 'ü§ñ Autoplay engaged (goal seeking)' : 'üßç Autoplay stopped');
  if(game.autoplay) pickNewGoal();
};

document.querySelectorAll('[data-profile]').forEach(b=>b.onclick=()=>{
  game.profile = b.dataset.profile;
  log(`ü§ñ Profile set to ${game.profile.toUpperCase()}`);
});

document.getElementById('panic').onclick = ()=>{
  for(let i=0;i<3;i++) spawnWave();
  doctrine.aggression=.9; doctrine.focus=.9; doctrine.kiting=.9;
  log('üö® PANIC MODE ‚Äî doctrines redlined');
};

document.getElementById('coneToggle').onclick = ()=>{
  coneOn = !coneOn;
  document.getElementById('coneToggle').textContent = `üß†üî¶ Cone: ${coneOn ? 'ON' : 'OFF'}`;
};

document.getElementById('interactToggle').onclick = ()=>{
  pingsOn = !pingsOn;
  document.getElementById('interactToggle').textContent = `üìç Pings: ${pingsOn ? 'ON' : 'OFF'}`;
  toast(pingsOn ? 'üìç Pings on' : 'üìç Pings off');
};

document.getElementById('resetCam').onclick = recenterCamera;

document.getElementById('qualityToggle').onclick = ()=> setQuality(!qualityHigh);

document.getElementById('gridToggle').onclick = ()=> setGrid(!gridOn);
document.getElementById('resetGrid').onclick = ()=>{ rebuildGrid(); toast('üß± Grid rebuilt'); };

/* ===================================================
   LOOP üîÅ
=================================================== */
let lastT = performance.now();
let lastDoctrine = performance.now();

function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min(0.033, (now - lastT)/1000);
  lastT = now;

  if(game.autoplay){
    autoplaySteer(dt);
  }

  if(game.autoplay && (now - lastDoctrine) > 4200){
    mutateDoctrine();
    if(game.enemies.length < 4) spawnWave();
    lastDoctrine = now;
  }

  updatePlayer(dt);
  updateCamera(dt);

  game.allies.forEach(s=>s.update());
  game.enemies.forEach(s=>s.update());
  updatePings();

  document.getElementById('gold').textContent = '$' + game.gold;
  document.getElementById('allies').textContent = game.allies.length;
  document.getElementById('enemies').textContent = game.enemies.length;
  document.getElementById('score').textContent = game.score;

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio || 1, qualityHigh ? 2 : 1));
});

/* ===================================================
   SELF-TESTS ‚úÖ
=================================================== */
(function tests(){
  console.assert(typeof THREE !== 'undefined', 'THREE should load');
  console.assert(typeof THREE.GridHelper === 'function', 'GridHelper should exist');
  console.assert(!!document.getElementById('gridToggle'), 'gridToggle should exist');
  console.assert(!!document.getElementById('qualityToggle'), 'qualityToggle should exist');
  console.assert(!!document.getElementById('uploadGLB'), 'uploadGLB should exist');
  console.assert(typeof makeFallbackPlayer === 'function', 'makeFallbackPlayer should exist');
  log('‚úÖ Self-tests passed');
})();

/* Boot */
log('üåä Maritime AI Commander Online');
log('üß≠ Grid helper stabilized (no water z-fight)');
log('üé• POV panel + üß† cone + üìç pings + üöß safe collisions');
log('üì¶ Upload GLB to swap the player model');
</script>
</body>
</html>
