<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Maritime AI Commander ‚Äî Five-AI Constellation Wars</title>
  <meta name="description" content="A playable naval logistics + defense sim where five AI factions (GPT, Gemini, Grok, Claude, AIUIUX) battle for island control." />
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'Courier New',monospace;background:linear-gradient(to bottom,#001a33 0%,#000 100%);color:#0ff;overflow:hidden}
    #canvas-container{width:100vw;height:100vh;position:relative}

    #hud{
      position:absolute;top:20px;left:20px;
      background:linear-gradient(135deg,rgba(0,30,60,.95),rgba(0,50,80,.95));
      border:3px solid #00d4ff;padding:20px;border-radius:12px;min-width:340px;
      pointer-events:none;z-index:100;box-shadow:0 8px 32px rgba(0,212,255,.3)
    }
    .hud-title{color:#00d4ff;font-size:20px;margin-bottom:10px;text-shadow:0 0 15px #00d4ff;font-weight:bold;letter-spacing:1px}
    .hud-subtitle{color:#88ccff;font-size:11px;margin-bottom:12px;opacity:.85;font-style:italic}
    .hud-stat{color:#88ccff;font-size:13px;margin:7px 0;padding:5px 0;border-bottom:1px solid rgba(0,212,255,.2)}
    .hud-value{color:#00ff88;font-weight:bold;float:right}

    #controls-panel{
      position:absolute;bottom:20px;left:20px;
      background:linear-gradient(135deg,rgba(20,20,40,.95),rgba(40,20,60,.95));
      border:3px solid #ff00ff;padding:16px;border-radius:12px;pointer-events:all;
      box-shadow:0 8px 32px rgba(255,0,255,.3);min-width:360px
    }
    .control-section-title{color:#ff00ff;font-size:15px;margin-bottom:10px;text-shadow:0 0 10px #ff00ff;font-weight:bold;letter-spacing:1px}
    .control-btn{
      background:linear-gradient(135deg,#001a33,#003366);
      border:2px solid #00d4ff;color:#00d4ff;padding:10px 14px;margin:5px;
      cursor:pointer;border-radius:8px;font-family:'Courier New',monospace;font-size:12px;font-weight:bold;
      transition:all .25s;box-shadow:0 4px 12px rgba(0,0,0,.3)
    }
    .control-btn:hover{background:linear-gradient(135deg,#00d4ff,#0088ff);color:#000;box-shadow:0 0 22px #00d4ff;transform:translateY(-2px)}
    .control-btn.active{background:linear-gradient(135deg,#ff00ff,#ff0088);border-color:#ff00ff;color:#fff;box-shadow:0 0 24px #ff00ff}

    #tower-shop{
      position:absolute;bottom:20px;right:20px;
      background:linear-gradient(135deg,rgba(40,30,0,.95),rgba(60,40,0,.95));
      border:3px solid #ffaa00;padding:16px;border-radius:12px;pointer-events:all;
      box-shadow:0 8px 32px rgba(255,170,0,.3)
    }
    .shop-title{color:#ffaa00;font-size:15px;margin-bottom:10px;text-shadow:0 0 10px #ffaa00;font-weight:bold;letter-spacing:1px}
    .tower-btn{
      background:linear-gradient(135deg,#332200,#554400);
      border:2px solid #ffaa00;color:#ffaa00;padding:9px 12px;margin:5px;
      cursor:pointer;border-radius:8px;font-family:'Courier New',monospace;font-size:11px;font-weight:bold;
      transition:all .2s;box-shadow:0 4px 12px rgba(0,0,0,.3)
    }
    .tower-btn:hover{background:linear-gradient(135deg,#ffaa00,#ffcc00);color:#000;box-shadow:0 0 18px #ffaa00;transform:translateY(-2px)}
    .tower-btn.selected{background:linear-gradient(135deg,#ffaa00,#ff8800);color:#000;border-color:#fff;box-shadow:0 0 22px #ffaa00}
    .tower-btn.disabled{opacity:.35;cursor:not-allowed}

    #ai-memory{
      position:absolute;top:20px;right:20px;
      background:rgba(40,0,40,.95);border:2px solid #f0f;padding:12px;border-radius:8px;
      max-width:380px;max-height:420px;overflow-y:auto;pointer-events:none
    }
    .memory-entry{background:rgba(80,0,80,.5);border-left:3px solid #f0f;padding:7px;margin:5px 0;font-size:11px;border-radius:3px}

    #battle-stats{
      position:absolute;top:50%;right:20px;transform:translateY(-50%);
      background:rgba(40,20,0,.95);border:2px solid #ff6600;padding:12px;border-radius:8px;pointer-events:none;min-width:220px
    }
    .stat-bar{height:18px;background:rgba(0,0,0,.5);border-radius:10px;overflow:hidden;margin:5px 0}
    .stat-fill{height:100%;transition:width .2s}
    .player-fill{background:linear-gradient(90deg,#00ff00,#00aa00)}
    .ai-fill{background:linear-gradient(90deg,#ff0000,#aa0000)}

    #help{
      position:absolute;left:20px;top:210px;
      background:rgba(0,40,80,.92);border:2px solid #0ff;padding:12px;border-radius:10px;max-width:340px;pointer-events:none
    }
    #help h3{color:#0ff;font-size:13px;margin-bottom:6px}
    #help p{color:#bfe7ff;font-size:11px;line-height:1.25;opacity:.95}
    #help .k{color:#00ff88;font-weight:bold}

    #legend{
      position:absolute;left:20px;top:360px;
      background:rgba(10,10,20,.86);border:1px solid rgba(255,255,255,.16);padding:10px;border-radius:10px;max-width:340px;pointer-events:none
    }
    #legend .row{display:flex;gap:8px;align-items:center;margin:6px 0;font-size:11px;color:#cfe9ff}
    .sw{width:12px;height:12px;border-radius:3px;border:1px solid rgba(255,255,255,.25)}

    #blue-line-knowledge{
      position:absolute;bottom:210px;left:20px;
      background:rgba(0,40,80,.95);border:2px solid #0ff;padding:12px;border-radius:8px;max-width:360px;pointer-events:none
    }

    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.18);font-size:10px;opacity:.9;margin-right:6px}

    #cursor-hint{position:absolute;inset:auto 0 0 0;pointer-events:none;display:flex;justify-content:center;bottom:8px;opacity:.55;font-size:11px;color:#cfe9ff}
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="hud">
    <div class="hud-title">‚öì MARITIME AI COMMANDER</div>
    <div class="hud-subtitle">Five-AI Constellation Wars ‚Ä¢ v3.0 (Playable)</div>
    <div class="hud-stat">Faction: <span class="hud-value" id="player-faction">AIUIUX</span></div>
    <div class="hud-stat">Vehicle Type: <span class="hud-value" id="current-form">NAVAL CARGO</span></div>
    <div class="hud-stat">Credits: <span class="hud-value" id="gold">$1000</span></div>
    <div class="hud-stat">Fleet Assets: <span class="hud-value" id="fleet-size">1</span></div>
    <div class="hud-stat">Enemy Units: <span class="hud-value" id="ai-ships">0</span></div>
    <div class="hud-stat">Allied Defense: <span class="hud-value" id="player-towers">0</span></div>
    <div class="hud-stat">Hostile Defense: <span class="hud-value" id="ai-towers">0</span></div>
    <div class="hud-stat">Island Control: <span class="hud-value" id="control">0 / 0</span></div>
    <div class="hud-stat">Mission Score: <span class="hud-value" id="score">0</span></div>
  </div>

  <div id="controls-panel">
    <div class="control-section-title">üéÆ FLEET OPERATIONS</div>
    <div style="margin-bottom: 12px; border-bottom: 1px solid rgba(255, 0, 255, 0.3); padding-bottom: 10px;">
      <div style="color:#88ccff;font-size:12px;margin-bottom:8px;">üß† Faction Mode</div>
      <button class="control-btn" id="mode-aiuiux" title="You (AIUIUX)">üé® AIUIUX</button>
      <button class="control-btn" id="mode-gpt" title="GPT">‚ú® GPT</button>
      <button class="control-btn" id="mode-gemini" title="Gemini">üßÆ Gemini</button>
      <button class="control-btn" id="mode-claude" title="Claude">üí¨ Claude</button>
      <button class="control-btn" id="mode-grok" title="Grok">ü§ñ Grok</button>
      <div style="color:#9bdcff;font-size:10px;margin-top:6px;opacity:.85">Choose your flagship faction. (Cosmetic + tuning)</div>
    </div>

    <div style="margin-bottom: 12px; border-bottom: 1px solid rgba(255, 0, 255, 0.3); padding-bottom: 10px;">
      <div style="color:#88ccff;font-size:12px;margin-bottom:8px;">üì¶ Vehicle Mode</div>
      <button class="control-btn" id="transform-ship" style="font-size: 11px;">‚õ¥Ô∏è Naval Cargo</button>
      <button class="control-btn" id="transform-car" style="font-size: 11px;">üöõ Ground Transport</button>
    </div>

    <div style="border-top: 1px solid rgba(255, 0, 255, 0.3); padding-top: 10px;">
      <div style="color:#88ccff;font-size:12px;margin-bottom:8px;">‚öôÔ∏è Simulation Control</div>
      <button class="control-btn" id="spawn-fleet">üö¢ Deploy Factions</button>
      <button class="control-btn" id="start-battle">‚öîÔ∏è Combat Mode: <span id="battle-status">STANDBY</span></button>
      <button class="control-btn" id="toggle-ai-build">üèóÔ∏è AI Construction: <span id="ai-build-status">OFF</span></button>
      <button class="control-btn" id="self-play">ü§ñ Auto-Sim: <span id="self-play-status">OFF</span></button>
    </div>
  </div>

  <div id="tower-shop">
    <div class="shop-title">üè≠ DEFENSE SYSTEMS CATALOG</div>
    <div style="font-size: 10px; color: #cc8800; margin-bottom: 10px; font-style: italic;">Select & Deploy on Islands ‚Ä¢ Click island to place</div>
    <button class="tower-btn" data-tower="cannon" data-cost="100">üî• Auto-Cannon<br>$100</button>
    <button class="tower-btn" data-tower="harpoon" data-cost="150">üéØ Harpoon Array<br>$150</button>
    <button class="tower-btn" data-tower="net" data-cost="200">üï∏Ô∏è Net Launcher<br>$200</button>
    <button class="tower-btn" data-tower="lighthouse" data-cost="300">üóº Defense Beacon<br>$300</button>
    <div style="margin-top:10px;font-size:10px;color:#ffd37a;opacity:.9">
      <span class="pill">Tip</span> Press <b>E</b> to place near flagship.
    </div>
  </div>

  <div id="ai-memory">
    <div style="color:#f0f;font-size:14px;margin-bottom:8px;">üß† AI LEARNING MEMORY</div>
    <div id="memory-log"></div>
  </div>

  <div id="help">
    <h3>üß≠ Controls</h3>
    <p><span class="k">WASD</span> move flagship ‚Ä¢ <span class="k">Shift</span> boost ‚Ä¢ <span class="k">Click</span> island to place selected tower</p>
    <p><span class="k">E</span> quick-place tower near flagship ‚Ä¢ <span class="k">Mouse</span> camera is auto-follow</p>
    <p>Goal: capture islands by building towers + surviving. Destroy enemy ships, earn credits, expand control.</p>
  </div>

  <div id="legend">
    <div style="color:#cfe9ff;font-size:12px;margin-bottom:6px;opacity:.95">üß© Factions</div>
    <div class="row"><span class="sw" style="background:#00ffff"></span> AIUIUX (You)</div>
    <div class="row"><span class="sw" style="background:#a855f7"></span> GPT</div>
    <div class="row"><span class="sw" style="background:#22c55e"></span> Gemini</div>
    <div class="row"><span class="sw" style="background:#f59e0b"></span> Claude</div>
    <div class="row"><span class="sw" style="background:#ef4444"></span> Grok</div>
    <div style="margin-top:8px;color:#9bdcff;font-size:10px;opacity:.85">Enemy factions spawn when you click ‚ÄúDeploy Factions‚Äù.</div>
  </div>

  <div id="blue-line-knowledge">
    <div style="color:#0ff;font-size:13px;margin-bottom:8px;">üìò BLUE LINE KNOWLEDGE</div>
    <div style="font-size:11px;color:#aaa;margin-bottom:6px;">Survival Strategies (learned)</div>
    <div id="knowledge-list" style="font-size:11px;"></div>
  </div>

  <div id="battle-stats">
    <div style="color:#ff6600;font-size:13px;margin-bottom:8px;">‚öîÔ∏è BATTLE STATUS</div>
    <div style="color:#0f0;font-size:12px;">Player Fleet</div>
    <div class="stat-bar"><div class="stat-fill player-fill" id="player-power" style="width:50%"></div></div>
    <div style="color:#f00;font-size:12px;margin-top:8px;">Enemy Factions</div>
    <div class="stat-bar"><div class="stat-fill ai-fill" id="ai-power" style="width:50%"></div></div>
    <div style="color:#fff;font-size:11px;margin-top:8px;">
      Battles Won: <span id="battles-won">0</span> / <span id="battles-total">0</span>
    </div>
  </div>

  <div id="cursor-hint">Click islands to place towers ‚Ä¢ Try Auto-Sim for chaos learning</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ==============================================
    // Five-AI Constellation Wars ‚Äî Playable Sim
    // ==============================================

    // ----------------------
    // Global Constants
    // ----------------------
    // Keep all ships on a single water plane (fixes elevation drift)
    const SEA_Y = 1.0;

    // ----------------------
    // Game State
    // ----------------------
    const gameState = {
      time: 0,
      gold: 1000,
      score: 0,
      battlesWon: 0,
      battlesTotal: 0,

      playerFaction: 'aiuiux',
      battleActive: false,
      aiBuildEnabled: false,
      selfPlayMode: false,
      selfPlayInterval: null,

      selectedTower: null,

      islands: [],
      playerShips: [],
      enemyShips: [],
      playerTowers: [],
      enemyTowers: [],
      projectiles: [],

      islandControl: { player: 0, enemy: 0 }
    };

    // ----------------------
    // Factions (colors + tuning)
    // ----------------------
    const FACTIONS = {
      aiuiux: { name: 'AIUIUX', emoji: 'üé®', color: 0x00ffff, emissive: 0x00ffff, tune: { maxSpeed: 0.42, maxForce: 0.055, income: 10 } },
      gpt:    { name: 'GPT',    emoji: '‚ú®', color: 0xa855f7, emissive: 0xa855f7, tune: { maxSpeed: 0.40, maxForce: 0.060, income: 10 } },
      gemini: { name: 'Gemini', emoji: 'üßÆ', color: 0x22c55e, emissive: 0x22c55e, tune: { maxSpeed: 0.44, maxForce: 0.050, income: 10 } },
      claude: { name: 'Claude', emoji: 'üí¨', color: 0xf59e0b, emissive: 0xf59e0b, tune: { maxSpeed: 0.38, maxForce: 0.065, income: 10 } },
      grok:   { name: 'Grok',   emoji: 'ü§ñ', color: 0xef4444, emissive: 0xef4444, tune: { maxSpeed: 0.46, maxForce: 0.070, income: 10 } },
    };

    function factionLabel(key){
      const f = FACTIONS[key] || FACTIONS.aiuiux;
      return `${f.emoji} ${f.name}`;
    }

    // ----------------------
    // AI Memory System
    // ----------------------
    const aiMemory = {
      towerPlacements: [],
      islandPreferences: {},
      towerTypeUsage: { cannon: 0, harpoon: 0, net: 0, lighthouse: 0 },

      recordPlacement(island, towerType, effectiveness){
        if(!island) return;
        const islandName = island.userData ? island.userData.name : island.name;
        if(!islandName) return;

        this.towerPlacements.push({ island, towerType, effectiveness, timestamp: Date.now() });
        this.towerTypeUsage[towerType] = (this.towerTypeUsage[towerType] || 0) + 1;

        if(!this.islandPreferences[islandName]){
          this.islandPreferences[islandName] = { placements: 0, towers: [], effectiveness: 0 };
        }
        const pref = this.islandPreferences[islandName];
        pref.placements++;
        pref.towers.push(towerType);
        pref.effectiveness = (pref.effectiveness + effectiveness) / 2;

        logMemory(`Learned: ${towerType} on ${islandName} (${(effectiveness*100).toFixed(0)}% effective)`);
        if(this.towerPlacements.length > 60) this.towerPlacements.shift();
      },

      getBestTowerForIsland(island){
        if(!island) return 'cannon';
        const islandName = island.userData ? island.userData.name : island.name;
        if(!islandName) return 'cannon';
        const pref = this.islandPreferences[islandName];
        if(!pref || pref.towers.length === 0){
          const sorted = Object.entries(this.towerTypeUsage).sort((a,b)=>b[1]-a[1]);
          return sorted[0] ? sorted[0][0] : 'cannon';
        }
        const counts = {};
        pref.towers.forEach(t => counts[t] = (counts[t]||0)+1);
        return Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
      },

      getBestIslands(){
        return Object.entries(this.islandPreferences)
          .sort((a,b)=>b[1].effectiveness-a[1].effectiveness)
          .slice(0,4)
          .map(e=>e[0]);
      }
    };

    function logMemory(message){
      const log = document.getElementById('memory-log');
      const entry = document.createElement('div');
      entry.className = 'memory-entry';
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      log.insertBefore(entry, log.firstChild);
      while(log.children.length > 22) log.removeChild(log.lastChild);
    }

    // ----------------------
    // Three.js Scene
    // ----------------------
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x001a33, 60, 320);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1100);
    camera.position.set(0, 45, 70);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0x404060, 0.65));

    const dir = new THREE.DirectionalLight(0xffffff, 0.85);
    dir.position.set(60, 120, 40);
    dir.castShadow = true;
    dir.shadow.mapSize.width = 2048;
    dir.shadow.mapSize.height = 2048;
    scene.add(dir);

    scene.add(new THREE.HemisphereLight(0x87CEEB, 0x0066aa, 0.55));

    // Water
    const waterGeometry = new THREE.PlaneGeometry(560, 560, 72, 72);
    const waterMaterial = new THREE.MeshStandardMaterial({
      color: 0x1E90FF,
      roughness: 0.65,
      metalness: 0.28,
      transparent: true,
      opacity: 0.9
    });
    const water = new THREE.Mesh(waterGeometry, waterMaterial);
    water.rotation.x = -Math.PI/2;
    water.receiveShadow = true;
    scene.add(water);

    function animateWater(){
      const t = performance.now() * 0.001;
      const pos = water.geometry.attributes.position;
      for(let i=0;i<pos.count;i++){
        const x = pos.getX(i);
        const y = pos.getY(i);
        pos.setZ(i,
          Math.sin(x*0.08 + t)*0.35 +
          Math.cos(y*0.09 + t*0.75)*0.25 +
          Math.sin((x+y)*0.03 + t*1.2)*0.18
        );
      }
      pos.needsUpdate = true;
      water.geometry.computeVertexNormals();
    }

    // ----------------------
    // Ships
    // ----------------------
    class NavalShip{
      constructor(x, z, opts = {}){
        this.position = new THREE.Vector3(x, SEA_Y, z);
        this.velocity = new THREE.Vector3(0,0,0);
        this.acceleration = new THREE.Vector3(0,0,0);
        this.rotation = 0;

        this.isPlayer = !!opts.isPlayer;
        this.faction = opts.faction || (this.isPlayer ? gameState.playerFaction : 'grok');
        this.owner = this.isPlayer ? 'player' : 'enemy';

        this.health = 100;
        this.maxHealth = 100;
        this.gold = this.isPlayer ? 0 : 450;
        this.form = 'ship';
        this.buildCooldown = 0;

        const tune = (FACTIONS[this.faction] || FACTIONS.aiuiux).tune;
        this.maxSpeed = tune.maxSpeed;
        this.maxForce = tune.maxForce;

        this.kills = 0;
        this.age = 0;
        this.maxAge = 800;
        this.decayRate = 0.02;
        this.scale = 1.0;

        this.blueLineKnowledge = [];
        this.survivalStrategies = {
          stayNearTowers: 0,
          buildCannons: 0,
          buildHarpoons: 0,
          buildNets: 0,
          buildLighthouses: 0,
          flockWithAllies: 0,
          maintainDistance: 0
        };

        this.createMesh();
        this.createHealthBar();
      }

      createMesh(){
        const f = FACTIONS[this.faction] || FACTIONS.aiuiux;
        this.group = new THREE.Group();

        const hullGeom = new THREE.BoxGeometry(3, 1, 6);
        const hullMat = new THREE.MeshStandardMaterial({
          color: f.color,
          emissive: f.emissive,
          emissiveIntensity: 0.28,
          metalness: 0.7,
          roughness: 0.35
        });
        this.hull = new THREE.Mesh(hullGeom, hullMat);
        this.hull.position.y = 0.5;
        this.hull.castShadow = true;
        this.group.add(this.hull);

        const deck = new THREE.Mesh(
          new THREE.BoxGeometry(2.5, 0.2, 5.5),
          new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9, metalness: 0.05 })
        );
        deck.position.y = 1.1;
        this.group.add(deck);

        const mast = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.15, 8),
          new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 })
        );
        mast.position.y = 5;
        this.group.add(mast);

        const sail = new THREE.Mesh(
          new THREE.PlaneGeometry(3, 5),
          new THREE.MeshStandardMaterial({
            color: this.isPlayer ? 0xffffff : f.color,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide,
            roughness: 0.9
          })
        );
        sail.position.set(1.5, 5, 0);
        this.group.add(sail);

        const badge = new THREE.Mesh(
          new THREE.SphereGeometry(0.25, 12, 12),
          new THREE.MeshBasicMaterial({ color: f.color })
        );
        badge.position.set(0, 2.2, -2.2);
        this.group.add(badge);

        this.group.position.copy(this.position);
        scene.add(this.group);
      }

      createHealthBar(){
        const barW = 3;
        const barH = 0.3;
        const bg = new THREE.Mesh(
          new THREE.PlaneGeometry(barW, barH),
          new THREE.MeshBasicMaterial({ color: 0x330000 })
        );
        bg.position.y = 8;
        this.group.add(bg);

        this.healthBar = new THREE.Mesh(
          new THREE.PlaneGeometry(barW, barH),
          new THREE.MeshBasicMaterial({ color: this.isPlayer ? 0x00ff00 : 0xff0000 })
        );
        this.healthBar.position.y = 8;
        this.healthBar.position.z = 0.01;
        this.group.add(this.healthBar);
      }

      updateHealthBar(){
        const p = Math.max(0, this.health / this.maxHealth);
        this.healthBar.scale.x = p;
        this.healthBar.position.x = -1.5 * (1 - p);
        this.healthBar.parent.children.forEach(o => {
          if(o.geometry && o.geometry.type === 'PlaneGeometry') o.lookAt(camera.position);
        });
      }

      addKill(){
        this.kills++;
        this.scale = Math.min(2.0, 1.0 + this.kills * 0.09);
        this.group.scale.set(this.scale, this.scale, this.scale);
        this.maxHealth = 100 + this.kills * 18;
        this.health = Math.min(this.health + 20, this.maxHealth);
        logMemory(`${this.isPlayer ? 'Player' : 'Enemy'} ship leveled up! Kills: ${this.kills} ‚Ä¢ Size: ${this.scale.toFixed(1)}x`);
      }

      learnStrategy(strategy, effectiveness){
        this.survivalStrategies[strategy] = (this.survivalStrategies[strategy] || 0) + effectiveness;
        this.blueLineKnowledge.push({ strategy, effectiveness, timestamp: Date.now() });
        if(this.blueLineKnowledge.length > 10) this.blueLineKnowledge.shift();
      }

      separate(others){
        const out = new THREE.Vector3();
        let count = 0;
        others.forEach(o => {
          if(o === this) return;
          const d = this.position.distanceTo(o.position);
          if(d < 8){
            out.add(new THREE.Vector3().subVectors(this.position, o.position).normalize().divideScalar(Math.max(0.001,d)));
            count++;
          }
        });
        if(count>0){
          out.divideScalar(count).normalize().multiplyScalar(this.maxSpeed);
          return new THREE.Vector3().subVectors(out, this.velocity).clampLength(0, this.maxForce);
        }
        return out;
      }

      align(others){
        const out = new THREE.Vector3();
        let count = 0;
        others.forEach(o => {
          if(o === this) return;
          const d = this.position.distanceTo(o.position);
          if(d < 16){ out.add(o.velocity); count++; }
        });
        if(count>0){
          out.divideScalar(count).normalize().multiplyScalar(this.maxSpeed);
          return new THREE.Vector3().subVectors(out, this.velocity).clampLength(0, this.maxForce);
        }
        return out;
      }

      cohesion(others){
        const center = new THREE.Vector3();
        let count = 0;
        others.forEach(o => {
          if(o === this) return;
          const d = this.position.distanceTo(o.position);
          if(d < 22){ center.add(o.position); count++; }
        });
        if(count>0){
          center.divideScalar(count);
          return this.seek(center);
        }
        return center;
      }

      seek(target){
        const desired = new THREE.Vector3().subVectors(target, this.position).normalize().multiplyScalar(this.maxSpeed);
        // force must be horizontal only
        desired.y = 0;
        const steer = new THREE.Vector3().subVectors(desired, this.velocity);
        steer.y = 0;
        return steer.clampLength(0, this.maxForce);
      }

      avoidShallowWater(){
        const avoidance = new THREE.Vector3();
        let count = 0;
        gameState.islands.forEach(island => {
          if(island.isInShallowWater(this.position)){
            const v = new THREE.Vector3().subVectors(this.position, island.position);
            v.y = 0;
            avoidance.add(v.normalize());
            count++;
          }
        });
        if(count>0){
          avoidance.divideScalar(count);
          avoidance.y = 0;
          avoidance.normalize().multiplyScalar(this.maxSpeed);
          const steer = new THREE.Vector3().subVectors(avoidance, this.velocity);
          steer.y = 0;
          return steer.clampLength(0, this.maxForce * 2.2);
        }
        return avoidance;
      }

      seekNearestTower(){
        const towers = this.isPlayer ? gameState.playerTowers : gameState.enemyTowers;
        if(!towers.length) return new THREE.Vector3();
        let best = null, bestD = Infinity;
        towers.forEach(t => {
          const d = this.position.distanceTo(t.position);
          if(d < bestD){ bestD = d; best = t; }
        });
        if(best && bestD < 36){
          this.learnStrategy('stayNearTowers', 0.08);
          return this.seek(best.position).multiplyScalar(0.35);
        }
        return new THREE.Vector3();
      }

      update(dt, allies = []){
        this.age++;
        if(this.age > this.maxAge){
          this.health -= this.decayRate;
          if(this.health <= 0){
            logMemory(`${this.isPlayer ? 'Player' : 'Enemy'} ship retired (old age).`);
            return false;
          }
        }

        const inShallow = gameState.islands.some(island => island.isInShallowWater(this.position));
        if(inShallow){
          if(!this.isPlayer){ this.health -= 0.8; }
          this.maxSpeed *= 0.985;
        } else {
          const tune = (FACTIONS[this.faction] || FACTIONS.aiuiux).tune;
          this.maxSpeed = tune.maxSpeed;
        }

        this.acceleration.set(0,0,0);
        const sep = this.separate(allies).multiplyScalar(1.45);
        const ali = this.align(allies).multiplyScalar(1.0);
        const coh = this.cohesion(allies).multiplyScalar(1.0);
        const tow = this.seekNearestTower();
        const shallow = this.avoidShallowWater().multiplyScalar(2.0);

        if(this.isPlayer && gameState.playerShips.length > 0 && this !== gameState.playerShips[0]){
          const lead = gameState.playerShips[0];
          this.acceleration.add(this.seek(lead.position).multiplyScalar(1.1));
          this.acceleration.add(sep.multiplyScalar(1.0));
          this.learnStrategy('flockWithAllies', 0.02);
        } else {
          this.acceleration.add(sep);
          this.acceleration.add(ali);
          this.acceleration.add(coh);
          this.acceleration.add(tow);
          this.acceleration.add(shallow);

          if(!this.isPlayer && gameState.battleActive && gameState.playerShips[0]){
            const p = gameState.playerShips[0];
            const desire = this.seek(p.position).multiplyScalar(0.25 + Math.min(0.35, this.kills * 0.05));
            this.acceleration.add(desire);
          }
        }

        // ensure horizontal-only acceleration
        this.acceleration.y = 0;

        this.velocity.add(this.acceleration);
        this.velocity.y = 0;
        this.velocity.clampLength(0, this.maxSpeed);

        this.position.add(this.velocity);
        // hard lock to sea plane
        this.position.y = SEA_Y;

        this.velocity.multiplyScalar(0.95);
        this.velocity.y = 0;

        if(this.velocity.length() > 0.01){
          this.rotation = Math.atan2(this.velocity.x, this.velocity.z);
        }

        this.position.x = Math.max(-230, Math.min(230, this.position.x));
        this.position.z = Math.max(-230, Math.min(230, this.position.z));

        this.group.position.copy(this.position);
        this.group.rotation.y = this.rotation;

        this.buildCooldown = Math.max(0, this.buildCooldown - dt*1000);
        this.updateHealthBar();
        return true;
      }

      remove(){ scene.remove(this.group); }
    }

    // ----------------------
    // Islands
    // ----------------------
    class ProceduralIsland{
      constructor(x, z, size, name, depth = 3){
        this.position = new THREE.Vector3(x, 0, z);
        this.size = size;
        this.baseSize = size;
        this.name = name;
        this.towers = [];
        this.depth = depth;
        this.shallowWaterRadius = size * 1.9;
        this.deepWaterRadius = size * 0.65;
        this.createProceduralMesh();
      }

      generateIslandPoints(iter){
        const pts = [];
        const seg = 10 + iter*4;
        for(let i=0;i<seg;i++){
          const a = (Math.PI*2*i)/seg;
          const n1 = Math.sin(a*3 + this.position.x*0.07)*0.3;
          const n2 = Math.cos(a*5 + this.position.z*0.07)*0.22;
          const n3 = Math.sin(a*7)*0.14;
          const r = this.baseSize*(1 + n1 + n2 + n3);
          pts.push(new THREE.Vector2(Math.cos(a)*r, Math.sin(a)*r));
        }
        return pts;
      }

      createProceduralMesh(){
        const pts = this.generateIslandPoints(this.depth);
        const shape = new THREE.Shape(pts);
        const extrude = {
          depth: 2.0 + Math.random()*2.2,
          bevelEnabled: true,
          bevelThickness: 0.55,
          bevelSize: 0.35,
          bevelSegments: 3
        };
        const geom = new THREE.ExtrudeGeometry(shape, extrude);
        const mat = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(0.25 + Math.random()*0.08, 0.45, 0.34),
          roughness: 0.92,
          metalness: 0.08
        });
        this.mesh = new THREE.Mesh(geom, mat);
        this.mesh.rotation.x = -Math.PI/2;
        this.mesh.position.copy(this.position);
        this.mesh.position.y = 0.55;
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        this.mesh.userData = { type:'island', name:this.name, island:this, isIsland:true };
        scene.add(this.mesh);

        this.addVegetation();
        this.createShallowWaterZone();
      }

      addVegetation(){
        const treeCount = Math.floor(3 + Math.random()*6);
        for(let i=0;i<treeCount;i++){
          const a = Math.random()*Math.PI*2;
          const d = Math.random()*this.baseSize*0.65;
          const h = 2 + Math.random()*3.2;
          const tree = new THREE.Mesh(
            new THREE.ConeGeometry(0.45 + Math.random()*0.45, h, 6),
            new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(0.30+Math.random()*0.05, 0.62, 0.25), roughness: 0.95 })
          );
          tree.position.set(this.position.x + Math.cos(a)*d, h/2 + 1.05, this.position.z + Math.sin(a)*d);
          tree.castShadow = true;
          scene.add(tree);
        }
      }

      createShallowWaterZone(){
        const ring = new THREE.Mesh(
          new THREE.RingGeometry(this.deepWaterRadius, this.shallowWaterRadius, 36),
          new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent:true, opacity:0.14, side:THREE.DoubleSide })
        );
        ring.rotation.x = -Math.PI/2;
        ring.position.copy(this.position);
        ring.position.y = 0.05;
        scene.add(ring);
      }

      isInShallowWater(pos){
        const dx = pos.x - this.position.x;
        const dz = pos.z - this.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        return dist < this.shallowWaterRadius && dist > this.deepWaterRadius;
      }
    }

    // ----------------------
    // Towers
    // ----------------------
    class Tower{
      constructor(position, type, owner, factionKey = null){
        this.position = position.clone();
        this.type = type;
        this.owner = owner;
        this.faction = factionKey || (owner === 'player' ? gameState.playerFaction : 'grok');
        this.lastFire = 0;
        this.kills = 0;
        this.setupStats();
        this.createMesh();
      }

      setupStats(){
        const stats = {
          cannon:    { range: 32, damage: 26, fireRate: 950, cost: 100, speed: 0.62 },
          harpoon:   { range: 44, damage: 42, fireRate: 1350, cost: 150, speed: 0.78 },
          net:       { range: 28, damage: 16, fireRate: 1850, cost: 200, slow: 0.55, speed: 0.55 },
          lighthouse:{ range: 56, damage: 10, fireRate: 520, cost: 300, speed: 0.88 }
        };
        const s = stats[this.type];
        this.range = s.range;
        this.damage = s.damage;
        this.fireRate = s.fireRate;
        this.cost = s.cost;
        this.slow = s.slow || 0;
        this.projSpeed = s.speed;
      }

      createMesh(){
        this.group = new THREE.Group();
        const f = FACTIONS[this.faction] || FACTIONS.aiuiux;
        const color = f.color;

        const pad = new THREE.Mesh(
          new THREE.CylinderGeometry(1.4, 1.8, 0.5, 16),
          new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.9, metalness: 0.1 })
        );
        pad.position.y = 0.25;
        this.group.add(pad);

        if(this.type === 'cannon'){
          const base = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.4, 1.8, 12), new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.85 }));
          base.position.y = 1.2; this.group.add(base);
          const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.28, 2.1, 10), new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.18, metalness: 0.85, roughness: 0.25 }));
          barrel.rotation.z = Math.PI/2; barrel.position.y = 2.2; this.group.add(barrel);
        }
        if(this.type === 'harpoon'){
          const base = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1.1, 2.2), new THREE.MeshStandardMaterial({ color: 0x8B7355, roughness: 0.85 }));
          base.position.y = 1.05; this.group.add(base);
          const rail = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.55, 3.2), new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.15, metalness: 0.8, roughness: 0.3 }));
          rail.position.y = 2.0; this.group.add(rail);
        }
        if(this.type === 'net'){
          const base = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.4, 1.4, 12), new THREE.MeshStandardMaterial({ color: 0x4d5d3d, roughness: 0.9 }));
          base.position.y = 1.0; this.group.add(base);
          const ring = new THREE.Mesh(new THREE.TorusGeometry(1.05, 0.12, 8, 18), new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.12, roughness: 0.6 }));
          ring.position.y = 2.2; this.group.add(ring);
        }
        if(this.type === 'lighthouse'){
          const body = new THREE.Mesh(new THREE.CylinderGeometry(1.05, 1.55, 6.2, 14), new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.85 }));
          body.position.y = 3.3; this.group.add(body);
          const cap = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.6, 14), new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7 }));
          cap.position.y = 6.7; this.group.add(cap);
          const lamp = new THREE.Mesh(new THREE.SphereGeometry(0.55, 16, 16), new THREE.MeshBasicMaterial({ color }));
          lamp.position.y = 7.1; this.group.add(lamp);
          const pl = new THREE.PointLight(color, 1.0, 65);
          pl.position.y = 7.1; this.group.add(pl);
        }

        const ring = new THREE.Mesh(
          new THREE.TorusGeometry(2.0, 0.08, 8, 22),
          new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.55 })
        );
        ring.rotation.x = Math.PI/2;
        ring.position.y = 0.65;
        this.group.add(ring);

        this.group.position.copy(this.position);
        this.group.castShadow = true;
        scene.add(this.group);
      }

      computeLeadPoint(target){
        const muzzle = this.position.clone().setY(3.0);
        const toTarget = new THREE.Vector3().subVectors(target.position, muzzle);
        const dist = toTarget.length();
        const t = dist / Math.max(0.001, this.projSpeed);
        const future = target.position.clone().add(target.velocity.clone().multiplyScalar(t));
        future.y = target.position.y;
        return future;
      }

      fire(target){
        const now = performance.now();
        if(now - this.lastFire < this.fireRate) return null;
        this.lastFire = now;

        const origin = this.position.clone().setY(3.0);
        const lead = this.computeLeadPoint(target);
        const dir = new THREE.Vector3().subVectors(lead, origin).normalize();

        const projectile = {
          position: origin.clone(),
          velocity: dir.multiplyScalar(this.projSpeed),
          damage: this.damage,
          owner: this.owner,
          type: this.type,
          slow: this.slow,
          mesh: this.createProjectileMesh(),
          ttl: 6.0
        };
        projectile.mesh.position.copy(projectile.position);
        scene.add(projectile.mesh);
        return projectile;
      }

      createProjectileMesh(){
        const f = FACTIONS[this.faction] || FACTIONS.aiuiux;
        const color = f.color;
        let geom, mat;
        if(this.type === 'cannon'){
          geom = new THREE.SphereGeometry(0.32, 12, 12);
          mat = new THREE.MeshBasicMaterial({ color });
        } else if(this.type === 'harpoon'){
          geom = new THREE.CylinderGeometry(0.06, 0.06, 1.6, 8);
          mat = new THREE.MeshBasicMaterial({ color });
        } else {
          geom = new THREE.SphereGeometry(0.22, 10, 10);
          mat = new THREE.MeshBasicMaterial({ color });
        }
        return new THREE.Mesh(geom, mat);
      }

      remove(){ scene.remove(this.group); }
    }

    // ----------------------
    // Map generation
    // ----------------------
    const islandNames = [
      'Port Authority','Logistics Hub','Trade Station','Cargo Terminal','Supply Depot','Distribution Center','Freight Island','Commerce Bay',
      'Industrial Sector','Transport Node','Shipping Central','Warehouse Bay','Loading Zone','Container Port','Maritime Junction','Bulk Terminal'
    ];

    function createIslandCluster(cx, cz, clusterSize, islandCount){
      const cellSize = 16;
      const occupied = new Set();
      for(let i=0;i<islandCount;i++){
        let tries=0, placed=false;
        while(!placed && tries<30){
          const a = Math.random()*Math.PI*2;
          const d = Math.random()*clusterSize;
          const x = cx + Math.cos(a)*d;
          const z = cz + Math.sin(a)*d;
          const cellX = Math.floor(x/cellSize);
          const cellZ = Math.floor(z/cellSize);
          const key = `${cellX},${cellZ}`;
          if(!occupied.has(key)){
            occupied.add(key);
            const size = 5 + Math.random()*4.2;
            const depth = Math.floor(2 + Math.random()*2);
            const name = islandNames[gameState.islands.length % islandNames.length];
            const island = new ProceduralIsland(x, z, size, name, depth);
            gameState.islands.push(island);
            placed = true;
          }
          tries++;
        }
      }
    }

    createIslandCluster(0, 0, 45, 5);
    createIslandCluster(-90, -65, 38, 3);
    createIslandCluster(80, -55, 34, 3);
    createIslandCluster(-55, 90, 36, 2);
    createIslandCluster(65, 78, 38, 3);
    createIslandCluster(-110, 20, 28, 2);

    // ----------------------
    // Player ship
    // ----------------------
    const playerShip = new NavalShip(0, 0, { isPlayer: true, faction: gameState.playerFaction });
    gameState.playerShips.push(playerShip);

    // ----------------------
    // Input
    // ----------------------
    const keys = {};
    document.addEventListener('keydown', (e)=>{
      keys[e.code] = true;
      if(e.code === 'KeyE' && gameState.selectedTower){
        const pos = gameState.playerShips[0]?.position?.clone();
        if(pos) {
          const n = nearestIsland(pos);
          if(n){
            const p = n.position.clone();
            const off = new THREE.Vector3((Math.random()-0.5)*n.size*0.55, 0, (Math.random()-0.5)*n.size*0.55);
            p.add(off);
            p.y = 3;
            tryPlaceTower(p, gameState.selectedTower, false, n);
          } else {
            pos.y = 3;
            tryPlaceTower(pos, gameState.selectedTower, false, null);
          }
        }
      }
    });
    document.addEventListener('keyup', (e)=> keys[e.code] = false);

    function nearestIsland(pos){
      let best=null, bestD=Infinity;
      for(const isl of gameState.islands){
        const d = pos.distanceTo(isl.position);
        if(d < bestD){ bestD = d; best = isl; }
      }
      return best;
    }

    // Mouse click for tower placement
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    renderer.domElement.addEventListener('click', (event)=>{
      if(!gameState.selectedTower) return;
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(gameState.islands.map(i=>i.mesh));
      if(intersects.length){
        const obj = intersects[0].object;
        if(!obj.userData || !obj.userData.island) return;
        const island = obj.userData.island;
        const p = intersects[0].point.clone();
        p.y = 3;
        tryPlaceTower(p, gameState.selectedTower, false, island);
      }
    });

    // ----------------------
    // Tower placement
    // ----------------------
    function towerCost(type){
      return ({ cannon:100, harpoon:150, net:200, lighthouse:300 })[type] || 100;
    }

    function tryPlaceTower(position, towerType, isEnemy, island=null, enemyFaction=null){
      const cost = towerCost(towerType);

      if(isEnemy){
        const builder = gameState.enemyShips.find(s => s.buildCooldown === 0 && s.gold >= cost);
        if(!builder) return false;
        builder.gold -= cost;
        builder.buildCooldown = 3000;
        const fac = enemyFaction || builder.faction || 'grok';
        const t = new Tower(position, towerType, 'enemy', fac);
        gameState.enemyTowers.push(t);
        if(island && island.towers) island.towers.push(t);
        builder.learnStrategy(`build${towerType.charAt(0).toUpperCase()}${towerType.slice(1)}s`, 0.45);
        logMemory(`${factionLabel(fac)} built ${towerType}`);
        return true;
      }

      if(gameState.gold < cost){
        logMemory(`Insufficient credits: need $${cost}, have $${gameState.gold}`);
        return false;
      }
      gameState.gold -= cost;
      const t = new Tower(position, towerType, 'player', gameState.playerFaction);
      gameState.playerTowers.push(t);
      if(island && island.towers) island.towers.push(t);

      if(island){
        const centerDist = position.distanceTo(island.position);
        const centerScore = Math.max(0, 1 - (centerDist / (island.size*1.2)));
        const typeBonus = (towerType === 'lighthouse') ? 0.1 : (towerType === 'harpoon' ? 0.08 : 0.04);
        const eff = Math.min(1, 0.65 + centerScore*0.25 + typeBonus + Math.random()*0.08);
        aiMemory.recordPlacement(island, towerType, eff);
      }

      gameState.playerShips.forEach(s => {
        if(s.position.distanceTo(position) < 55){
          s.learnStrategy(`build${towerType.charAt(0).toUpperCase()}${towerType.slice(1)}s`, 0.35);
        }
      });

      logMemory(`Built ${towerType} for $${cost}`);
      return true;
    }

    // ----------------------
    // Enemy AI building logic
    // ----------------------
    function updateEnemyBuilding(){
      if(!gameState.aiBuildEnabled) return;
      for(const ship of gameState.enemyShips){
        if(ship.buildCooldown > 0 || ship.gold < 100) continue;

        const bestIslands = aiMemory.getBestIslands();
        let targetIsland = null;
        if(bestIslands.length){
          const name = bestIslands[Math.floor(Math.random()*bestIslands.length)];
          targetIsland = gameState.islands.find(i => i.name === name);
        }
        if(!targetIsland) targetIsland = gameState.islands[Math.floor(Math.random()*gameState.islands.length)];
        if(!targetIsland) continue;

        const towerType = aiMemory.getBestTowerForIsland(targetIsland);
        const off = new THREE.Vector3((Math.random()-0.5)*targetIsland.size*0.65, 0, (Math.random()-0.5)*targetIsland.size*0.65);
        const p = targetIsland.position.clone().add(off);
        p.y = 3;
        tryPlaceTower(p, towerType, true, targetIsland, ship.faction);
      }
    }

    // ----------------------
    // Combat system
    // ----------------------
    function updateCombat(dt){
      // Collision detection only on shots: approximate land as deep-water radius.
      function projectileHitsLand(p){
        for(const isl of gameState.islands){
          const dx = p.x - isl.position.x;
          const dz = p.z - isl.position.z;
          const d = Math.sqrt(dx*dx + dz*dz);
          if(d < isl.deepWaterRadius){
            return true;
          }
        }
        return false;
      }

      for(const t of gameState.playerTowers){
        for(const s of gameState.enemyShips){
          if(t.position.distanceTo(s.position) <= t.range){
            const p = t.fire(s);
            if(p) gameState.projectiles.push(p);
          }
        }
      }
      for(const t of gameState.enemyTowers){
        for(const s of gameState.playerShips){
          if(t.position.distanceTo(s.position) <= t.range){
            const p = t.fire(s);
            if(p) gameState.projectiles.push(p);
          }
        }
      }

      for(let i = gameState.projectiles.length-1; i>=0; i--){
        const proj = gameState.projectiles[i];
        proj.ttl -= dt;
        proj.position.add(proj.velocity.clone().multiplyScalar(1.0));
        // keep shots above water surface
        proj.position.y = Math.max(0.6, proj.position.y);
        proj.mesh.position.copy(proj.position);

        if(projectileHitsLand(proj.position)){
          scene.remove(proj.mesh);
          gameState.projectiles.splice(i,1);
          continue;
        }

        const hitR = (proj.type === 'harpoon') ? 2.2 : 1.9;

        if(proj.owner === 'player'){
          for(let j=gameState.enemyShips.length-1; j>=0; j--){
            const ship = gameState.enemyShips[j];
            if(proj.position.distanceTo(ship.position) < hitR){
              ship.health -= proj.damage;
              if(proj.slow){ ship.velocity.multiplyScalar(1 - proj.slow*0.15); ship.velocity.y = 0; }
              scene.remove(proj.mesh);
              gameState.projectiles.splice(i,1);

              if(ship.health <= 0){
                const deadPos = ship.position.clone();
                ship.remove();
                gameState.enemyShips.splice(j,1);

                gameState.score += 120;
                gameState.gold += 60;

                let best=null, bestD=Infinity;
                for(const ps of gameState.playerShips){
                  const d = ps.position.distanceTo(deadPos);
                  if(d < bestD){ bestD = d; best = ps; }
                }
                if(best && bestD < 60) best.addKill();

                logMemory(`Enemy ship destroyed (+$60)`);
              }
              break;
            }
          }
        } else {
          for(let j=gameState.playerShips.length-1; j>=0; j--){
            const ship = gameState.playerShips[j];
            if(proj.position.distanceTo(ship.position) < hitR){
              ship.health -= proj.damage;
              if(proj.slow){ ship.velocity.multiplyScalar(1 - proj.slow*0.15); ship.velocity.y = 0; }
              scene.remove(proj.mesh);
              gameState.projectiles.splice(i,1);

              if(ship.health <= 0){
                const deadPos = ship.position.clone();
                ship.remove();
                gameState.playerShips.splice(j,1);

                let best=null, bestD=Infinity;
                for(const es of gameState.enemyShips){
                  const d = es.position.distanceTo(deadPos);
                  if(d < bestD){ bestD=d; best=es; }
                }
                if(best && bestD < 60) best.addKill();

                logMemory('Player ship destroyed!');
              }
              break;
            }
          }
        }

        if(proj.ttl <= 0 || proj.position.length() > 350){
          scene.remove(proj.mesh);
          gameState.projectiles.splice(i,1);
        }
      }
    }

    // ----------------------
    // Island control
    // ----------------------
    function computeIslandControl(){
      let player=0, enemy=0;
      for(const isl of gameState.islands){
        const r = isl.size * 1.15;
        let pScore = 0, eScore = 0;
        for(const t of gameState.playerTowers){
          if(t.position.distanceTo(isl.position) < r + 8) pScore += 1;
        }
        for(const t of gameState.enemyTowers){
          if(t.position.distanceTo(isl.position) < r + 8) eScore += 1;
        }
        if(pScore > eScore && pScore > 0) player++;
        else if(eScore > pScore && eScore > 0) enemy++;
      }
      gameState.islandControl.player = player;
      gameState.islandControl.enemy = enemy;
    }

    // ----------------------
    // Movement update
    // ----------------------
    function updateShipMovement(dt){
      const boost = (keys['ShiftLeft'] || keys['ShiftRight']) ? 1.9 : 1.0;
      if(gameState.playerShips.length && !gameState.selfPlayMode){
        const s = gameState.playerShips[0];
        const base = 0.42 * boost;
        if(keys['KeyW']) s.velocity.z -= base;
        if(keys['KeyS']) s.velocity.z += base;
        if(keys['KeyA']) s.velocity.x -= base;
        if(keys['KeyD']) s.velocity.x += base;
        // force horizontal
        s.velocity.y = 0;
      }

      const playerAll = [...gameState.playerShips];
      gameState.playerShips = gameState.playerShips.filter(s => s.update(dt, playerAll));

      const enemyAll = [...gameState.enemyShips];
      gameState.enemyShips = gameState.enemyShips.filter(s => s.update(dt, enemyAll));
    }

    function updateCamera(){
      if(!gameState.playerShips.length) return;
      const s = gameState.playerShips[0];
      const target = s.position.clone();
      target.y += 45;
      target.z += 72;
      camera.position.lerp(target, 0.05);
      camera.lookAt(s.position);
    }

    function updateUI(){
      document.getElementById('gold').textContent = '$' + Math.floor(gameState.gold);
      document.getElementById('fleet-size').textContent = gameState.playerShips.length;
      document.getElementById('ai-ships').textContent = gameState.enemyShips.length;
      document.getElementById('player-towers').textContent = gameState.playerTowers.length;
      document.getElementById('ai-towers').textContent = gameState.enemyTowers.length;
      document.getElementById('score').textContent = Math.floor(gameState.score);
      document.getElementById('player-faction').textContent = factionLabel(gameState.playerFaction);

      if(gameState.playerShips[0]){
        const form = gameState.playerShips[0].form;
        document.getElementById('current-form').textContent = (form === 'ship') ? 'NAVAL CARGO' : 'GROUND TRANSPORT';
      }

      computeIslandControl();
      document.getElementById('control').textContent = `${gameState.islandControl.player} / ${gameState.islands.length}`;

      const playerPower = (gameState.playerTowers.length*12) + (gameState.playerShips.length*22);
      const enemyPower  = (gameState.enemyTowers.length*12) + (gameState.enemyShips.length*22);
      const total = playerPower + enemyPower || 1;
      document.getElementById('player-power').style.width = `${(playerPower/total)*100}%`;
      document.getElementById('ai-power').style.width = `${(enemyPower/total)*100}%`;
      document.getElementById('battles-won').textContent = gameState.battlesWon;
      document.getElementById('battles-total').textContent = gameState.battlesTotal;

      document.querySelectorAll('.tower-btn').forEach(btn => {
        const cost = parseInt(btn.dataset.cost, 10);
        btn.classList.toggle('disabled', gameState.gold < cost);
      });

      updateBlueLineKnowledge();
    }

    function updateBlueLineKnowledge(){
      const list = document.getElementById('knowledge-list');
      list.innerHTML = '';
      const agg = {
        stayNearTowers: 0,
        buildCannons: 0,
        buildHarpoons: 0,
        buildNets: 0,
        buildLighthouses: 0,
        flockWithAllies: 0,
        maintainDistance: 0
      };
      [...gameState.playerShips, ...gameState.enemyShips].forEach(s => {
        for(const k in agg) agg[k] += (s.survivalStrategies[k] || 0);
      });
      const sorted = Object.entries(agg).sort((a,b)=>b[1]-a[1]).slice(0,5);
      const names = {
        stayNearTowers: 'üóº Stay Near Towers',
        buildCannons: 'üî• Build Cannons',
        buildHarpoons: 'üéØ Build Harpoons',
        buildNets: 'üï∏Ô∏è Build Nets',
        buildLighthouses: 'üí° Build Lighthouses',
        flockWithAllies: 'üë• Flock with Allies',
        maintainDistance: '‚ÜîÔ∏è Maintain Distance'
      };
      let shown = 0;
      for(const [k,v] of sorted){
        if(v <= 0) continue;
        shown++;
        const div = document.createElement('div');
        div.style.cssText = 'margin:3px 0;padding:3px;background:rgba(0,100,150,.28);border-left:2px solid #0ff;';
        const pct = Math.min(100, Math.round(v*12));
        div.innerHTML = `${names[k]}: <span style="color:#0f0;">${pct}%</span>`;
        list.appendChild(div);
      }
      if(!shown) list.innerHTML = '<div style="color:#666;font-style:italic;">No survival data yet‚Ä¶</div>';
    }

    // ----------------------
    // UI buttons
    // ----------------------
    function setFaction(key){
      gameState.playerFaction = key;
      if(gameState.playerShips[0]){
        const s = gameState.playerShips[0];
        s.faction = key;
        const f = FACTIONS[key] || FACTIONS.aiuiux;
        s.hull.material.color.setHex(f.color);
        s.hull.material.emissive.setHex(f.emissive);
        s.maxSpeed = f.tune.maxSpeed;
        s.maxForce = f.tune.maxForce;
      }
      logMemory(`Faction set to ${factionLabel(key)}.`);
    }

    document.getElementById('mode-aiuiux').addEventListener('click', ()=>setFaction('aiuiux'));
    document.getElementById('mode-gpt').addEventListener('click', ()=>setFaction('gpt'));
    document.getElementById('mode-gemini').addEventListener('click', ()=>setFaction('gemini'));
    document.getElementById('mode-claude').addEventListener('click', ()=>setFaction('claude'));
    document.getElementById('mode-grok').addEventListener('click', ()=>setFaction('grok'));

    document.getElementById('transform-ship').addEventListener('click', ()=>{
      if(gameState.playerShips[0]){ gameState.playerShips[0].form = 'ship'; logMemory('üì¶ Switched to Naval Cargo Mode'); }
    });
    document.getElementById('transform-car').addEventListener('click', ()=>{
      if(gameState.playerShips[0]){ gameState.playerShips[0].form = 'car'; logMemory('üöõ Switched to Ground Transport Mode'); }
    });

    document.getElementById('spawn-fleet').addEventListener('click', ()=>{
      const enemies = ['gpt','gemini','claude','grok'];
      const ringR = 42;
      let idx = 0;
      for(const f of enemies){
        for(let k=0;k<2;k++){
          const a = (Math.PI*2*(idx++))/(enemies.length*2);
          const s = new NavalShip(Math.cos(a)*ringR, Math.sin(a)*ringR, { isPlayer:false, faction:f });
          gameState.enemyShips.push(s);
        }
      }

      for(let i=0;i<2;i++){
        const a = Math.PI + (Math.PI*2*i)/2;
        const s = new NavalShip(Math.cos(a)*18, Math.sin(a)*18, { isPlayer:true, faction:gameState.playerFaction });
        gameState.playerShips.push(s);
      }

      logMemory('üö¢ Deployed enemy factions + allied escorts.');
    });

    document.getElementById('start-battle').addEventListener('click', ()=>{
      gameState.battleActive = !gameState.battleActive;
      gameState.battlesTotal++;
      const el = document.getElementById('start-battle');
      document.getElementById('battle-status').textContent = gameState.battleActive ? 'ACTIVE' : 'STANDBY';
      el.classList.toggle('active', gameState.battleActive);

      if(gameState.battleActive){
        logMemory('‚öîÔ∏è COMBAT MODE ACTIVATED');
      } else {
        logMemory('Combat mode deactivated');
        if(gameState.enemyShips.length === 0 && gameState.playerShips.length > 0){
          gameState.battlesWon++;
          logMemory('üèÜ MISSION SUCCESSFUL!');
        }
      }
    });

    document.getElementById('toggle-ai-build').addEventListener('click', ()=>{
      gameState.aiBuildEnabled = !gameState.aiBuildEnabled;
      const el = document.getElementById('toggle-ai-build');
      document.getElementById('ai-build-status').textContent = gameState.aiBuildEnabled ? 'ON' : 'OFF';
      el.classList.toggle('active', gameState.aiBuildEnabled);
      logMemory(gameState.aiBuildEnabled ? 'üèóÔ∏è Enemy factions analyzing your builds‚Ä¶' : 'Enemy construction paused.');
    });

    document.getElementById('self-play').addEventListener('click', ()=>{
      gameState.selfPlayMode = !gameState.selfPlayMode;
      const el = document.getElementById('self-play');
      document.getElementById('self-play-status').textContent = gameState.selfPlayMode ? 'ON' : 'OFF';
      el.classList.toggle('active', gameState.selfPlayMode);

      if(gameState.selfPlayMode){
        logMemory('ü§ñ Auto-Sim enabled: fleets auto-respawn; learning continues.');
        if(!gameState.battleActive) document.getElementById('start-battle').click();
        if(!gameState.aiBuildEnabled) document.getElementById('toggle-ai-build').click();

        gameState.selfPlayInterval = setInterval(()=>{
          if(gameState.playerShips.length < 2){
            const a = Math.random()*Math.PI*2;
            const s = new NavalShip(Math.cos(a)*25, Math.sin(a)*25, { isPlayer:true, faction:gameState.playerFaction });
            gameState.playerShips.push(s);
          }
          const need = 6 - gameState.enemyShips.length;
          if(need > 0){
            const factions = ['gpt','gemini','claude','grok'];
            for(let i=0;i<need;i++){
              const f = factions[Math.floor(Math.random()*factions.length)];
              const a = Math.random()*Math.PI*2;
              const s = new NavalShip(Math.cos(a)*55, Math.sin(a)*55, { isPlayer:false, faction:f });
              gameState.enemyShips.push(s);
            }
          }
        }, 4500);
      } else {
        logMemory('Auto-Sim disabled.');
        if(gameState.selfPlayInterval){
          clearInterval(gameState.selfPlayInterval);
          gameState.selfPlayInterval = null;
        }
      }
    });

    document.querySelectorAll('.tower-btn').forEach(btn => {
      btn.addEventListener('click', ()=>{
        const type = btn.dataset.tower;
        const cost = parseInt(btn.dataset.cost, 10);
        if(gameState.gold < cost) return;
        gameState.selectedTower = type;
        document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
      });
    });

    // Passive income
    setInterval(()=>{
      if(!gameState.battleActive) return;
      const tune = (FACTIONS[gameState.playerFaction] || FACTIONS.aiuiux).tune;
      gameState.gold += tune.income;
      for(const s of gameState.enemyShips){ s.gold += 14; }
      gameState.score += (gameState.islandControl.player * 0.6);
    }, 2000);

    // ----------------------
    // Sanity Tests (run once)
    // ----------------------
    function assert(cond, msg){
      if(!cond){
        console.error('TEST FAIL:', msg);
        throw new Error('TEST FAIL: ' + msg);
      }
      console.log('TEST OK:', msg);
    }

    function runTests(){
      assert(typeof SEA_Y === 'number', 'SEA_Y constant exists');
      assert(gameState && typeof gameState === 'object', 'gameState object exists');
      assert(Array.isArray(gameState.playerShips) && Array.isArray(gameState.enemyShips), 'ship arrays exist');
      assert(gameState.playerShips.length === 1, 'one initial player ship');
      assert(Math.abs(gameState.playerShips[0].position.y - SEA_Y) < 1e-6, 'player ship starts on SEA_Y');
      // ensure seek produces horizontal steering
      const s = gameState.playerShips[0];
      const steer = s.seek(new THREE.Vector3(10, 999, 10));
      assert(Math.abs(steer.y) < 1e-6, 'seek() returns y=0 steering');
    }

    // ----------------------
    // Main loop
    // ----------------------
    let last = performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;

      gameState.time += dt;

      animateWater();
      updateShipMovement(dt);
      updateCamera();

      if(gameState.battleActive) updateCombat(dt);
      if(gameState.aiBuildEnabled) updateEnemyBuilding();

      updateUI();
      renderer.render(scene, camera);

      if(gameState.battleActive && gameState.enemyShips.length === 0 && gameState.playerShips.length > 0){
        if(gameState.time % 5 < dt){
          gameState.battleActive = false;
          document.getElementById('battle-status').textContent = 'STANDBY';
          document.getElementById('start-battle').classList.remove('active');
          gameState.battlesWon++;
          logMemory('üèÜ Enemy fleets eliminated. Mission complete.');
        }
      }
      if(gameState.battleActive && gameState.playerShips.length === 0){
        if(gameState.time % 5 < dt){
          gameState.battleActive = false;
          document.getElementById('battle-status').textContent = 'STANDBY';
          document.getElementById('start-battle').classList.remove('active');
          logMemory('üíÄ Flagship lost. Re-deploy to continue.');
          const s = new NavalShip(0, 0, { isPlayer:true, faction: gameState.playerFaction });
          gameState.playerShips.push(s);
        }
      }
    }

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Init
    setFaction('aiuiux');
    logMemory('üåä System online. Choose faction, deploy enemies, build defenses.');
    logMemory('üß† Towers use lead-target aim ‚Äî moving ships get hit more realistically.');
    logMemory('üèùÔ∏è Capture islands by out-building enemies near island centers.');

    runTests();
    animate();
  </script>
</body>
</html>
