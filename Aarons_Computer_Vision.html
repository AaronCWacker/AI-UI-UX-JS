<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Computer Vision</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000; /* Darker background */
            color: #e5e5e5;
        }
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
        }
        #teleprompter-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            display: flex;
            justify-content: center;
            pointer-events: none; /* Let clicks pass through to canvas unless on a principle */
            overflow: hidden;
            perspective: 600px; /* Made perspective less extreme */
        }
        #teleprompter {
            width: 98%;
            max-width: 1400px;
            position: relative;
            transform-style: preserve-3d;
            transition: max-width 0.5s ease-in-out; /* Smooth transition for width changes */
        }
        .principle {
            color: #ffc909; /* Classic crawl yellow */
            font-size: 2.8rem;
            font-weight: bold;
            line-height: 1.5;
            text-align: justify;
            padding: 2rem 0;
            cursor: pointer;
            pointer-events: all; /* Allow clicks on principles */
            transition: color 0.3s, transform 0.3s;
            text-shadow: 0 0 8px rgba(0,0,0,0.7);
        }
        .principle:hover {
            color: #fff352;
            transform: scale(1.02); /* Keep a subtle hover effect */
        }
        /* Teleprompter scrolling animation */
        .scrolling-content {
            position: absolute;
            width: 100%;
            animation: crawl 180s linear infinite;
        }
        /* This will be the fallback and initial animation */
        @keyframes crawl {
            0% {
                /* Start from below the screen and closer to the camera */
                transform: rotateX(12deg) translateY(100vh) translateZ(50px);
            }
            100% {
                /* End far away and high above the screen */
                transform: rotateX(12deg) translateY(-1150vh) translateZ(-1200px);
            }
        }
        #copy-notification {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(30, 200, 100, 0.85);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
        }
        #copy-notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-20px);
        }

        .controls-container {
            position: fixed;
            top: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #speed-controls { left: 20px; }
        #text-controls { right: 20px; }

        .controls-container button, #bottom-controls button {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 201, 9, 0.5); /* Yellow border */
            color: #ffc909;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px #ffc909;
            font-weight: bold;
            pointer-events: all;
            min-width: 80px;
        }
        .controls-container button:hover, #bottom-controls button:hover {
            background-color: rgba(255, 201, 9, 0.2);
            box-shadow: 0 0 10px #ffc909;
        }

        #bottom-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
        }

        @media (max-width: 768px) {
            .principle {
                font-size: 1.8rem;
                text-align: left;
            }
            #teleprompter-container {
                perspective: 250px;
            }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400&display=swap" rel="stylesheet">
</head>
<body>

    <div id="speed-controls" class="controls-container">
        <button id="slow-btn">Slow</button>
        <button id="pause-btn">Pause</button>
        <button id="fast-btn">Fast</button>
    </div>

    <div id="text-controls" class="controls-container">
        <button id="wider-btn">Wider</button>
        <button id="reset-btn">Reset</button>
        <button id="smaller-btn">Smaller</button>
    </div>

    <div id="bottom-controls">
        <button id="copy-all-btn">Copy All</button>
    </div>

    <div id="scene-container"></div>
    
    <div id="teleprompter-container">
        <div id="teleprompter">
              </div>
    </div>

    <div id="copy-notification">Copied to clipboard!</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- DATA ---
        const principles = [
            "1. üåâ Bifrost-1: Bridging Multimodal LLMs and Diffusion Models with Patch-Level CLIP Latents. This innovation introduces a unified framework that connects pretrained multimodal LLMs with diffusion models using patch-level CLIP embeddings as latent variables. It enables high-fidelity image synthesis while preserving LLM reasoning capabilities, reducing training costs by leveraging aligned visual encoders. This is particularly impactful for LRMS in vision tasks like generation and understanding.",
            "2. ü§ñ LLaDA-VLA: Vision-Language Diffusion Action Models. A novel paradigm shifting from autoregressive VLMs to masked diffusion models for robotic manipulation and vision tasks. It integrates diffusion-based generation with language-action reasoning, allowing parallel decoding for faster, more controllable image and video processing in LRMS, outperforming traditional autoregressive approaches in multimodal reasoning.",
            "3. üé≤ Discrete Diffusion in Large Language and Multimodal Models. This survey highlights the shift to discrete diffusion paradigms in LLMs and multimodal models, enabling parallel multi-token generation for image and text. It addresses limitations of autoregressive models by incorporating denoising strategies, improving scalability for vision-language tasks in LRMS and diffusion-based image synthesis.",
            "4. üìä Multimodal ArXiv Dataset for Scientific Image Comprehension. An innovative dataset (ArXivCap and ArXivQA) from 572K scientific papers, enhancing LVLMs' ability to interpret abstract figures (e.g., plots, diagrams) alongside text. It boosts mathematical reasoning in LRMS by 10.4% on benchmarks, addressing gaps in training data for vision processing in scientific domains.",
            "5. üñºÔ∏è Self-Training on Image Comprehension for Large Vision Language Models. This method uses self-training with unlabeled images to improve LVLMs' perception and reasoning, decoupling prompt understanding from segmentation. It leverages foundation models like SAM for mask proposals, enhancing diffusion-integrated LLMs for fine-grained image tasks without extensive labeled data."
        ];
        
        const toolLinks = [
            { text: "Bifrost-1 PDF", url: "https://arxiv.org/pdf/2508.05954" },
            { text: "Bifrost-1 Abstract", url: "https://arxiv.org/abs/2508.05954" },
            { text: "LLaDA-VLA PDF", url: "https://arxiv.org/pdf/2509.06932" },
            { text: "LLaDA-VLA Abstract", url: "https://arxiv.org/abs/2509.06932" },
            { text: "Discrete Diffusion Survey PDF", url: "https://arxiv.org/pdf/2506.13759" },
            { text: "Discrete Diffusion Survey Abstract", url: "https://arxiv.org/abs/2506.13759" },
            { text: "Multimodal ArXiv PDF", url: "https://arxiv.org/pdf/2403.00231" },
            { text: "Multimodal ArXiv Abstract", url: "https://arxiv.org/abs/2403.00231" },
            { text: "Self-Training LVLM PDF", url: "https://arxiv.org/pdf/2405.19716" },
            { text: "Self-Training LVLM Abstract", url: "https://arxiv.org/abs/2405.19716" },
            { text: "üöÄ AIRun", url: "https://aaroncwacker.github.io/AI-UI-UX-JS/" },
            { text: "üíæ AICode", url: "https://github.com/AaronCWacker/AI-UI-UX-JS" }
        ];

        // --- DOM ELEMENTS ---
        const teleprompter = document.getElementById('teleprompter');
        const notification = document.getElementById('copy-notification');
        // Speed controls
        const slowBtn = document.getElementById('slow-btn');
        const fastBtn = document.getElementById('fast-btn');
        const pauseBtn = document.getElementById('pause-btn');
        // Text controls
        const widerBtn = document.getElementById('wider-btn');
        const resetBtn = document.getElementById('reset-btn');
        const smallerBtn = document.getElementById('smaller-btn');
        // Bottom controls
        const copyAllBtn = document.getElementById('copy-all-btn');

        // --- STATE VARIABLES ---
        let scrollingContent;
        const initialDuration = 180;
        const initialMaxWidth = 1400;
        const initialRotationX = 12;
        let currentDuration = initialDuration;
        let currentMaxWidth = initialMaxWidth;
        let currentRotationX = initialRotationX;
        let isPaused = false;
        
        // --- INITIALIZATION ---
        function init() {
            initTeleprompter();
            init3D();
            animate();
        }

        // --- TELEPROMPTER LOGIC ---
        function initTeleprompter() {
            const contentDiv = document.createElement('div');
            contentDiv.className = 'scrolling-content';
            
            principles.forEach(text => {
                const p = document.createElement('p');
                p.textContent = text;
                p.className = 'principle';
                p.addEventListener('click', () => copyToClipboard(text));
                contentDiv.appendChild(p);
            });

            const linksHeader = document.createElement('p');
            linksHeader.textContent = '--- Key Research Links ---';
            linksHeader.className = 'principle'; 
            linksHeader.style.textAlign = 'center';
            linksHeader.style.marginTop = '5rem'; 
            contentDiv.appendChild(linksHeader);

            toolLinks.forEach(link => {
                const a = document.createElement('a');
                a.href = link.url;
                a.target = '_blank';
                a.textContent = link.text;
                a.className = 'principle';
                a.style.display = 'block'; 
                a.style.textAlign = 'center'; 
                contentDiv.appendChild(a);
            });
            
            scrollingContent = contentDiv;
            teleprompter.appendChild(scrollingContent);

            // Add event listeners for controls
            slowBtn.addEventListener('click', slowDown);
            fastBtn.addEventListener('click', speedUp);
            pauseBtn.addEventListener('click', togglePause);
            widerBtn.addEventListener('click', makeWider);
            smallerBtn.addEventListener('click', makeSmaller);
            resetBtn.addEventListener('click', resetSettings);
            copyAllBtn.addEventListener('click', copyAllPrinciples);
        }

        function slowDown() {
            currentDuration += 30;
            scrollingContent.style.animationDuration = currentDuration + 's';
        }

        function speedUp() {
            if (currentDuration > 15) { // Set a minimum speed
                currentDuration -= 15;
                scrollingContent.style.animationDuration = currentDuration + 's';
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                scrollingContent.style.animationPlayState = 'paused';
                pauseBtn.textContent = 'Play';
            } else {
                scrollingContent.style.animationPlayState = 'running';
                pauseBtn.textContent = 'Pause';
            }
        }

        function makeWider() {
            // Adjust width
            if (currentMaxWidth < 5000) { // Increased upper limit
                currentMaxWidth += 500;
                teleprompter.style.maxWidth = currentMaxWidth + 'px';
            }
            // Adjust angle to make it flatter
            if (currentRotationX > 5) { // Lowered angle limit for flatter perspective
                currentRotationX -= 1;
                updateCrawlAnimation();
            }
        }
        
        function makeSmaller() {
            // Adjust width
            if (currentMaxWidth > 800) { 
                currentMaxWidth -= 500;
                teleprompter.style.maxWidth = currentMaxWidth + 'px';
            }
             // Adjust angle to make it steeper
            if (currentRotationX < 20) {
                currentRotationX += 1;
                updateCrawlAnimation();
            }
        }

        function resetSettings() {
            // Reset width and angle
            currentMaxWidth = initialMaxWidth;
            currentRotationX = initialRotationX;
            teleprompter.style.maxWidth = currentMaxWidth + 'px';
            updateCrawlAnimation();

            // Reset speed
            currentDuration = initialDuration;
            scrollingContent.style.animationDuration = currentDuration + 's';
            
            // Unpause if paused
            if (isPaused) {
                togglePause();
            }
        }

        function updateCrawlAnimation() {
            let styleSheet = document.getElementById('dynamic-styles');
            if (!styleSheet) {
                styleSheet = document.createElement('style');
                styleSheet.id = 'dynamic-styles';
                document.head.appendChild(styleSheet);
            }

            const keyframes = `
                @keyframes crawl {
                    0% {
                        transform: rotateX(${currentRotationX}deg) translateY(100vh) translateZ(50px);
                    }
                    100% {
                        transform: rotateX(${currentRotationX}deg) translateY(-1150vh) translateZ(-1200px);
                    }
                }
            `;
            styleSheet.innerHTML = keyframes;
        }
        
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);

            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }

        function copyAllPrinciples() {
            let allText = principles.join('\n\n');
            allText += '\n\n\n--- Key Research Links ---\n\n';
            const linksText = toolLinks.map(link => `${link.text}: ${link.url}`).join('\n');
            allText += linksText;
            copyToClipboard(allText);
        }

        // --- THREE.JS BACKGROUND LOGIC ---
        let scene, camera, renderer, starLayers = [];

        function init3D() {
            const container = document.getElementById('scene-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0007);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const starTexture = createStarTexture();
            createStarLayer(15000, 0.7, 0xffffff, starTexture);
            createStarLayer(25000, 0.5, 0xf0e68c, starTexture);
            createStarLayer(10000, 0.6, 0xadd8e6, starTexture);
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function createStarLayer(count, size, color, texture) {
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.PointsMaterial({
                color: color,
                size: size,
                transparent: true,
                opacity: 0.8,
                map: texture,
                blending: THREE.AdditiveBlending
            });
            
            const vertices = [];
            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                vertices.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const stars = new THREE.Points(geometry, material);
            starLayers.push(stars);
            scene.add(stars);
        }
        
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.7, 'rgba(255,255,255,0.1)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            camera.lookAt(scene.position);
            
            if (starLayers.length) {
                starLayers[0].rotation.y += 0.00020;
                starLayers[1].rotation.y += 0.00010;
                starLayers[2].rotation.y += 0.00015;
            }

            renderer.render(scene, camera);
        }

        // --- START THE APP ---
        init();
    </script>
</body>
</html>
