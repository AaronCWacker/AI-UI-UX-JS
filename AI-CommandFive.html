<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Command - AI Swarm Defense Simulator</title>
    <meta name="description" content="Advanced AI-powered space fleet combat with mind control, particle swarms, and evolving ship designs.">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier New', monospace; background: #000; color: #0ff; overflow: hidden; }
        #canvas-container { width: 100vw; height: 100vh; }
        .hud { position: absolute; background: rgba(0, 30, 60, 0.95); border: 3px solid #00d4ff; padding: 20px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3); user-select: none; }
        #main-hud { top: 20px; left: 20px; min-width: 300px; }
        #unit-hud { top: 20px; right: 20px; min-width: 280px; background: rgba(60, 0, 80, 0.95); border-color: #ff00ff; box-shadow: 0 8px 32px rgba(255, 0, 255, 0.3); }
        #controls { bottom: 20px; left: 20px; background: rgba(40, 20, 0, 0.95); border-color: #ffaa00; box-shadow: 0 8px 32px rgba(255, 170, 0, 0.3); max-width: 280px; }
        #shop { bottom: 20px; right: 20px; background: rgba(40, 30, 0, 0.95); border-color: #ffaa00; box-shadow: 0 8px 32px rgba(255, 170, 0, 0.3); min-width: 290px; }
        .hud-title { color: #00d4ff; font-size: 18px; margin-bottom: 10px; text-shadow: 0 0 10px currentColor; }
        .hud-stat { color: #88ccff; font-size: 12px; margin: 5px 0; }
        .hud-value { color: #00ff88; font-weight: bold; float: right; }
        .btn { background: linear-gradient(135deg, #332200, #554400); border: 2px solid #ffaa00; color: #ffaa00; padding: 8px 15px; margin: 5px 0; cursor: pointer; border-radius: 6px; font-size: 10px; width: 100%; transition: all 0.2s; }
        .btn:hover { background: #ffaa00; color: #000; }
        .btn.selected { background: #ff8800; color: #000; }
        .xp-bar { background: rgba(0, 0, 0, 0.5); height: 12px; border-radius: 6px; overflow: hidden; margin: 5px 0; border: 1px solid #ff00ff; }
        .xp-fill { height: 100%; background: linear-gradient(90deg, #ff00ff, #ff00aa); transition: width 0.15s; }
        .key { background: rgba(255, 170, 0, 0.2); border: 1px solid #ffaa00; padding: 2px 6px; border-radius: 3px; color: #ffaa00; font-weight: bold; display: inline-block; margin: 0 2px; }
        #hint { position:absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color:#88ccff; font-size:12px; opacity:0.0; pointer-events:none; text-shadow:0 0 10px rgba(0,212,255,0.6); transition: opacity 0.2s;}
        #hint.on { opacity: 1.0; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="hint">Click on the surface to place a tower</div>

    <div class="hud" id="main-hud">
        <div class="hud-title">‚≠ê STELLAR COMMAND</div>
        <div class="hud-stat">Credits: <span class="hud-value" id="credits">$5000</span></div>
        <div class="hud-stat">Units: <span class="hud-value" id="units">1</span></div>
        <div class="hud-stat">AI Swarms: <span class="hud-value" id="ai">0</span></div>
        <div class="hud-stat">Captured: <span class="hud-value" id="captured">0</span></div>
        <div class="hud-stat">Score: <span class="hud-value" id="score">0</span></div>
        <div class="hud-stat">Wave: <span class="hud-value" id="wave">1</span></div>
    </div>

    <div class="hud" id="unit-hud">
        <div class="hud-title" style="color: #ff00ff;">üéØ <span id="unit-name">Command Ship</span></div>
        <div class="hud-stat" style="color: #ffaaff;">Level: <span id="level">1</span></div>
        <div class="xp-bar"><div class="xp-fill" id="xp" style="width: 0%"></div></div>
        <div class="hud-stat" style="color: #ffaaff;">HP: <span id="hp">100</span>/<span id="maxhp">100</span></div>
        <div class="hud-stat" style="color: #ffaaff;">Damage: <span id="dmg">10</span></div>
        <div class="hud-stat" style="color: #ffaaff;">Range: <span id="range">30</span></div>
        <div class="hud-stat" style="color: #ffaaff;">Fire Rate: <span id="rate">1.0s</span></div>
        <div class="hud-stat" style="color: #ffaaff;">Heal Aura: <span id="aura">ON</span></div>
    </div>

    <div class="hud" id="controls">
        <div class="hud-title" style="color: #ffaa00;">‚å®Ô∏è CONTROLS</div>
        <div style="font-size: 10px; color: #ffcc88; line-height: 1.6;">
            <span class="key">W/S</span> Move<br/>
            <span class="key">A/D</span> Rotate<br/>
            <span class="key">SPACE</span> Fire<br/>
            <span class="key">E</span> Heal Pulse (boost)<br/>
            <span class="key">&lt; &gt;</span> Switch Unit<br/>
            <span class="key">ESC</span> Cancel Build
        </div>
    </div>

    <div class="hud" id="shop">
        <div class="hud-title" style="color: #ffaa00;">üè≠ DEFENSE SYSTEMS</div>
        <button class="btn" data-tower="mind" data-cost="500">üß† Mind Lighthouse 500CR</button>
        <button class="btn" data-tower="cannon" data-cost="100">üî• Plasma Cannon 100CR</button>
        <button class="btn" data-tower="ion" data-cost="150">‚ö° Ion Lance 150CR</button>
        <button class="btn" data-tower="swarm" data-cost="250">ü´ß Particle Swarm Node 250CR</button>
        <div style="margin-top:8px; font-size:10px; color:#ffcc88; opacity:0.9; line-height:1.4;">
            ‚Ä¢ All weapons lead targets (predictive aim)<br/>
            ‚Ä¢ Command ship projects a self-healing ally aura
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const G = {
            credits: 5000,
            score: 0,
            tower: null,
            units: [],
            ai: [],
            towers: [],
            projs: [],
            parts: [],
            idx: 0,
            cap: 0,
            wave: 1,
            nextWaveAt: 20,
            buildHint: false
        };

        const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
        const lerp = (a,b,t)=>a+(b-a)*t;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000011, 0.0011);
        const cam = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 2500);
        cam.position.set(0, 80, 120);
        const R = new THREE.WebGLRenderer({ antialias: true });
        R.setSize(innerWidth, innerHeight);
        R.setPixelRatio(Math.min(2, devicePixelRatio || 1));
        document.getElementById('canvas-container').appendChild(R.domElement);

        scene.add(new THREE.AmbientLight(0x220044, 0.45));
        const sun = new THREE.PointLight(0xffffaa, 2.2, 650);
        sun.position.set(0, 260, 0);
        scene.add(sun);
        scene.add(new THREE.HemisphereLight(0x0044ff, 0xff0044, 0.35));

        // Star surface
        const surfGeo = new THREE.PlaneGeometry(2200, 2200, 140, 140);
        const surfMat = new THREE.ShaderMaterial({
            uniforms: { t: { value: 0 } },
            vertexShader: `
                uniform float t;
                varying vec2 v;
                varying float h;
                float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
                float noise(vec2 p){
                    vec2 i=floor(p), f=fract(p);
                    float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
                    vec2 u=f*f*(3.0-2.0*f);
                    return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
                }
                void main() {
                    v = uv;
                    vec3 p = position;
                    float n = noise(p.xz*0.02 + vec2(t*0.05, -t*0.03));
                    float n2 = noise(p.xz*0.06 + vec2(-t*0.08, t*0.04));
                    float w = sin(p.x*0.018 + t*0.9)*1.7 + cos(p.y*0.014 + t*1.2)*1.2;
                    float ridges = abs(sin((p.x+p.y)*0.01 + t*0.4))*1.1;
                    p.z = w + (n*3.0 + n2*2.0) + ridges;
                    h = p.z;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
                }
            `,
            fragmentShader: `
                uniform float t;
                varying vec2 v;
                varying float h;
                void main() {
                    vec3 c1 = vec3(1.0, 0.32, 0.0);
                    vec3 c2 = vec3(1.0, 0.86, 0.06);
                    vec3 c3 = vec3(0.2, 1.0, 0.9);
                    float band = sin(v.x*12.0 + t*0.6)*0.5+0.5;
                    float glow = clamp((h+6.0)/14.0, 0.0, 1.0);
                    vec3 base = mix(c1, c2, band);
                    base = mix(base, c3, glow*0.25);
                    float vign = smoothstep(0.0, 0.9, 1.0 - length(v-0.5)*1.25);
                    gl_FragColor = vec4(base*vign, 0.92);
                }
            `,
            transparent: true
        });
        const surf = new THREE.Mesh(surfGeo, surfMat);
        surf.rotation.x = -Math.PI / 2;
        scene.add(surf);

        // Stars
        const sg = new THREE.BufferGeometry();
        const sv = [];
        for (let i = 0; i < 6500; i++) {
            sv.push((Math.random() - 0.5) * 2400, Math.random() * 650 + 160, (Math.random() - 0.5) * 2400);
        }
        sg.setAttribute('position', new THREE.Float32BufferAttribute(sv, 3));
        scene.add(new THREE.Points(sg, new THREE.PointsMaterial({ color: 0xffffff, size: 1.7 })));

        // Helpers: lead target (intercept) + aim
        function leadDirection(shooterPos, targetPos, targetVel, projectileSpeed){
            // Solve for t in |(targetPos + targetVel*t) - shooterPos| = projectileSpeed*t
            const to = new THREE.Vector3().subVectors(targetPos, shooterPos);
            const a = targetVel.dot(targetVel) - projectileSpeed*projectileSpeed;
            const b = 2 * to.dot(targetVel);
            const c = to.dot(to);
            let t = 0;

            if (Math.abs(a) < 1e-6) {
                // linear
                t = (Math.abs(b) < 1e-6) ? 0 : (-c / b);
            } else {
                const disc = b*b - 4*a*c;
                if (disc >= 0) {
                    const s = Math.sqrt(disc);
                    const t1 = (-b - s) / (2*a);
                    const t2 = (-b + s) / (2*a);
                    t = Math.min(t1, t2);
                    if (t < 0) t = Math.max(t1, t2);
                } else {
                    t = 0;
                }
            }

            t = clamp(t, 0, 2.0); // keep sane
            const aim = targetPos.clone().add(targetVel.clone().multiplyScalar(t));
            return aim.sub(shooterPos).normalize();
        }

        function makeGlowRing(radius, color, opacity=0.25){
            const g = new THREE.RingGeometry(radius*0.85, radius, 64);
            const m = new THREE.MeshBasicMaterial({ color, transparent:true, opacity, side:THREE.DoubleSide, depthWrite:false });
            const r = new THREE.Mesh(g,m);
            r.rotation.x = -Math.PI/2;
            return r;
        }

        class Ship {
            constructor(x, z, ai = false) {
                this.p = new THREE.Vector3(x, 5, z);
                this.v = new THREE.Vector3();
                this.r = 0;
                this.ai = ai;

                this.hp = this.mhp = ai ? 85 : 100;
                this.lv = 1;
                this.xp = 0;
                this.nxp = 100;
                this.dmg = ai ? 8 : 10;
                this.rng = ai ? 34 : 30;
                this.fr  = ai ? 1200 : 1000;
                this.lf = 0;
                this.spd = ai ? 0.26 : 0.32;
                this.rs = ai ? 0.026 : 0.032;

                this.evSeed = Math.random();
                this.evo = { fins: 1, spines: 0, pods: 0 };

                // heal aura (for player/command ships)
                this.auraR = this.ai ? 0 : 26;
                this.auraBase = 6.0; // hp per second near aura core, falls off
                this.auraBoost = 0;  // temporary from E
                this.auraMesh = null;

                this.g = new THREE.Group();
                const c = ai ? 0xff0044 : 0x00aaff;
                const e = ai ? 0xff2266 : 0x00ffff;

                const hg = new THREE.BoxGeometry(3.2, 1.5, 8.4);
                const hm = new THREE.MeshStandardMaterial({ color: c, emissive: c, emissiveIntensity: 0.42, metalness: 0.92, roughness: 0.12 });
                this.hull = new THREE.Mesh(hg, hm);
                this.g.add(this.hull);

                // wings
                const wg = new THREE.BoxGeometry(10.5, 0.35, 3.2);
                const w = new THREE.Mesh(wg, hm);
                w.position.y = 0.15;
                this.g.add(w);

                // cockpit core glow
                const cg = new THREE.SphereGeometry(1.05, 18, 18);
                const cm = new THREE.MeshBasicMaterial({ color: e, transparent: true, opacity: 0.75 });
                const ck = new THREE.Mesh(cg, cm);
                ck.position.set(0, 1.05, 2.2);
                this.g.add(ck);

                // engines
                [-2.1, 2.1].forEach(xx => {
                    const eg = new THREE.CylinderGeometry(0.42, 0.7, 2.2, 16);
                    const em = new THREE.MeshBasicMaterial({ color: e });
                    const en = new THREE.Mesh(eg, em);
                    en.position.set(xx, 0.0, -4.3);
                    en.rotation.x = Math.PI/2;
                    this.g.add(en);
                });

                // health bar
                const hbg = new THREE.PlaneGeometry(5, 0.45);
                const bg = new THREE.Mesh(hbg, new THREE.MeshBasicMaterial({ color: 0x220015, transparent:true, opacity:0.85, depthWrite:false }));
                bg.position.set(0, 3.15, 0.01);
                bg.rotation.x = -0.7;
                this.g.add(bg);

                this.hb = new THREE.Mesh(hbg, new THREE.MeshBasicMaterial({ color: ai ? 0xff0000 : 0x00ff66, transparent:true, opacity:0.95, depthWrite:false }));
                this.hb.position.set(0, 3.15, 0.02);
                this.hb.rotation.x = -0.7;
                this.g.add(this.hb);

                // evolving greebles
                this.greebles = new THREE.Group();
                this.g.add(this.greebles);
                this.applyEvolution();

                if (!ai) {
                    this.auraMesh = makeGlowRing(this.auraR, 0x00ffaa, 0.18);
                    this.auraMesh.position.y = 0.2;
                    this.g.add(this.auraMesh);
                }

                this.g.position.copy(this.p);
                scene.add(this.g);
            }

            applyEvolution(){
                // reset
                while(this.greebles.children.length) this.greebles.remove(this.greebles.children[0]);
                const isAI = this.ai;
                const col = isAI ? 0xff4477 : 0x88ccff;
                const em  = isAI ? 0xff2255 : 0x00ffff;
                const mat = new THREE.MeshStandardMaterial({ color: col, emissive: em, emissiveIntensity: 0.22, metalness:0.9, roughness:0.2 });

                // fins
                for(let i=0;i<this.evo.fins;i++){
                    const fg = new THREE.BoxGeometry(0.35, 1.2 + i*0.15, 2.4 + i*0.2);
                    const f = new THREE.Mesh(fg, mat);
                    const side = (i%2===0)?1:-1;
                    f.position.set( (4.8 + i*0.3)*side, 0.2, -0.4 - i*0.6);
                    f.rotation.z = side*0.35;
                    this.greebles.add(f);
                }

                // spines
                for(let i=0;i<this.evo.spines;i++){
                    const sg = new THREE.ConeGeometry(0.35, 1.6, 12);
                    const s = new THREE.Mesh(sg, mat);
                    s.position.set((Math.random()-0.5)*1.0, 1.2 + i*0.5, -1.0 - i*1.1);
                    this.greebles.add(s);
                }

                // pods
                for(let i=0;i<this.evo.pods;i++){
                    const pg = new THREE.SphereGeometry(0.55, 14, 14);
                    const p = new THREE.Mesh(pg, new THREE.MeshStandardMaterial({ color: col, emissive: em, emissiveIntensity: 0.5, metalness:0.8, roughness:0.25 }));
                    p.position.set((i%2? -2.0:2.0), 0.6, 2.8 - i*1.2);
                    this.greebles.add(p);
                }
            }

            upHB() {
                const hp = clamp(this.hp / this.mhp, 0, 1);
                this.hb.scale.x = hp;
                this.hb.position.x = -2.5 * (1 - hp);
            }

            addXP(a) {
                this.xp += a;
                while (this.xp >= this.nxp) {
                    this.lv++;
                    this.xp -= this.nxp;
                    this.nxp = Math.floor(this.nxp * 1.45);

                    this.mhp += 18 + Math.floor(Math.random()*6);
                    this.hp = this.mhp;
                    this.dmg += 4 + (Math.random()<0.35?1:0);
                    this.rng += 4;
                    this.fr = Math.max(260, this.fr - 90);

                    // evolve visuals + slight stat flavor
                    const roll = Math.random();
                    if (roll < 0.45) this.evo.fins = Math.min(4, this.evo.fins + 1);
                    else if (roll < 0.75) this.evo.spines = Math.min(4, this.evo.spines + 1);
                    else this.evo.pods = Math.min(3, this.evo.pods + 1);
                    this.applyEvolution();

                    const ug = new THREE.SphereGeometry(0.45, 14, 14);
                    const u = new THREE.Mesh(ug, new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent:true, opacity:0.95 }));
                    u.position.set((Math.random() - 0.5) * 3.2, 1.2 + (this.lv*0.1), 0);
                    this.g.add(u);
                }
            }

            fire() {
                const n = performance.now();
                if (n - this.lf < this.fr) return null;
                this.lf = n;

                const targets = this.ai ? G.units : G.ai;
                if (!targets.length) return null;

                let best = null, bd = this.rng;
                for (const t of targets) {
                    const d = this.p.distanceTo(t.p);
                    if (d < bd) { bd = d; best = t; }
                }
                if (!best) return null;

                const speed = this.ai ? 1.55 : 1.85;
                const dir = leadDirection(this.p, best.p, best.v, speed);

                const pg = new THREE.SphereGeometry(0.28, 14, 14);
                const col = this.ai ? 0xff0044 : 0x00ffff;
                const pm = new THREE.MeshBasicMaterial({ color: col, transparent:true, opacity:0.95 });
                const pj = new THREE.Mesh(pg, pm);
                pj.position.copy(this.p);
                pj.position.y += 1.2;
                scene.add(pj);

                return { kind:"bolt", m: pj, p: pj.position.clone(), v: dir.multiplyScalar(speed), d: this.dmg, o: this, l: 130, rad: 2.0, pierce: 0 };
            }

            healAuraTick(dt){
                if (this.ai || !this.auraMesh) return;
                const auraR = this.auraR;
                const base = this.auraBase + this.auraBoost;
                if (base <= 0) return;

                // animate aura subtly
                const t = performance.now()*0.001;
                this.auraMesh.material.opacity = 0.13 + 0.05*Math.sin(t*2.0);
                this.auraMesh.rotation.z += 0.35*dt;

                for (const u of G.units) {
                    if (u === this) continue;
                    const d = this.p.distanceTo(u.p);
                    if (d < auraR) {
                        const fall = 1 - (d / auraR);
                        const heal = base * fall * dt;
                        u.hp = Math.min(u.mhp, u.hp + heal);
                    }
                }

                // decay boost
                this.auraBoost = Math.max(0, this.auraBoost - 10*dt);
            }

            aiBrain(dt){
                // simple swarm chase + orbit + avoidance
                const target = G.units[G.idx] || G.units[0];
                if (!target) return;

                const to = new THREE.Vector3().subVectors(target.p, this.p);
                const dist = to.length();
                const desired = to.normalize();

                // orbit bias
                const side = (Math.sin(this.evSeed*1000 + performance.now()*0.0004) > 0) ? 1 : -1;
                const orbit = new THREE.Vector3(-desired.z, 0, desired.x).multiplyScalar(side * 0.45);

                // separation
                const sep = new THREE.Vector3();
                for (const other of G.ai) {
                    if (other === this) continue;
                    const d = this.p.distanceTo(other.p);
                    if (d < 12) {
                        const away = new THREE.Vector3().subVectors(this.p, other.p).normalize().multiplyScalar((12-d)/12);
                        sep.add(away);
                    }
                }

                const steer = desired.multiplyScalar(dist > 55 ? 1.0 : 0.2)
                    .add(orbit)
                    .add(sep.multiplyScalar(1.25))
                    .normalize();

                // turn toward steer
                const ang = Math.atan2(steer.x, steer.z);
                let da = ang - this.r;
                while (da > Math.PI) da -= Math.PI*2;
                while (da < -Math.PI) da += Math.PI*2;
                this.r += clamp(da, -this.rs*1.6, this.rs*1.6);

                // thrust
                const thrust = (dist > 20 ? 1.0 : 0.4);
                this.v.x += Math.sin(this.r) * this.spd * thrust;
                this.v.z += Math.cos(this.r) * this.spd * thrust;

                // occasional firing
                if (dist < this.rng) {
                    if (Math.random() < dt*1.2) {
                        const pj = this.fire();
                        if (pj) G.projs.push(pj);
                    }
                }
            }

            u(k, dt) {
                if (!this.ai && k) {
                    if (k.KeyW) { this.v.x += Math.sin(this.r) * this.spd; this.v.z += Math.cos(this.r) * this.spd; }
                    if (k.KeyS) { this.v.x -= Math.sin(this.r) * this.spd * 0.55; this.v.z -= Math.cos(this.r) * this.spd * 0.55; }
                    if (k.KeyA) this.r += this.rs;
                    if (k.KeyD) this.r -= this.rs;

                    // passive auto-fire for player units (helps "rarely miss")
                    if (k.Space) {
                        const pj = this.fire();
                        if (pj) G.projs.push(pj);
                    }
                } else if (this.ai) {
                    this.aiBrain(dt);
                }

                this.p.add(this.v);
                this.v.multiplyScalar(0.93);

                this.p.x = clamp(this.p.x, -520, 520);
                this.p.z = clamp(this.p.z, -520, 520);

                this.g.position.copy(this.p);
                this.g.rotation.y = this.r;

                this.upHB();
                return this.hp > 0;
            }

            rm() { scene.remove(this.g); }
        }

        class MindTower {
            constructor(p) {
                this.p = p.clone();
                this.rng = 48;
                this.cap = new Map();

                this.g = new THREE.Group();
                const bg = new THREE.CylinderGeometry(2, 3, 9, 18);
                const bm = new THREE.MeshStandardMaterial({ color: 0x6600ff, emissive: 0x6600ff, emissiveIntensity: 0.45, metalness:0.6, roughness:0.4 });
                const base = new THREE.Mesh(bg, bm);
                base.position.y = 4.5;
                this.g.add(base);

                const cg = new THREE.ConeGeometry(3.2, 7, 40, 1, true);
                const cm = new THREE.ShaderMaterial({
                    uniforms: { t: { value: 0 } },
                    vertexShader: `varying vec2 v; void main(){ v=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
                    fragmentShader: `
                        uniform float t; varying vec2 v;
                        void main(){
                            float s = sin(v.x*22.0 + t)*cos(v.y*18.0 - t*1.2);
                            vec3 c = mix(vec3(0.45,0.0,1.0), vec3(0.0,1.0,1.0), s*0.5+0.5);
                            float a = 0.45 + 0.2*sin(t*2.0+v.y*8.0);
                            gl_FragColor = vec4(c, a);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite:false
                });
                this.cn = new THREE.Mesh(cg, cm);
                this.cn.position.y = 13.5;
                this.g.add(this.cn);

                // halo ring
                this.halo = makeGlowRing(this.rng, 0xaa00ff, 0.08);
                this.halo.position.y = 0.25;
                this.g.add(this.halo);

                this.pts = [];
                for (let i = 0; i < 60; i++) {
                    const pg = new THREE.SphereGeometry(0.14, 10, 10);
                    const pt = new THREE.Mesh(pg, new THREE.MeshBasicMaterial({ color: i%2?0xff00ff:0x00ffff, transparent:true, opacity:0.85, depthWrite:false }));
                    this.g.add(pt);
                    this.pts.push({ m: pt, a: Math.random()*Math.PI*2, r: Math.random()*3.3+1, h: Math.random()*11+6, s: Math.random()*0.025+0.01 });
                }

                this.g.position.copy(this.p);
                scene.add(this.g);
            }

            u(dt) {
                this.cn.material.uniforms.t.value += dt*1.0;
                this.cn.rotation.y += 0.02;

                this.pts.forEach(pt => {
                    pt.a += pt.s;
                    pt.m.position.set(Math.cos(pt.a)*pt.r, pt.h + Math.sin(pt.a*3.2)*2.2, Math.sin(pt.a)*pt.r);
                });

                // capture AI ships inside rng
                for (const u of G.ai.slice()) {
                    const d = this.p.distanceTo(u.p);
                    if (d < this.rng) {
                        if (!this.cap.has(u)) this.cap.set(u, 0);
                        let pr = this.cap.get(u);
                        pr += (0.7 + 0.25*Math.sin(performance.now()*0.002)) * dt * 60; // ~per second, scaled
                        if (pr >= 100) {
                            u.ai = false;
                            G.cap++;
                            const i = G.ai.indexOf(u);
                            if (i > -1) {
                                G.ai.splice(i, 1);
                                G.units.push(u);
                            }
                            this.cap.delete(u);
                        } else {
                            this.cap.set(u, pr);
                            if (u.hull) {
                                const cc = new THREE.Color().lerpColors(new THREE.Color(0xff0044), new THREE.Color(0x00aaff), pr/100);
                                u.hull.material.color = cc;
                                u.hull.material.emissive = cc;
                            }
                        }
                    } else {
                        // decay progress slowly if leaving range
                        if (this.cap.has(u)) {
                            const pr = Math.max(0, this.cap.get(u) - dt*10);
                            if (pr === 0) this.cap.delete(u);
                            else this.cap.set(u, pr);
                        }
                    }
                }
            }
        }

        class CannonTower {
            constructor(p) {
                this.p = p.clone();
                this.rng = 62;
                this.dmg = 10;
                this.fr = 700; // ms
                this.lf = 0;
                this.boltSpeed = 2.1;

                this.g = new THREE.Group();
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(2.2, 3.0, 3.4, 18),
                    new THREE.MeshStandardMaterial({ color: 0x332200, emissive: 0xff8800, emissiveIntensity: 0.18, metalness:0.7, roughness:0.35 })
                );
                base.position.y = 1.7;
                this.g.add(base);

                this.tur = new THREE.Mesh(
                    new THREE.BoxGeometry(3.4, 1.2, 3.4),
                    new THREE.MeshStandardMaterial({ color: 0x553300, emissive: 0xffaa00, emissiveIntensity: 0.22, metalness:0.8, roughness:0.25 })
                );
                this.tur.position.y = 3.0;
                this.g.add(this.tur);

                this.bar = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.25, 0.35, 6.0, 12),
                    new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.25, metalness:0.9, roughness:0.2 })
                );
                this.bar.position.y = 3.2;
                this.bar.rotation.x = Math.PI/2;
                this.g.add(this.bar);

                this.halo = makeGlowRing(this.rng, 0xffaa00, 0.05);
                this.halo.position.y = 0.22;
                this.g.add(this.halo);

                this.g.position.copy(this.p);
                scene.add(this.g);
            }

            fireAt(t){
                const n = performance.now();
                if (n - this.lf < this.fr) return null;
                this.lf = n;

                const dir = leadDirection(this.p, t.p, t.v, this.boltSpeed);

                // rotate turret to face
                const ang = Math.atan2(dir.x, dir.z);
                this.tur.rotation.y = ang;
                this.bar.rotation.y = ang;

                const pg = new THREE.SphereGeometry(0.26, 14, 14);
                const pm = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent:true, opacity:0.95 });
                const pj = new THREE.Mesh(pg, pm);
                pj.position.copy(this.p);
                pj.position.y += 4.2;
                scene.add(pj);

                return { kind:"plasma", m: pj, p: pj.position.clone(), v: dir.multiplyScalar(this.boltSpeed), d: this.dmg, o: this, l: 145, rad: 2.2, pierce: 0 };
            }

            u(dt){
                this.halo.rotation.z -= 0.25*dt;
                // pick closest AI target
                let best=null, bd=this.rng;
                for(const a of G.ai){
                    const d = this.p.distanceTo(a.p);
                    if(d<bd){ bd=d; best=a; }
                }
                if(best){
                    const pj = this.fireAt(best);
                    if(pj) G.projs.push(pj);
                }
            }

            rm(){ scene.remove(this.g); }
        }

        class IonTower {
            constructor(p) {
                this.p = p.clone();
                this.rng = 78;
                this.dmg = 7;
                this.fr = 360; // ms
                this.lf = 0;
                this.boltSpeed = 2.6;

                this.g = new THREE.Group();
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(2.0, 3.2, 4.5, 18),
                    new THREE.MeshStandardMaterial({ color: 0x002233, emissive: 0x00aaff, emissiveIntensity: 0.22, metalness:0.8, roughness:0.3 })
                );
                base.position.y = 2.25;
                this.g.add(base);

                const sp = new THREE.Mesh(
                    new THREE.ConeGeometry(2.1, 6.5, 20),
                    new THREE.MeshStandardMaterial({ color: 0x004466, emissive: 0x00ffff, emissiveIntensity: 0.32, metalness:0.9, roughness:0.2 })
                );
                sp.position.y = 6.0;
                this.g.add(sp);

                this.coil = new THREE.Mesh(
                    new THREE.TorusGeometry(2.2, 0.18, 10, 40),
                    new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent:true, opacity:0.75, depthWrite:false })
                );
                this.coil.position.y = 5.0;
                this.coil.rotation.x = Math.PI/2;
                this.g.add(this.coil);

                this.halo = makeGlowRing(this.rng, 0x00ffff, 0.04);
                this.halo.position.y = 0.22;
                this.g.add(this.halo);

                this.g.position.copy(this.p);
                scene.add(this.g);
            }

            fireAt(t){
                const n = performance.now();
                if (n - this.lf < this.fr) return null;
                this.lf = n;

                const dir = leadDirection(this.p, t.p, t.v, this.boltSpeed);

                const gg = new THREE.SphereGeometry(0.18, 12, 12);
                const mm = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent:true, opacity:0.95, depthWrite:false });
                const pj = new THREE.Mesh(gg, mm);
                pj.position.copy(this.p);
                pj.position.y += 6.6;
                scene.add(pj);

                return { kind:"ion", m: pj, p: pj.position.clone(), v: dir.multiplyScalar(this.boltSpeed), d: this.dmg, o: this, l: 120, rad: 1.8, pierce: 1 };
            }

            u(dt){
                this.coil.rotation.z += 1.4*dt;
                this.halo.rotation.z += 0.32*dt;

                // pick best AI in range (prefer closest)
                let best=null, bd=this.rng;
                for(const a of G.ai){
                    const d = this.p.distanceTo(a.p);
                    if(d<bd){ bd=d; best=a; }
                }
                if(best){
                    const pj = this.fireAt(best);
                    if(pj) G.projs.push(pj);
                }
            }

            rm(){ scene.remove(this.g); }
        }

        class SwarmNode {
            constructor(p) {
                this.p = p.clone();
                this.rng = 55;
                this.dps = 9; // per second, distributed
                this.slow = 0.10;

                this.g = new THREE.Group();
                const core = new THREE.Mesh(
                    new THREE.SphereGeometry(2.0, 18, 18),
                    new THREE.MeshStandardMaterial({ color: 0x113311, emissive: 0x00ff88, emissiveIntensity: 0.28, metalness:0.4, roughness:0.35 })
                );
                core.position.y = 3.2;
                this.g.add(core);

                this.halo = makeGlowRing(this.rng, 0x00ff88, 0.035);
                this.halo.position.y = 0.22;
                this.g.add(this.halo);

                // particles
                const n = 380;
                const pos = new Float32Array(n*3);
                const spd = new Float32Array(n);
                for(let i=0;i<n;i++){
                    pos[i*3+0]=(Math.random()-0.5)*10;
                    pos[i*3+1]=Math.random()*12+2;
                    pos[i*3+2]=(Math.random()-0.5)*10;
                    spd[i]=0.6+Math.random()*1.2;
                }
                const geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
                this.pPos = pos;
                this.pSpd = spd;

                const mat = new THREE.PointsMaterial({ color: 0x00ffcc, size: 0.9, transparent:true, opacity:0.75, depthWrite:false });
                this.points = new THREE.Points(geom, mat);
                this.g.add(this.points);

                this.g.position.copy(this.p);
                scene.add(this.g);
            }

            u(dt){
                this.halo.rotation.z -= 0.22*dt;
                // animate particles around node
                const t = performance.now()*0.001;
                const arr = this.points.geometry.attributes.position.array;
                for(let i=0;i<this.pSpd.length;i++){
                    const s = this.pSpd[i];
                    const a = t*s + i*0.13;
                    const r = 3.5 + 3.5*Math.sin(i*0.07 + t*0.9);
                    arr[i*3+0] = Math.cos(a)*r + Math.sin(a*2.1)*1.2;
                    arr[i*3+2] = Math.sin(a)*r + Math.cos(a*1.7)*1.2;
                    arr[i*3+1] = 2.5 + 4.0 + Math.sin(a*1.5+i)*2.5;
                }
                this.points.geometry.attributes.position.needsUpdate = true;

                // apply DPS + slow to AI in range
                const inRange = [];
                for(const a of G.ai){
                    const d = this.p.distanceTo(a.p);
                    if(d < this.rng) inRange.push({a,d});
                }
                if(inRange.length){
                    const total = this.dps*dt;
                    const per = total / inRange.length;
                    for(const it of inRange){
                        it.a.hp -= per;
                        it.a.v.multiplyScalar(1.0 - this.slow*dt*2.0);
                    }
                }
            }

            rm(){ scene.remove(this.g); }
        }

        const p1 = new Ship(0, 0, false);
        G.units.push(p1);

        const K = {};
        document.addEventListener('keydown', e => {
            K[e.code] = true;

            if (e.code === 'Space') {
                // enable hold-to-fire
                K.Space = true;
                const u = G.units[G.idx];
                if (u) { const pj = u.fire(); if (pj) G.projs.push(pj); }
            }

            if (e.code === 'Comma') G.idx = (G.idx - 1 + G.units.length) % G.units.length;
            if (e.code === 'Period') G.idx = (G.idx + 1) % G.units.length;

            if (e.code === 'Escape') {
                G.tower = null;
                document.querySelectorAll('.btn').forEach(x => x.classList.remove('selected'));
                document.getElementById('hint').classList.remove('on');
            }

            if (e.code === 'KeyE') {
                // aura boost pulse for currently selected unit if it has aura
                const u = G.units[G.idx];
                if (u && !u.ai) {
                    u.auraBoost = Math.min(18, u.auraBoost + 10);
                }
            }
        });
        document.addEventListener('keyup', e => {
            K[e.code] = false;
            if (e.code === 'Space') K.Space = false;
        });

        const rc = new THREE.Raycaster();
        const ms = new THREE.Vector2();
        R.domElement.addEventListener('click', e => {
            if (!G.tower) return;
            ms.x = (e.clientX / innerWidth) * 2 - 1;
            ms.y = -(e.clientY / innerHeight) * 2 + 1;
            rc.setFromCamera(ms, cam);
            const its = rc.intersectObject(surf);
            if (its.length) {
                const p = its[0].point;
                p.y = 0; // towers sit on surface plane visually
                const costs = { mind: 500, cannon: 100, ion: 150, swarm: 250 };
                const c = costs[G.tower] || 999999;

                // avoid placing on ships
                let ok = true;
                for(const u of [...G.units, ...G.ai]){
                    if (p.distanceTo(u.p) < 12) { ok=false; break; }
                }
                if(!ok) return;

                if (G.credits >= c) {
                    G.credits -= c;
                    if (G.tower === 'mind') G.towers.push(new MindTower(p));
                    if (G.tower === 'cannon') G.towers.push(new CannonTower(p));
                    if (G.tower === 'ion') G.towers.push(new IonTower(p));
                    if (G.tower === 'swarm') G.towers.push(new SwarmNode(p));
                }
            }
        });

        document.querySelectorAll('.btn').forEach(b => {
            b.addEventListener('click', () => {
                G.tower = b.dataset.tower;
                document.querySelectorAll('.btn').forEach(x => x.classList.remove('selected'));
                b.classList.add('selected');
                document.getElementById('hint').classList.add('on');
            });
        });

        function spawnAI(n) {
            for (let i = 0; i < n; i++) {
                const a = Math.random() * Math.PI * 2;
                const r = 120 + Math.random() * 120;
                const s = new Ship(Math.cos(a) * r, Math.sin(a) * r, true);
                s.r = a + Math.PI;
                s.v.x = (Math.random()-0.5)*0.6;
                s.v.z = (Math.random()-0.5)*0.6;
                G.ai.push(s);
            }
        }

        function waveLogic(dt){
            G.nextWaveAt -= dt;
            if (G.nextWaveAt <= 0) {
                G.wave++;
                G.nextWaveAt = 25 + Math.max(0, 30 - G.wave*1.5);
                const count = 2 + Math.floor(G.wave*0.8);
                spawnAI(count);

                // reward drip
                G.credits += 120 + G.wave*25;
            }
        }

        function explodeAt(pos, color=0xffaa00){
            const n = 24;
            for(let i=0;i<n;i++){
                const g = new THREE.SphereGeometry(0.18, 10, 10);
                const m = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.9, depthWrite:false });
                const p = new THREE.Mesh(g,m);
                p.position.copy(pos);
                scene.add(p);

                const v = new THREE.Vector3((Math.random()-0.5)*2.6, (Math.random()*1.2), (Math.random()-0.5)*2.6);
                G.parts.push({ m:p, v, life: 35+Math.floor(Math.random()*20) });
            }
        }

        function upUI() {
            document.getElementById('credits').textContent = '$' + Math.floor(G.credits);
            document.getElementById('units').textContent = G.units.length;
            document.getElementById('ai').textContent = G.ai.length;
            document.getElementById('captured').textContent = G.cap;
            document.getElementById('score').textContent = G.score;
            document.getElementById('wave').textContent = G.wave;

            const u = G.units[G.idx];
            if (u) {
                document.getElementById('unit-name').textContent = `Ship #${G.idx + 1}`;
                document.getElementById('level').textContent = u.lv;
                document.getElementById('hp').textContent = Math.floor(u.hp);
                document.getElementById('maxhp').textContent = u.mhp;
                document.getElementById('dmg').textContent = u.dmg;
                document.getElementById('range').textContent = u.rng;
                document.getElementById('rate').textContent = (u.fr / 1000).toFixed(2) + 's';
                document.getElementById('xp').style.width = (u.xp / u.nxp * 100) + '%';
                document.getElementById('aura').textContent = u.auraMesh ? 'ON' : 'OFF';
            }
        }

        // initial enemies
        spawnAI(4);

        let lt = performance.now();
        function anim() {
            requestAnimationFrame(anim);
            const ct = performance.now();
            const dt = (ct - lt) / 1000;
            lt = ct;

            surfMat.uniforms.t.value = ct * 0.001;

            // wave spawning
            waveLogic(dt);

            // update ships
            const cu = G.units[G.idx];
            for (let i = G.units.length - 1; i >= 0; i--) {
                const u = G.units[i];
                const alive = u.u(i === G.idx ? K : {}, dt);
                u.healAuraTick(dt);
                if (!alive) { u.rm(); G.units.splice(i, 1); if (G.idx >= G.units.length) G.idx = Math.max(0, G.units.length-1); }
            }
            for (let i = G.ai.length - 1; i >= 0; i--) {
                const u = G.ai[i];
                const alive = u.u({}, dt);
                if (!alive) { explodeAt(u.p, 0xff3366); u.rm(); G.ai.splice(i, 1); G.score += 40; G.credits += 18; }
            }

            // projectiles
            for (let i = G.projs.length - 1; i >= 0; i--) {
                const pj = G.projs[i];
                pj.p.add(pj.v);
                pj.m.position.copy(pj.p);
                pj.l--;

                // projectile glow fade
                pj.m.material.opacity = Math.max(0, pj.l / 140);

                if (pj.l <= 0) {
                    scene.remove(pj.m);
                    G.projs.splice(i, 1);
                    continue;
                }

                const targets = (pj.o instanceof Ship) ? (pj.o.ai ? G.units : G.ai) : G.ai;
                for (let ti = targets.length - 1; ti >= 0; ti--) {
                    const t = targets[ti];
                    if (pj.o instanceof Ship) {
                        if (pj.o.ai && !t) continue;
                        if (!pj.o.ai && t && !t.ai) continue;
                    }
                    if (pj.p.distanceTo(t.p) < pj.rad) {
                        t.hp -= pj.d;

                        if (pj.kind === "ion") {
                            // tiny "chain" / stun-ish feel: damp velocity
                            t.v.multiplyScalar(0.72);
                        }

                        explodeAt(pj.p, pj.kind === "plasma" ? 0xffaa00 : (pj.kind === "ion" ? 0x00ffff : 0x00ffff));

                        // remove projectile unless it pierces
                        if (!pj.pierce || pj.pierce <= 0) {
                            scene.remove(pj.m);
                            G.projs.splice(i, 1);
                        } else {
                            pj.pierce--;
                            pj.d *= 0.75;
                        }

                        if (t.hp <= 0) {
                            explodeAt(t.p, t.ai ? 0xff3366 : 0x00ffaa);
                            t.rm();
                            targets.splice(ti, 1);

                            // XP + score when player unit kills
                            if (pj.o instanceof Ship && !pj.o.ai) {
                                pj.o.addXP(55);
                                G.score += 120;
                                G.credits += 35;
                            }
                        }
                        break;
                    }
                }
            }

            // towers
            for (const t of G.towers) t.u(dt);

            // particles
            for (let i = G.parts.length - 1; i >= 0; i--) {
                const p = G.parts[i];
                p.m.position.add(p.v);
                p.v.multiplyScalar(0.92);
                p.m.material.opacity *= 0.93;
                p.life--;
                if (p.life <= 0) {
                    scene.remove(p.m);
                    G.parts.splice(i, 1);
                }
            }

            // camera follow
            const focus = cu || G.units[0];
            if (focus) {
                const tp = focus.p.clone();
                tp.y += 82;
                tp.z += 130;
                cam.position.lerp(tp, 0.05);
                cam.lookAt(focus.p);
            } else {
                cam.lookAt(new THREE.Vector3(0,0,0));
            }

            upUI();
            R.render(scene, cam);
        }

        window.addEventListener('resize', () => {
            cam.aspect = innerWidth / innerHeight;
            cam.updateProjectionMatrix();
            R.setSize(innerWidth, innerHeight);
        });

        anim();
    </script>
</body>
</html>
