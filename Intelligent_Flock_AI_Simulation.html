<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homunculus Morphing Vehicle - City Network</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(to bottom, #001a33 0%, #000000 100%);
            color: #0ff;
            overflow: hidden;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #0ff;
            padding: 15px;
            border-radius: 8px;
            min-width: 300px;
            pointer-events: none;
            z-index: 100;
        }
        .hud-title {
            color: #ff0;
            font-size: 18px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #ff0;
        }
        .hud-stat {
            color: #0ff;
            font-size: 14px;
            margin: 5px 0;
        }
        .hud-value {
            color: #0f0;
            font-weight: bold;
        }
        #controls-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #f0f;
            padding: 15px;
            border-radius: 8px;
            pointer-events: all;
        }
        .control-btn {
            background: #001a33;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.3s;
        }
        .control-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
            transform: scale(1.05);
        }
        .control-btn.active {
            background: #f0f;
            border-color: #f0f;
            color: #fff;
            box-shadow: 0 0 20px #f0f;
        }
        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #ff0;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            pointer-events: none;
        }
        .instruction-item {
            color: #ff0;
            font-size: 12px;
            margin: 5px 0;
        }
        .key {
            background: #001a33;
            border: 1px solid #ff0;
            padding: 2px 6px;
            border-radius: 3px;
            color: #0ff;
            font-weight: bold;
        }
        #morph-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 255, 0.9);
            border: 3px solid #fff;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 32px;
            font-weight: bold;
            color: #000;
            display: none;
            pointer-events: none;
            z-index: 200;
            animation: pulse 0.5s ease-in-out;
        }
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
        #agent-count-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 0, 255, 0.9);
            border: 2px solid #fff;
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
        }
        .agent-stat {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 10px #f0f;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="hud">
        <div class="hud-title">ü§ñ HOMUNCULUS SYSTEMS</div>
        <div class="hud-stat">Current Form: <span class="hud-value" id="current-form">CAR</span></div>
        <div class="hud-stat">Jump Count: <span class="hud-value" id="jump-count">0/2</span></div>
        <div class="hud-stat">Speed: <span class="hud-value" id="speed">0</span> km/h</div>
        <div class="hud-stat">Altitude: <span class="hud-value" id="altitude">0</span> m</div>
        <div class="hud-stat">Position: <span class="hud-value" id="position">0, 0</span></div>
        <div class="hud-stat">Network Agents: <span class="hud-value" id="network-agents">1</span></div>
        <div class="hud-stat" style="color: #f00;">Collision: <span class="hud-value" id="collision-status">CLEAR</span></div>
        <div class="hud-stat" style="color: #0f0;">Flock Size: <span class="hud-value" id="flock-size">0</span></div>
        <div class="hud-stat" style="color: #ff0;">Formation Score: <span class="hud-value" id="formation-score">0%</span></div>
    </div>

    <div id="controls-panel">
        <div style="color: #f0f; margin-bottom: 10px; font-size: 16px;">üéÆ CONTROLS</div>
        <div style="margin-bottom: 15px;">
            <div style="color: #0ff; font-size: 14px; margin-bottom: 8px;">üîÑ TRANSFORMS</div>
            <button class="control-btn" id="transform-car">üöó Car Mode</button>
            <button class="control-btn" id="transform-plane">‚úàÔ∏è Plane Mode</button>
            <button class="control-btn" id="transform-biped">üö∂ Biped Mode</button>
        </div>
        <div style="border-top: 1px solid #f0f; padding-top: 10px;">
            <button class="control-btn" id="spawn-clone">üë• Clone Agent</button>
            <button class="control-btn" id="spawn-flock">üöô Spawn Flock (+10)</button>
            <button class="control-btn" id="toggle-whiskers">üëÅÔ∏è Toggle Whiskers</button>
            <button class="control-btn" id="reset">üîÉ Reset Scene</button>
        </div>
    </div>

    <div id="instructions">
        <div style="color: #ff0; margin-bottom: 10px; font-size: 16px;">‚å®Ô∏è KEYBOARD</div>
        <div class="instruction-item"><span class="key">W/S</span> Forward/Back</div>
        <div class="instruction-item"><span class="key">A/D</span> Turn Left/Right</div>
        <div class="instruction-item"><span class="key">SPACE</span> Jump (Car/Biped)</div>
        <div class="instruction-item"><span class="key">‚Üë/‚Üì</span> Pitch (Plane)</div>
        <div class="instruction-item"><span class="key">SHIFT</span> Boost Speed</div>
        <div class="instruction-item"><span class="key">C</span> Clone Agent</div>
    </div>

    <div id="morph-indicator"></div>

    <div id="agent-count-display">
        <div class="agent-stat">ACTIVE AGENTS: <span id="active-agents">1</span></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x001a33, 50, 300);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting - Optimized to prevent shader uniform overflow
        const ambientLight = new THREE.AmbientLight(0x404060, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Single hemisphere light for ambient city glow
        const hemiLight = new THREE.HemisphereLight(0x00ffff, 0xff00ff, 0.4);
        hemiLight.position.set(0, 50, 0);
        scene.add(hemiLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(500, 500, 50, 50);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x001a1a,
            roughness: 0.8,
            metalness: 0.2,
            wireframe: false
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Building collision data and states
        const buildingBounds = [];
        const buildings = [];

        // Building class with open/close states
        class Building {
            constructor(bounds, mesh, position) {
                this.bounds = bounds;
                this.mesh = mesh;
                this.position = position;
                this.isOpen = Math.random() > 0.5;
                this.carCount = 0;
                this.maxCars = Math.floor(5 + Math.random() * 10);
                this.lightIntensity = this.isOpen ? 0.8 : 0.3;
                this.nextStateChange = Date.now() + (10000 + Math.random() * 20000);
            }

            update() {
                // Change state periodically
                if (Date.now() > this.nextStateChange) {
                    this.isOpen = !this.isOpen;
                    this.nextStateChange = Date.now() + (10000 + Math.random() * 20000);
                }

                // Update light intensity based on car count
                const targetIntensity = this.isOpen ? 
                    0.3 + (this.carCount / this.maxCars) * 0.5 : 0.3;
                this.lightIntensity += (targetIntensity - this.lightIntensity) * 0.05;
                
                if (this.mesh && this.mesh.material) {
                    this.mesh.material.emissiveIntensity = this.lightIntensity;
                }
            }

            canAcceptCar() {
                return this.isOpen && this.carCount < this.maxCars;
            }

            addCar() {
                this.carCount++;
            }

            removeCar() {
                this.carCount = Math.max(0, this.carCount - 1);
            }
        }

        // Flock Car with AI and whisker sensors
        class FlockCar {
            constructor(x, z, color = 0x00ff00) {
                this.position = new THREE.Vector3(x, 0.5, z);
                this.velocity = new THREE.Vector3();
                this.acceleration = new THREE.Vector3();
                this.rotation = 0;
                this.targetRotation = 0;
                this.speed = 0;
                this.maxSpeed = 0.5;
                this.maxForce = 0.05;
                
                // AI state
                this.state = 'follow'; // follow, goto, enter, idle
                this.targetBuilding = null;
                this.currentBuilding = null;
                this.formationScore = 0;
                this.speedBoost = 0;
                
                // Whisker sensors (forward collision detection)
                this.whiskers = [
                    { angle: 0, length: 4, detected: false },      // front
                    { angle: Math.PI/4, length: 3, detected: false },   // front-right
                    { angle: -Math.PI/4, length: 3, detected: false },  // front-left
                    { angle: Math.PI/2, length: 2, detected: false },   // right
                    { angle: -Math.PI/2, length: 2, detected: false }   // left
                ];

                this.createMesh(color);
            }

            createMesh(color) {
                this.group = new THREE.Group();
                
                const bodyGeom = new THREE.BoxGeometry(2, 0.8, 1.2);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    metalness: 0.7,
                    roughness: 0.3
                });
                this.body = new THREE.Mesh(bodyGeom, bodyMat);
                this.body.position.y = 0.4;
                this.body.castShadow = true;
                this.group.add(this.body);

                // Wheels
                const wheelGeom = new THREE.CylinderGeometry(0.25, 0.25, 0.2, 8);
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                
                [[-0.7, 0.25, -0.7], [-0.7, 0.25, 0.7], 
                 [0.7, 0.25, -0.7], [0.7, 0.25, 0.7]].forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(...pos);
                    this.group.add(wheel);
                });

                // Headlights
                const lightGeom = new THREE.SphereGeometry(0.1, 8, 8);
                const lightMat = new THREE.MeshStandardMaterial({
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 1
                });
                [-0.4, 0.4].forEach(z => {
                    const light = new THREE.Mesh(lightGeom, lightMat);
                    light.position.set(1, 0.4, z);
                    this.group.add(light);
                });

                this.group.position.copy(this.position);
                scene.add(this.group);

                // Whisker visualization lines
                this.whiskerLines = [];
                this.whiskers.forEach(() => {
                    const lineGeom = new THREE.BufferGeometry();
                    const lineMat = new THREE.LineBasicMaterial({ 
                        color: 0x00ff00,
                        transparent: true,
                        opacity: 0.5
                    });
                    const line = new THREE.Line(lineGeom, lineMat);
                    this.whiskerLines.push(line);
                    this.group.add(line);
                });
                this.showWhiskers = false;
            }

            updateWhiskers() {
                this.whiskers.forEach((whisker, i) => {
                    const angle = this.rotation + whisker.angle;
                    const endX = this.position.x + Math.sin(angle) * whisker.length;
                    const endZ = this.position.z + Math.cos(angle) * whisker.length;
                    
                    whisker.detected = false;
                    
                    // Check against buildings
                    for (let building of buildingBounds) {
                        if (endX > building.minX && endX < building.maxX &&
                            endZ > building.minZ && endZ < building.maxZ) {
                            whisker.detected = true;
                            break;
                        }
                    }

                    // Update visualization
                    if (this.whiskerLines[i] && this.showWhiskers) {
                        const points = [
                            new THREE.Vector3(0, 0.5, 0),
                            new THREE.Vector3(
                                Math.sin(whisker.angle) * whisker.length,
                                0.5,
                                Math.cos(whisker.angle) * whisker.length
                            )
                        ];
                        this.whiskerLines[i].geometry.setFromPoints(points);
                        this.whiskerLines[i].material.color.setHex(
                            whisker.detected ? 0xff0000 : 0x00ff00
                        );
                        this.whiskerLines[i].visible = true;
                    } else if (this.whiskerLines[i]) {
                        this.whiskerLines[i].visible = false;
                    }
                });
            }

            avoidObstacles() {
                const avoidance = new THREE.Vector3();
                let avoidCount = 0;

                this.whiskers.forEach(whisker => {
                    if (whisker.detected) {
                        const angle = this.rotation + whisker.angle + Math.PI; // opposite direction
                        avoidance.x += Math.sin(angle);
                        avoidance.z += Math.cos(angle);
                        avoidCount++;
                    }
                });

                if (avoidCount > 0) {
                    avoidance.divideScalar(avoidCount);
                    avoidance.normalize();
                    avoidance.multiplyScalar(this.maxForce * 2);
                }

                return avoidance;
            }

            calculateFormation(player) {
                // Formation: side-by-side on right side, parallel to player
                const rightSide = new THREE.Vector3(
                    -Math.cos(player.rotation),
                    0,
                    Math.sin(player.rotation)
                );

                // Find formation slot (grid pattern on right side)
                const slotIndex = flockCars.indexOf(this);
                const row = Math.floor(slotIndex / 5);
                const col = slotIndex % 5;
                
                const formationOffset = rightSide.clone()
                    .multiplyScalar(4 + col * 3)
                    .add(new THREE.Vector3(
                        Math.sin(player.rotation) * (row - 2) * 3,
                        0,
                        Math.cos(player.rotation) * (row - 2) * 3
                    ));

                const formationPos = player.position.clone().add(formationOffset);
                
                // Calculate formation score based on alignment
                const distToFormation = this.position.distanceTo(formationPos);
                const facingDiff = Math.abs(this.rotation - player.rotation);
                const velocityMatch = 1 - Math.abs(this.speed - player.velocity.length());
                
                this.formationScore = Math.max(0, 1 - (distToFormation / 20) - (facingDiff / Math.PI));
                
                // Speed boost when approaching formation
                if (distToFormation < 15 && distToFormation > 3) {
                    this.speedBoost = 0.2 * (1 - distToFormation / 15);
                } else {
                    this.speedBoost *= 0.9;
                }

                return formationPos;
            }

            seek(target) {
                const desired = new THREE.Vector3()
                    .subVectors(target, this.position)
                    .normalize()
                    .multiplyScalar(this.maxSpeed + this.speedBoost);
                
                const steer = new THREE.Vector3()
                    .subVectors(desired, this.velocity)
                    .clampLength(0, this.maxForce);
                
                return steer;
            }

            separate(others) {
                const separation = new THREE.Vector3();
                let count = 0;

                others.forEach(other => {
                    const dist = this.position.distanceTo(other.position);
                    if (other !== this && dist < 4) {
                        const diff = new THREE.Vector3()
                            .subVectors(this.position, other.position)
                            .normalize()
                            .divideScalar(dist);
                        separation.add(diff);
                        count++;
                    }
                });

                if (count > 0) {
                    separation.divideScalar(count);
                    separation.normalize().multiplyScalar(this.maxSpeed);
                    const steer = new THREE.Vector3()
                        .subVectors(separation, this.velocity)
                        .clampLength(0, this.maxForce);
                    return steer;
                }

                return separation;
            }

            align(player) {
                // Match player's direction and velocity
                const alignment = new THREE.Vector3();
                
                this.targetRotation = player.rotation;
                
                return alignment;
            }

            update(player, deltaTime) {
                this.updateWhiskers();

                // State machine
                switch (this.state) {
                    case 'follow':
                        const formationPos = this.calculateFormation(player);
                        
                        this.acceleration.set(0, 0, 0);
                        this.acceleration.add(this.seek(formationPos).multiplyScalar(1.5));
                        this.acceleration.add(this.separate(flockCars).multiplyScalar(1.2));
                        this.acceleration.add(this.avoidObstacles().multiplyScalar(2.0));
                        
                        // Match player velocity
                        const playerVel = player.velocity.clone().setY(0);
                        if (playerVel.length() < 0.1) {
                            // Player stopped - match exactly
                            this.velocity.multiplyScalar(0.85);
                        }
                        
                        break;

                    case 'goto':
                        if (this.targetBuilding) {
                            const targetPos = new THREE.Vector3(
                                this.targetBuilding.position.x,
                                0,
                                this.targetBuilding.position.z
                            );
                            
                            this.acceleration.add(this.seek(targetPos));
                            this.acceleration.add(this.separate(flockCars));
                            this.acceleration.add(this.avoidObstacles().multiplyScalar(2.0));
                            
                            // Check if arrived
                            if (this.position.distanceTo(targetPos) < 3) {
                                this.state = 'enter';
                            }
                        } else {
                            this.state = 'follow';
                        }
                        break;

                    case 'enter':
                        if (this.targetBuilding && this.targetBuilding.canAcceptCar()) {
                            this.targetBuilding.addCar();
                            this.remove();
                            flockCars.splice(flockCars.indexOf(this), 1);
                        } else {
                            this.state = 'follow';
                        }
                        break;
                }

                // Update physics
                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed + this.speedBoost);
                this.position.add(this.velocity);

                // Update rotation smoothly
                if (this.velocity.length() > 0.01) {
                    const targetRot = Math.atan2(this.velocity.x, this.velocity.z);
                    let rotDiff = targetRot - this.rotation;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    this.rotation += rotDiff * 0.1;
                }

                this.speed = this.velocity.length();

                // Keep on ground
                this.position.y = 0.5;

                // Update mesh
                this.group.position.copy(this.position);
                this.group.rotation.y = this.rotation;

                // Visual feedback for formation score
                if (this.body && this.body.material) {
                    this.body.material.emissiveIntensity = 0.3 + this.formationScore * 0.4;
                }
            }

            remove() {
                scene.remove(this.group);
            }
        }

        // Flock management
        const flockCars = [];
        let showWhiskersGlobal = false;

        function spawnFlockCar(building) {
            if (!building) return;
            
            const offset = (Math.random() - 0.5) * 10;
            const car = new FlockCar(
                building.position.x + offset,
                building.position.z + offset,
                0x00ff00
            );
            car.showWhiskers = showWhiskersGlobal;
            flockCars.push(car);
            
            if (building.carCount > 0) {
                building.removeCar();
            }
        }

        function manageBuildingCars() {
            buildings.forEach(building => {
                // Cars leave when building closes
                if (!building.isOpen && building.carCount > 0 && Math.random() < 0.02) {
                    spawnFlockCar(building);
                }
            });

            // Send cars to open buildings when idle
            flockCars.forEach(car => {
                if (car.state === 'follow' && Math.random() < 0.001) {
                    const openBuildings = buildings.filter(b => b.canAcceptCar());
                    if (openBuildings.length > 0) {
                        car.targetBuilding = openBuildings[Math.floor(Math.random() * openBuildings.length)];
                        car.state = 'goto';
                    }
                }
            });
        }

        // Create city grid
        function createCity() {
            const buildingGroup = new THREE.Group();
            
            for (let i = -10; i <= 10; i++) {
                for (let j = -10; j <= 10; j++) {
                    if (Math.abs(i) < 2 && Math.abs(j) < 2) continue; // Clear center area
                    
                    if (Math.random() > 0.3) {
                        const height = 5 + Math.random() * 30;
                        const width = 3 + Math.random() * 4;
                        const depth = 3 + Math.random() * 4;
                        
                        const buildingGeom = new THREE.BoxGeometry(width, height, depth);
                        const buildingMat = new THREE.MeshStandardMaterial({
                            color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.7, 0.3),
                            emissive: new THREE.Color().setHSL(Math.random(), 1, 0.3),
                            emissiveIntensity: 0.5,
                            roughness: 0.7,
                            metalness: 0.3
                        });
                        
                        const buildingMesh = new THREE.Mesh(buildingGeom, buildingMat);
                        buildingMesh.position.set(i * 15, height / 2, j * 15);
                        buildingMesh.castShadow = false;
                        buildingMesh.receiveShadow = true;
                        buildingGroup.add(buildingMesh);

                        // Store collision bounds and building state
                        const bounds = {
                            minX: i * 15 - width / 2,
                            maxX: i * 15 + width / 2,
                            minZ: j * 15 - depth / 2,
                            maxZ: j * 15 + depth / 2,
                            height: height
                        };
                        
                        buildingBounds.push(bounds);
                        
                        const building = new Building(
                            bounds,
                            buildingMesh,
                            new THREE.Vector3(i * 15, 0, j * 15)
                        );
                        buildings.push(building);

                        // Spawn initial cars from some buildings
                        if (Math.random() < 0.3) {
                            for (let k = 0; k < Math.floor(Math.random() * 3); k++) {
                                spawnFlockCar(building);
                            }
                        }
                    }
                }
            }
            
            scene.add(buildingGroup);
        }

        // Collision detection function
        function checkCollision(position, radius = 2) {
            for (let building of buildingBounds) {
                // Check if position is inside building bounds
                if (position.x + radius > building.minX && 
                    position.x - radius < building.maxX &&
                    position.z + radius > building.minZ && 
                    position.z - radius < building.maxZ &&
                    position.y < building.height) {
                    return building;
                }
            }
            return null;
        }

        // Push agent out of collision
        function resolveCollision(position, velocity, radius = 2) {
            const collision = checkCollision(position, radius);
            if (collision) {
                // Visual feedback - flash the screen border
                document.body.style.boxShadow = 'inset 0 0 50px 10px rgba(255, 0, 0, 0.5)';
                setTimeout(() => {
                    document.body.style.boxShadow = '';
                }, 100);

                // Find closest edge and push out
                const distToLeft = position.x - collision.minX;
                const distToRight = collision.maxX - position.x;
                const distToFront = position.z - collision.minZ;
                const distToBack = collision.maxZ - position.z;
                
                const minDist = Math.min(distToLeft, distToRight, distToFront, distToBack);
                
                if (minDist === distToLeft) {
                    position.x = collision.minX - radius;
                    velocity.x = Math.min(velocity.x, 0);
                } else if (minDist === distToRight) {
                    position.x = collision.maxX + radius;
                    velocity.x = Math.max(velocity.x, 0);
                } else if (minDist === distToFront) {
                    position.z = collision.minZ - radius;
                    velocity.z = Math.min(velocity.z, 0);
                } else {
                    position.z = collision.maxZ + radius;
                    velocity.z = Math.max(velocity.z, 0);
                }
                
                return true;
            }
            return false;
        }

        createCity();

        // Road grid
        function createRoads() {
            const roadMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.9
            });

            for (let i = -10; i <= 10; i++) {
                const roadH = new THREE.Mesh(
                    new THREE.PlaneGeometry(300, 5),
                    roadMaterial
                );
                roadH.rotation.x = -Math.PI / 2;
                roadH.position.set(0, 0.1, i * 15);
                roadH.receiveShadow = true;
                scene.add(roadH);

                const roadV = new THREE.Mesh(
                    new THREE.PlaneGeometry(5, 300),
                    roadMaterial
                );
                roadV.rotation.x = -Math.PI / 2;
                roadV.position.set(i * 15, 0.1, 0);
                roadV.receiveShadow = true;
                scene.add(roadV);
            }
        }

        createRoads();

        // Homunculus Vehicle Class
        class HomuncVehicle {
            constructor(x, z, isClone = false) {
                this.group = new THREE.Group();
                this.position = new THREE.Vector3(x, 0, z);
                this.velocity = new THREE.Vector3();
                this.rotation = 0;
                this.verticalVelocity = 0;
                this.onGround = true;
                this.isClone = isClone;
                
                this.form = 'car'; // car, plane, biped
                this.jumpCount = 0;
                this.morphing = false;
                
                this.parts = {
                    car: new THREE.Group(),
                    plane: new THREE.Group(),
                    biped: new THREE.Group()
                };
                
                this.createCarForm();
                this.createPlaneForm();
                this.createBipedForm();
                
                this.group.add(this.parts.car);
                this.parts.plane.visible = false;
                this.parts.biped.visible = false;
                
                this.group.position.copy(this.position);
                scene.add(this.group);
            }

            createCarForm() {
                const car = this.parts.car;
                
                // Body
                const bodyGeom = new THREE.BoxGeometry(4, 1.5, 2);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: this.isClone ? 0xff00ff : 0x00ffff,
                    emissive: this.isClone ? 0xff00ff : 0x00ffff,
                    emissiveIntensity: 0.5,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.position.y = 1;
                body.castShadow = true;
                car.add(body);

                // Cabin
                const cabinGeom = new THREE.BoxGeometry(2, 1, 1.8);
                const cabin = new THREE.Mesh(cabinGeom, bodyMat);
                cabin.position.set(-0.5, 2, 0);
                cabin.castShadow = false;
                car.add(cabin);

                // Wheels
                const wheelGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 16);
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                
                const wheelPositions = [
                    [-1.5, 0.5, -1.2],
                    [-1.5, 0.5, 1.2],
                    [1.5, 0.5, -1.2],
                    [1.5, 0.5, 1.2]
                ];

                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(...pos);
                    wheel.castShadow = false;
                    car.add(wheel);
                });

                // Headlights
                const lightGeom = new THREE.SphereGeometry(0.2, 16, 16);
                const lightMat = new THREE.MeshStandardMaterial({
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 1
                });
                
                [-0.8, 0.8].forEach(x => {
                    const light = new THREE.Mesh(lightGeom, lightMat);
                    light.position.set(2, 1, x);
                    car.add(light);
                });
            }

            createPlaneForm() {
                const plane = this.parts.plane;
                
                // Fuselage
                const fuselageGeom = new THREE.CylinderGeometry(0.8, 0.5, 6, 16);
                const fuselageMat = new THREE.MeshStandardMaterial({
                    color: this.isClone ? 0xff00ff : 0x00ffff,
                    emissive: this.isClone ? 0xff00ff : 0x00ffff,
                    emissiveIntensity: 0.5,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const fuselage = new THREE.Mesh(fuselageGeom, fuselageMat);
                fuselage.rotation.z = Math.PI / 2;
                fuselage.position.y = 2;
                fuselage.castShadow = true;
                plane.add(fuselage);

                // Wings
                const wingGeom = new THREE.BoxGeometry(12, 0.3, 2);
                const wing = new THREE.Mesh(wingGeom, fuselageMat);
                wing.position.y = 2;
                wing.castShadow = false;
                plane.add(wing);

                // Tail wings
                const tailGeom = new THREE.BoxGeometry(4, 0.2, 1);
                const tail = new THREE.Mesh(tailGeom, fuselageMat);
                tail.position.set(-2.5, 2.5, 0);
                tail.castShadow = false;
                plane.add(tail);

                // Vertical stabilizer
                const vstabGeom = new THREE.BoxGeometry(0.2, 2, 1.5);
                const vstab = new THREE.Mesh(vstabGeom, fuselageMat);
                vstab.position.set(-2.5, 3, 0);
                vstab.castShadow = false;
                plane.add(vstab);

                // Engines
                [-4, 4].forEach(x => {
                    const engineGeom = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16);
                    const engine = new THREE.Mesh(engineGeom, fuselageMat);
                    engine.rotation.z = Math.PI / 2;
                    engine.position.set(x * 0.3, 1.5, x);
                    engine.castShadow = false;
                    plane.add(engine);
                });
            }

            createBipedForm() {
                const biped = this.parts.biped;
                
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: this.isClone ? 0xff00ff : 0x00ffff,
                    emissive: this.isClone ? 0xff00ff : 0x00ffff,
                    emissiveIntensity: 0.5,
                    metalness: 0.7,
                    roughness: 0.3
                });

                // Head
                const headGeom = new THREE.SphereGeometry(0.6, 16, 16);
                const head = new THREE.Mesh(headGeom, bodyMat);
                head.position.y = 5;
                head.castShadow = false;
                biped.add(head);

                // Eyes
                const eyeGeom = new THREE.SphereGeometry(0.15, 8, 8);
                const eyeMat = new THREE.MeshStandardMaterial({
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 1
                });
                [-0.25, 0.25].forEach(x => {
                    const eye = new THREE.Mesh(eyeGeom, eyeMat);
                    eye.position.set(x, 5.2, 0.5);
                    biped.add(eye);
                });

                // Torso
                const torsoGeom = new THREE.BoxGeometry(1.5, 2, 1);
                const torso = new THREE.Mesh(torsoGeom, bodyMat);
                torso.position.y = 3;
                torso.castShadow = true;
                biped.add(torso);

                // Arms
                const armGeom = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
                [-1, 1].forEach(x => {
                    const arm = new THREE.Mesh(armGeom, bodyMat);
                    arm.position.set(x, 3, 0);
                    arm.castShadow = false;
                    biped.add(arm);

                    // Hands
                    const handGeom = new THREE.SphereGeometry(0.25, 8, 8);
                    const hand = new THREE.Mesh(handGeom, bodyMat);
                    hand.position.set(x, 2, 0);
                    hand.castShadow = false;
                    biped.add(hand);
                });

                // Legs
                const legGeom = new THREE.CylinderGeometry(0.25, 0.25, 2.5, 8);
                [-0.5, 0.5].forEach(x => {
                    const leg = new THREE.Mesh(legGeom, bodyMat);
                    leg.position.set(x, 1.25, 0);
                    leg.castShadow = false;
                    biped.add(leg);

                    // Feet
                    const footGeom = new THREE.BoxGeometry(0.3, 0.2, 0.6);
                    const foot = new THREE.Mesh(footGeom, bodyMat);
                    foot.position.set(x, 0.1, 0.2);
                    foot.castShadow = false;
                    biped.add(foot);
                });
            }

            morph(newForm) {
                if (this.morphing || this.form === newForm) return;
                
                this.morphing = true;
                this.form = newForm;
                
                // Hide all forms
                this.parts.car.visible = false;
                this.parts.plane.visible = false;
                this.parts.biped.visible = false;
                
                // Show new form
                this.parts[newForm].visible = true;
                
                if (!this.isClone) {
                    showMorphIndicator(newForm.toUpperCase());
                }
                
                setTimeout(() => {
                    this.morphing = false;
                }, 1000);
            }

            jump() {
                if (this.form === 'plane') return;
                
                if (this.onGround) {
                    this.verticalVelocity = 15;
                    this.onGround = false;
                    this.jumpCount++;
                    
                    if (this.form === 'car' && this.jumpCount >= 2) {
                        this.morph('plane');
                        this.jumpCount = 0;
                    }
                }
            }

            update(deltaTime, keys) {
                const speed = keys.shift ? 2 : 1;
                
                if (this.form === 'car' || this.form === 'biped') {
                    // Ground movement
                    if (keys.w) {
                        this.velocity.x += Math.sin(this.rotation) * 0.5 * speed;
                        this.velocity.z += Math.cos(this.rotation) * 0.5 * speed;
                    }
                    if (keys.s) {
                        this.velocity.x -= Math.sin(this.rotation) * 0.3 * speed;
                        this.velocity.z -= Math.cos(this.rotation) * 0.3 * speed;
                    }
                    if (keys.a) this.rotation += 0.05;
                    if (keys.d) this.rotation -= 0.05;
                    
                    this.velocity.multiplyScalar(0.92);
                } else if (this.form === 'plane') {
                    // Flight controls
                    if (keys.w) {
                        this.velocity.x += Math.sin(this.rotation) * 0.3 * speed;
                        this.velocity.z += Math.cos(this.rotation) * 0.3 * speed;
                    }
                    if (keys.s) {
                        this.velocity.x -= Math.sin(this.rotation) * 0.2 * speed;
                        this.velocity.z -= Math.cos(this.rotation) * 0.2 * speed;
                    }
                    if (keys.a) this.rotation += 0.03;
                    if (keys.d) this.rotation -= 0.03;
                    if (keys.up) this.verticalVelocity += 0.2;
                    if (keys.down) this.verticalVelocity -= 0.2;
                    
                    this.velocity.multiplyScalar(0.98);
                    this.verticalVelocity *= 0.95;
                }

                // Gravity
                if (!this.onGround) {
                    this.verticalVelocity -= 0.8;
                }

                // Update position
                this.position.add(this.velocity);
                this.position.y += this.verticalVelocity * deltaTime;

                // Collision detection with buildings (only when on ground or low altitude)
                if (this.position.y < 40) {
                    const collided = resolveCollision(this.position, this.velocity, 2);
                    if (!this.isClone) {
                        lastCollision = collided;
                    }
                }

                // Ground collision
                if (this.position.y <= 0) {
                    this.position.y = 0;
                    this.verticalVelocity = 0;
                    this.onGround = true;
                    
                    if (this.form === 'plane') {
                        this.morph('biped');
                    }
                } else {
                    this.onGround = false;
                }

                // Keep within world bounds
                const worldBound = 200;
                if (Math.abs(this.position.x) > worldBound) {
                    this.position.x = Math.sign(this.position.x) * worldBound;
                    this.velocity.x *= -0.5;
                }
                if (Math.abs(this.position.z) > worldBound) {
                    this.position.z = Math.sign(this.position.z) * worldBound;
                    this.velocity.z *= -0.5;
                }

                // Update group transform
                this.group.position.copy(this.position);
                this.group.rotation.y = this.rotation;

                // Animate biped walking
                if (this.form === 'biped' && this.velocity.length() > 0.1) {
                    const walkCycle = Math.sin(Date.now() * 0.01);
                    this.parts.biped.children.forEach((child, i) => {
                        if (i > 4) { // Legs and feet
                            child.rotation.x = walkCycle * 0.3;
                        }
                    });
                }
            }

            remove() {
                scene.remove(this.group);
            }
        }

        // Agent management
        const agents = [];
        let mainAgent = new HomuncVehicle(0, 0, false);
        agents.push(mainAgent);

        let lastCollision = false;

        function spawnClone() {
            const offsetX = (Math.random() - 0.5) * 10;
            const offsetZ = (Math.random() - 0.5) * 10;
            const clone = new HomuncVehicle(
                mainAgent.position.x + offsetX,
                mainAgent.position.z + offsetZ,
                true
            );
            clone.form = mainAgent.form;
            clone.morph(mainAgent.form);
            agents.push(clone);
            updateAgentCount();
        }

        function updateAgentCount() {
            document.getElementById('network-agents').textContent = agents.length;
            document.getElementById('active-agents').textContent = agents.length;
        }

        function showMorphIndicator(formName) {
            const indicator = document.getElementById('morph-indicator');
            indicator.textContent = `MORPHING TO ${formName}`;
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 1500);
        }

        // Keyboard controls
        const keys = {
            w: false, s: false, a: false, d: false,
            up: false, down: false, shift: false, space: false, c: false
        };

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w') keys.w = true;
            if (key === 's') keys.s = true;
            if (key === 'a') keys.a = true;
            if (key === 'd') keys.d = true;
            if (key === 'arrowup') keys.up = true;
            if (key === 'arrowdown') keys.down = true;
            if (key === 'shift') keys.shift = true;
            if (key === ' ') {
                keys.space = true;
                mainAgent.jump();
            }
            if (key === 'c') {
                keys.c = true;
                spawnClone();
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'w') keys.w = false;
            if (key === 's') keys.s = false;
            if (key === 'a') keys.a = false;
            if (key === 'd') keys.d = false;
            if (key === 'arrowup') keys.up = false;
            if (key === 'arrowdown') keys.down = false;
            if (key === 'shift') keys.shift = false;
            if (key === ' ') keys.space = false;
            if (key === 'c') keys.c = false;
        });

        // UI Controls
        document.getElementById('spawn-clone').addEventListener('click', spawnClone);

        document.getElementById('spawn-flock').addEventListener('click', () => {
            for (let i = 0; i < 10; i++) {
                const angle = (Math.PI * 2 * i) / 10;
                const radius = 15;
                const car = new FlockCar(
                    mainAgent.position.x + Math.cos(angle) * radius,
                    mainAgent.position.z + Math.sin(angle) * radius,
                    0x00ff00
                );
                car.showWhiskers = showWhiskersGlobal;
                flockCars.push(car);
            }
        });

        document.getElementById('toggle-whiskers').addEventListener('click', () => {
            showWhiskersGlobal = !showWhiskersGlobal;
            flockCars.forEach(car => car.showWhiskers = showWhiskersGlobal);
        });

        document.getElementById('transform-car').addEventListener('click', () => {
            agents.forEach(agent => agent.morph('car'));
        });

        document.getElementById('transform-plane').addEventListener('click', () => {
            agents.forEach(agent => agent.morph('plane'));
        });

        document.getElementById('transform-biped').addEventListener('click', () => {
            agents.forEach(agent => agent.morph('biped'));
        });

        document.getElementById('reset').addEventListener('click', () => {
            agents.forEach(agent => agent.remove());
            agents.length = 0;
            mainAgent = new HomuncVehicle(0, 0, false);
            agents.push(mainAgent);
            
            flockCars.forEach(car => car.remove());
            flockCars.length = 0;
            
            updateAgentCount();
        });

        // Animation loop
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update all agents
            agents.forEach(agent => {
                agent.update(deltaTime, keys);
            });

            // Update flock cars
            flockCars.forEach(car => {
                car.update(mainAgent, deltaTime);
            });

            // Update buildings
            buildings.forEach(building => {
                building.update();
            });

            // Manage building car spawning/entering
            manageBuildingCars();

            // Clones follow main agent's form with delay
            if (agents.length > 1) {
                agents.slice(1).forEach((clone, i) => {
                    setTimeout(() => {
                        if (clone.form !== mainAgent.form && !clone.morphing) {
                            clone.morph(mainAgent.form);
                        }
                    }, i * 500);
                });
            }

            // Update HUD
            document.getElementById('current-form').textContent = mainAgent.form.toUpperCase();
            document.getElementById('jump-count').textContent = `${mainAgent.jumpCount}/2`;
            document.getElementById('speed').textContent = 
                Math.round(mainAgent.velocity.length() * 100);
            document.getElementById('altitude').textContent = 
                Math.round(mainAgent.position.y);
            document.getElementById('position').textContent = 
                `${Math.round(mainAgent.position.x)}, ${Math.round(mainAgent.position.z)}`;
            
            // Update collision status
            const collisionEl = document.getElementById('collision-status');
            if (lastCollision) {
                collisionEl.textContent = '‚ö†Ô∏è IMPACT';
                collisionEl.style.color = '#f00';
            } else {
                collisionEl.textContent = 'CLEAR';
                collisionEl.style.color = '#0f0';
            }

            // Update flock stats
            document.getElementById('flock-size').textContent = flockCars.length;
            
            const avgFormation = flockCars.reduce((sum, car) => sum + car.formationScore, 0) / 
                                 (flockCars.length || 1);
            document.getElementById('formation-score').textContent = 
                Math.round(avgFormation * 100) + '%';

            // Camera follow
            const cameraOffset = new THREE.Vector3(
                -Math.sin(mainAgent.rotation) * 15,
                10,
                -Math.cos(mainAgent.rotation) * 15
            );
            
            const targetCameraPos = new THREE.Vector3()
                .copy(mainAgent.position)
                .add(cameraOffset);
                
            camera.position.lerp(targetCameraPos, 0.05);
            camera.lookAt(mainAgent.position);

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
