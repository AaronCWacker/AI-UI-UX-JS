<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no"/>
  <title>ScifiKin ‚Äî Neon Arcade: Atari 2600 Remix (Three.js)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0c0a1e;
      --panel: rgba(0,0,0,.70);
      --line: rgba(255,255,255,.14);
      --cyan:#00ffff;
      --pink:#ff00ff;
      --gold:#ffd700;
    }
    html,body{height:100%;margin:0;overflow:hidden;background:var(--bg);font-family:'Orbitron',sans-serif;color:#eaeaff}
    #wrap{position:relative;width:100vw;height:100vh}
    canvas{display:block}
    .text-glow{text-shadow:0 0 6px #fff,0 0 14px var(--pink),0 0 22px var(--pink)}
    .btn-glow{box-shadow:0 0 7px var(--cyan),0 0 14px var(--cyan);transition:all .2s}
    .btn-glow:hover{box-shadow:0 0 10px var(--pink),0 0 22px var(--pink);transform:translateY(-1px)}
    .panel{background:var(--panel);border:2px solid var(--line);backdrop-filter:blur(10px);border-radius:12px}
    .tiny{font-size:12px;color:#c9c9ff}
    #hud{position:absolute;inset:0;pointer-events:none}
    #topbar{position:absolute;top:10px;left:10px;right:10px;display:flex;gap:10px;justify-content:space-between;align-items:flex-start}
    #hint{max-width:740px}
    #toast{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);padding:10px 14px;border-radius:10px;font-weight:700;opacity:0;transition:opacity .35s,bottom .35s,transform .35s;pointer-events:none}
    #toast.show{opacity:1;bottom:34px;transform:translateX(-50%) scale(1.02)}
    #gameOverlay{position:absolute;inset:0;display:none;pointer-events:auto}
    #gameOverlay.show{display:block}
    #gameCanvasWrap{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter:blur(8px)}
    #gameCanvas{width:min(92vw,980px);height:min(80vh,700px);background:#0b0b18;border:3px solid rgba(255,255,255,.18);border-radius:14px;box-shadow:0 0 20px rgba(255,0,255,.35),0 0 26px rgba(0,255,255,.18)}
    #gameUI{position:absolute;top:12px;left:12px;right:12px;display:flex;gap:10px;justify-content:space-between;align-items:flex-start;pointer-events:none}
    #gameUI .panel{pointer-events:auto}
    .kbd{display:inline-block;padding:0 6px;border:1px solid rgba(255,255,255,.25);border-bottom-width:2px;border-radius:6px;background:rgba(0,0,0,.35);font-size:12px}
    #mobileControls{position:absolute;left:12px;right:12px;bottom:12px;display:none;gap:10px;justify-content:space-between;pointer-events:auto}
    #mobileControls button{flex:1;border-radius:12px;padding:12px 10px;font-weight:800}
    @media (max-width: 820px){ #mobileControls{display:flex} }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="three"></canvas>

  <div id="hud">
    <div id="topbar" class="pointer-events-none">
      <div class="panel p-3 pointer-events-auto" style="max-width:820px">
        <div class="text-2xl md:text-3xl font-bold text-glow">SCIFIKIN ‚Ä¢ NEON ARCADE (ATARI REMIX)</div>
        <div class="tiny mt-1">
          Click a cabinet screen to play. <span class="hidden md:inline">Rotate view: drag ‚Ä¢ Zoom: wheel/pinch</span>
          <span class="md:hidden">Drag to look ‚Ä¢ Pinch to zoom</span>
        </div>
        <div id="hint" class="tiny mt-2">
          In-game controls (most): Move <span class="kbd">WASD</span> / <span class="kbd">‚Üë‚Üì‚Üê‚Üí</span> ‚Ä¢ Action/Fire <span class="kbd">Space</span> ‚Ä¢ Exit <span class="kbd">Esc</span>.
          Combat: rotate <span class="kbd">‚Üê‚Üí</span>, drive <span class="kbd">‚Üë‚Üì</span>, fire <span class="kbd">Space</span>.
        </div>
      </div>

      <div class="panel p-3 pointer-events-auto text-right">
        <div class="tiny">Arcade Status</div>
        <div id="status" class="font-bold text-cyan-200">Attract Mode ‚ú®</div>
        <div class="tiny mt-1">Cabinets: <span id="cabCount">5</span></div>
      </div>
    </div>

    <div id="toast" class="panel"></div>
  </div>

  <div id="gameOverlay">
    <div id="gameCanvasWrap">
      <canvas id="gameCanvas"></canvas>
    </div>

    <div id="gameUI">
      <div class="panel p-3">
        <div id="gameTitle" class="text-xl font-bold text-glow">GAME</div>
        <div id="gameSub" class="tiny mt-1">‚Äî</div>
        <div id="gameHelp" class="tiny mt-2">‚Äî</div>
      </div>

      <div class="panel p-3 text-right">
        <div class="tiny">Score</div>
        <div id="gameScore" class="text-2xl font-bold text-yellow-300">0</div>
        <div class="tiny mt-2">Best</div>
        <div id="gameBest" class="font-bold text-cyan-200">0</div>
        <button id="backBtn" class="mt-3 bg-cyan-400 text-black font-extrabold py-2 px-3 rounded-lg btn-glow pointer-events-auto">Back to Arcade</button>
      </div>
    </div>

    <div id="mobileControls">
      <button id="mLeft"  class="bg-white/10 border border-white/20">‚¨ÖÔ∏è</button>
      <button id="mAct"   class="bg-fuchsia-500 text-black btn-glow">üî• / ‚úÖ</button>
      <button id="mRight" class="bg-white/10 border border-white/20">‚û°Ô∏è</button>
    </div>
  </div>
</div>

<script>
/* ===========================
   Tiny Audio (blips)
=========================== */
let audioCtx;
function ainit(){
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
}
function blip(type="tap", vol=0.12, pitch=1){
  ainit();
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = (type==="shoot") ? "square" : (type==="boom") ? "sawtooth" : "sine";
  o.frequency.setValueAtTime((type==="shoot"?720:type==="boom"?180:520)*pitch, t);
  g.gain.setValueAtTime(0.0001, t);
  g.gain.linearRampToValueAtTime(vol, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t + (type==="boom"?0.20:0.12));
  o.connect(g).connect(audioCtx.destination);
  o.start(t);
  o.stop(t + (type==="boom"?0.22:0.14));
}
document.addEventListener("pointerdown",()=>ainit(),{once:true});

/* ===========================
   Helpers
=========================== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const wrap = (v, m)=>((v%m)+m)%m;

const toastEl = document.getElementById("toast");
let toastT=0;
function toast(msg, glow="rgba(0,255,255,.16)"){
  toastEl.textContent = msg;
  toastEl.style.borderColor = "rgba(255,255,255,.18)";
  toastEl.style.boxShadow = `0 0 16px ${glow}`;
  toastEl.classList.add("show");
  toastT = performance.now();
  setTimeout(()=>{
    if(performance.now()-toastT>800) toastEl.classList.remove("show");
  }, 1300);
}

/* ===========================
   Three.js Arcade (5 cabinets)
=========================== */
const threeCanvas = document.getElementById("three");
let scene, camera, renderer, raycaster;
let starfield, floor, neon;
let cabinets=[];
let dragging=false, lastX=0,lastY=0;
let orbitYaw=0, orbitPitch=0.25, orbitDist=32;
let targetYaw=0, targetPitch=0.25, targetDist=32;

function initThree(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0c0a1e, 0.02);

  camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0, 14, 28);

  renderer = new THREE.WebGLRenderer({canvas: threeCanvas, antialias:true, alpha:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));

  raycaster = new THREE.Raycaster();

  scene.add(new THREE.AmbientLight(0x1a1438, 0.78));
  const key = new THREE.DirectionalLight(0xffffff, 1.05);
  key.position.set(18, 30, 20);
  scene.add(key);

  const rim = new THREE.PointLight(0xff00ff, 2.0, 100);
  rim.position.set(-18, 10, -12);
  scene.add(rim);

  const cyan = new THREE.PointLight(0x00ffff, 2.0, 100);
  cyan.position.set(18, 10, -12);
  scene.add(cyan);

  const fgeo = new THREE.PlaneGeometry(140, 140, 1, 1);
  const fmat = new THREE.MeshStandardMaterial({color:0x080814, metalness:0.2, roughness:0.9});
  floor = new THREE.Mesh(fgeo, fmat);
  floor.rotation.x = -Math.PI/2;
  floor.position.y = 0;
  scene.add(floor);

  const grid = new THREE.GridHelper(140, 40, 0x00ffff, 0xff00ff);
  grid.material.opacity = 0.18;
  grid.material.transparent = true;
  grid.position.y = 0.01;
  scene.add(grid);

  const starGeo = new THREE.BufferGeometry();
  const n=2000;
  const p = new Float32Array(n*3);
  for(let i=0;i<n;i++){
    p[i*3+0]=(Math.random()-0.5)*1800;
    p[i*3+1]=Math.random()*520 + 10;
    p[i*3+2]=(Math.random()-0.5)*1800;
  }
  starGeo.setAttribute("position", new THREE.BufferAttribute(p,3));
  starfield = new THREE.Points(starGeo, new THREE.PointsMaterial({color:0x8f8fff, size:1.7, transparent:true, opacity:0.65}));
  scene.add(starfield);

  const arch = new THREE.TorusGeometry(20, 0.35, 10, 120, Math.PI);
  const archMat = new THREE.MeshBasicMaterial({color:0xff00ff, transparent:true, opacity:0.25});
  neon = new THREE.Mesh(arch, archMat);
  neon.rotation.x = Math.PI;
  neon.position.set(0, 10, -18);
  scene.add(neon);

  buildCabinets();
  animate();
}

function mkCabinet(name, accent, screenTexture, x, z){
  const g = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({color:0x111118, metalness:0.35, roughness:0.6});
  const trimMat = new THREE.MeshStandardMaterial({color:accent, metalness:0.7, roughness:0.25, emissive:accent, emissiveIntensity:0.25});

  const base = new THREE.Mesh(new THREE.BoxGeometry(3.0, 3.6, 3.0), bodyMat);
  base.position.y = 1.8;
  g.add(base);

  const head = new THREE.Mesh(new THREE.BoxGeometry(3.0, 2.4, 2.2), bodyMat);
  head.position.set(0, 4.3, -0.2);
  g.add(head);

  const bezel = new THREE.Mesh(new THREE.BoxGeometry(2.35, 1.55, 0.12), trimMat);
  bezel.position.set(0, 4.55, 0.92);
  bezel.rotation.x = -0.18;
  g.add(bezel);

  const screenMat = new THREE.MeshBasicMaterial({map: screenTexture, transparent:true, opacity:1});
  const screen = new THREE.Mesh(new THREE.PlaneGeometry(2.1, 1.25), screenMat);
  screen.position.set(0, 4.55, 0.99);
  screen.rotation.x = -0.18;
  g.add(screen);

  const marquee = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 0.45), new THREE.MeshBasicMaterial({color:accent, transparent:true, opacity:0.8}));
  marquee.position.set(0, 5.55, 0.87);
  marquee.rotation.x = -0.2;
  g.add(marquee);

  const panel = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.35, 1.1), bodyMat);
  panel.position.set(0, 3.35, 1.00);
  panel.rotation.x = -0.25;
  g.add(panel);

  const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.45,10), trimMat);
  stick.position.set(-0.6, 3.55, 1.35);
  g.add(stick);
  const knob = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), new THREE.MeshBasicMaterial({color:accent}));
  knob.position.set(-0.6, 3.82, 1.35);
  g.add(knob);

  for(let i=0;i<3;i++){
    const b = new THREE.Mesh(new THREE.CylinderGeometry(0.14,0.14,0.08,16), new THREE.MeshBasicMaterial({color:accent}));
    b.position.set(0.35+i*0.28, 3.55, 1.35);
    b.rotation.x = Math.PI/2;
    g.add(b);
  }

  const glow = new THREE.Mesh(new THREE.RingGeometry(1.1, 1.5, 48), new THREE.MeshBasicMaterial({color:accent, transparent:true, opacity:0.28, side:THREE.DoubleSide}));
  glow.rotation.x = -Math.PI/2;
  glow.position.y = 0.02;
  g.add(glow);

  g.userData = {name, accent, screen};
  g.position.set(x, 0, z);
  g.rotation.y = Math.PI;
  scene.add(g);

  return g;
}

function buildCabinets(){
  const defs = [
    {id:"COMBAT",    title:"Combat",              accent:0x00ffff,  sub:"Tank arena ‚Ä¢ ricochet shots"},
    {id:"YARS",      title:"Yars' Revenge",       accent:0xff00ff,  sub:"Nibble barrier ‚Ä¢ charge cannon"},
    {id:"ADVENTURE", title:"Adventure",           accent:0xffd700,  sub:"Rooms ‚Ä¢ dragon ‚Ä¢ key ‚Ä¢ chalice"},
    {id:"RAIDERS",   title:"Raiders (Lite)",      accent:0x54a8ff,  sub:"Temple loot ‚Ä¢ snakes ‚Ä¢ doors"},
    {id:"INVADERS",  title:"Space Invaders",      accent:0x00ff66,  sub:"3D lane invaders ‚Ä¢ shield"},
  ];

  const spacing = 7.0;
  const startX = -spacing*2;
  const z = -6.0;

  cabinets.length = 0;
  defs.forEach((d,i)=>{
    const scr = makeScreenTexture(d.title, d.sub, d.accent);
    const cab = mkCabinet(d.title, d.accent, scr.tex, startX + i*spacing, z);
    cab.userData.gameId = d.id;
    cab.userData.scr = scr;
    cabinets.push(cab);
  });

  document.getElementById("cabCount").textContent = cabinets.length;
}

function makeScreenTexture(title, sub, accent){
  const c = document.createElement("canvas");
  c.width = 256; c.height = 160;
  const ctx = c.getContext("2d");
  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;

  const demo = {
    t:0,
    dots: Array.from({length:26},()=>({ x:Math.random(), y:Math.random(), s:0.2+Math.random()*1.4 })),
    ping: 0
  };

  drawScreenFrame(ctx, c.width, c.height, title, sub, accent, demo, 0);
  tex.needsUpdate = true;

  return {canvas:c, ctx, tex, demo, title, sub, accent};
}

function drawScreenFrame(ctx, w, h, title, sub, accent, demo, dt){
  demo.t += dt;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "#050512";
  ctx.fillRect(0,0,w,h);

  ctx.globalAlpha = 0.85;
  for(const d of demo.dots){
    d.y += dt*(0.16 + d.s*0.08);
    if(d.y>1) { d.y=0; d.x=Math.random(); }
    ctx.fillStyle = "rgba(170,170,255,0.7)";
    ctx.fillRect(d.x*w, d.y*h, 2, 2);
  }
  ctx.globalAlpha = 1;

  const r = 18 + 6*Math.sin(demo.t*3.2);
  const cx = w*0.5, cy = h*0.62;
  ctx.strokeStyle = `rgba(${(accent>>16)&255},${(accent>>8)&255},${accent&255},0.55)`;
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(6, 6, w-12, 34);
  ctx.strokeStyle = `rgba(${(accent>>16)&255},${(accent>>8)&255},${accent&255},0.55)`;
  ctx.lineWidth = 2;
  ctx.strokeRect(6,6,w-12,34);

  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.font = "bold 16px Orbitron, monospace";
  ctx.fillText(title, 14, 28);

  ctx.fillStyle = "rgba(200,200,255,0.85)";
  ctx.font = "12px Orbitron, monospace";
  ctx.fillText(sub, 14, 48);

  const flick = 0.45 + 0.45*Math.sin(demo.t*6.0);
  ctx.fillStyle = `rgba(0,255,255,${0.20+flick*0.35})`;
  ctx.font = "bold 12px Orbitron, monospace";
  ctx.fillText("CLICK TO PLAY", 14, h-12);
}

function updateCabinetScreens(dt){
  for(const cab of cabinets){
    const s = cab.userData.scr;
    drawScreenFrame(s.ctx, s.canvas.width, s.canvas.height, s.title, s.sub, s.accent, s.demo, dt);
    s.tex.needsUpdate = true;
  }
}

function updateCamera(dt){
  orbitYaw   = lerp(orbitYaw, targetYaw, 0.10);
  orbitPitch = lerp(orbitPitch, targetPitch, 0.10);
  orbitDist  = lerp(orbitDist, targetDist, 0.10);

  const cx = Math.sin(orbitYaw)*orbitDist;
  const cz = Math.cos(orbitYaw)*orbitDist;
  const cy = 9 + orbitPitch*14;

  camera.position.set(cx, cy, cz);
  camera.lookAt(0, 5, -6);
}

let last3=performance.now();
function animate(){
  requestAnimationFrame(animate);
  const now=performance.now();
  const dt=Math.min((now-last3)/1000, 0.05);
  last3=now;

  starfield.rotation.y += dt*0.02;
  neon.material.opacity = 0.18 + Math.abs(Math.sin(now*0.0016))*0.22;

  updateCabinetScreens(dt);
  if(!inGame) updateCamera(dt);

  renderer.render(scene, camera);
}

/* ===========================
   Picking / Input for arcade
=========================== */
function setPointerFromEvent(e){
  const x = (e.clientX / innerWidth) * 2 - 1;
  const y = -(e.clientY / innerHeight) * 2 + 1;
  return new THREE.Vector2(x,y);
}
function pickCabinet(e){
  const m = setPointerFromEvent(e);
  raycaster.setFromCamera(m, camera);

  const screenMeshes = cabinets.map(c=>c.userData.screen);
  const hits = raycaster.intersectObjects(screenMeshes, true);
  if(!hits.length) return null;

  const hit = hits[0].object;
  const cab = cabinets.find(c => c.userData.screen === hit || c.userData.screen === hit.parent);
  return cab || null;
}

threeCanvas.addEventListener("pointerdown",(e)=>{
  if(inGame) return;
  dragging=true; lastX=e.clientX; lastY=e.clientY;
});
window.addEventListener("pointerup",(e)=>{
  if(inGame) return;
  if(!dragging) return;
  dragging=false;

  const dx = Math.abs(e.clientX-lastX);
  const dy = Math.abs(e.clientY-lastY);
  if(dx<6 && dy<6){
    const cab = pickCabinet(e);
    if(cab){
      blip("tap",0.14,1.2);
      toast(`‚ñ∂ ${cab.userData.name}`, "rgba(255,0,255,.22)");
      enterGame(cab.userData.gameId, cab.userData.name);
    }
  }
});
window.addEventListener("pointermove",(e)=>{
  if(inGame) return;
  if(!dragging) return;
  const dx = (e.clientX-lastX);
  const dy = (e.clientY-lastY);
  lastX=e.clientX; lastY=e.clientY;
  targetYaw   += dx * 0.006;
  targetPitch = clamp(targetPitch + dy*0.002, -0.10, 0.75);
});
threeCanvas.addEventListener("wheel",(e)=>{
  if(inGame) return;
  targetDist = clamp(targetDist + e.deltaY*0.01, 18, 60);
},{passive:true});

window.addEventListener("resize",()=>{
  if(!renderer || !camera) return;
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

/* ===========================
   Overlay + Game System (Three.js)
=========================== */
const overlay = document.getElementById("gameOverlay");
const gameCanvas = document.getElementById("gameCanvas");
const statusEl = document.getElementById("status");
const gameTitle = document.getElementById("gameTitle");
const gameSub = document.getElementById("gameSub");
const gameHelp = document.getElementById("gameHelp");
const gameScoreEl = document.getElementById("gameScore");
const gameBestEl = document.getElementById("gameBest");
const backBtn = document.getElementById("backBtn");

let inGame=false;
let currentGame=null;
let gameId=null;
let keys = {};
let pointer = {x:0,y:0,down:false};
let mobile = {left:false,right:false,act:false};
let best = JSON.parse(localStorage.getItem("SCIFIKIN_ATARI_BEST")||"{}");

// Three renderer for overlay
let gRenderer=null, gScene=null, gCamera=null;
let gClockLast=performance.now();
let gSize={w:900,h:640,dpr:1};

function setGameUI(title, sub, help){
  gameTitle.textContent = title;
  gameSub.textContent = sub;
  gameHelp.innerHTML = help;
}
function setScore(s){
  gameScoreEl.textContent = String(s|0);
  const b = best[gameId]||0;
  gameBestEl.textContent = String(b|0);
}
function commitBest(s){
  const b = best[gameId]||0;
  if(s>b){
    best[gameId]=s|0;
    localStorage.setItem("SCIFIKIN_ATARI_BEST", JSON.stringify(best));
    gameBestEl.textContent = String(best[gameId]);
    toast("NEW BEST! ‚ú®", "rgba(0,255,255,.25)");
    blip("tap",0.18,1.6);
  }
}

function resizeGameRenderer(){
  const rect = gameCanvas.getBoundingClientRect();
  const dpr = Math.min(devicePixelRatio||1, 2);
  gSize.w = Math.floor(rect.width*dpr);
  gSize.h = Math.floor(rect.height*dpr);
  gSize.dpr = dpr;

  gameCanvas.width = gSize.w;
  gameCanvas.height = gSize.h;

  if(gRenderer){
    gRenderer.setSize(gSize.w, gSize.h, false);
    gRenderer.setPixelRatio(1); // already baked into canvas size
  }
  if(gCamera && gCamera.isPerspectiveCamera){
    gCamera.aspect = gSize.w/gSize.h;
    gCamera.updateProjectionMatrix();
  }
}
window.addEventListener("resize", ()=> { if(inGame) resizeGameRenderer(); });

function ensureGameRenderer(){
  if(gRenderer) return;
  gRenderer = new THREE.WebGLRenderer({
    canvas: gameCanvas,
    antialias:true,
    alpha:true
  });
  gRenderer.setClearColor(0x050512, 1);
}

function clearGame3D(){
  if(!gScene) return;
  gScene.traverse(obj=>{
    if(obj.geometry) obj.geometry.dispose?.();
    if(obj.material){
      if(Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose?.());
      else obj.material.dispose?.();
    }
  });
  gScene = null;
  gCamera = null;
}

/* ---------- Input ---------- */
window.addEventListener("keydown",(e)=>{
  if(inGame){
    if(e.key==="Escape"){ exitGame(); return; }
    keys[e.key.toLowerCase()] = true;
    if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"," "].includes(e.key)) e.preventDefault();
    if(e.key===" ") { currentGame?.action?.(); blip("shoot",0.12,1.05); }
  }
});
window.addEventListener("keyup",(e)=>{
  if(inGame) keys[e.key.toLowerCase()] = false;
});

gameCanvas.addEventListener("pointerdown",(e)=>{
  if(!inGame) return;
  pointer.down=true;
  const r=gameCanvas.getBoundingClientRect();
  pointer.x=(e.clientX-r.left)/r.width;
  pointer.y=(e.clientY-r.top)/r.height;
  currentGame.pointerDown?.(pointer.x, pointer.y);
  blip("tap",0.10,1.15);
});
gameCanvas.addEventListener("pointermove",(e)=>{
  if(!inGame) return;
  const r=gameCanvas.getBoundingClientRect();
  pointer.x=(e.clientX-r.left)/r.width;
  pointer.y=(e.clientY-r.top)/r.height;
  currentGame.pointerMove?.(pointer.x, pointer.y);
});
window.addEventListener("pointerup",()=>{
  if(!inGame) return;
  pointer.down=false;
  currentGame.pointerUp?.();
});

// Mobile control buttons
function bindHold(btnId, prop){
  const b=document.getElementById(btnId);
  const down=()=>{ mobile[prop]=true; };
  const up=()=>{ mobile[prop]=false; };
  b.addEventListener("pointerdown",(e)=>{ e.preventDefault(); down(); });
  b.addEventListener("pointerup",(e)=>{ e.preventDefault(); up(); });
  b.addEventListener("pointercancel",(e)=>{ e.preventDefault(); up(); });
  b.addEventListener("pointerleave",(e)=>{ e.preventDefault(); up(); });
}
bindHold("mLeft","left");
bindHold("mRight","right");
document.getElementById("mAct").addEventListener("pointerdown",(e)=>{
  e.preventDefault();
  mobile.act=true;
  currentGame?.action?.();
  blip("shoot",0.12,1.05);
  setTimeout(()=>mobile.act=false, 80);
});

/* ===========================
   Particles Helper (GPU Points)
=========================== */
function ParticleSystem(max=800){
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(max*3);
  const col = new Float32Array(max*3);
  const life= new Float32Array(max);
  geo.setAttribute("position", new THREE.BufferAttribute(pos,3));
  geo.setAttribute("color", new THREE.BufferAttribute(col,3));

  const mat = new THREE.PointsMaterial({
    size: 0.18,
    vertexColors:true,
    transparent:true,
    opacity:0.9,
    depthWrite:false
  });
  const points = new THREE.Points(geo, mat);
  points.frustumCulled = false;

  const vel = Array.from({length:max},()=>new THREE.Vector3());
  let alive=0;

  function spawn(p, v, c, ttl){
    const i = alive % max;
    pos[i*3+0]=p.x; pos[i*3+1]=p.y; pos[i*3+2]=p.z;
    vel[i].copy(v);
    col[i*3+0]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
    life[i]=ttl;
    alive++;
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
  }

  function burst(center, count, speed, color, ttlMin=0.25, ttlMax=0.8){
    for(let k=0;k<count;k++){
      const dir = new THREE.Vector3((Math.random()-0.5),(Math.random()-0.25),(Math.random()-0.5)).normalize();
      const v = dir.multiplyScalar(speed*(0.5+Math.random()*0.8));
      const c = color.clone().multiplyScalar(0.7+Math.random()*0.6);
      spawn(center, v, c, ttlMin + Math.random()*(ttlMax-ttlMin));
    }
  }

  function update(dt){
    const n = Math.min(alive, max);
    for(let i=0;i<n;i++){
      if(life[i]<=0) continue;
      life[i]-=dt;
      pos[i*3+0]+=vel[i].x*dt;
      pos[i*3+1]+=vel[i].y*dt;
      pos[i*3+2]+=vel[i].z*dt;
      vel[i].multiplyScalar(0.985);
      if(life[i]<=0){
        // move far away
        pos[i*3+1]=-9999;
      }
    }
    geo.attributes.position.needsUpdate = true;
  }

  return { points, spawn, burst, update, dispose(){
    geo.dispose(); mat.dispose();
  }};
}

/* ===========================
   Game Factory
=========================== */
function makeGame(id){
  if(id==="COMBAT") return GameCombat();
  if(id==="YARS") return GameYars();
  if(id==="ADVENTURE") return GameAdventure();
  if(id==="RAIDERS") return GameRaiders();
  if(id==="INVADERS") return GameInvaders();
  return GameCombat();
}

/* ===========================
   Game Loop
=========================== */
function gameLoop(){
  if(!inGame) return;
  requestAnimationFrame(gameLoop);
  const now=performance.now();
  const dt=Math.min((now-gClockLast)/1000,0.05);
  gClockLast=now;

  currentGame.update(dt);
  currentGame.render();
}

/* ===========================
   Enter / Exit
=========================== */
function enterGame(id, name){
  inGame=true;
  gameId=id;
  overlay.classList.add("show");
  statusEl.textContent = `Playing: ${name} üïπÔ∏è`;

  keys = {};
  pointer = {x:0,y:0,down:false};
  mobile = {left:false,right:false,act:false};

  ensureGameRenderer();
  clearGame3D();
  resizeGameRenderer();

  currentGame = makeGame(id);
  currentGame.init();

  setScore(currentGame.score||0);
  gClockLast=performance.now();
  gameLoop();
}

function exitGame(){
  if(!inGame) return;
  inGame=false;
  overlay.classList.remove("show");
  statusEl.textContent = "Attract Mode ‚ú®";
  try{ currentGame?.dispose?.(); }catch(_){}
  currentGame = null;
  gameId = null;
  clearGame3D();
}

backBtn.onclick = ()=> { blip("tap",0.12,1.2); exitGame(); };

/* ===========================
   GAME 1: COMBAT (Tank Arena)
=========================== */
function GameCombat(){
  const S = {
    score:0, over:false,
    arena: {w:18, h:12},
    player:{pos:new THREE.Vector3(-5,0,0), vel:new THREE.Vector3(), ang:0, hp:3, cd:0},
    enemy:{pos:new THREE.Vector3(5,0,0),  vel:new THREE.Vector3(), ang:Math.PI, hp:3, cd:0},
    bullets:[],
    t:0
  };

  let particles, walls=[];
  let pTank, eTank, bulletGeo, bulletMat, bulletsGroup;

  function mkTank(color){
    const g = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(1.2, 0.5, 0.9),
      new THREE.MeshStandardMaterial({color, metalness:0.35, roughness:0.55, emissive:color, emissiveIntensity:0.12})
    );
    body.position.y = 0.25;
    g.add(body);

    const turret = new THREE.Mesh(
      new THREE.CylinderGeometry(0.28,0.28,0.25,16),
      new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.55, roughness:0.35, emissive:0x222222, emissiveIntensity:0.2})
    );
    turret.rotation.x = Math.PI/2;
    turret.position.set(0,0.45,0);
    g.add(turret);

    const barrel = new THREE.Mesh(
      new THREE.BoxGeometry(0.08,0.08,0.9),
      new THREE.MeshStandardMaterial({color:0xffffff, emissive:0x444444, emissiveIntensity:0.2})
    );
    barrel.position.set(0,0.45,0.55);
    g.add(barrel);

    const glow = new THREE.Mesh(
      new THREE.RingGeometry(0.7, 0.98, 48),
      new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.18, side:THREE.DoubleSide})
    );
    glow.rotation.x = -Math.PI/2;
    glow.position.y = 0.02;
    g.add(glow);

    return g;
  }

  function buildArena(){
    const root = new THREE.Group();
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(30, 20),
      new THREE.MeshStandardMaterial({color:0x07071a, roughness:0.95, metalness:0.05})
    );
    floor.rotation.x = -Math.PI/2;
    root.add(floor);

    const edgeMat = new THREE.MeshStandardMaterial({color:0x11112a, roughness:0.6, metalness:0.2, emissive:0x001122, emissiveIntensity:0.6});
    function wall(x,z,w,d){
      const m = new THREE.Mesh(new THREE.BoxGeometry(w,1.2,d), edgeMat);
      m.position.set(x,0.6,z);
      root.add(m);
      walls.push(m);
    }
    // bounds
    wall(0, -S.arena.h/2-0.6, S.arena.w+2.6, 1.2);
    wall(0,  S.arena.h/2+0.6, S.arena.w+2.6, 1.2);
    wall(-S.arena.w/2-0.6, 0, 1.2, S.arena.h+2.6);
    wall( S.arena.w/2+0.6, 0, 1.2, S.arena.h+2.6);

    // interior blocks (classic vibe)
    wall(0,0, 1.2, 4.8);
    wall(-3.2, 2.6, 3.6, 1.2);
    wall( 3.2,-2.6, 3.6, 1.2);

    return root;
  }

  function fire(from, isPlayer){
    const dir = new THREE.Vector3(Math.sin(from.ang),0,Math.cos(from.ang));
    const p = from.pos.clone().add(dir.clone().multiplyScalar(0.9));
    const v = dir.clone().multiplyScalar(11);
    S.bullets.push({pos:p, vel:v, life:2.5, owner:isPlayer?"p":"e"});
    from.cd = 0.28;
    blip("shoot",0.10, isPlayer?1.15:0.95);
    particles.burst(p.clone().add(new THREE.Vector3(0,0.4,0)), 18, 3.2, new THREE.Color(isPlayer?0x00ffff:0xff00ff), 0.15, 0.45);
  }

  function hitTank(tank, byPlayer){
    tank.hp -= 1;
    const c = new THREE.Color(byPlayer?0x00ffff:0xff00ff);
    particles.burst(tank.pos.clone().add(new THREE.Vector3(0,0.5,0)), 70, 6.0, c, 0.25, 0.95);
    blip("boom",0.18, byPlayer?1.15:0.9);

    if(tank.hp<=0){
      S.over = true;
      if(byPlayer) S.score += 250;
      commitBest(S.score);
      toast(byPlayer ? "YOU WIN! Space/Tap to restart" : "YOU LOSE! Space/Tap to restart", "rgba(255,0,255,.25)");
    }
  }

  function moveTank(tank, accel, turn, dt){
    tank.ang += turn*dt;
    const forward = new THREE.Vector3(Math.sin(tank.ang),0,Math.cos(tank.ang));
    tank.vel.add(forward.multiplyScalar(accel*dt));
    tank.vel.multiplyScalar(0.92);

    const next = tank.pos.clone().add(tank.vel.clone().multiplyScalar(dt));
    // simple collision vs walls AABB
    const r = 0.55;
    // bounds clamp
    next.x = clamp(next.x, -S.arena.w/2+0.7, S.arena.w/2-0.7);
    next.z = clamp(next.z, -S.arena.h/2+0.7, S.arena.h/2-0.7);

    // interior collision: push out of wall boxes
    for(const w of walls){
      // skip bounds? doesn't matter
      const hx = w.geometry.parameters.width/2;
      const hz = w.geometry.parameters.depth/2;
      const cx = w.position.x, cz = w.position.z;
      const dx = next.x - cx;
      const dz = next.z - cz;
      const px = hx + r - Math.abs(dx);
      const pz = hz + r - Math.abs(dz);
      if(px>0 && pz>0){
        if(px < pz) next.x = cx + Math.sign(dx)*(hx+r);
        else next.z = cz + Math.sign(dz)*(hz+r);
        tank.vel.multiplyScalar(0.6);
      }
    }

    tank.pos.copy(next);

    // exhaust particles
    if(Math.abs(accel)>0.2){
      const back = new THREE.Vector3(Math.sin(tank.ang),0,Math.cos(tank.ang)).multiplyScalar(-0.7);
      particles.burst(tank.pos.clone().add(back).add(new THREE.Vector3(0,0.25,0)), 2, 1.6, new THREE.Color(0xffffff), 0.10, 0.22);
    }
  }

  return {
    score:0,
    init(){
      S.score=0; S.over=false; S.t=0;
      S.player.pos.set(-5,0,0); S.player.vel.set(0,0,0); S.player.ang=0; S.player.hp=3; S.player.cd=0;
      S.enemy.pos.set(5,0,0);  S.enemy.vel.set(0,0,0);  S.enemy.ang=Math.PI; S.enemy.hp=3; S.enemy.cd=0;
      S.bullets.length=0;

      setGameUI(
        "Combat (2600 Remix)",
        "Tank duel ‚Ä¢ ricochet-ish shots ‚Ä¢ tiny physics",
        `Rotate <span class="kbd">‚Üê‚Üí</span>, Drive <span class="kbd">‚Üë‚Üì</span> ‚Ä¢ Fire <span class="kbd">Space</span> / Tap ‚Ä¢ Exit <span class="kbd">Esc</span>`
      );

      gScene = new THREE.Scene();
      gScene.fog = new THREE.FogExp2(0x050512, 0.06);

      gCamera = new THREE.PerspectiveCamera(65, gSize.w/gSize.h, 0.1, 200);
      gCamera.position.set(0, 16, 16);
      gCamera.lookAt(0,0,0);

      gScene.add(new THREE.AmbientLight(0x2a2255, 0.9));
      const d = new THREE.DirectionalLight(0xffffff, 1.1);
      d.position.set(8,18,10);
      gScene.add(d);
      const p = new THREE.PointLight(0x00ffff, 1.6, 60);
      p.position.set(-10,8,-6);
      gScene.add(p);
      const q = new THREE.PointLight(0xff00ff, 1.6, 60);
      q.position.set(10,8,6);
      gScene.add(q);

      walls = [];
      const arena = buildArena();
      gScene.add(arena);

      pTank = mkTank(0x00ffff);
      eTank = mkTank(0xff00ff);
      gScene.add(pTank);
      gScene.add(eTank);

      bulletsGroup = new THREE.Group();
      bulletGeo = new THREE.SphereGeometry(0.12, 10, 10);
      bulletMat = new THREE.MeshStandardMaterial({color:0xffffff, emissive:0xffffff, emissiveIntensity:0.6, roughness:0.2, metalness:0.1});
      gScene.add(bulletsGroup);

      particles = ParticleSystem(1200);
      gScene.add(particles.points);

      toast("COMBAT! Fir
