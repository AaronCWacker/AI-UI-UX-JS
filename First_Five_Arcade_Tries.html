<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=no"/>
  <title>ScifiKin ‚Äî Neon Arcade: Atari 2600 Remix (Three.js)</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#0c0a1e;
      --panel: rgba(0,0,0,.70);
      --line: rgba(255,255,255,.14);
      --cyan:#00ffff;
      --pink:#ff00ff;
      --gold:#ffd700;
    }
    html,body{height:100%;margin:0;overflow:hidden;background:var(--bg);font-family:'Orbitron',sans-serif;color:#eaeaff}
    #wrap{position:relative;width:100vw;height:100vh}
    canvas{display:block}
    .text-glow{text-shadow:0 0 6px #fff,0 0 14px var(--pink),0 0 22px var(--pink)}
    .btn-glow{box-shadow:0 0 7px var(--cyan),0 0 14px var(--cyan);transition:all .2s}
    .btn-glow:hover{box-shadow:0 0 10px var(--pink),0 0 22px var(--pink);transform:translateY(-1px)}
    .panel{background:var(--panel);border:2px solid var(--line);backdrop-filter:blur(10px);border-radius:12px}
    .tiny{font-size:12px;color:#c9c9ff}
    #hud{position:absolute;inset:0;pointer-events:none}
    #topbar{position:absolute;top:10px;left:10px;right:10px;display:flex;gap:10px;justify-content:space-between;align-items:flex-start}
    #hint{max-width:740px}
    #toast{position:absolute;left:50%;bottom:18px;transform:translateX(-50%);padding:10px 14px;border-radius:10px;font-weight:700;opacity:0;transition:opacity .35s,bottom .35s,transform .35s;pointer-events:none}
    #toast.show{opacity:1;bottom:34px;transform:translateX(-50%) scale(1.02)}
    #gameOverlay{position:absolute;inset:0;display:none;pointer-events:auto}
    #gameOverlay.show{display:block}
    #gameCanvasWrap{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter:blur(8px)}
    #gameCanvas{width:min(92vw,980px);height:min(80vh,700px);background:#0b0b18;border:3px solid rgba(255,255,255,.18);border-radius:14px;box-shadow:0 0 20px rgba(255,0,255,.35),0 0 26px rgba(0,255,255,.18)}
    #gameUI{position:absolute;top:12px;left:12px;right:12px;display:flex;gap:10px;justify-content:space-between;align-items:flex-start;pointer-events:none}
    #gameUI .panel{pointer-events:auto}
    .kbd{display:inline-block;padding:0 6px;border:1px solid rgba(255,255,255,.25);border-bottom-width:2px;border-radius:6px;background:rgba(0,0,0,.35);font-size:12px}
    #mobileControls{position:absolute;left:12px;right:12px;bottom:12px;display:none;gap:10px;justify-content:space-between;pointer-events:auto}
    #mobileControls button{flex:1;border-radius:12px;padding:12px 10px;font-weight:800}
    @media (max-width: 820px){ #mobileControls{display:flex} }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="three"></canvas>

  <div id="hud">
    <div id="topbar" class="pointer-events-none">
      <div class="panel p-3 pointer-events-auto" style="max-width:820px">
        <div class="text-2xl md:text-3xl font-bold text-glow">SCIFIKIN ‚Ä¢ NEON ARCADE (ATARI REMIX)</div>
        <div class="tiny mt-1">
          Click a cabinet screen to play. <span class="hidden md:inline">Rotate view: drag ‚Ä¢ Zoom: wheel/pinch</span>
          <span class="md:hidden">Drag to look ‚Ä¢ Pinch to zoom</span>
        </div>
        <div id="hint" class="tiny mt-2">
          In-game controls (most): Move <span class="kbd">WASD</span> / <span class="kbd">‚Üë‚Üì‚Üê‚Üí</span> ‚Ä¢ Action/Fire <span class="kbd">Space</span> ‚Ä¢ Exit <span class="kbd">Esc</span>.
          Combat: rotate <span class="kbd">‚Üê‚Üí</span>, drive <span class="kbd">‚Üë‚Üì</span>, fire <span class="kbd">Space</span>.
        </div>
      </div>

      <div class="panel p-3 pointer-events-auto text-right">
        <div class="tiny">Arcade Status</div>
        <div id="status" class="font-bold text-cyan-200">Attract Mode ‚ú®</div>
        <div class="tiny mt-1">Cabinets: <span id="cabCount">5</span></div>
      </div>
    </div>

    <div id="toast" class="panel"></div>
  </div>

  <div id="gameOverlay">
    <div id="gameCanvasWrap">
      <canvas id="gameCanvas"></canvas>
    </div>

    <div id="gameUI">
      <div class="panel p-3">
        <div id="gameTitle" class="text-xl font-bold text-glow">GAME</div>
        <div id="gameSub" class="tiny mt-1">‚Äî</div>
        <div id="gameHelp" class="tiny mt-2">‚Äî</div>
      </div>

      <div class="panel p-3 text-right">
        <div class="tiny">Score</div>
        <div id="gameScore" class="text-2xl font-bold text-yellow-300">0</div>
        <div class="tiny mt-2">Best</div>
        <div id="gameBest" class="font-bold text-cyan-200">0</div>
        <button id="backBtn" class="mt-3 bg-cyan-400 text-black font-extrabold py-2 px-3 rounded-lg btn-glow pointer-events-auto">Back to Arcade</button>
      </div>
    </div>

    <div id="mobileControls">
      <button id="mLeft"  class="bg-white/10 border border-white/20">‚¨ÖÔ∏è</button>
      <button id="mAct"   class="bg-fuchsia-500 text-black btn-glow">üî• / ‚úÖ</button>
      <button id="mRight" class="bg-white/10 border border-white/20">‚û°Ô∏è</button>
    </div>
  </div>
</div>

<script>
/* ===========================
   Tiny Audio (blips)
=========================== */
let audioCtx;
function ainit(){
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
}
function blip(type="tap", vol=0.12, pitch=1){
  ainit();
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = (type==="shoot") ? "square" : (type==="boom") ? "sawtooth" : "sine";
  o.frequency.setValueAtTime((type==="shoot"?720:type==="boom"?180:520)*pitch, t);
  g.gain.setValueAtTime(0.0001, t);
  g.gain.linearRampToValueAtTime(vol, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t + (type==="boom"?0.20:0.12));
  o.connect(g).connect(audioCtx.destination);
  o.start(t);
  o.stop(t + (type==="boom"?0.22:0.14));
}
document.addEventListener("pointerdown",()=>ainit(),{once:true});

/* ===========================
   Helpers
=========================== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const wrap = (v, m)=>((v%m)+m)%m;

const toastEl = document.getElementById("toast");
let toastT=0;
function toast(msg, glow="rgba(0,255,255,.16)"){
  toastEl.textContent = msg;
  toastEl.style.borderColor = "rgba(255,255,255,.18)";
  toastEl.style.boxShadow = `0 0 16px ${glow}`;
  toastEl.classList.add("show");
  toastT = performance.now();
  setTimeout(()=>{
    if(performance.now()-toastT>800) toastEl.classList.remove("show");
  }, 1300);
}

/* ===========================
   Three.js Arcade (5 cabinets)
=========================== */
const threeCanvas = document.getElementById("three");
let scene, camera, renderer, raycaster;
let starfield, floor, neon;
let cabinets=[];
let dragging=false, lastX=0,lastY=0;
let orbitYaw=0, orbitPitch=0.25, orbitDist=32;
let targetYaw=0, targetPitch=0.25, targetDist=32;

function initThree(){
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0c0a1e, 0.02);

  camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0, 14, 28);

  renderer = new THREE.WebGLRenderer({canvas: threeCanvas, antialias:true, alpha:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));

  raycaster = new THREE.Raycaster();

  scene.add(new THREE.AmbientLight(0x1a1438, 0.78));
  const key = new THREE.DirectionalLight(0xffffff, 1.05);
  key.position.set(18, 30, 20);
  scene.add(key);

  const rim = new THREE.PointLight(0xff00ff, 2.0, 100);
  rim.position.set(-18, 10, -12);
  scene.add(rim);

  const cyan = new THREE.PointLight(0x00ffff, 2.0, 100);
  cyan.position.set(18, 10, -12);
  scene.add(cyan);

  const fgeo = new THREE.PlaneGeometry(140, 140, 1, 1);
  const fmat = new THREE.MeshStandardMaterial({color:0x080814, metalness:0.2, roughness:0.9});
  floor = new THREE.Mesh(fgeo, fmat);
  floor.rotation.x = -Math.PI/2;
  floor.position.y = 0;
  scene.add(floor);

  const grid = new THREE.GridHelper(140, 40, 0x00ffff, 0xff00ff);
  grid.material.opacity = 0.18;
  grid.material.transparent = true;
  grid.position.y = 0.01;
  scene.add(grid);

  const starGeo = new THREE.BufferGeometry();
  const n=2000;
  const p = new Float32Array(n*3);
  for(let i=0;i<n;i++){
    p[i*3+0]=(Math.random()-0.5)*1800;
    p[i*3+1]=Math.random()*520 + 10;
    p[i*3+2]=(Math.random()-0.5)*1800;
  }
  starGeo.setAttribute("position", new THREE.BufferAttribute(p,3));
  starfield = new THREE.Points(starGeo, new THREE.PointsMaterial({color:0x8f8fff, size:1.7, transparent:true, opacity:0.65}));
  scene.add(starfield);

  const arch = new THREE.TorusGeometry(20, 0.35, 10, 120, Math.PI);
  const archMat = new THREE.MeshBasicMaterial({color:0xff00ff, transparent:true, opacity:0.25});
  neon = new THREE.Mesh(arch, archMat);
  neon.rotation.x = Math.PI;
  neon.position.set(0, 10, -18);
  scene.add(neon);

  buildCabinets();
  animate();
}

function mkCabinet(name, accent, screenTexture, x, z){
  const g = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({color:0x111118, metalness:0.35, roughness:0.6});
  const trimMat = new THREE.MeshStandardMaterial({color:accent, metalness:0.7, roughness:0.25, emissive:accent, emissiveIntensity:0.25});

  const base = new THREE.Mesh(new THREE.BoxGeometry(3.0, 3.6, 3.0), bodyMat);
  base.position.y = 1.8;
  g.add(base);

  const head = new THREE.Mesh(new THREE.BoxGeometry(3.0, 2.4, 2.2), bodyMat);
  head.position.set(0, 4.3, -0.2);
  g.add(head);

  const bezel = new THREE.Mesh(new THREE.BoxGeometry(2.35, 1.55, 0.12), trimMat);
  bezel.position.set(0, 4.55, 0.92);
  bezel.rotation.x = -0.18;
  g.add(bezel);

  const screenMat = new THREE.MeshBasicMaterial({map: screenTexture, transparent:true, opacity:1});
  const screen = new THREE.Mesh(new THREE.PlaneGeometry(2.1, 1.25), screenMat);
  screen.position.set(0, 4.55, 0.99);
  screen.rotation.x = -0.18;
  g.add(screen);

  const marquee = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 0.45), new THREE.MeshBasicMaterial({color:accent, transparent:true, opacity:0.8}));
  marquee.position.set(0, 5.55, 0.87);
  marquee.rotation.x = -0.2;
  g.add(marquee);

  const panel = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.35, 1.1), bodyMat);
  panel.position.set(0, 3.35, 1.00);
  panel.rotation.x = -0.25;
  g.add(panel);

  const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.45,10), trimMat);
  stick.position.set(-0.6, 3.55, 1.35);
  g.add(stick);
  const knob = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), new THREE.MeshBasicMaterial({color:accent}));
  knob.position.set(-0.6, 3.82, 1.35);
  g.add(knob);

  for(let i=0;i<3;i++){
    const b = new THREE.Mesh(new THREE.CylinderGeometry(0.14,0.14,0.08,16), new THREE.MeshBasicMaterial({color:accent}));
    b.position.set(0.35+i*0.28, 3.55, 1.35);
    b.rotation.x = Math.PI/2;
    g.add(b);
  }

  const glow = new THREE.Mesh(new THREE.RingGeometry(1.1, 1.5, 48), new THREE.MeshBasicMaterial({color:accent, transparent:true, opacity:0.28, side:THREE.DoubleSide}));
  glow.rotation.x = -Math.PI/2;
  glow.position.y = 0.02;
  g.add(glow);

  g.userData = {name, accent, screen};
  g.position.set(x, 0, z);
  g.rotation.y = Math.PI;
  scene.add(g);

  return g;
}

function buildCabinets(){
  const defs = [
    {id:"COMBAT",    title:"Combat",              accent:0x00ffff,  sub:"Tank arena ‚Ä¢ ricochet shots"},
    {id:"YARS",      title:"Yars' Revenge",       accent:0xff00ff,  sub:"Nibble barrier ‚Ä¢ charge cannon"},
    {id:"ADVENTURE", title:"Adventure",           accent:0xffd700,  sub:"Rooms ‚Ä¢ dragon ‚Ä¢ key ‚Ä¢ chalice"},
    {id:"RAIDERS",   title:"Raiders (Lite)",      accent:0x54a8ff,  sub:"Temple loot ‚Ä¢ snakes ‚Ä¢ doors"},
    {id:"INVADERS",  title:"Space Invaders",      accent:0x00ff66,  sub:"3D lane invaders ‚Ä¢ shield"},
  ];

  const spacing = 7.0;
  const startX = -spacing*2;
  const z = -6.0;

  cabinets.length = 0;
  defs.forEach((d,i)=>{
    const scr = makeScreenTexture(d.title, d.sub, d.accent);
    const cab = mkCabinet(d.title, d.accent, scr.tex, startX + i*spacing, z);
    cab.userData.gameId = d.id;
    cab.userData.scr = scr;
    cabinets.push(cab);
  });

  document.getElementById("cabCount").textContent = cabinets.length;
}

function makeScreenTexture(title, sub, accent){
  const c = document.createElement("canvas");
  c.width = 256; c.height = 160;
  const ctx = c.getContext("2d");
  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;

  const demo = {
    t:0,
    dots: Array.from({length:26},()=>({ x:Math.random(), y:Math.random(), s:0.2+Math.random()*1.4 })),
    ping: 0
  };

  drawScreenFrame(ctx, c.width, c.height, title, sub, accent, demo, 0);
  tex.needsUpdate = true;

  return {canvas:c, ctx, tex, demo, title, sub, accent};
}

function drawScreenFrame(ctx, w, h, title, sub, accent, demo, dt){
  demo.t += dt;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = "#050512";
  ctx.fillRect(0,0,w,h);

  ctx.globalAlpha = 0.85;
  for(const d of demo.dots){
    d.y += dt*(0.16 + d.s*0.08);
    if(d.y>1) { d.y=0; d.x=Math.random(); }
    ctx.fillStyle = "rgba(170,170,255,0.7)";
    ctx.fillRect(d.x*w, d.y*h, 2, 2);
  }
  ctx.globalAlpha = 1;

  const r = 18 + 6*Math.sin(demo.t*3.2);
  const cx = w*0.5, cy = h*0.62;
  ctx.strokeStyle = `rgba(${(accent>>16)&255},${(accent>>8)&255},${accent&255},0.55)`;
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(6, 6, w-12, 34);
  ctx.strokeStyle = `rgba(${(accent>>16)&255},${(accent>>8)&255},${accent&255},0.55)`;
  ctx.lineWidth = 2;
  ctx.strokeRect(6,6,w-12,34);

  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.font = "bold 16px Orbitron, monospace";
  ctx.fillText(title, 14, 28);

  ctx.fillStyle = "rgba(200,200,255,0.85)";
  ctx.font = "12px Orbitron, monospace";
  ctx.fillText(sub, 14, 48);

  const flick = 0.45 + 0.45*Math.sin(demo.t*6.0);
  ctx.fillStyle = `rgba(0,255,255,${0.20+flick*0.35})`;
  ctx.font = "bold 12px Orbitron, monospace";
  ctx.fillText("CLICK TO PLAY", 14, h-12);
}

function updateCabinetScreens(dt){
  for(const cab of cabinets){
    const s = cab.userData.scr;
    drawScreenFrame(s.ctx, s.canvas.width, s.canvas.height, s.title, s.sub, s.accent, s.demo, dt);
    s.tex.needsUpdate = true;
  }
}

function updateCamera(dt){
  orbitYaw   = lerp(orbitYaw, targetYaw, 0.10);
  orbitPitch = lerp(orbitPitch, targetPitch, 0.10);
  orbitDist  = lerp(orbitDist, targetDist, 0.10);

  const cx = Math.sin(orbitYaw)*orbitDist;
  const cz = Math.cos(orbitYaw)*orbitDist;
  const cy = 9 + orbitPitch*14;

  camera.position.set(cx, cy, cz);
  camera.lookAt(0, 5, -6);
}

let last3=performance.now();
function animate(){
  requestAnimationFrame(animate);
  const now=performance.now();
  const dt=Math.min((now-last3)/1000, 0.05);
  last3=now;

  starfield.rotation.y += dt*0.02;
  neon.material.opacity = 0.18 + Math.abs(Math.sin(now*0.0016))*0.22;

  updateCabinetScreens(dt);
  if(!inGame) updateCamera(dt);

  renderer.render(scene, camera);
}

/* ===========================
   Picking / Input for arcade
=========================== */
function setPointerFromEvent(e){
  const x = (e.clientX / innerWidth) * 2 - 1;
  const y = -(e.clientY / innerHeight) * 2 + 1;
  return new THREE.Vector2(x,y);
}
function pickCabinet(e){
  const m = setPointerFromEvent(e);
  raycaster.setFromCamera(m, camera);

  const screenMeshes = cabinets.map(c=>c.userData.screen);
  const hits = raycaster.intersectObjects(screenMeshes, true);
  if(!hits.length) return null;

  const hit = hits[0].object;
  const cab = cabinets.find(c => c.userData.screen === hit || c.userData.screen === hit.parent);
  return cab || null;
}

threeCanvas.addEventListener("pointerdown",(e)=>{
  if(inGame) return;
  dragging=true; lastX=e.clientX; lastY=e.clientY;
});
window.addEventListener("pointerup",(e)=>{
  if(inGame) return;
  if(!dragging) return;
  dragging=false;

  const dx = Math.abs(e.clientX-lastX);
  const dy = Math.abs(e.clientY-lastY);
  if(dx<6 && dy<6){
    const cab = pickCabinet(e);
    if(cab){
      blip("tap",0.14,1.2);
      toast(`‚ñ∂ ${cab.userData.name}`, "rgba(255,0,255,.22)");
      enterGame(cab.userData.gameId, cab.userData.name);
    }
  }
});
window.addEventListener("pointermove",(e)=>{
  if(inGame) return;
  if(!dragging) return;
  const dx = (e.clientX-lastX);
  const dy = (e.clientY-lastY);
  lastX=e.clientX; lastY=e.clientY;
  targetYaw   += dx * 0.006;
  targetPitch = clamp(targetPitch + dy*0.002, -0.10, 0.75);
});
threeCanvas.addEventListener("wheel",(e)=>{
  if(inGame) return;
  targetDist = clamp(targetDist + e.deltaY*0.01, 18, 60);
},{passive:true});

window.addEventListener("resize",()=>{
  if(!renderer || !camera) return;
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

/* ===========================
   Overlay + Game System (Three.js)
=========================== */
const overlay = document.getElementById("gameOverlay");
const gameCanvas = document.getElementById("gameCanvas");
const statusEl = document.getElementById("status");
const gameTitle = document.getElementById("gameTitle");
const gameSub = document.getElementById("gameSub");
const gameHelp = document.getElementById("gameHelp");
const gameScoreEl = document.getElementById("gameScore");
const gameBestEl = document.getElementById("gameBest");
const backBtn = document.getElementById("backBtn");

let inGame=false;
let currentGame=null;
let gameId=null;
let keys = {};
let pointer = {x:0,y:0,down:false};
let mobile = {left:false,right:false,act:false};
let best = JSON.parse(localStorage.getItem("SCIFIKIN_ATARI_BEST")||"{}");

// Three renderer for overlay
let gRenderer=null, gScene=null, gCamera=null;
let gClockLast=performance.now();
let gSize={w:900,h:640,dpr:1};

function setGameUI(title, sub, help){
  gameTitle.textContent = title;
  gameSub.textContent = sub;
  gameHelp.innerHTML = help;
}
function setScore(s){
  gameScoreEl.textContent = String(s|0);
  const b = best[gameId]||0;
  gameBestEl.textContent = String(b|0);
}
function commitBest(s){
  const b = best[gameId]||0;
  if(s>b){
    best[gameId]=s|0;
    localStorage.setItem("SCIFIKIN_ATARI_BEST", JSON.stringify(best));
    gameBestEl.textContent = String(best[gameId]);
    toast("NEW BEST! ‚ú®", "rgba(0,255,255,.25)");
    blip("tap",0.18,1.6);
  }
}

function resizeGameRenderer(){
  const rect = gameCanvas.getBoundingClientRect();
  const dpr = Math.min(devicePixelRatio||1, 2);
  gSize.w = Math.floor(rect.width*dpr);
  gSize.h = Math.floor(rect.height*dpr);
  gSize.dpr = dpr;

  gameCanvas.width = gSize.w;
  gameCanvas.height = gSize.h;

  if(gRenderer){
    gRenderer.setSize(gSize.w, gSize.h, false);
    gRenderer.setPixelRatio(1); // already baked into canvas size
  }
  if(gCamera && gCamera.isPerspectiveCamera){
    gCamera.aspect = gSize.w/gSize.h;
    gCamera.updateProjectionMatrix();
  }
}
window.addEventListener("resize", ()=> { if(inGame) resizeGameRenderer(); });

function ensureGameRenderer(){
  if(gRenderer) return;
  gRenderer = new THREE.WebGLRenderer({
    canvas: gameCanvas,
    antialias:true,
    alpha:true
  });
  gRenderer.setClearColor(0x050512, 1);
}

function clearGame3D(){
  if(!gScene) return;
  gScene.traverse(obj=>{
    if(obj.geometry) obj.geometry.dispose?.();
    if(obj.material){
      if(Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose?.());
      else obj.material.dispose?.();
    }
  });
  gScene = null;
  gCamera = null;
}

/* ---------- Input ---------- */
window.addEventListener("keydown",(e)=>{
  if(inGame){
    if(e.key==="Escape"){ exitGame(); return; }
    keys[e.key.toLowerCase()] = true;
    if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"," "].includes(e.key)) e.preventDefault();
    if(e.key===" ") { currentGame?.action?.(); blip("shoot",0.12,1.05); }
  }
});
window.addEventListener("keyup",(e)=>{
  if(inGame) keys[e.key.toLowerCase()] = false;
});

gameCanvas.addEventListener("pointerdown",(e)=>{
  if(!inGame) return;
  pointer.down=true;
  const r=gameCanvas.getBoundingClientRect();
  pointer.x=(e.clientX-r.left)/r.width;
  pointer.y=(e.clientY-r.top)/r.height;
  currentGame.pointerDown?.(pointer.x, pointer.y);
  blip("tap",0.10,1.15);
});
gameCanvas.addEventListener("pointermove",(e)=>{
  if(!inGame) return;
  const r=gameCanvas.getBoundingClientRect();
  pointer.x=(e.clientX-r.left)/r.width;
  pointer.y=(e.clientY-r.top)/r.height;
  currentGame.pointerMove?.(pointer.x, pointer.y);
});
window.addEventListener("pointerup",()=>{
  if(!inGame) return;
  pointer.down=false;
  currentGame.pointerUp?.();
});

// Mobile control buttons
function bindHold(btnId, prop){
  const b=document.getElementById(btnId);
  const down=()=>{ mobile[prop]=true; };
  const up=()=>{ mobile[prop]=false; };
  b.addEventListener("pointerdown",(e)=>{ e.preventDefault(); down(); });
  b.addEventListener("pointerup",(e)=>{ e.preventDefault(); up(); });
  b.addEventListener("pointercancel",(e)=>{ e.preventDefault(); up(); });
  b.addEventListener("pointerleave",(e)=>{ e.preventDefault(); up(); });
}
bindHold("mLeft","left");
bindHold("mRight","right");
document.getElementById("mAct").addEventListener("pointerdown",(e)=>{
  e.preventDefault();
  mobile.act=true;
  currentGame?.action?.();
  blip("shoot",0.12,1.05);
  setTimeout(()=>mobile.act=false, 80);
});

/* ===========================
   Particles Helper (GPU Points)
=========================== */
function ParticleSystem(max=800){
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(max*3);
  const col = new Float32Array(max*3);
  const life= new Float32Array(max);
  geo.setAttribute("position", new THREE.BufferAttribute(pos,3));
  geo.setAttribute("color", new THREE.BufferAttribute(col,3));

  const mat = new THREE.PointsMaterial({
    size: 0.18,
    vertexColors:true,
    transparent:true,
    opacity:0.9,
    depthWrite:false
  });
  const points = new THREE.Points(geo, mat);
  points.frustumCulled = false;

  const vel = Array.from({length:max},()=>new THREE.Vector3());
  let alive=0;

  function spawn(p, v, c, ttl){
    const i = alive % max;
    pos[i*3+0]=p.x; pos[i*3+1]=p.y; pos[i*3+2]=p.z;
    vel[i].copy(v);
    col[i*3+0]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
    life[i]=ttl;
    alive++;
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate = true;
  }

  function burst(center, count, speed, color, ttlMin=0.25, ttlMax=0.8){
    for(let k=0;k<count;k++){
      const dir = new THREE.Vector3((Math.random()-0.5),(Math.random()-0.25),(Math.random()-0.5)).normalize();
      const v = dir.multiplyScalar(speed*(0.5+Math.random()*0.8));
      const c = color.clone().multiplyScalar(0.7+Math.random()*0.6);
      spawn(center, v, c, ttlMin + Math.random()*(ttlMax-ttlMin));
    }
  }

  function update(dt){
    const n = Math.min(alive, max);
    for(let i=0;i<n;i++){
      if(life[i]<=0) continue;
      life[i]-=dt;
      pos[i*3+0]+=vel[i].x*dt;
      pos[i*3+1]+=vel[i].y*dt;
      pos[i*3+2]+=vel[i].z*dt;
      vel[i].multiplyScalar(0.985);
      if(life[i]<=0){
        // move far away
        pos[i*3+1]=-9999;
      }
    }
    geo.attributes.position.needsUpdate = true;
  }

  return { points, spawn, burst, update, dispose(){
    geo.dispose(); mat.dispose();
  }};
}

/* ===========================
   Game Factory
=========================== */
function makeGame(id){
  if(id==="COMBAT") return GameCombat();
  if(id==="YARS") return GameYars();
  if(id==="ADVENTURE") return GameAdventure();
  if(id==="RAIDERS") return GameRaiders();
  if(id==="INVADERS") return GameInvaders();
  return GameCombat();
}

/* ===========================
   Game Loop
=========================== */
function gameLoop(){
  if(!inGame) return;
  requestAnimationFrame(gameLoop);
  const now=performance.now();
  const dt=Math.min((now-gClockLast)/1000,0.05);
  gClockLast=now;

  currentGame.update(dt);
  currentGame.render();
}

/* ===========================
   Enter / Exit
=========================== */
function enterGame(id, name){
  inGame=true;
  gameId=id;
  overlay.classList.add("show");
  statusEl.textContent = `Playing: ${name} üïπÔ∏è`;

  keys = {};
  pointer = {x:0,y:0,down:false};
  mobile = {left:false,right:false,act:false};

  ensureGameRenderer();
  clearGame3D();
  resizeGameRenderer();

  currentGame = makeGame(id);
  currentGame.init();

  setScore(currentGame.score||0);
  gClockLast=performance.now();
  gameLoop();
}

function exitGame(){
  if(!inGame) return;
  inGame=false;
  overlay.classList.remove("show");
  statusEl.textContent = "Attract Mode ‚ú®";
  try{ currentGame?.dispose?.(); }catch(_){}
  currentGame = null;
  gameId = null;
  clearGame3D();
}

backBtn.onclick = ()=> { blip("tap",0.12,1.2); exitGame(); };

/* ===========================
   GAME 1: COMBAT (Tank Arena)
=========================== */
function GameCombat(){
  const S = {
    score:0, over:false,
    arena: {w:18, h:12},
    player:{pos:new THREE.Vector3(-5,0,0), vel:new THREE.Vector3(), ang:0, hp:3, cd:0},
    enemy:{pos:new THREE.Vector3(5,0,0),  vel:new THREE.Vector3(), ang:Math.PI, hp:3, cd:0},
    bullets:[],
    t:0
  };

  let particles, walls=[];
  let pTank, eTank, bulletGeo, bulletMat, bulletsGroup;

  function mkTank(color){
    const g = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(1.2, 0.5, 0.9),
      new THREE.MeshStandardMaterial({color, metalness:0.35, roughness:0.55, emissive:color, emissiveIntensity:0.12})
    );
    body.position.y = 0.25;
    g.add(body);

    const turret = new THREE.Mesh(
      new THREE.CylinderGeometry(0.28,0.28,0.25,16),
      new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.55, roughness:0.35, emissive:0x222222, emissiveIntensity:0.2})
    );
    turret.rotation.x = Math.PI/2;
    turret.position.set(0,0.45,0);
    g.add(turret);

    const barrel = new THREE.Mesh(
      new THREE.BoxGeometry(0.08,0.08,0.9),
      new THREE.MeshStandardMaterial({color:0xffffff, emissive:0x444444, emissiveIntensity:0.2})
    );
    barrel.position.set(0,0.45,0.55);
    g.add(barrel);

    const glow = new THREE.Mesh(
      new THREE.RingGeometry(0.7, 0.98, 48),
      new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.18, side:THREE.DoubleSide})
    );
    glow.rotation.x = -Math.PI/2;
    glow.position.y = 0.02;
    g.add(glow);

    return g;
  }

  function buildArena(){
    const root = new THREE.Group();
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(30, 20),
      new THREE.MeshStandardMaterial({color:0x07071a, roughness:0.95, metalness:0.05})
    );
    floor.rotation.x = -Math.PI/2;
    root.add(floor);

    const edgeMat = new THREE.MeshStandardMaterial({color:0x11112a, roughness:0.6, metalness:0.2, emissive:0x001122, emissiveIntensity:0.6});
    function wall(x,z,w,d){
      const m = new THREE.Mesh(new THREE.BoxGeometry(w,1.2,d), edgeMat);
      m.position.set(x,0.6,z);
      root.add(m);
      walls.push(m);
    }
    // bounds
    wall(0, -S.arena.h/2-0.6, S.arena.w+2.6, 1.2);
    wall(0,  S.arena.h/2+0.6, S.arena.w+2.6, 1.2);
    wall(-S.arena.w/2-0.6, 0, 1.2, S.arena.h+2.6);
    wall( S.arena.w/2+0.6, 0, 1.2, S.arena.h+2.6);

    // interior blocks (classic vibe)
    wall(0,0, 1.2, 4.8);
    wall(-3.2, 2.6, 3.6, 1.2);
    wall( 3.2,-2.6, 3.6, 1.2);

    return root;
  }

  function fire(from, isPlayer){
    const dir = new THREE.Vector3(Math.sin(from.ang),0,Math.cos(from.ang));
    const p = from.pos.clone().add(dir.clone().multiplyScalar(0.9));
    const v = dir.clone().multiplyScalar(11);
    S.bullets.push({pos:p, vel:v, life:2.5, owner:isPlayer?"p":"e"});
    from.cd = 0.28;
    blip("shoot",0.10, isPlayer?1.15:0.95);
    particles.burst(p.clone().add(new THREE.Vector3(0,0.4,0)), 18, 3.2, new THREE.Color(isPlayer?0x00ffff:0xff00ff), 0.15, 0.45);
  }

  function hitTank(tank, byPlayer){
    tank.hp -= 1;
    const c = new THREE.Color(byPlayer?0x00ffff:0xff00ff);
    particles.burst(tank.pos.clone().add(new THREE.Vector3(0,0.5,0)), 70, 6.0, c, 0.25, 0.95);
    blip("boom",0.18, byPlayer?1.15:0.9);

    if(tank.hp<=0){
      S.over = true;
      if(byPlayer) S.score += 250;
      commitBest(S.score);
      toast(byPlayer ? "YOU WIN! Space/Tap to restart" : "YOU LOSE! Space/Tap to restart", "rgba(255,0,255,.25)");
    }
  }

  function moveTank(tank, accel, turn, dt){
    tank.ang += turn*dt;
    const forward = new THREE.Vector3(Math.sin(tank.ang),0,Math.cos(tank.ang));
    tank.vel.add(forward.multiplyScalar(accel*dt));
    tank.vel.multiplyScalar(0.92);

    const next = tank.pos.clone().add(tank.vel.clone().multiplyScalar(dt));
    // simple collision vs walls AABB
    const r = 0.55;
    // bounds clamp
    next.x = clamp(next.x, -S.arena.w/2+0.7, S.arena.w/2-0.7);
    next.z = clamp(next.z, -S.arena.h/2+0.7, S.arena.h/2-0.7);

    // interior collision: push out of wall boxes
    for(const w of walls){
      // skip bounds? doesn't matter
      const hx = w.geometry.parameters.width/2;
      const hz = w.geometry.parameters.depth/2;
      const cx = w.position.x, cz = w.position.z;
      const dx = next.x - cx;
      const dz = next.z - cz;
      const px = hx + r - Math.abs(dx);
      const pz = hz + r - Math.abs(dz);
      if(px>0 && pz>0){
        if(px < pz) next.x = cx + Math.sign(dx)*(hx+r);
        else next.z = cz + Math.sign(dz)*(hz+r);
        tank.vel.multiplyScalar(0.6);
      }
    }

    tank.pos.copy(next);

    // exhaust particles
    if(Math.abs(accel)>0.2){
      const back = new THREE.Vector3(Math.sin(tank.ang),0,Math.cos(tank.ang)).multiplyScalar(-0.7);
      particles.burst(tank.pos.clone().add(back).add(new THREE.Vector3(0,0.25,0)), 2, 1.6, new THREE.Color(0xffffff), 0.10, 0.22);
    }
  }

  return {
    score:0,
    init(){
      S.score=0; S.over=false; S.t=0;
      S.player.pos.set(-5,0,0); S.player.vel.set(0,0,0); S.player.ang=0; S.player.hp=3; S.player.cd=0;
      S.enemy.pos.set(5,0,0);  S.enemy.vel.set(0,0,0);  S.enemy.ang=Math.PI; S.enemy.hp=3; S.enemy.cd=0;
      S.bullets.length=0;

      setGameUI(
        "Combat (2600 Remix)",
        "Tank duel ‚Ä¢ ricochet-ish shots ‚Ä¢ tiny physics",
        `Rotate <span class="kbd">‚Üê‚Üí</span>, Drive <span class="kbd">‚Üë‚Üì</span> ‚Ä¢ Fire <span class="kbd">Space</span> / Tap ‚Ä¢ Exit <span class="kbd">Esc</span>`
      );

      gScene = new THREE.Scene();
      gScene.fog = new THREE.FogExp2(0x050512, 0.06);

      gCamera = new THREE.PerspectiveCamera(65, gSize.w/gSize.h, 0.1, 200);
      gCamera.position.set(0, 16, 16);
      gCamera.lookAt(0,0,0);

      gScene.add(new THREE.AmbientLight(0x2a2255, 0.9));
      const d = new THREE.DirectionalLight(0xffffff, 1.1);
      d.position.set(8,18,10);
      gScene.add(d);
      const p = new THREE.PointLight(0x00ffff, 1.6, 60);
      p.position.set(-10,8,-6);
      gScene.add(p);
      const q = new THREE.PointLight(0xff00ff, 1.6, 60);
      q.position.set(10,8,6);
      gScene.add(q);

      walls = [];
      const arena = buildArena();
      gScene.add(arena);

      pTank = mkTank(0x00ffff);
      eTank = mkTank(0xff00ff);
      gScene.add(pTank);
      gScene.add(eTank);

      bulletsGroup = new THREE.Group();
      bulletGeo = new THREE.SphereGeometry(0.12, 10, 10);
      bulletMat = new THREE.MeshStandardMaterial({color:0xffffff, emissive:0xffffff, emissiveIntensity:0.6, roughness:0.2, metalness:0.1});
      gScene.add(bulletsGroup);

      particles = ParticleSystem(1200);
      gScene.add(particles.points);

      toast("COMBAT! First to 3 hits wins üí•", "rgba(0,255,255,.25)");
    },
    action(){
      if(S.over){ this.init(); return; }
      if(S.player.cd<=0) fire(S.player, true);
    },
    pointerDown(){
      this.action();
    },
    update(dt){
      S.t += dt;
      if(S.over){
        if((keys[" "]||keys["space"]) || mobile.act) this.init();
        return;
      }

      // player
      const turn = (keys["arrowright"]||mobile.right) ? -2.6 : (keys["arrowleft"]||mobile.left) ? 2.6 : 0;
      const accel = (keys["arrowup"]||keys["w"]) ? 12 : (keys["arrowdown"]||keys["s"]) ? -9 : 0;

      S.player.cd = Math.max(0, S.player.cd - dt);
      moveTank(S.player, accel, turn, dt);

      // enemy AI: face player + drive + fire
      S.enemy.cd = Math.max(0, S.enemy.cd - dt);
      const toP = S.player.pos.clone().sub(S.enemy.pos);
      const desired = Math.atan2(toP.x, toP.z);
      let da = desired - S.enemy.ang;
      while(da>Math.PI) da-=Math.PI*2;
      while(da<-Math.PI) da+=Math.PI*2;
      const eTurn = clamp(da, -1.8, 1.8) * 2.2;
      const eAccel = (toP.length()<3.0) ? -7 : 8;
      moveTank(S.enemy, eAccel, eTurn, dt);

      // enemy fire when roughly aligned
      if(S.enemy.cd<=0 && Math.abs(da)<0.25 && toP.length()<11){
        fire(S.enemy, false);
      }

      // bullets update
      for(let i=S.bullets.length-1;i>=0;i--){
        const b = S.bullets[i];
        b.life -= dt;
        if(b.life<=0){ S.bullets.splice(i,1); continue; }

        const next = b.pos.clone().add(b.vel.clone().multiplyScalar(dt));

        // bounce off bounds
        const minX=-S.arena.w/2+0.6, maxX=S.arena.w/2-0.6;
        const minZ=-S.arena.h/2+0.6, maxZ=S.arena.h/2-0.6;
        if(next.x<minX||next.x>maxX){ b.vel.x*=-1; blip("tap",0.06,1.35); }
        if(next.z<minZ||next.z>maxZ){ b.vel.z*=-1; blip("tap",0.06,1.35); }

        // bounce off interior walls
        let bounced=false;
        for(const w of walls){
          const hx = w.geometry.parameters.width/2;
          const hz = w.geometry.parameters.depth/2;
          const cx = w.position.x, cz = w.position.z;
          const dx = next.x - cx;
          const dz = next.z - cz;
          if(Math.abs(dx)<hx+0.18 && Math.abs(dz)<hz+0.18){
            if((hx - Math.abs(dx)) < (hz - Math.abs(dz))) b.vel.x*=-1;
            else b.vel.z*=-1;
            bounced=true;
            break;
          }
        }
        if(bounced){
          particles.burst(b.pos.clone().add(new THREE.Vector3(0,0.35,0)), 14, 2.8, new THREE.Color(0xffffff), 0.12, 0.30);
          blip("tap",0.07,1.55);
        }

        b.pos.add(b.vel.clone().multiplyScalar(dt));

        // hit tanks
        const hitP = b.owner!=="p" && b.pos.distanceTo(S.player.pos) < 0.62;
        const hitE = b.owner!=="e" && b.pos.distanceTo(S.enemy.pos) < 0.62;
        if(hitP){ S.bullets.splice(i,1); hitTank(S.player,false); }
        else if(hitE){ S.bullets.splice(i,1); S.score += 25; hitTank(S.enemy,true); }
      }

      // visuals
      pTank.position.copy(S.player.pos); pTank.rotation.y = S.player.ang;
      eTank.position.copy(S.enemy.pos);  eTank.rotation.y = S.enemy.ang;

      // bullet meshes
      bulletsGroup.clear();
      for(const b of S.bullets){
        const m = new THREE.Mesh(bulletGeo, bulletMat);
        m.position.copy(b.pos).add(new THREE.Vector3(0,0.35,0));
        bulletsGroup.add(m);
      }

      particles.update(dt);

      S.score += dt*2; // tiny survival drip
      this.score = S.score|0;
      setScore(this.score);
    },
    render(){
      // camera: gentle follow
      const center = S.player.pos.clone().lerp(S.enemy.pos,0.5);
      const camR = 16;
      gCamera.position.set(center.x + Math.sin(S.t*0.35)*2.0, 16, center.z + camR);
      gCamera.lookAt(center.x,0,center.z);
      gRenderer.render(gScene, gCamera);
    },
    dispose(){
      particles?.dispose?.();
    }
  };
}

/* ===========================
   GAME 2: YARS' REVENGE (lite)
=========================== */
function GameYars(){
  const S = {
    score:0, over:false, t:0,
    yar:{pos:new THREE.Vector3(-6,1.8,0), vel:new THREE.Vector3(), charge:0},
    enemy:{pos:new THREE.Vector3(7,1.8,0), vy:0.0, hp:6, cd:0},
    barrier:[], // blocks
    shots:[],   // cannon shots
    enemyShots:[]
  };
  let particles, yarMesh, enemyMesh, groupBarrier, groupShots, groupEnemyShots;

  function build(){
    gScene = new THREE.Scene();
    gScene.fog = new THREE.FogExp2(0x050512, 0.08);

    gCamera = new THREE.PerspectiveCamera(70, gSize.w/gSize.h, 0.1, 120);
    gCamera.position.set(0, 8.5, 17);
    gCamera.lookAt(0,1.5,0);

    gScene.add(new THREE.AmbientLight(0x2a2255, 0.95));
    const d = new THREE.DirectionalLight(0xffffff, 1.0);
    d.position.set(6,14,10);
    gScene.add(d);
    const a = new THREE.PointLight(0xff00ff, 1.3, 60); a.position.set(8,6,0); gScene.add(a);
    const b = new THREE.PointLight(0x00ffff, 1.1, 60); b.position.set(-10,6,0); gScene.add(b);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(30, 14),
      new THREE.MeshStandardMaterial({color:0x07071a, roughness:0.95})
    );
    floor.rotation.x = -Math.PI/2;
    gScene.add(floor);

    // left/right ‚Äúlanes‚Äù line glow
    const lineMat = new THREE.MeshBasicMaterial({color:0x00ffff, transparent:true, opacity:0.12});
    const line = new THREE.Mesh(new THREE.PlaneGeometry(30,0.08), lineMat);
    line.rotation.x = -Math.PI/2;
    line.position.y = 0.02;
    line.position.z = 0;
    gScene.add(line);

    yarMesh = new THREE.Mesh(
      new THREE.IcosahedronGeometry(0.45, 1),
      new THREE.MeshStandardMaterial({color:0x00ffff, emissive:0x00ffff, emissiveIntensity:0.35, roughness:0.25, metalness:0.15})
    );
    yarMesh.position.copy(S.yar.pos);
    gScene.add(yarMesh);

    enemyMesh = new THREE.Mesh(
      new THREE.BoxGeometry(0.9,0.9,0.9),
      new THREE.MeshStandardMaterial({color:0xff00ff, emissive:0xff00ff, emissiveIntensity:0.25, roughness:0.35})
    );
    enemyMesh.position.copy(S.enemy.pos);
    gScene.add(enemyMesh);

    groupBarrier = new THREE.Group(); gScene.add(groupBarrier);
    groupShots = new THREE.Group(); gScene.add(groupShots);
    groupEnemyShots = new THREE.Group(); gScene.add(groupEnemyShots);

    // barrier blocks (classic center-ish)
    S.barrier.length=0;
    for(let x=-1; x<=2; x++){
      for(let y=0; y<6; y++){
        const p = new THREE.Vector3(-1.0 + x*0.6, 0.7 + y*0.45, 0);
        S.barrier.push({pos:p, alive:true});
      }
    }

    particles = ParticleSystem(1400);
    gScene.add(particles.points);
  }

  function reset(){
    S.score=0; S.over=false; S.t=0;
    S.yar.pos.set(-6,1.8,0); S.yar.vel.set(0,0,0); S.yar.charge=0;
    S.enemy.pos.set(7,1.8,0); S.enemy.vy=1.6; S.enemy.hp=6; S.enemy.cd=0;
    S.shots.length=0; S.enemyShots.length=0;
    build();
  }

  function fireCannon(){
    if(S.over) return;
    if(S.yar.charge<1) return;
    S.yar.charge = 0;
    S.shots.push({pos:S.yar.pos.clone().add(new THREE.Vector3(0,0,0)), vel:new THREE.Vector3(18,0,0), life:1.2});
    blip("shoot",0.12,1.25);
    particles.burst(S.yar.pos.clone(), 40, 5.0, new THREE.Color(0xffffff), 0.18, 0.6);
  }

  return {
    score:0,
    init(){
      setGameUI(
        "Yars' Revenge (Lite)",
        "Eat barrier ‚Ä¢ charge cannon ‚Ä¢ hit the Qotile",
        `Move <span class="kbd">WASD</span>/<span class="kbd">‚Üë‚Üì‚Üê‚Üí</span> ‚Ä¢ Cannon <span class="kbd">Space</span>/Tap (needs charge) ‚Ä¢ Exit <span class="kbd">Esc</span>`
      );
      reset();
      toast("NIBBLE THE BARRIER ‚Üí CHARGE ‚Üí FIRE ‚ö°", "rgba(255,0,255,.22)");
    },
    action(){
      if(S.over){ this.init(); return; }
      fireCannon();
    },
    pointerDown(){ this.action(); },
    update(dt){
      S.t += dt;
      if(S.over){
        if((keys[" "]||keys["space"]) || mobile.act) this.init();
        return;
      }

      // movement
      const ax = (keys["d"]||keys["arrowright"]||mobile.right) ? 1 : (keys["a"]||keys["arrowleft"]||mobile.left) ? -1 : 0;
      const ay = (keys["w"]||keys["arrowup"]) ? 1 : (keys["s"]||keys["arrowdown"]) ? -1 : 0;

      const acc = new THREE.Vector3(ax*20, ay*20, 0);
      S.yar.vel.add(acc.multiplyScalar(dt));
      S.yar.vel.multiplyScalar(0.88);

      S.yar.pos.add(S.yar.vel.clone().multiplyScalar(dt));
      S.yar.pos.x = clamp(S.yar.pos.x, -11, 9);
      S.yar.pos.y = clamp(S.yar.pos.y, 0.8, 4.6);

      // eat barrier to charge
      for(const b of S.barrier){
        if(!b.alive) continue;
        if(b.pos.distanceTo(S.yar.pos) < 0.55){
          b.alive=false;
          S.yar.charge = clamp(S.yar.charge + 0.18, 0, 1);
          S.score += 10;
          blip("tap",0.08,1.55);
          particles.burst(b.pos.clone(), 14, 2.4, new THREE.Color(0x00ffff), 0.12, 0.35);
        }
      }

      // enemy motion + fire
      S.enemy.pos.y += S.enemy.vy*dt;
      if(S.enemy.pos.y>4.6){ S.enemy.pos.y=4.6; S.enemy.vy*=-1; }
      if(S.enemy.pos.y<0.9){ S.enemy.pos.y=0.9; S.enemy.vy*=-1; }
      S.enemy.cd = Math.max(0, S.enemy.cd-dt);
      if(S.enemy.cd<=0 && Math.random()<0.9){
        S.enemy.cd = 0.55;
        const v = new THREE.Vector3(-10.5 + Math.random()*-2.0, (Math.random()-0.5)*2.0, 0);
        S.enemyShots.push({pos:S.enemy.pos.clone(), vel:v, life:2.0});
        blip("shoot",0.08,0.95);
      }

      // fire cannon by key (also mobile act)
      if((keys[" "]||keys["space"]) || mobile.act) fireCannon();

      // shots
      for(let i=S.shots.length-1;i>=0;i--){
        const s=S.shots[i];
        s.life-=dt;
        s.pos.add(s.vel.clone().multiplyScalar(dt));
        particles.burst(s.pos.clone(), 1, 0.7, new THREE.Color(0xffffff), 0.08, 0.12);
        if(s.life<=0 || s.pos.x>12) S.shots.splice(i,1);
        else{
          if(s.pos.distanceTo(S.enemy.pos)<0.75){
            S.shots.splice(i,1);
            S.enemy.hp -= 1;
            S.score += 120;
            particles.burst(S.enemy.pos.clone(), 90, 7.5, new THREE.Color(0xff00ff), 0.25, 1.0);
            blip("boom",0.18,1.1);
            if(S.enemy.hp<=0){
              S.over=true;
              commitBest(S.score);
              toast("QOTILE DOWN! Space/Tap to restart", "rgba(0,255,255,.25)");
            }
          }
        }
      }

      // enemy shots
      for(let i=S.enemyShots.length-1;i>=0;i--){
        const s=S.enemyShots[i];
        s.life-=dt;
        s.pos.add(s.vel.clone().multiplyScalar(dt));
        if(s.life<=0 || s.pos.x<-12) S.enemyShots.splice(i,1);
        else{
          if(s.pos.distanceTo(S.yar.pos)<0.6){
            S.enemyShots.splice(i,1);
            particles.burst(S.yar.pos.clone(), 70, 7.0, new THREE.Color(0xffffff), 0.25, 0.9);
            blip("boom",0.16,0.9);
            S.over=true;
            commitBest(S.score);
            toast("YAR HIT! Space/Tap to restart", "rgba(255,0,255,.25)");
          }
        }
      }

      // visuals
      yarMesh.position.copy(S.yar.pos);
      yarMesh.rotation.y += dt*2.8;
      const c = 0.15 + S.yar.charge*0.65;
      yarMesh.material.emissiveIntensity = c;

      enemyMesh.position.copy(S.enemy.pos);
      enemyMesh.rotation.x += dt*1.1;
      enemyMesh.rotation.y += dt*1.5;

      // barrier meshes
      groupBarrier.clear();
      const bm = new THREE.MeshStandardMaterial({color:0xffffff, emissive:0x00ffff, emissiveIntensity:0.12, roughness:0.6});
      for(const b of S.barrier){
        if(!b.alive) continue;
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.45,0.3,0.45), bm);
        m.position.copy(b.pos);
        groupBarrier.add(m);
      }

      // shots meshes
      groupShots.clear();
      const sm = new THREE.MeshStandardMaterial({color:0xffffff, emissive:0xffffff, emissiveIntensity:0.9});
      for(const s of S.shots){
        const m = new THREE.Mesh(new THREE.SphereGeometry(0.14, 10, 10), sm);
        m.position.copy(s.pos);
        groupShots.add(m);
      }
      groupEnemyShots.clear();
      const em = new THREE.MeshStandardMaterial({color:0xff00ff, emissive:0xff00ff, emissiveIntensity:0.8});
      for(const s of S.enemyShots){
        const m = new THREE.Mesh(new THREE.SphereGeometry(0.12, 10, 10), em);
        m.position.copy(s.pos);
        groupEnemyShots.add(m);
      }

      particles.update(dt);
      this.score = S.score|0;
      setScore(this.score);
    },
    render(){
      // subtle camera sway
      gCamera.position.x = Math.sin(S.t*0.25)*0.6;
      gCamera.lookAt(0,1.6,0);
      gRenderer.render(gScene, gCamera);
    },
    dispose(){ particles?.dispose?.(); }
  };
}

/* ===========================
   GAME 3: ADVENTURE (lite)
=========================== */
function GameAdventure(){
  const S = {
    score:0, over:false, t:0,
    room:0,
    hero:{pos:new THREE.Vector3(0,0,0), vel:new THREE.Vector3(), hp:3, hasKey:false, hasChalice:false, sword:false},
    dragon:{pos:new THREE.Vector3(4,0,4), hp:3},
    keyPos:new THREE.Vector3(-4,0,4),
    chalicePos:new THREE.Vector3(0,0,-4),
    gatePos:new THREE.Vector3(0,0,6),
    gateOpen:false,
    rooms:[]
  };

  let particles, heroMesh, dragonMesh, keyMesh, chaliceMesh, gateMesh, swordMesh;
  let world = new THREE.Group();

  function mkWall(x,z,w,d,h=1.4, col=0x11112a, e=0x003344){
    const m = new THREE.Mesh(
      new THREE.BoxGeometry(w,h,d),
      new THREE.MeshStandardMaterial({color:col, roughness:0.75, metalness:0.15, emissive:e, emissiveIntensity:0.25})
    );
    m.position.set(x,h/2,z);
    world.add(m);
    return m;
  }

  function buildRooms(){
    world.clear();
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(22, 22),
      new THREE.MeshStandardMaterial({color:0x07071a, roughness:0.95})
    );
    floor.rotation.x=-Math.PI/2;
    world.add(floor);

    // outer bounds
    mkWall(0,-10.7, 22, 1.2);
    mkWall(0, 10.7, 22, 1.2);
    mkWall(-10.7,0, 1.2, 22);
    mkWall( 10.7,0, 1.2, 22);

    // inner maze partitions (simple)
    mkWall(-5, 0, 1.2, 14);
    mkWall( 5, 0, 1.2, 14);
    mkWall( 0,-3, 10, 1.2);
    mkWall( 0, 4, 10, 1.2);

    // ‚Äúdoor gaps‚Äù
    // (we just leave gaps by not placing walls there)
  }

  function collideCircle(pos, r){
    // brute: check all wall meshes in world (box)
    for(const obj of world.children){
      if(!obj.isMesh) continue;
      if(obj.geometry.type!=="BoxGeometry") continue;
      const w = obj.geometry.parameters.width/2;
      const d = obj.geometry.parameters.depth/2;
      const cx = obj.position.x;
      const cz = obj.position.z;
      const dx = pos.x - cx;
      const dz = pos.z - cz;
      const px = w + r - Math.abs(dx);
      const pz = d + r - Math.abs(dz);
      if(px>0 && pz>0){
        if(px<pz) pos.x = cx + Math.sign(dx)*(w+r);
        else pos.z = cz + Math.sign(dz)*(d+r);
      }
    }
  }

  function reset(){
    S.score=0; S.over=false; S.t=0;
    S.hero.pos.set(0,0,0); S.hero.vel.set(0,0,0); S.hero.hp=3; S.hero.hasKey=false; S.hero.hasChalice=false; S.hero.sword=false;
    S.gateOpen=false;
    S.dragon.pos.set(6,0,-6); S.dragon.hp=3;
    S.keyPos.set(-7,0,7);
    S.chalicePos.set(7,0,7);
    S.gatePos.set(0,0,10.2);

    gScene = new THREE.Scene();
    gScene.fog = new THREE.FogExp2(0x050512, 0.08);
    gScene.add(new THREE.AmbientLight(0x2a2255, 0.95));
    const d = new THREE.DirectionalLight(0xffffff, 1.05);
    d.position.set(8,16,10);
    gScene.add(d);
    const p = new THREE.PointLight(0xffd700, 1.2, 70); p.position.set(0,6,0); gScene.add(p);

    gCamera = new THREE.PerspectiveCamera(70, gSize.w/gSize.h, 0.1, 160);
    gCamera.position.set(0, 14, 14);
    gCamera.lookAt(0,0,0);

    world = new THREE.Group();
    buildRooms();
    gScene.add(world);

    // hero (classic square -> neon cube)
    heroMesh = new THREE.Mesh(
      new THREE.BoxGeometry(0.8,0.8,0.8),
      new THREE.MeshStandardMaterial({color:0xffffaa, emissive:0xffffaa, emissiveIntensity:0.18, roughness:0.55})
    );
    heroMesh.position.set(0,0.4,0);
    gScene.add(heroMesh);

    dragonMesh = new THREE.Mesh(
      new THREE.TorusKnotGeometry(0.55,0.18, 80, 12),
      new THREE.MeshStandardMaterial({color:0xff00ff, emissive:0xff00ff, emissiveIntensity:0.22, roughness:0.35})
    );
    dragonMesh.position.copy(S.dragon.pos).add(new THREE.Vector3(0,0.6,0));
    gScene.add(dragonMesh);

    keyMesh = new THREE.Mesh(
      new THREE.TorusGeometry(0.25,0.08, 10, 18),
      new THREE.MeshStandardMaterial({color:0x00ffff, emissive:0x00ffff, emissiveIntensity:0.35, roughness:0.25})
    );
    keyMesh.position.copy(S.keyPos).add(new THREE.Vector3(0,0.35,0));
    gScene.add(keyMesh);

    chaliceMesh = new THREE.Mesh(
      new THREE.ConeGeometry(0.34,0.7, 16),
      new THREE.MeshStandardMaterial({color:0xffd700, emissive:0xffd700, emissiveIntensity:0.25, roughness:0.35})
    );
    chaliceMesh.position.copy(S.chalicePos).add(new THREE.Vector3(0,0.45,0));
    gScene.add(chaliceMesh);

    gateMesh = new THREE.Mesh(
      new THREE.BoxGeometry(2.4,1.4,0.4),
      new THREE.MeshStandardMaterial({color:0x54a8ff, emissive:0x003366, emissiveIntensity:0.6, roughness:0.5})
    );
    gateMesh.position.copy(S.gatePos).add(new THREE.Vector3(0,0.7,0));
    gScene.add(gateMesh);

    swordMesh = new THREE.Mesh(
      new THREE.BoxGeometry(0.1,0.1,1.2),
      new THREE.MeshStandardMaterial({color:0xffffff, emissive:0xffffff, emissiveIntensity:0.25})
    );
    swordMesh.position.set(0,0.7,0.8);
    swordMesh.visible = false;
    heroMesh.add(swordMesh);

    particles = ParticleSystem(1600);
    gScene.add(particles.points);
  }

  function useSword(){
    if(S.over) return;
    S.hero.sword = true;
    swordMesh.visible = true;
    swordMesh.rotation.y = 0;
    // quick slash particle
    particles.burst(S.hero.pos.clone().add(new THREE.Vector3(0,0.6,0)), 28, 4.5, new THREE.Color(0xffffff), 0.10, 0.35);
    blip("shoot",0.10,1.2);

    // hit dragon if close
    if(S.hero.pos.distanceTo(S.dragon.pos) < 1.6){
      S.dragon.hp -= 1;
      S.score += 120;
      particles.burst(S.dragon.pos.clone().add(new THREE.Vector3(0,0.6,0)), 90, 7.0, new THREE.Color(0xff00ff), 0.20, 1.0);
      blip("boom",0.14,1.05);
      if(S.dragon.hp<=0){
        S.score += 250;
        toast("DRAGON DOWN! üêâ", "rgba(255,0,255,.25)");
      }
    }
  }

  return {
    score:0,
    init(){
      setGameUI(
        "Adventure (Lite)",
        "Get key ‚Ä¢ open gate ‚Ä¢ grab chalice ‚Ä¢ avoid dragon",
        `Move <span class="kbd">WASD</span>/<span class="kbd">‚Üë‚Üì‚Üê‚Üí</span> ‚Ä¢ Sword <span class="kbd">Space</span>/Tap ‚Ä¢ Exit <span class="kbd">Esc</span>`
      );
      reset();
      toast("FIND THE CHALICE üèÜ (AND DON'T GET CHOMPED)", "rgba(255,215,0,.22)");
    },
    action(){
      if(S.over){ this.init(); return; }
      useSword();
    },
    pointerDown(){ this.action(); },
    update(dt){
      S.t += dt;
      if(S.over){
        if((keys[" "]||keys["space"]) || mobile.act) this.init();
        return;
      }

      const ax = (keys["d"]||keys["arrowright"]||mobile.right) ? 1 : (keys["a"]||keys["arrowleft"]||mobile.left) ? -1 : 0;
      const az = (keys["s"]||keys["arrowdown"]) ? 1 : (keys["w"]||keys["arrowup"]) ? -1 : 0;

      const accel = new THREE.Vector3(ax*14,0,az*14);
      S.hero.vel.add(accel.multiplyScalar(dt));
      S.hero.vel.multiplyScalar(0.84);
      S.hero.pos.add(S.hero.vel.clone().multiplyScalar(dt));
      collideCircle(S.hero.pos, 0.45);

      // sword timeout
      if(S.hero.sword){
        swordMesh.rotation.y += dt*12;
        if(swordMesh.rotation.y > Math.PI*1.2){
          S.hero.sword=false;
          swordMesh.visible=false;
        }
      }

      if((keys[" "]||keys["space"]) || mobile.act) useSword();

      // pick up key
      if(!S.hero.hasKey && S.hero.pos.distanceTo(S.keyPos)<0.9){
        S.hero.hasKey=true;
        keyMesh.visible=false;
        S.score += 150;
        blip("tap",0.12,1.45);
        toast("KEY GET! üîë", "rgba(0,255,255,.25)");
      }

      // open gate (needs key)
      if(!S.gateOpen && S.hero.hasKey && S.hero.pos.distanceTo(S.gatePos)<1.2){
        S.gateOpen=true;
        gateMesh.visible=false;
        S.score += 120;
        blip("tap",0.12,1.2);
        particles.burst(S.gatePos.clone().add(new THREE.Vector3(0,0.8,0)), 60, 6.0, new THREE.Color(0x54a8ff), 0.18, 0.8);
        toast("GATE OPEN! üö™", "rgba(84,168,255,.22)");
      }

      // grab chalice (win condition)
      if(!S.hero.hasChalice && (S.gateOpen || S.hero.hasKey) && S.hero.pos.distanceTo(S.chalicePos)<0.95){
        S.hero.hasChalice=true;
        chaliceMesh.visible=false;
        S.score += 500;
        S.over=true;
        commitBest(S.score);
        particles.burst(S.hero.pos.clone().add(new THREE.Vector3(0,0.8,0)), 160, 8.0, new THREE.Color(0xffd700), 0.25, 1.2);
        blip("boom",0.20,1.15);
        toast("YOU FOUND THE CHALICE! Space/Tap to restart", "rgba(255,215,0,.25)");
      }

      // dragon chase if alive
      if(S.dragon.hp>0){
        const toH = S.hero.pos.clone().sub(S.dragon.pos);
        const d = toH.length();
        const v = toH.normalize().multiplyScalar( (d>0.01 ? 3.4 : 0) );
        S.dragon.pos.add(v.multiplyScalar(dt));
        collideCircle(S.dragon.pos, 0.55);

        if(d<1.0){
          // bite
          S.hero.hp -= 1;
          particles.burst(S.hero.pos.clone().add(new THREE.Vector3(0,0.7,0)), 90, 7.0, new THREE.Color(0xffffff), 0.2, 0.9);
          blip("boom",0.14,0.9);
          S.hero.pos.add(toH.normalize().multiplyScalar(1.4));
          if(S.hero.hp<=0){
            S.over=true;
            commitBest(S.score);
            toast("DRAGON GOT YOU! Space/Tap to restart", "rgba(255,0,255,.25)");
          }
        }
      }

      // visuals
      heroMesh.position.copy(S.hero.pos).add(new THREE.Vector3(0,0.4,0));
      if(ax!==0||az!==0) heroMesh.rotation.y = Math.atan2(ax, -az);

      dragonMesh.position.copy(S.dragon.pos).add(new THREE.Vector3(0,0.6,0));
      dragonMesh.rotation.y += dt*1.5;

      keyMesh.rotation.x += dt*2.0;
      keyMesh.rotation.y += dt*2.6;
      chaliceMesh.rotation.y += dt*2.0;

      particles.update(dt);

      S.score += dt*3;
      this.score = S.score|0;
      setScore(this.score);
    },
    render(){
      // follow camera
      const target = S.hero.pos.clone();
      gCamera.position.lerp(new THREE.Vector3(target.x, 14, target.z+14), 0.12);
      gCamera.lookAt(target.x, 0, target.z);
      gRenderer.render(gScene, gCamera);
    },
    dispose(){ particles?.dispose?.(); }
  };
}

/* ===========================
   GAME 4: RAIDERS (Lite)
=========================== */
function GameRaiders(){
  const S = {
    score:0, over:false, t:0,
    hero:{pos:new THREE.Vector3(-6,0,6), vel:new THREE.Vector3(), hp:3, keys:0},
    idol:{pos:new THREE.Vector3(6,0,-6), got:false},
    doors:[ {pos:new THREE.Vector3(0,0,1.5), open:false} ],
    snakes:[],
    dustTimer:0
  };
  let particles, heroMesh, idolMesh, doorMesh, world;

  function reset(){
    S.score=0; S.over=false; S.t=0;
    S.hero.pos.set(-6,0,6); S.hero.vel.set(0,0,0); S.hero.hp=3; S.hero.keys=0;
    S.idol.pos.set(6,0,-6); S.idol.got=false;
    S.doors[0].open=false;
    S.snakes = Array.from({length:5},(_,i)=>({pos:new THREE.Vector3(-1+i*1.8,0,-2+Math.random()*6), vel:new THREE.Vector3((Math.random()-0.5)*2,0,(Math.random()-0.5)*2)}));
    S.dustTimer=0;

    gScene = new THREE.Scene();
    gScene.fog = new THREE.FogExp2(0x050512, 0.085);

    gCamera = new THREE.PerspectiveCamera(70, gSize.w/gSize.h, 0.1, 180);
    gCamera.position.set(0, 15, 15);
    gCamera.lookAt(0,0,0);

    gScene.add(new THREE.AmbientLight(0x2a2255, 0.95));
    const d = new THREE.DirectionalLight(0xffffff, 1.0);
    d.position.set(9,18,10);
    gScene.add(d);
    const p = new THREE.PointLight(0xffd700, 1.1, 80); p.position.set(0,8,0); gScene.add(p);

    world = new THREE.Group();
    gScene.add(world);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(26, 26),
      new THREE.MeshStandardMaterial({color:0x07071a, roughness:0.95})
    );
    floor.rotation.x=-Math.PI/2;
    world.add(floor);

    const wallMat = new THREE.MeshStandardMaterial({color:0x14142b, roughness:0.8, metalness:0.15, emissive:0x220a00, emissiveIntensity:0.22});
    function wall(x,z,w,d,h=1.4){
      const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
      m.position.set(x,h/2,z);
      world.add(m);
      return m;
    }
    // bounds
    wall(0,-12.7, 26, 1.2);
    wall(0, 12.7, 26, 1.2);
    wall(-12.7,0, 1.2, 26);
    wall( 12.7,0, 1.2, 26);

    // temple corridors
    wall(0, 0, 1.2, 18);
    wall(-5, -3, 10, 1.2);
    wall( 5,  4, 10, 1.2);

    // door
    doorMesh = new THREE.Mesh(
      new THREE.BoxGeometry(2.2,1.4,0.4),
      new THREE.MeshStandardMaterial({color:0x54a8ff, emissive:0x003366, emissiveIntensity:0.7, roughness:0.45})
    );
    doorMesh.position.copy(S.doors[0].pos).add(new THREE.Vector3(0,0.7,0));
    gScene.add(doorMesh);

    heroMesh = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.35,0.6, 8, 12),
      new THREE.MeshStandardMaterial({color:0xffffff, emissive:0x222222, emissiveIntensity:0.25, roughness:0.55})
    );
    heroMesh.position.set(S.hero.pos.x,0.65,S.hero.pos.z);
    gScene.add(heroMesh);

    idolMesh = new THREE.Mesh(
      new THREE.DodecahedronGeometry(0.6, 0),
      new THREE.MeshStandardMaterial({color:0xffd700, emissive:0xffd700, emissiveIntensity:0.25, roughness:0.35})
    );
    idolMesh.position.set(S.idol.pos.x,0.85,S.idol.pos.z);
    gScene.add(idolMesh);

    particles = ParticleSystem(1700);
    gScene.add(particles.points);
  }

  function collideWorld(pos, r){
    // simple bounds only (keep it fun)
    pos.x = clamp(pos.x, -11.2, 11.2);
    pos.z = clamp(pos.z, -11.2, 11.2);

    // door collider if closed
    if(!S.doors[0].open){
      const dp = S.doors[0].pos;
      if(Math.abs(pos.x-dp.x)<1.4+r && Math.abs(pos.z-dp.z)<0.35+r){
        // push away in z
        pos.z = dp.z + Math.sign(pos.z-dp.z)*(0.35+r);
      }
    }
  }

  function useKey(){
    if(S.over) return;
    if(S.hero.keys<=0) return;
    const dp = S.doors[0].pos;
    if(!S.doors[0].open && S.hero.pos.distanceTo(dp)<1.8){
      S.hero.keys -= 1;
      S.doors[0].open = true;
      doorMesh.visible = false;
      S.score += 200;
      blip("tap",0.12,1.25);
      particles.burst(dp.clone().add(new THREE.Vector3(0,0.8,0)), 90, 7.0, new THREE.Color(0x54a8ff), 0.22, 1.0);
      toast("DOOR UNLOCKED üîì", "rgba(84,168,255,.22)");
    }
  }

  return {
    score:0,
    init(){
      setGameUI(
        "Raiders (Lite)",
        "Explore ‚Ä¢ find keys ‚Ä¢ unlock door ‚Ä¢ grab idol ‚Ä¢ avoid snakes",
        `Move <span class="kbd">WASD</span>/<span class="kbd">‚Üë‚Üì‚Üê‚Üí</span> ‚Ä¢ Use Key <span class="kbd">Space</span>/Tap ‚Ä¢ Exit <span class="kbd">Esc</span>`
      );
      reset();
      toast("TEMPLE RUN üè∫ (SPACE = USE KEY)", "rgba(84,168,255,.22)");
    },
    action(){
      if(S.over){ this.init(); return; }
      useKey();
    },
    pointerDown(){ this.action(); },
    update(dt){
      S.t += dt;
      if(S.over){
        if((keys[" "]||keys["space"]) || mobile.act) this.init();
        return;
      }

      const ax = (keys["d"]||keys["arrowright"]||mobile.right) ? 1 : (keys["a"]||keys["arrowleft"]||mobile.left) ? -1 : 0;
      const az = (keys["s"]||keys["arrowdown"]) ? 1 : (keys["w"]||keys["arrowup"]) ? -1 : 0;

      const accel = new THREE.Vector3(ax*14,0,az*14);
      S.hero.vel.add(accel.multiplyScalar(dt));
      S.hero.vel.multiplyScalar(0.84);
      S.hero.pos.add(S.hero.vel.clone().multiplyScalar(dt));
      collideWorld(S.hero.pos, 0.45);

      if((keys[" "]||keys["space"]) || mobile.act) useKey();

      // dust trail
      S.dustTimer -= dt;
      if((ax!==0||az!==0) && S.dustTimer<=0){
        S.dustTimer = 0.05;
        particles.burst(S.hero.pos.clone().add(new THREE.Vector3(0,0.2,0)), 2, 1.2, new THREE.Color(0xffffff), 0.10, 0.22);
      }

      // keys: spawn as glowing orbs periodically (simple)
      if(Math.random()<0.18*dt && S.hero.keys<2){
        // drop a key-orb somewhere near center
        const kp = new THREE.Vector3((Math.random()-0.5)*8,0,(Math.random()-0.5)*8);
        // if hero close, award
        if(S.hero.pos.distanceTo(kp)<2.2){
          S.hero.keys += 1;
          S.score += 120;
          blip("tap",0.10,1.45);
          particles.burst(kp.clone().add(new THREE.Vector3(0,0.6,0)), 60, 6.0, new THREE.Color(0x00ffff), 0.18, 0.9);
          toast("FOUND A KEY üîë", "rgba(0,255,255,.22)");
        }
      }

      // idol
      idolMesh.visible = !S.idol.got;
      idolMesh.rotation.y += dt*1.5;
      if(!S.idol.got && S.hero.pos.distanceTo(S.idol.pos)<1.1){
        S.idol.got = true;
        S.score += 600;
        particles.burst(S.idol.pos.clone().add(new THREE.Vector3(0,0.8,0)), 180, 8.5, new THREE.Color(0xffd700), 0.25, 1.25);
        blip("boom",0.20,1.2);
        toast("YOU GOT THE IDOL! Space/Tap to restart", "rgba(255,215,0,.25)");
        S.over = true;
        commitBest(S.score);
      }

      // snakes: drift + bite
      for(const sn of S.snakes){
        sn.pos.add(sn.vel.clone().multiplyScalar(dt));
        if(sn.pos.x<-11||sn.pos.x>11) sn.vel.x*=-1;
        if(sn.pos.z<-11||sn.pos.z>11) sn.vel.z*=-1;

        const d = sn.pos.distanceTo(S.hero.pos);
        if(d<3.2){
          // aggro
          const to = S.hero.pos.clone().sub(sn.pos).normalize();
          sn.vel.lerp(to.multiplyScalar(3.2), dt*2.0);
        }else{
          // wander
          sn.vel.lerp(new THREE.Vector3((Math.random()-0.5)*2.0,0,(Math.random()-0.5)*2.0), dt*0.3);
        }

        if(d<0.85){
          S.hero.hp -= 1;
          particles.burst(S.hero.pos.clone().add(new THREE.Vector3(0,0.7,0)), 90, 7.0, new THREE.Color(0xff00ff), 0.2, 1.0);
          blip("boom",0.14,0.9);
          S.hero.pos.add(S.hero.pos.clone().sub(sn.pos).normalize().multiplyScalar(1.6));
          if(S.hero.hp<=0){
            S.over = true;
            commitBest(S.score);
            toast("SNAKES GOT YOU! Space/Tap to restart", "rgba(255,0,255,.25)");
          }
        }
      }

      // render snake meshes (cheap): reuse group
      // (for simplicity, rebuild each tick)
      // create / reuse a group stored on scene
      if(!gScene.userData.snakeGroup){
        gScene.userData.snakeGroup = new THREE.Group();
        gScene.add(gScene.userData.snakeGroup);
      }
      const sg = gScene.userData.snakeGroup;
      sg.clear();
      const sm = new THREE.MeshStandardMaterial({color:0xff00ff, emissive:0xff00ff, emissiveIntensity:0.18, roughness:0.5});
      for(const sn of S.snakes){
        const m = new THREE.Mesh(new THREE.TorusGeometry(0.35,0.12, 10, 16), sm);
        m.position.set(sn.pos.x,0.55,sn.pos.z);
        m.rotation.y = Math.atan2(sn.vel.x, sn.vel.z);
        sg.add(m);
      }

      heroMesh.position.set(S.hero.pos.x,0.65,S.hero.pos.z);
      if(ax!==0||az!==0) heroMesh.rotation.y = Math.atan2(ax, -az);

      particles.update(dt);

      S.score += dt*4;
      this.score = S.score|0;
      setScore(this.score);
    },
    render(){
      gCamera.position.lerp(new THREE.Vector3(S.hero.pos.x, 15, S.hero.pos.z+15), 0.12);
      gCamera.lookAt(S.hero.pos.x, 0, S.hero.pos.z);
      gRenderer.render(gScene, gCamera);
    },
    dispose(){ particles?.dispose?.(); }
  };
}

/* ===========================
   GAME 5: SPACE INVADERS (bonus)
=========================== */
function GameInvaders(){
  const S = {
    score:0, over:false, t:0,
    player:{x:0, cd:0, hp:3},
    shots:[],
    inv:[],
    bombs:[],
    dir:1,
    stepT:0
  };
  let particles, playerMesh, groupInv, groupShots, groupBombs;

  function reset(){
    S.score=0; S.over=false; S.t=0;
    S.player.x=0; S.player.cd=0; S.player.hp=3;
    S.shots.length=0; S.bombs.length=0;
    S.dir=1; S.stepT=0;

    gScene = new THREE.Scene();
    gScene.fog = new THREE.FogExp2(0x050512, 0.07);
    gCamera = new THREE.PerspectiveCamera(70, gSize.w/gSize.h, 0.1, 200);
    gCamera.position.set(0, 12, 16);
    gCamera.lookAt(0,2,0);

    gScene.add(new THREE.AmbientLight(0x2a2255, 0.95));
    const d = new THREE.DirectionalLight(0xffffff, 1.05);
    d.position.set(8,18,10);
    gScene.add(d);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(26, 18),
      new THREE.MeshStandardMaterial({color:0x07071a, roughness:0.95})
    );
    floor.rotation.x=-Math.PI/2;
    gScene.add(floor);

    // player
    playerMesh = new THREE.Mesh(
      new THREE.BoxGeometry(1.0,0.5,1.0),
      new THREE.MeshStandardMaterial({color:0x00ff66, emissive:0x00ff66, emissiveIntensity:0.22, roughness:0.45})
    );
    playerMesh.position.set(0,0.35,7);
    gScene.add(playerMesh);

    groupInv = new THREE.Group(); gScene.add(groupInv);
    groupShots = new THREE.Group(); gScene.add(groupShots);
    groupBombs = new THREE.Group(); gScene.add(groupBombs);

    // invaders grid
    S.inv = [];
    for(let r=0;r<4;r++){
      for(let c=0;c<9;c++){
        S.inv.push({x:-8 + c*2.0, z:-6 + r*1.4, alive:true});
      }
    }

    particles = ParticleSystem(1500);
    gScene.add(particles.points);
  }

  function fire(){
    if(S.over) return;
    if(S.player.cd>0) return;
    S.player.cd=0.14;
    S.shots.push({x:S.player.x, z:6.2, v:18});
    blip("shoot",0.10,1.2);
    particles.burst(new THREE.Vector3(S.player.x,0.6,6.8), 18, 3.2, new THREE.Color(0x00ff66), 0.12, 0.35);
  }

  return {
    score:0,
    init(){
      setGameUI(
        "Space Invaders (Bonus)",
        "Slide ‚Ä¢ shoot ‚Ä¢ don‚Äôt get bombed",
        `Move <span class="kbd">‚Üê‚Üí</span>/<span class="kbd">A/D</span> ‚Ä¢ Fire <span class="kbd">Space</span>/Tap ‚Ä¢ Exit <span class="kbd">Esc</span>`
      );
      reset();
      toast("INVADERS INCOMING üëæ", "rgba(0,255,102,.22)");
    },
    action(){
      if(S.over){ this.init(); return; }
      fire();
    },
    pointerDown(){ this.action(); },
    update(dt){
      S.t += dt;
      if(S.over){
        if((keys[" "]||keys["space"]) || mobile.act) this.init();
        return;
      }

      const left = keys["a"]||keys["arrowleft"]||mobile.left;
      const right= keys["d"]||keys["arrowright"]||mobile.right;
      S.player.x += (right-left)*dt*10.5;
      S.player.x = clamp(S.player.x, -11, 11);

      S.player.cd = Math.max(0, S.player.cd-dt);
      if((keys[" "]||keys["space"]) || mobile.act) fire();

      // invader step
      S.stepT -= dt;
      if(S.stepT<=0){
        S.stepT = 0.28;
        let hitEdge=false;
        for(const inv of S.inv){
          if(!inv.alive) continue;
          inv.x += S.dir*0.55;
          if(inv.x>11 || inv.x<-11) hitEdge=true;
        }
        if(hitEdge){
          S.dir *= -1;
          for(const inv of S.inv){
            if(!inv.alive) continue;
            inv.z += 0.55;
            if(inv.z>5.0){
              S.over=true;
              commitBest(S.score);
              toast("THEY LANDED! Space/Tap to restart", "rgba(255,0,255,.25)");
            }
          }
        }

        // bombs
        if(Math.random()<0.8){
          // pick a random alive invader
          const alive = S.inv.filter(i=>i.alive);
          if(alive.length){
            const src = alive[Math.floor(Math.random()*alive.length)];
            S.bombs.push({x:src.x, z:src.z, v:10});
          }
        }
      }

      // shots
      for(let i=S.shots.length-1;i>=0;i--){
        const s=S.shots[i];
        s.z -= s.v*dt;
        if(s.z<-9){ S.shots.splice(i,1); continue; }
        // hit invader
        for(const inv of S.inv){
          if(!inv.alive) continue;
          if(Math.abs(inv.x - s.x)<0.65 && Math.abs(inv.z - s.z)<0.55){
            inv.alive=false;
            S.shots.splice(i,1);
            S.score += 60;
            particles.burst(new THREE.Vector3(inv.x,0.8,inv.z), 70, 7.0, new THREE.Color(0xff00ff), 0.22, 0.95);
            blip("boom",0.12,1.1);
            break;
          }
        }
      }

      // bombs
      for(let i=S.bombs.length-1;i>=0;i--){
        const b=S.bombs[i];
        b.z += b.v*dt;
        if(b.z>9){ S.bombs.splice(i,1); continue; }
        if(Math.abs(b.x - S.player.x)<0.8 && Math.abs(b.z - 7.0)<0.8){
          S.bombs.splice(i,1);
          S.player.hp -= 1;
          particles.burst(new THREE.Vector3(S.player.x,0.7,7.0), 90, 7.0, new THREE.Color(0xffffff), 0.22, 1.0);
          blip("boom",0.14,0.9);
          if(S.player.hp<=0){
            S.over=true;
            commitBest(S.score);
            toast("SHIP DOWN! Space/Tap to restart", "rgba(255,0,255,.25)");
          }
        }
      }

      // win
      if(S.inv.every(i=>!i.alive)){
        S.over=true;
        S.score += 500;
        commitBest(S.score);
        toast("WAVE CLEARED! Space/Tap to restart", "rgba(0,255,255,.25)");
        particles.burst(new THREE.Vector3(0,1,0), 220, 9.0, new THREE.Color(0x00ffff), 0.25, 1.3);
        blip("boom",0.20,1.2);
      }

      // visuals
      playerMesh.position.x = S.player.x;

      groupInv.clear();
      const im = new THREE.MeshStandardMaterial({color:0xff00ff, emissive:0xff00ff, emissiveIntensity:0.18, roughness:0.45});
      for(const inv of S.inv){
        if(!inv.alive) continue;
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.55,0.55), im);
        m.position.set(inv.x,0.6,inv.z);
        groupInv.add(m);
      }

      groupShots.clear();
      const sm = new THREE.MeshStandardMaterial({color:0xffffff, emissive:0xffffff, emissiveIntensity:0.9});
      for(const s of S.shots){
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.12,0.6), sm);
        m.position.set(s.x,0.6,s.z);
        groupShots.add(m);
      }

      groupBombs.clear();
      const bm = new THREE.MeshStandardMaterial({color:0xffd700, emissive:0xffd700, emissiveIntensity:0.7});
      for(const b of S.bombs){
        const m = new THREE.Mesh(new THREE.SphereGeometry(0.18,10,10), bm);
        m.position.set(b.x,0.6,b.z);
        groupBombs.add(m);
      }

      particles.update(dt);

      S.score += dt*2;
      this.score = S.score|0;
      setScore(this.score);
    },
    render(){
      gCamera.lookAt(S.player.x*0.2, 0, 0);
      gRenderer.render(gScene, gCamera);
    },
    dispose(){ particles?.dispose?.(); }
  };
}

/* ===========================
   Boot
=========================== */
initThree();
toast("Click a cabinet screen to play üïπÔ∏è", "rgba(0,255,255,.22)");
</script>
</body>
</html>
