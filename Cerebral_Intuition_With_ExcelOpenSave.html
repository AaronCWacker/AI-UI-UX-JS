<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cerebral Intuition - Neural Biodome</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        #canvas { display: block; }
       
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
       
        #title {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 8px;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #00ffff, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s infinite;
        }
       
        @keyframes shimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
        }
       
        #subtitle {
            font-size: 0.9em;
            letter-spacing: 4px;
            opacity: 0.7;
        }
       
        #stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #00ffff;
            font-size: 0.8em;
            opacity: 0.6;
        }
       
        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #00ffff;
            font-size: 0.75em;
            text-align: right;
            opacity: 0.5;
        }
       
        #neural-activity {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            padding: 15px;
            background: rgba(0, 20, 40, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            color: #00ffff;
            font-size: 0.8em;
        }
       
        #neural-activity h3 {
            margin-bottom: 10px;
            font-weight: 300;
            letter-spacing: 2px;
        }
       
        .activity-bar {
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            margin: 8px 0;
            border-radius: 2px;
            overflow: hidden;
        }
       
        .activity-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            border-radius: 2px;
            transition: width 0.3s;
        }
       
        .activity-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            opacity: 0.8;
        }

        /* New scene controls styles */
        #scene-controls {
            position: fixed;
            top: 80px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .scene-btn {
            background: rgba(0, 20, 40, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px;
            color: #00ffff;
            padding: 8px 16px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 5px #00ffff;
        }

        .scene-btn:hover {
            background: rgba(0, 40, 80, 0.7);
            transform: scale(1.05);
        }

        #file-input {
            display: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="title">CEREBRAL INTUITION</div>
        <div id="subtitle">NEURAL BIODOME COLONY • TITAN ORBIT</div>
    </div>
   
    <div id="neural-activity">
        <h3>⚡ NEURAL ACTIVITY</h3>
        <div class="activity-label"><span>Synaptic Flow</span><span id="syn-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="syn-bar" style="width: 0%"></div></div>
        <div class="activity-label"><span>Consciousness Net</span><span id="con-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="con-bar" style="width: 0%"></div></div>
        <div class="activity-label"><span>Intuition Matrix</span><span id="int-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="int-bar" style="width: 0%"></div></div>
        <div class="activity-label"><span>Drone Swarm</span><span id="drone-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="drone-bar" style="width: 0%"></div></div>
    </div>
   
    <div id="stats">
        <div>Population: 12,847 minds</div>
        <div>Drones Active: <span id="drone-count">0</span></div>
        <div>Neural Sync: <span id="sync-rate">0</span>%</div>
    </div>
   
    <div id="controls">
        Drag to orbit • Scroll to zoom<br>
        Click domes to highlight
    </div>

    <!-- New scene controls -->
    <div id="scene-controls">
        <button class="scene-btn" id="new-btn">New Scene</button>
        <button class="scene-btn" id="save-btn">Save Scene</button>
        <button class="scene-btn" id="open-btn">Open Scene</button>
        <input type="file" id="file-input" accept=".xlsx">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);
        // Camera position
        camera.position.set(0, 8, 25);
        camera.lookAt(0, 5, 0);
        // Orbit controls (simple implementation)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let spherical = { theta: 0, phi: Math.PI / 3, radius: 30 };
        document.addEventListener('mousedown', (e) => { isDragging = true; });
        document.addEventListener('mouseup', () => { isDragging = false; });
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                spherical.theta -= e.movementX * 0.005;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi - e.movementY * 0.005));
            }
        });
        document.addEventListener('wheel', (e) => {
            spherical.radius = Math.max(15, Math.min(60, spherical.radius + e.deltaY * 0.02));
        });
        // Starfield
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = [];
        const starColors = [];
        for (let i = 0; i < 10000; i++) {
            const r = 500 + Math.random() * 500;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            starPositions.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
            const color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.5, 0.5, 0.7 + Math.random() * 0.3);
            starColors.push(color.r, color.g, color.b);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        const starsMaterial = new THREE.PointsMaterial({ size: 1.5, vertexColors: true, transparent: true, opacity: 0.8 });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
        // Saturn
        const saturnGroup = new THREE.Group();
        saturnGroup.position.set(-80, 40, -150);
       
        const saturnGeometry = new THREE.SphereGeometry(40, 64, 64);
        const saturnMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4a574,
            roughness: 0.8,
            metalness: 0.1
        });
        const saturn = new THREE.Mesh(saturnGeometry, saturnMaterial);
        saturnGroup.add(saturn);
        // Saturn rings
        const ringGeometry = new THREE.RingGeometry(50, 80, 128);
        const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0xc9b896,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6
        });
        const rings = new THREE.Mesh(ringGeometry, ringMaterial);
        rings.rotation.x = Math.PI / 2.2;
        saturnGroup.add(rings);
        scene.add(saturnGroup);
        // Main biodome
        const domeGroup = new THREE.Group();
       
        // Dome shell (glass)
        const domeGeometry = new THREE.SphereGeometry(12, 64, 32, 0, Math.PI * 2, 0, Math.PI / 2);
        const domeMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x88ccff,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.2,
            clearcoat: 1,
            clearcoatRoughness: 0.1,
            side: THREE.DoubleSide
        });
        const dome = new THREE.Mesh(domeGeometry, domeMaterial);
        domeGroup.add(dome);
        // Dome frame rings
        for (let i = 1; i <= 5; i++) {
            const ringRadius = 12 * Math.sin((i / 6) * Math.PI / 2);
            const ringHeight = 12 * Math.cos((i / 6) * Math.PI / 2);
            const frameGeometry = new THREE.TorusGeometry(ringRadius, 0.05, 8, 64);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.3
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.y = ringHeight;
            frame.rotation.x = Math.PI / 2;
            domeGroup.add(frame);
        }
        // Base platform
        const baseGeometry = new THREE.CylinderGeometry(13, 14, 1, 64);
        const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x334455, metalness: 0.8, roughness: 0.2 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -0.5;
        domeGroup.add(base);
        scene.add(domeGroup);
        // NEURAL BRAIN TREE - The centerpiece!
        const brainTreeGroup = new THREE.Group();
       
        // Tree trunk (neural stem)
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.8, 4, 16);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x4488ff,
            emissive: 0x2244aa,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 2;
        brainTreeGroup.add(trunk);
        // Brain lobes
        function createBrainLobe(x, y, z, scale, color) {
            const lobeGroup = new THREE.Group();
           
            // Main lobe shape
            const lobeGeometry = new THREE.SphereGeometry(1, 32, 32);
            lobeGeometry.scale(1.2, 0.8, 1);
            const lobeMaterial = new THREE.MeshPhysicalMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.4,
                transparent: true,
                opacity: 0.7,
                roughness: 0.3,
                metalness: 0.5,
                clearcoat: 0.5
            });
            const lobe = new THREE.Mesh(lobeGeometry, lobeMaterial);
            lobeGroup.add(lobe);
            // Convolution lines (brain folds)
            for (let i = 0; i < 8; i++) {
                const curvePoints = [];
                const startAngle = (i / 8) * Math.PI * 2;
                for (let t = 0; t <= 1; t += 0.1) {
                    curvePoints.push(new THREE.Vector3(
                        Math.cos(startAngle + t * 2) * (0.8 - t * 0.3),
                        (t - 0.5) * 1.2,
                        Math.sin(startAngle + t * 2) * (0.8 - t * 0.3)
                    ));
                }
                const curve = new THREE.CatmullRomCurve3(curvePoints);
                const tubeGeometry = new THREE.TubeGeometry(curve, 20, 0.03, 8, false);
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.6
                });
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                lobeGroup.add(tube);
            }
            lobeGroup.position.set(x, y, z);
            lobeGroup.scale.setScalar(scale);
            return lobeGroup;
        }
        // Create brain structure
        const brain = new THREE.Group();
        brain.add(createBrainLobe(-1, 0, 0, 1.5, 0x4488ff)); // Left hemisphere
        brain.add(createBrainLobe(1, 0, 0, 1.5, 0x8844ff)); // Right hemisphere
        brain.add(createBrainLobe(0, -0.5, 0.8, 0.8, 0xff44aa)); // Frontal
        brain.add(createBrainLobe(0, 0, -0.8, 0.7, 0x44ffaa)); // Occipital
        brain.position.y = 6;
        brain.scale.setScalar(1.2);
        brainTreeGroup.add(brain);
        // Neural pathways (glowing tendrils)
        const pathways = [];
        for (let i = 0; i < 20; i++) {
            const points = [];
            const startAngle = (i / 20) * Math.PI * 2;
            const height = 4 + Math.random() * 3;
           
            for (let t = 0; t <= 1; t += 0.05) {
                const spread = t * 2;
                points.push(new THREE.Vector3(
                    Math.cos(startAngle + t * 0.5) * spread + Math.sin(t * 5) * 0.2,
                    t * height,
                    Math.sin(startAngle + t * 0.5) * spread + Math.cos(t * 5) * 0.2
                ));
            }
           
            const curve = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(curve, 50, 0.02 + Math.random() * 0.03, 8, false);
            const hue = 0.5 + Math.random() * 0.3;
            const material = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(hue, 1, 0.5),
                transparent: true,
                opacity: 0.7
            });
            const pathway = new THREE.Mesh(geometry, material);
            pathway.userData = { phase: Math.random() * Math.PI * 2, speed: 0.5 + Math.random() };
            pathways.push(pathway);
            brainTreeGroup.add(pathway);
        }
        // Synaptic particles
        const synapseGeometry = new THREE.BufferGeometry();
        const synapseCount = 500;
        const synapsePositions = new Float32Array(synapseCount * 3);
        const synapseSpeeds = [];
       
        for (let i = 0; i < synapseCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 3;
            const height = Math.random() * 8;
            synapsePositions[i * 3] = Math.cos(angle) * radius;
            synapsePositions[i * 3 + 1] = height;
            synapsePositions[i * 3 + 2] = Math.sin(angle) * radius;
            synapseSpeeds.push({
                angle: angle,
                radius: radius,
                speed: 0.5 + Math.random() * 1.5,
                vertSpeed: (Math.random() - 0.5) * 0.5
            });
        }
        synapseGeometry.setAttribute('position', new THREE.BufferAttribute(synapsePositions, 3));
       
        const synapseMaterial = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.15,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const synapses = new THREE.Points(synapseGeometry, synapseMaterial);
        brainTreeGroup.add(synapses);
        scene.add(brainTreeGroup);
        // Small domes (buildings)
        const smallDomes = [];
        const domePositions = [
            { x: -6, z: 3, scale: 0.8 },
            { x: 6, z: 3, scale: 0.7 },
            { x: -4, z: -5, scale: 0.6 },
            { x: 5, z: -4, scale: 0.75 },
            { x: -7, z: -2, scale: 0.5 },
            { x: 7, z: 0, scale: 0.55 },
            { x: 0, z: 7, scale: 0.65 },
            { x: 3, z: 6, scale: 0.5 }
        ];
        domePositions.forEach((pos, index) => {
            const smallDomeGroup = new THREE.Group();
           
            const sdGeometry = new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const sdMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xaaddff,
                transparent: true,
                opacity: 0.3,
                roughness: 0.1,
                metalness: 0.3,
                clearcoat: 1
            });
            const sdMesh = new THREE.Mesh(sdGeometry, sdMaterial);
            smallDomeGroup.add(sdMesh);
            // Base
            const sdBase = new THREE.Mesh(
                new THREE.CylinderGeometry(1.6, 1.7, 0.3, 32),
                new THREE.MeshStandardMaterial({ color: 0x556677, metalness: 0.7 })
            );
            sdBase.position.y = -0.15;
            smallDomeGroup.add(sdBase);
            // Interior glow
            const glowGeometry = new THREE.SphereGeometry(1, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.3 + index * 0.05, 0.8, 0.5),
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 0.3;
            smallDomeGroup.add(glow);
            smallDomeGroup.position.set(pos.x, 0, pos.z);
            smallDomeGroup.scale.setScalar(pos.scale);
            smallDomeGroup.userData = { pulsePhase: Math.random() * Math.PI * 2 };
            smallDomes.push(smallDomeGroup);
            scene.add(smallDomeGroup);
        });
        // Vegetation patches
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 3 + Math.random() * 8;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
           
            // Simple bush geometry
            const bushGeometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.4, 8, 8);
            const bushMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.7, 0.3 + Math.random() * 0.2),
                roughness: 0.8
            });
            const bush = new THREE.Mesh(bushGeometry, bushMaterial);
            bush.position.set(x, 0.2, z);
            bush.scale.y = 0.6 + Math.random() * 0.4;
            scene.add(bush);
        }
        // Drones
        const drones = [];
        for (let i = 0; i < 15; i++) {
            const droneGroup = new THREE.Group();
           
            // Drone body
            const bodyGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.3);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.9 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            droneGroup.add(body);
            // Rotors
            for (let r = 0; r < 4; r++) {
                const rotorGeometry = new THREE.TorusGeometry(0.1, 0.02, 8, 16);
                const rotorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const rotor = new THREE.Mesh(rotorGeometry, rotorMaterial);
                rotor.position.set(
                    (r % 2 === 0 ? 1 : -1) * 0.2,
                    0.05,
                    (r < 2 ? 1 : -1) * 0.2
                );
                rotor.rotation.x = Math.PI / 2;
                droneGroup.add(rotor);
            }
            // Light
            const lightGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.y = -0.1;
            droneGroup.add(light);
            // Random orbit parameters
            droneGroup.userData = {
                orbitRadius: 5 + Math.random() * 7,
                orbitHeight: 3 + Math.random() * 6,
                orbitSpeed: 0.2 + Math.random() * 0.3,
                orbitPhase: Math.random() * Math.PI * 2,
                bobSpeed: 1 + Math.random() * 2,
                bobAmount: 0.1 + Math.random() * 0.2
            };
            droneGroup.scale.setScalar(0.8);
            drones.push(droneGroup);
            scene.add(droneGroup);
        }
        // Floating holographic sign
        const signGroup = new THREE.Group();
        const signGeometry = new THREE.PlaneGeometry(4, 1);
        const signMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
        });
        const sign = new THREE.Mesh(signGeometry, signMaterial);
        signGroup.position.set(-5, 4, 2);
        signGroup.add(sign);
       
        // Sign border
        const borderGeometry = new THREE.EdgesGeometry(signGeometry);
        const borderMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const border = new THREE.LineSegments(borderGeometry, borderMaterial);
        signGroup.add(border);
        scene.add(signGroup);
        // People/robots (simplified figures)
        for (let i = 0; i < 20; i++) {
            const figureGroup = new THREE.Group();
           
            const isRobot = Math.random() > 0.5;
            const color = isRobot ? 0x88aacc : new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 0.5, 0.5);
           
            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.3, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: color, metalness: isRobot ? 0.8 : 0.1 });
            const figBody = new THREE.Mesh(bodyGeo, bodyMat);
            figBody.position.y = 0.25;
            figureGroup.add(figBody);
            // Head
            const headGeo = new THREE.SphereGeometry(0.06, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({
                color: isRobot ? 0xaaccee : 0xffcc99,
                metalness: isRobot ? 0.8 : 0.1
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.45;
            figureGroup.add(head);
            if (isRobot) {
                // Robot eye
                const eyeGeo = new THREE.SphereGeometry(0.02, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const eye = new THREE.Mesh(eyeGeo, eyeMat);
                eye.position.set(0, 0.45, 0.05);
                figureGroup.add(eye);
            }
            const angle = Math.random() * Math.PI * 2;
            const radius = 2 + Math.random() * 9;
            figureGroup.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            );
            figureGroup.rotation.y = Math.random() * Math.PI * 2;
            figureGroup.scale.setScalar(0.8 + Math.random() * 0.4);
           
            scene.add(figureGroup);
        }
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x334466, 0.5);
        scene.add(ambientLight);
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(10, 20, 10);
        scene.add(mainLight);
        const brainLight = new THREE.PointLight(0x00ffff, 2, 20);
        brainLight.position.set(0, 6, 0);
        scene.add(brainLight);
        const purpleLight = new THREE.PointLight(0xff00ff, 1, 15);
        purpleLight.position.set(0, 8, 0);
        scene.add(purpleLight);
        // Ground plane
        const groundGeometry = new THREE.CircleGeometry(12, 64);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x223344,
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0.01;
        scene.add(ground);
        // Pathways on ground
        for (let i = 0; i < 8; i++) {
            const pathGeometry = new THREE.PlaneGeometry(0.3, 10);
            const pathMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.2
            });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.rotation.x = -Math.PI / 2;
            path.rotation.z = (i / 8) * Math.PI * 2;
            path.position.y = 0.02;
            scene.add(path);
        }
        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            // Update camera
            camera.position.x = Math.sin(spherical.theta) * Math.sin(spherical.phi) * spherical.radius;
            camera.position.y = Math.cos(spherical.phi) * spherical.radius;
            camera.position.z = Math.cos(spherical.theta) * Math.sin(spherical.phi) * spherical.radius;
            camera.lookAt(0, 5, 0);
            // Rotate brain slowly
            brain.rotation.y = time * 0.1;
            // Pulse brain light
            brainLight.intensity = 2 + Math.sin(time * 2) * 0.5;
            purpleLight.intensity = 1 + Math.sin(time * 2.5 + 1) * 0.3;
            // Animate pathways
            pathways.forEach((pathway, i) => {
                pathway.material.opacity = 0.4 + Math.sin(time * pathway.userData.speed + pathway.userData.phase) * 0.3;
            });
            // Animate synapses
            const positions = synapses.geometry.attributes.position.array;
            for (let i = 0; i < synapseCount; i++) {
                const s = synapseSpeeds[i];
                s.angle += s.speed * 0.01;
               
                positions[i * 3] = Math.cos(s.angle) * s.radius;
                positions[i * 3 + 1] += s.vertSpeed * 0.05;
                positions[i * 3 + 2] = Math.sin(s.angle) * s.radius;
                // Reset if too high or low
                if (positions[i * 3 + 1] > 8) positions[i * 3 + 1] = 0;
                if (positions[i * 3 + 1] < 0) positions[i * 3 + 1] = 8;
            }
            synapses.geometry.attributes.position.needsUpdate = true;
            // Animate drones
            drones.forEach((drone, i) => {
                const d = drone.userData;
                const angle = time * d.orbitSpeed + d.orbitPhase;
                drone.position.x = Math.cos(angle) * d.orbitRadius;
                drone.position.z = Math.sin(angle) * d.orbitRadius;
                drone.position.y = d.orbitHeight + Math.sin(time * d.bobSpeed) * d.bobAmount;
                drone.rotation.y = angle + Math.PI;
               
                // Rotor spin
                drone.children.forEach((child, ci) => {
                    if (ci > 0 && ci < 5) {
                        child.rotation.z = time * 20;
                    }
                });
            });
            // Pulse small domes
            smallDomes.forEach((dome, i) => {
                const pulse = Math.sin(time * 1.5 + dome.userData.pulsePhase) * 0.1 + 1;
                dome.children[2].material.opacity = 0.2 + Math.sin(time * 2 + i) * 0.1;
            });
            // Float the sign
            signGroup.position.y = 4 + Math.sin(time) * 0.2;
            signGroup.rotation.y = Math.sin(time * 0.5) * 0.1;
            // Slowly rotate Saturn
            saturn.rotation.y = time * 0.02;
            rings.rotation.z = time * 0.01;
            // Update UI
            const synVal = Math.floor(50 + Math.sin(time * 1.2) * 30 + Math.random() * 10);
            const conVal = Math.floor(60 + Math.sin(time * 0.8 + 1) * 25 + Math.random() * 8);
            const intVal = Math.floor(70 + Math.sin(time * 1.5 + 2) * 20 + Math.random() * 5);
            const droneVal = Math.floor(80 + Math.sin(time * 0.5) * 15);
           
            document.getElementById('syn-val').textContent = synVal + '%';
            document.getElementById('syn-bar').style.width = synVal + '%';
            document.getElementById('con-val').textContent = conVal + '%';
            document.getElementById('con-bar').style.width = conVal + '%';
            document.getElementById('int-val').textContent = intVal + '%';
            document.getElementById('int-bar').style.width = intVal + '%';
            document.getElementById('drone-val').textContent = droneVal + '%';
            document.getElementById('drone-bar').style.width = droneVal + '%';
           
            document.getElementById('drone-count').textContent = drones.length;
            document.getElementById('sync-rate').textContent = Math.floor((synVal + conVal + intVal) / 3);
            renderer.render(scene, camera);
        }
        animate();
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Save function
        function saveBiodomeState() {
            const wb = XLSX.utils.book_new();

            // === Drones Sheet ===
            const droneData = drones.map((drone, i) => ({
                id: i,
                orbitRadius: drone.userData.orbitRadius,
                orbitHeight: drone.userData.orbitHeight,
                orbitSpeed: drone.userData.orbitSpeed,
                orbitPhase: drone.userData.orbitPhase,
                bobSpeed: drone.userData.bobSpeed,
                bobAmount: drone.userData.bobAmount,
                currentX: drone.position.x,
                currentY: drone.position.y,
                currentZ: drone.position.z
            }));
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(droneData), "Drones");

            // === Small Domes Sheet ===
            const domeData = smallDomes.map((dome, i) => ({
                id: i,
                posX: dome.position.x,
                posZ: dome.position.z,
                scale: dome.scale.x,
                pulsePhase: dome.userData.pulsePhase
            }));
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(domeData), "SmallDomes");

            // === Globals ===
            const globals = [
                {key: "time", value: time},
                {key: "camera_theta", value: spherical.theta},
                {key: "camera_phi", value: spherical.phi},
                {key: "camera_radius", value: spherical.radius},
                {key: "brain_scale", value: brain.scale.x},
                {key: "population", value: 12847} // you can make this dynamic later
            ];
            XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(globals), "Globals");

            // Auto-download
            XLSX.writeFile(wb, `NeuralBiodome_State_${new Date().toISOString().slice(0,19)}.xlsx`);
            console.log("✅ State saved to XLSX");
        }

        // Load function
        function loadBiodomeState(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, { type: 'array' });

                // Load Drones
                const droneSheet = XLSX.utils.sheet_to_json(wb.Sheets["Drones"]);
                droneSheet.forEach(row => {
                    const drone = drones[row.id];
                    if (drone) {
                        Object.assign(drone.userData, {
                            orbitRadius: row.orbitRadius,
                            orbitHeight: row.orbitHeight,
                            orbitSpeed: row.orbitSpeed,
                            orbitPhase: row.orbitPhase,
                            bobSpeed: row.bobSpeed,
                            bobAmount: row.bobAmount
                        });
                        drone.position.set(row.currentX || 0, row.currentY || 3, row.currentZ || 0);
                    }
                });

                // Load Small Domes (similar pattern)
                const domeSheet = XLSX.utils.sheet_to_json(wb.Sheets["SmallDomes"]);
                domeSheet.forEach(row => {
                    const dome = smallDomes[row.id];
                    if (dome) {
                        dome.position.set(row.posX, 0, row.posZ);
                        dome.scale.setScalar(row.scale);
                        dome.userData.pulsePhase = row.pulsePhase;
                    }
                });

                // Load Globals
                const globals = XLSX.utils.sheet_to_json(wb.Sheets["Globals"]);
                globals.forEach(g => {
                    if (g.key === "time") time = g.value;
                    if (g.key === "camera_theta") spherical.theta = g.value;
                    if (g.key === "camera_phi") spherical.phi = g.value;
                    if (g.key === "camera_radius") spherical.radius = g.value;
                    if (g.key === "brain_scale") brain.scale.setScalar(g.value);
                    if (g.key === "population") document.querySelector('#stats > div:first-child').textContent = `Population: ${g.value} minds`;
                });

                console.log("✅ State loaded successfully!");
            };
            reader.readAsArrayBuffer(file);
        }

        // Reset/New Scene function
        function resetScene() {
            // Reset time
            time = 0;

            // Reset camera
            spherical = { theta: 0, phi: Math.PI / 3, radius: 30 };

            // Reset drones to initial random states
            drones.forEach((drone, i) => {
                drone.userData = {
                    orbitRadius: 5 + Math.random() * 7,
                    orbitHeight: 3 + Math.random() * 6,
                    orbitSpeed: 0.2 + Math.random() * 0.3,
                    orbitPhase: Math.random() * Math.PI * 2,
                    bobSpeed: 1 + Math.random() * 2,
                    bobAmount: 0.1 + Math.random() * 0.2
                };
            });

            // Reset small domes to initial positions/scales
            domePositions.forEach((pos, i) => {
                const dome = smallDomes[i];
                dome.position.set(pos.x, 0, pos.z);
                dome.scale.setScalar(pos.scale);
                dome.userData.pulsePhase = Math.random() * Math.PI * 2;
            });

            // Reset brain scale if needed
            brain.scale.setScalar(1.2);

            // Reset synapses
            for (let i = 0; i < synapseCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 3;
                const height = Math.random() * 8;
                synapsePositions[i * 3] = Math.cos(angle) * radius;
                synapsePositions[i * 3 + 1] = height;
                synapsePositions[i * 3 + 2] = Math.sin(angle) * radius;
                synapseSpeeds[i] = {
                    angle: angle,
                    radius: radius,
                    speed: 0.5 + Math.random() * 1.5,
                    vertSpeed: (Math.random() - 0.5) * 0.5
                };
            }
            synapses.geometry.attributes.position.needsUpdate = true;

            // Reset population UI (if dynamic, else static)
            document.querySelector('#stats > div:first-child').textContent = 'Population: 12,847 minds';

            console.log("✅ New scene created (reset to initial state)");
        }

        // Button event listeners
        document.getElementById('new-btn').addEventListener('click', resetScene);
        document.getElementById('save-btn').addEventListener('click', saveBiodomeState);
        document.getElementById('open-btn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });
        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadBiodomeState(file);
            }
        });
    </script>
</body>
</html>
