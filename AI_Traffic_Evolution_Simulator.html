<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>City + Flock Imitation AI (Fast)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000;font-family:system-ui,Segoe UI,Inter,Arial}
    #ui{
      position:fixed;left:10px;top:10px;z-index:10;color:#fff;
      background:rgba(0,0,0,.78);border:1px solid rgba(255,255,255,.12);
      border-radius:12px;padding:12px;min-width:260px
    }
    #ui .row{display:flex;justify-content:space-between;gap:10px;font-size:13px;margin:4px 0}
    #ui .big{font-weight:800;letter-spacing:.6px;margin-bottom:6px}
    #ui .small{opacity:.8;font-size:11px;line-height:1.35;margin-top:6px}
    #controls{
      position:fixed;right:10px;top:10px;z-index:10;color:#fff;
      background:rgba(0,0,0,.78);border:1px solid rgba(255,255,255,.12);
      border-radius:12px;padding:12px;min-width:250px
    }
    button{
      width:100%;margin:6px 0;padding:10px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.15);
      background:rgba(255,255,255,.08);color:#fff;cursor:pointer;font-weight:650
    }
    button:hover{background:rgba(255,255,255,.12)}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(0,255,255,.14);border:1px solid rgba(0,255,255,.3);font-size:11px}
    #hint{
      position:fixed;left:10px;bottom:10px;z-index:10;color:#fff;
      background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.1);
      border-radius:12px;padding:10px;font-family:ui-monospace,Consolas,monospace;font-size:11px;opacity:.9
    }
  </style>
</head>
<body>
  <div id="ui">
    <div class="big">üèôÔ∏è City + Flock Imitation AI <span class="pill">FAST</span></div>
    <div class="row"><span>Agents</span><span id="agents">0</span></div>
    <div class="row"><span>Best Fitness</span><span id="bestFit">0</span></div>
    <div class="row"><span>Token Pool</span><span id="poolSize">0</span></div>
    <div class="row"><span>Network Edges</span><span id="edges">0</span></div>
    <div class="row"><span>Mode</span><span id="modeLabel">PLAYER: CAR</span></div>
    <div class="row"><span>Camera</span><span id="camLabel">TOP</span></div>
    <div class="row"><span>FPS</span><span id="fps">0</span></div>
    <div class="small">
      This is ‚ÄúLLM-ish imitation‚Äù: agents use <b>context‚Üítoken biases</b> from the CSV canvas,
      copy the player‚Äôs successful micro-moves, share with neighbors when it worked.
    </div>
  </div>

  <div id="controls">
    <button id="pauseBtn">‚è∏Ô∏è Pause</button>
    <button id="camBtn">üé• Camera: Top</button>
    <button id="netBtn">üï∏Ô∏è Network Lines: ON</button>
    <button id="funBtn">‚≠ê Mark Last 5s as FUN (boost tokens)</button>
    <button id="resetBtn">‚ôªÔ∏è Reset World</button>
  </div>

  <div id="hint">
    <b>Player</b>: W/S throttle ‚Ä¢ A/D steer ‚Ä¢ Space = Car‚áÑPlane ‚Ä¢ C = Camera<br/>
    <b>Goal</b>: keep moving, stay on roads, don‚Äôt get stuck. Clones learn from you + each other.
  </div>

  <!-- =========================
       MEMORY CANVAS (CSV TOKENS)
       =========================
       Each token = a tiny ‚Äúinstruction chunk‚Äù (biases) keyed by CONTEXT.
       Agents run a cheap base controller + add token biases.
       They share/merge tokens if fitness improved.
  -->
  <script id="brain-csv" type="text/plain">
id,context,steerBias,throttleBias,brakeBias,planePref,score
T0,STRAIGHT, 0.00, 0.10, 0.00,0.00, 10
T1,TURN,     0.18,-0.05, 0.05,0.00, 10
T2,OFFROAD,  0.35,-0.20, 0.08,0.20, 10
T3,NEAR,    -0.10,-0.10, 0.20,0.00, 10
T4,STUCK,    0.30, 0.20, 0.00,0.70, 10
T5,FLY,      0.05, 0.15, 0.00,1.00, 10
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
  (() => {
    // =========================================================
    // PERF-FIRST DESIGN
    // - InstancedMesh for agents + buildings
    // - No Raycasters per agent
    // - Cheap road metric from analytic grid roads
    // - Network edges updated at low rate (not every frame)
    // =========================================================

    // ---------- CONFIG ----------
    const CFG = {
      WORLD_SIZE: 900,
      ROAD_SPACING: 140,
      ROAD_HALF: 12,          // half width for ‚Äúon road‚Äù
      ROAD_SOFT: 26,          // soft band for roadScore
      AGENTS: 80,             // lower by default; instancing still handles higher
      BUILDINGS: 120,
      K_NEIGHBORS: 3,         // network degree
      EDGE_UPDATE_HZ: 2,      // network refresh rate
      TOKEN_SHARE_HZ: 1,      // token share cadence
      DT_CLAMP: 0.05,
      PLAYER_SPEED_MAX: 42,
      CAR_SPEED_MAX: 34,
      PLANE_SPEED_MAX: 55,
      STUCK_SPEED: 1.2,
      STUCK_TIME: 1.6,
      PLANE_HEIGHT: 45,
      PLANE_LIFT_RATE: 2.2,
      PLANE_DROP_RATE: 1.6,
      COLLISION_R: 3.2,
      SEPARATION_FORCE: 16,
      ALIGN_FORCE: 3.5,
      COHESION_FORCE: 1.2,
      ROAD_FORCE: 26,
      DAMP: 0.985
    };

    // ---------- UI ----------
    const $ = (id) => document.getElementById(id);
    let paused = false;
    let showNetwork = true;

    // ---------- THREE ----------
    let scene, camera, renderer, clock;

    // Camera modes: TOP / FOLLOW / CINEMATIC
    const CAM = { TOP:0, FOLLOW:1, ORBIT:2 };
    let camMode = CAM.TOP;

    // ---------- WORLD ROADS ----------
    // We'll build a grid ‚Äúcross‚Äù like your original: 3 rings each axis.
    const roads = []; // each road = {dir:'h'|'v', x|z, start, end}
    function buildRoads() {
      roads.length = 0;
      const L = CFG.WORLD_SIZE * 0.95;
      const s = CFG.ROAD_SPACING;
      const offsets = [0, s, -s, 2*s, -2*s];

      // Horizontal lines at z=offset
      offsets.forEach(z => roads.push({ dir:'h', z, start:-L, end:L }));
      // Vertical lines at x=offset
      offsets.forEach(x => roads.push({ dir:'v', x, start:-L, end:L }));
    }

    // Analytic road score: 1 on road center, falls off to 0 outside soft band
    function roadScoreAt(x, z) {
      let best = 0;
      for (const r of roads) {
        if (r.dir === 'h') {
          if (x < r.start || x > r.end) continue;
          const d = Math.abs(z - r.z);
          const s = 1 - (d / CFG.ROAD_SOFT);
          best = Math.max(best, clamp01(s));
        } else {
          if (z < r.start || z > r.end) continue;
          const d = Math.abs(x - r.x);
          const s = 1 - (d / CFG.ROAD_SOFT);
          best = Math.max(best, clamp01(s));
        }
      }
      return best;
    }

    // Closest road direction + ‚Äútarget line‚Äù point for steering back
    function nearestRoadVector(x, z) {
      let best = null;
      let bestD = Infinity;

      for (const r of roads) {
        if (r.dir === 'h') {
          if (x < r.start || x > r.end) continue;
          const d = Math.abs(z - r.z);
          if (d < bestD) {
            bestD = d;
            best = { dir:'h', targetX:x, targetZ:r.z, heading:0 }; // +Z forward direction (we‚Äôll map later)
          }
        } else {
          if (z < r.start || z > r.end) continue;
          const d = Math.abs(x - r.x);
          if (d < bestD) {
            bestD = d;
            best = { dir:'v', targetX:r.x, targetZ:z, heading:Math.PI/2 };
          }
        }
      }
      return best || { dir:'h', targetX:x, targetZ:z, heading:0 };
    }

    // ---------- CSV ‚ÄúMemory Canvas‚Äù ----------
    function parseCSV(text) {
      const lines = text.trim().split(/\r?\n/).filter(l => l.trim() && !l.trim().startsWith('#'));
      const head = lines.shift().split(',').map(s => s.trim());
      return lines.map(line => {
        const parts = line.split(',').map(s => s.trim());
        const o = {};
        head.forEach((h,i)=> o[h]=parts[i]);
        // numeric fields
        ['steerBias','throttleBias','brakeBias','planePref','score'].forEach(k => o[k] = Number(o[k]));
        return o;
      });
    }

    // Token pool keyed by context; each context has multiple tokens (ranked by score)
    const tokenPool = new Map(); // context -> [{...token}]
    function loadTokenPool() {
      tokenPool.clear();
      const csv = parseCSV($('brain-csv').textContent);
      for (const t of csv) {
        if (!tokenPool.has(t.context)) tokenPool.set(t.context, []);
        tokenPool.get(t.context).push(t);
      }
      // sort high score first
      for (const [ctx, arr] of tokenPool) arr.sort((a,b)=>b.score-a.score);
    }

    function poolSize() {
      let n = 0; for (const [,arr] of tokenPool) n += arr.length;
      return n;
    }

    function pickToken(ctx) {
      const arr = tokenPool.get(ctx) || [];
      if (!arr.length) return null;
      // Weighted pick favoring top tokens (cheap)
      const i = Math.floor(Math.random() * Math.min(arr.length, 4));
      return arr[i];
    }

    function boostToken(ctx, steerB, thrB, brkB, planeP, deltaScore) {
      // Merge into best-matching token or create new one
      if (!tokenPool.has(ctx)) tokenPool.set(ctx, []);
      const arr = tokenPool.get(ctx);
      let best = null, bestD = Infinity;
      for (const t of arr) {
        const d = Math.abs(t.steerBias - steerB) + Math.abs(t.throttleBias - thrB) + Math.abs(t.brakeBias - brkB) + Math.abs(t.planePref - planeP);
        if (d < bestD) { bestD = d; best = t; }
      }
      if (!best || bestD > 0.6 || arr.length < 2) {
        const nt = {
          id: `N${Math.floor(Math.random()*1e9)}`,
          context: ctx,
          steerBias: steerB,
          throttleBias: thrB,
          brakeBias: brkB,
          planePref: planeP,
          score: 10
        };
        arr.push(nt);
      } else {
        const a = 0.18; // blend rate
        best.steerBias    = lerp(best.steerBias, steerB, a);
        best.throttleBias = lerp(best.throttleBias, thrB, a);
        best.brakeBias    = lerp(best.brakeBias, brkB, a);
        best.planePref    = lerp(best.planePref, planeP, a);
        best.score += deltaScore;
      }
      arr.sort((a,b)=>b.score-a.score);
      // prune if too large
      if (arr.length > 12) arr.length = 12;
    }

    // ---------- AGENT MODEL ----------
    // ‚ÄúInstruction combos‚Äù = a set of tokens (one per context) + a tiny mutation.
    function makePolicyFromPool() {
      const contexts = ['STRAIGHT','TURN','OFFROAD','NEAR','STUCK','FLY'];
      const policy = {};
      contexts.forEach(ctx => policy[ctx] = pickToken(ctx) || {steerBias:0,throttleBias:0,brakeBias:0,planePref:0,score:1,id:'Z'});
      return policy;
    }

    function mutatePolicy(policy) {
      // mutate: swap 1 context token + small jitter on one
      const keys = Object.keys(policy);
      const k = keys[Math.floor(Math.random()*keys.length)];
      if (Math.random() < 0.55) {
        policy[k] = pickToken(k) || policy[k];
      } else {
        const t = policy[k];
        policy[k] = {
          ...t,
          steerBias: t.steerBias + (Math.random()-0.5)*0.08,
          throttleBias: t.throttleBias + (Math.random()-0.5)*0.08,
          brakeBias: t.brakeBias + (Math.random()-0.5)*0.06,
          planePref: t.planePref + (Math.random()-0.5)*0.10,
          score: t.score
        };
      }
    }

    // Relationship graph: each agent chooses K nearest; edges typed by ‚Äúwho is better‚Äù
    const edges = []; // {a,b,type}
    const edgePos = []; // float array for line geometry

    // Player demonstrations (context buckets -> averaged biases)
    const playerDemo = {
      // ctx -> {n, steer, thr, brk, plane}
    };

    function initDemo() {
      ['STRAIGHT','TURN','OFFROAD','NEAR','STUCK','FLY'].forEach(ctx => {
        playerDemo[ctx] = { n:0, steer:0, thr:0, brk:0, plane:0, funBoost:0 };
      });
    }

    // ---------- INSTANCING ----------
    let carInst, buildingInst, roadMeshes = [];
    const dummy = new THREE.Object3D();
    const color = new THREE.Color();

    // Agents list
    let agents = [];
    let player = null;

    function newAgent(i, isPlayer=false) {
      const p = spawnPoint(i);
      const a = {
        id: isPlayer ? 'PLAYER' : `A${i}`,
        isPlayer,
        pos: new THREE.Vector3(p.x, 1, p.z),
        vel: new THREE.Vector3((Math.random()-0.5)*6, 0, (Math.random()-0.5)*6),
        yaw: Math.random()*Math.PI*2,
        mode: 'CAR',   // CAR or PLANE
        height: 1,
        policy: makePolicyFromPool(),
        fitness: 0,
        bestFitness: 0,
        lastPos: new THREE.Vector3(p.x, 1, p.z),
        stuckT: 0,
        lastShareAt: 0,
        lastFitSample: 0,
        lastFitAt: 0,
        rel: [],       // neighbors indices
        relType: [],   // relationship types
        observePlayer: 0,
        funCredit: 0
      };
      if (!isPlayer && Math.random() < 0.35) mutatePolicy(a.policy);
      return a;
    }

    function spawnPoint(i) {
      const s = CFG.ROAD_SPACING;
      const picks = [
        {x:0,z:0},{x:s,z:0},{x:-s,z:0},{x:0,z:s},{x:0,z:-s},
        {x:2*s,z:0},{x:-2*s,z:0},{x:0,z:2*s},{x:0,z:-2*s}
      ];
      const b = picks[i % picks.length];
      return { x: b.x + (Math.random()-0.5)*20, z: b.z + (Math.random()-0.5)*20 };
    }

    // ---------- CONTEXT DETECTION ----------
    function contextOf(agent, nearDist, rScore, turnNeed) {
      if (agent.mode === 'PLANE') return 'FLY';
      if (rScore < 0.22) return 'OFFROAD';
      if (agent.stuckT > 0.6) return 'STUCK';
      if (nearDist < 10) return 'NEAR';
      if (turnNeed > 0.35) return 'TURN';
      return 'STRAIGHT';
    }

    // ---------- BASE CONTROLLER ----------
    function baseControl(agent) {
      // Determine target along nearest road line
      const nr = nearestRoadVector(agent.pos.x, agent.pos.z);
      const toLine = new THREE.Vector3(nr.targetX - agent.pos.x, 0, nr.targetZ - agent.pos.z);
      const distToLine = toLine.length();
      const desired = (distToLine > 0.001) ? toLine.normalize() : new THREE.Vector3(0,0,1);

      // Forward vector from yaw (+Z forward)
      const fwd = new THREE.Vector3(Math.sin(agent.yaw), 0, Math.cos(agent.yaw));
      const dot = clamp(fwd.dot(desired), -1, 1);
      const turnNeed = Math.acos(dot) / Math.PI; // 0..1

      // Signed turn direction (cross on Y)
      const crossY = fwd.x*desired.z - fwd.z*desired.x; // y component
      const steer = clamp(crossY * 2.2, -1, 1);

      // Speed target: slower if turning sharply or far from road center
      const rScore = roadScoreAt(agent.pos.x, agent.pos.z);
      const targetSpeed = lerp(18, 30, rScore) * (1 - turnNeed*0.55);

      const speed = agent.vel.length();
      let throttle = clamp((targetSpeed - speed) / 10, 0, 1);
      let brake = clamp((speed - targetSpeed) / 12, 0, 1);

      // If offroad, bias harder to road and slow
      if (rScore < 0.25) { throttle *= 0.55; brake = Math.max(brake, 0.15); }

      return { steer, throttle, brake, turnNeed, rScore };
    }

    // ---------- FLOCKING / AVOIDANCE ----------
    function neighborInfo(agent, idxList) {
      let nearest = Infinity;
      let align = new THREE.Vector3(0,0,0);
      let cohesion = new THREE.Vector3(0,0,0);
      let sep = new THREE.Vector3(0,0,0);
      let count = 0;

      for (const j of idxList) {
        const b = agents[j];
        if (!b || b === agent) continue;
        const d = agent.pos.distanceTo(b.pos);
        nearest = Math.min(nearest, d);
        if (d < 0.001 || d > 35) continue;

        // alignment
        align.add(b.vel);

        // cohesion
        cohesion.add(b.pos);

        // separation
        if (d < 12) {
          const away = agent.pos.clone().sub(b.pos).normalize().multiplyScalar(1 / (d + 0.001));
          sep.add(away);
        }
        count++;
      }

      if (count) {
        align.multiplyScalar(1/count);
        cohesion.multiplyScalar(1/count).sub(agent.pos);
      }
      return { nearest, align, cohesion, sep, count };
    }

    // ---------- RELATIONSHIP GRAPH ----------
    function updateEdges() {
      edges.length = 0;

      // kNN per agent (O(n^2) but at low rate and n~80 => fine)
      for (let i=0;i<agents.length;i++) {
        const a = agents[i];
        a.rel.length = 0;
        a.relType.length = 0;

        const dists = [];
        for (let j=0;j<agents.length;j++) {
          if (i===j) continue;
          const b = agents[j];
          const d = a.pos.distanceToSquared(b.pos);
          dists.push([d,j]);
        }
        dists.sort((u,v)=>u[0]-v[0]);
        const picks = dists.slice(0, CFG.K_NEIGHBORS).map(x=>x[1]);

        for (const j of picks) {
          const b = agents[j];
          const d = Math.sqrt(a.pos.distanceToSquared(b.pos));

          // Relationship typing:
          // - observer if near player
          // - convoy if headings aligned and close
          // - mentor if b.fitness > a.fitness by margin
          // - else peer
          const isObs = (!a.isPlayer && player && b===player) || (!b.isPlayer && player && a===player);
          const aF = new THREE.Vector3(Math.sin(a.yaw),0,Math.cos(a.yaw));
          const bF = new THREE.Vector3(Math.sin(b.yaw),0,Math.cos(b.yaw));
          const align = aF.dot(bF);

          let type = 'peer';
          if (isObs && d < 80) type = 'observer';
          else if (d < 18 && align > 0.88) type = 'convoy';
          else if (b.fitness > a.fitness + 25) type = 'mentor';

          a.rel.push(j);
          a.relType.push(type);

          edges.push({a:i,b:j,type});
        }
      }
      updateEdgeGeometry();
    }

    // ---------- NETWORK LINE GEOMETRY ----------
    let edgeGeom, edgeLines;
    function makeEdgeLines() {
      edgeGeom = new THREE.BufferGeometry();
      edgeGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
      const mat = new THREE.LineBasicMaterial({ transparent:true, opacity:0.35 });
      edgeLines = new THREE.LineSegments(edgeGeom, mat);
      scene.add(edgeLines);
    }

    function updateEdgeGeometry() {
      if (!edgeGeom) return;
      // Limit max edges for sanity
      const maxE = Math.min(edges.length, agents.length * CFG.K_NEIGHBORS);
      const arr = new Float32Array(maxE * 2 * 3);
      let k = 0;

      for (let i=0;i<maxE;i++) {
        const e = edges[i];
        const A = agents[e.a], B = agents[e.b];
        if (!A || !B) continue;

        // slightly lift lines
        const ay = A.mode==='PLANE' ? A.height : 2.2;
        const by = B.mode==='PLANE' ? B.height : 2.2;

        arr[k++] = A.pos.x; arr[k++] = ay; arr[k++] = A.pos.z;
        arr[k++] = B.pos.x; arr[k++] = by; arr[k++] = B.pos.z;
      }

      edgeGeom.setAttribute('position', new THREE.BufferAttribute(arr, 3));
      edgeGeom.computeBoundingSphere();
    }

    // ---------- IMITATION / SHARING ----------
    // Agents "learn" by:
    // 1) copying player demo biases (context bucket averages)
    // 2) sharing tokens from mentors/peers if fitness improved over last sample
    function updateSharing(now) {
      for (const a of agents) {
        if (a.isPlayer) continue;

        if (now - a.lastFitAt > 1000) {
          a.lastFitSample = a.fitness;
          a.lastFitAt = now;
        }

        if (now - a.lastShareAt < (1000/CFG.TOKEN_SHARE_HZ)) continue;

        const improved = (a.fitness - a.lastFitSample) > 6;
        if (improved) {
          // share 1-2 tokens from current context into pool
          const nr = baseControl(a);
          const ninfo = neighborInfo(a, a.rel);
          const ctx = contextOf(a, ninfo.nearest, nr.rScore, nr.turnNeed);
          const tok = a.policy[ctx];

          boostToken(ctx,
            clamp(tok.steerBias, -0.6, 0.6),
            clamp(tok.throttleBias, -0.6, 0.6),
            clamp(tok.brakeBias, -0.4, 0.6),
            clamp01(tok.planePref),
            2 + Math.floor(Math.random()*3)
          );
        }

        // copy from mentors (if any) or from player observation
        let mentorIdx = -1;
        for (let i=0;i<a.rel.length;i++) {
          if (a.relType[i] === 'mentor') { mentorIdx = a.rel[i]; break; }
        }

        if (mentorIdx >= 0 && Math.random() < 0.55) {
          const m = agents[mentorIdx];
          // soft-imprint: swap one token from mentor policy
          const keys = Object.keys(a.policy);
          const k = keys[Math.floor(Math.random()*keys.length)];
          a.policy[k] = m.policy[k];
        } else if (player && Math.random() < 0.42) {
          // soft-imprint from player demo: convert demo averages into biases
          const keys = Object.keys(playerDemo);
          const k = keys[Math.floor(Math.random()*keys.length)];
          const d = playerDemo[k];
          if (d.n > 6) {
            a.policy[k] = {
              id:`P${k}`, context:k,
              steerBias: clamp(d.steer/d.n, -0.6, 0.6),
              throttleBias: clamp(d.thr/d.n, -0.6, 0.6),
              brakeBias: clamp(d.brk/d.n, -0.5, 0.6),
              planePref: clamp01(d.plane/d.n),
              score: 10
            };
          }
        }

        // slight exploration mutation
        if (Math.random() < 0.25) mutatePolicy(a.policy);

        a.lastShareAt = now;
      }
      $('poolSize').textContent = poolSize();
    }

    // Record player ‚Äúmeta actions‚Äù into demo buckets
    function recordPlayerDemo(ctx, steer, thr, brk, planeFlag) {
      const d = playerDemo[ctx];
      d.n += 1;
      d.steer += steer;
      d.thr += thr;
      d.brk += brk;
      d.plane += planeFlag;
    }

    // Mark fun boosts: push recent demo into token scores
    function markFunBoost() {
      for (const ctx of Object.keys(playerDemo)) {
        const d = playerDemo[ctx];
        if (d.n > 10) {
          boostToken(ctx,
            clamp(d.steer/d.n, -0.6, 0.6),
            clamp(d.thr/d.n, -0.6, 0.6),
            clamp(d.brk/d.n, -0.5, 0.6),
            clamp01(d.plane/d.n),
            12
          );
          d.funBoost += 1;
        }
      }
      $('poolSize').textContent = poolSize();
    }

    // ---------- INPUT ----------
    const key = {};
    function setupInput() {
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        key[k] = true;

        if (k === 'c') cycleCamera();
        if (k === ' ') togglePlayerMode();
      });
      window.addEventListener('keyup', (e) => key[e.key.toLowerCase()] = false);
    }

    function cycleCamera() {
      camMode = (camMode + 1) % 3;
      $('camLabel').textContent = camMode===CAM.TOP ? 'TOP' : camMode===CAM.FOLLOW ? 'FOLLOW' : 'ORBIT';
      $('camBtn').textContent = `üé• Camera: ${camMode===CAM.TOP?'Top':camMode===CAM.FOLLOW?'Follow':'Orbit'}`;
    }

    function togglePlayerMode() {
      if (!player) return;
      player.mode = (player.mode === 'CAR') ? 'PLANE' : 'CAR';
      $('modeLabel').textContent = `PLAYER: ${player.mode}`;
    }

    // ---------- SCENE BUILD ----------
    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b1020);
      scene.fog = new THREE.Fog(0x0b1020, 450, 1400);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 3500);
      camera.position.set(0, 420, 420);
      camera.lookAt(0,0,0);

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      document.body.appendChild(renderer.domElement);

      const amb = new THREE.AmbientLight(0xffffff, 0.55);
      scene.add(amb);

      const sun = new THREE.DirectionalLight(0xfff2cc, 0.9);
      sun.position.set(250, 520, 180);
      scene.add(sun);

      clock = new THREE.Clock();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function buildGroundAndRoadMeshes() {
      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(CFG.WORLD_SIZE*2, CFG.WORLD_SIZE*2),
        new THREE.MeshLambertMaterial({ color: 0x14311f })
      );
      ground.rotation.x = -Math.PI/2;
      ground.position.y = 0;
      scene.add(ground);

      // Roads (few meshes only)
      roadMeshes.forEach(m => scene.remove(m));
      roadMeshes = [];

      const matRoad = new THREE.MeshLambertMaterial({ color: 0x1a1f2a });
      for (const r of roads) {
        const len = (r.end - r.start);
        const w = CFG.ROAD_HALF*2;
        const geom = (r.dir==='h')
          ? new THREE.PlaneGeometry(len, w)
          : new THREE.PlaneGeometry(w, len);

        const mesh = new THREE.Mesh(geom, matRoad);
        mesh.rotation.x = -Math.PI/2;
        mesh.position.set(r.dir==='h'?0:r.x, 0.02, r.dir==='h'?r.z:0);
        scene.add(mesh);
        roadMeshes.push(mesh);
      }

      // Simple city buildings (instanced)
      if (buildingInst) scene.remove(buildingInst);

      const bGeom = new THREE.BoxGeometry(1,1,1);
      const bMat = new THREE.MeshLambertMaterial({ color: 0x3b4257 });
      buildingInst = new THREE.InstancedMesh(bGeom, bMat, CFG.BUILDINGS);
      buildingInst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      for (let i=0;i<CFG.BUILDINGS;i++) {
        const w = 14 + Math.random()*32;
        const d = 14 + Math.random()*32;
        const h = 22 + Math.random()*120;

        // place buildings away from road centerlines
        let x=0,z=0,tries=0;
        while (tries++ < 50) {
          x = (Math.random()-0.5)*CFG.WORLD_SIZE*1.6;
          z = (Math.random()-0.5)*CFG.WORLD_SIZE*1.6;
          if (roadScoreAt(x,z) < 0.10) break;
        }

        dummy.position.set(x, h/2, z);
        dummy.scale.set(w, h, d);
        dummy.rotation.set(0, Math.random()*Math.PI*2, 0);
        dummy.updateMatrix();
        buildingInst.setMatrixAt(i, dummy.matrix);
      }
      scene.add(buildingInst);
    }

    function buildAgentsInst() {
      if (carInst) scene.remove(carInst);

      // One instanced mesh for both cars + planes; plane is just elevated + slightly stretched
      const geom = new THREE.BoxGeometry(1.6, 0.9, 3.4);
      const mat = new THREE.MeshLambertMaterial({ vertexColors:true });
      carInst = new THREE.InstancedMesh(geom, mat, CFG.AGENTS + 1);
      carInst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      const colors = [];
      for (let i=0;i<CFG.AGENTS+1;i++) {
        color.setHSL((i/(CFG.AGENTS+1)), 0.8, 0.62);
        colors.push(color.r, color.g, color.b);
      }
      carInst.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(colors), 3);
      scene.add(carInst);
    }

    // ---------- SIM LOOP ----------
    let lastEdgeUpdate = 0;
    let fpsS = { frames:0, t0:performance.now(), fps:0 };

    function step(dt) {
      // Update graph at low rate
      const now = performance.now();
      if (now - lastEdgeUpdate > (1000/CFG.EDGE_UPDATE_HZ)) {
        updateEdges();
        lastEdgeUpdate = now;
        $('edges').textContent = edges.length;
      }

      // Sharing cadence
      updateSharing(now);

      // Update agents
      let best = -Infinity;

      for (let i=0;i<agents.length;i++) {
        const a = agents[i];
        if (a.isPlayer) updatePlayer(a, dt);
        else updateBot(a, dt);

        a.fitness = computeFitness(a, dt);
        a.bestFitness = Math.max(a.bestFitness, a.fitness);
        best = Math.max(best, a.fitness);
      }

      $('bestFit').textContent = Math.round(best);

      // Network line visibility
      if (edgeLines) edgeLines.visible = showNetwork;

      // Render instances
      renderInstances();

      // Camera
      updateCamera(dt);
    }

    function computeFitness(a, dt) {
      const r = roadScoreAt(a.pos.x, a.pos.z);
      const speed = a.vel.length();

      // reward: distance + road adherence + not stuck
      const dist = a.pos.distanceTo(a.lastPos);
      a.lastPos.copy(a.pos);

      let f = a.fitness;
      f += dist * 0.55;
      f += r * 0.75;
      f += clamp(speed/20, 0, 1) * 0.15;

      // penalties
      if (r < 0.18 && a.mode==='CAR') f -= 0.6 * dt * 60;
      if (a.stuckT > 0.7) f -= 0.35 * dt * 60;

      // small plane cost unless needed
      if (a.mode==='PLANE' && r > 0.3) f -= 0.12 * dt * 60;

      // keep within bounds
      const b = CFG.WORLD_SIZE*0.95;
      if (Math.abs(a.pos.x)>b || Math.abs(a.pos.z)>b) f -= 2.5 * dt * 60;

      return f;
    }

    function updatePlayer(a, dt) {
      const turn = (key['a']?1:0) - (key['d']?1:0);
      const thr  = (key['w']?1:0);
      const brk  = (key['s']?1:0);

      // Car/plane mode height control
      if (a.mode === 'PLANE') {
        a.height = lerp(a.height, CFG.PLANE_HEIGHT, 1 - Math.pow(0.001, dt));
      } else {
        a.height = lerp(a.height, 1.2, 1 - Math.pow(0.001, dt));
      }

      // yaw control
      a.yaw += (-turn) * dt * (a.mode==='PLANE' ? 2.2 : 2.0);

      const fwd = new THREE.Vector3(Math.sin(a.yaw), 0, Math.cos(a.yaw));
      const speed = a.vel.length();
      const maxV = (a.mode==='PLANE') ? CFG.PLANE_SPEED_MAX : CFG.PLAYER_SPEED_MAX;

      // throttle/brake
      a.vel.add(fwd.multiplyScalar(thr * dt * 36));
      a.vel.multiplyScalar(1 - brk * dt * 2.4);

      // mild damping
      if (!thr) a.vel.multiplyScalar(0.985);

      // clamp speed
      if (a.vel.length() > maxV) a.vel.setLength(maxV);

      // road ‚Äúpush‚Äù (only in car)
      const bc = baseControl(a);
      if (a.mode === 'CAR') {
        // push toward road center + direction
        const nr = nearestRoadVector(a.pos.x, a.pos.z);
        const toLine = new THREE.Vector3(nr.targetX-a.pos.x, 0, nr.targetZ-a.pos.z);
        a.vel.add(toLine.multiplyScalar(dt * (1-bc.rScore) * 0.9));
      }

      // update pos
      a.pos.add(a.vel.clone().multiplyScalar(dt));
      a.pos.y = a.height;

      // stuck detect (player too)
      const sp = a.vel.length();
      a.stuckT = (sp < CFG.STUCK_SPEED && a.mode==='CAR') ? (a.stuckT + dt) : Math.max(0, a.stuckT - dt*1.2);

      // Record demo (context + chosen controls vs base)
      const ninfo = neighborInfo(a, a.rel);
      const ctx = contextOf(a, ninfo.nearest, bc.rScore, bc.turnNeed);
      const steerSigned = clamp(-turn, -1, 1);

      // biases are ‚Äúdifference‚Äù between player action and base suggestion
      const steerBias = clamp(steerSigned - bc.steer, -0.8, 0.8);
      const thrBias   = clamp(thr - bc.throttle, -0.8, 0.8);
      const brkBias   = clamp(brk - bc.brake, -0.8, 0.8);
      const planeFlag = (a.mode==='PLANE') ? 1 : 0;

      recordPlayerDemo(ctx, steerBias, thrBias, brkBias, planeFlag);

      $('modeLabel').textContent = `PLAYER: ${a.mode}`;
    }

    function updateBot(a, dt) {
      // Low-cost base control (road follow)
      const bc = baseControl(a);

      // Neighbor effects (flock-ish)
      const ninfo = neighborInfo(a, a.rel);
      const nearDist = ninfo.nearest;

      // Context + token biases
      const ctx = contextOf(a, nearDist, bc.rScore, bc.turnNeed);
      const tok = a.policy[ctx] || { steerBias:0, throttleBias:0, brakeBias:0, planePref:0 };

      // Decide plane switch (if stuck/offroad + token prefers)
      const speed = a.vel.length();
      a.stuckT = (speed < CFG.STUCK_SPEED && a.mode==='CAR') ? (a.stuckT + dt) : Math.max(0, a.stuckT - dt*1.4);

      const wantPlane =
        (ctx === 'STUCK' || ctx === 'OFFROAD') && (Math.random() < clamp01(tok.planePref * 0.55));

      if (wantPlane) a.mode = 'PLANE';
      if (a.mode === 'PLANE' && bc.rScore > 0.55 && a.stuckT < 0.2 && Math.random() < 0.02) a.mode = 'CAR';

      // Height smoothing
      if (a.mode === 'PLANE') a.height = lerp(a.height, CFG.PLANE_HEIGHT, 1 - Math.pow(0.001, dt));
      else a.height = lerp(a.height, 1.2, 1 - Math.pow(0.001, dt));

      // Steering: base + token + alignment
      let steer = bc.steer + tok.steerBias;

      // flock: alignment and separation only when near
      if (ninfo.count) {
        const alignV = ninfo.align.clone();
        if (alignV.lengthSq() > 0.001) {
          alignV.normalize();
          const fwd = new THREE.Vector3(Math.sin(a.yaw), 0, Math.cos(a.yaw));
          const crossY = fwd.x*alignV.z - fwd.z*alignV.x;
          steer += clamp(crossY, -1, 1) * (CFG.ALIGN_FORCE/10);
        }
        // separation pushes away by adding lateral steer bias
        if (nearDist < 10) {
          steer += clamp((Math.random()<0.5?1:-1) * (10-nearDist)/10, -1, 1) * 0.18;
        }
      }
      steer = clamp(steer, -1, 1);

      // Throttle/brake: base + token
      let throttle = clamp01(bc.throttle + tok.throttleBias);
      let brake    = clamp01(bc.brake    + tok.brakeBias);

      // If very near someone, brake more
      if (nearDist < 7 && a.mode==='CAR') brake = Math.max(brake, 0.25);

      // Apply dynamics
      const turnRate = (a.mode==='PLANE') ? 1.9 : 1.7;
      a.yaw += (-steer) * dt * turnRate;

      const fwd = new THREE.Vector3(Math.sin(a.yaw), 0, Math.cos(a.yaw));

      const maxV = (a.mode==='PLANE') ? CFG.PLANE_SPEED_MAX : CFG.CAR_SPEED_MAX;
      a.vel.add(fwd.multiplyScalar(throttle * dt * (a.mode==='PLANE' ? 42 : 34)));
      a.vel.multiplyScalar(1 - brake * dt * 2.1);

      // Road pull (car only): centerline attraction
      if (a.mode === 'CAR') {
        const nr = nearestRoadVector(a.pos.x, a.pos.z);
        const toLine = new THREE.Vector3(nr.targetX-a.pos.x, 0, nr.targetZ-a.pos.z);
        a.vel.add(toLine.multiplyScalar(dt * (1-bc.rScore) * 1.4));
      }

      // Collision avoidance: simple separation
      if (ninfo.count && a.mode==='CAR') {
        a.vel.add(ninfo.sep.multiplyScalar(dt * CFG.SEPARATION_FORCE));
      }

      // damping + speed clamp
      a.vel.multiplyScalar(CFG.DAMP);
      if (a.vel.length() > maxV) a.vel.setLength(maxV);

      // update pos
      a.pos.add(a.vel.clone().multiplyScalar(dt));
      a.pos.y = a.height;

      // keep in bounds bounce
      const b = CFG.WORLD_SIZE*0.95;
      if (a.pos.x > b || a.pos.x < -b) { a.pos.x = clamp(a.pos.x, -b, b); a.vel.x *= -0.5; }
      if (a.pos.z > b || a.pos.z < -b) { a.pos.z = clamp(a.pos.z, -b, b); a.vel.z *= -0.5; }
    }

    function renderInstances() {
      // agents
      for (let i=0;i<agents.length;i++) {
        const a = agents[i];
        const isPlane = a.mode==='PLANE';

        dummy.position.set(a.pos.x, a.pos.y, a.pos.z);
        dummy.rotation.set(0, a.yaw, 0);

        if (a.isPlayer) {
          dummy.scale.set(isPlane ? 2.0 : 1.4, isPlane ? 0.65 : 1.1, isPlane ? 5.2 : 3.8);
        } else {
          dummy.scale.set(isPlane ? 1.7 : 1.0, isPlane ? 0.60 : 1.0, isPlane ? 4.2 : 3.0);
        }

        dummy.updateMatrix();
        carInst.setMatrixAt(i, dummy.matrix);
      }
      carInst.instanceMatrix.needsUpdate = true;
    }

    function updateCamera(dt) {
      if (!player) return;

      if (camMode === CAM.TOP) {
        const target = new THREE.Vector3(0, 520, 520);
        camera.position.lerp(target, 0.02);
        camera.lookAt(0,0,0);
      }
      else if (camMode === CAM.FOLLOW) {
        const behind = new THREE.Vector3(0, 25, -40);
        behind.applyAxisAngle(new THREE.Vector3(0,1,0), player.yaw);
        const target = player.pos.clone().add(behind);
        camera.position.lerp(target, 0.08);
        camera.lookAt(player.pos);
      }
      else { // ORBIT
        const t = performance.now()*0.00025;
        const r = 110;
        const target = player.pos.clone().add(new THREE.Vector3(Math.cos(t)*r, 60, Math.sin(t)*r));
        camera.position.lerp(target, 0.05);
        camera.lookAt(player.pos);
      }

      $('camLabel').textContent = camMode===CAM.TOP ? 'TOP' : camMode===CAM.FOLLOW ? 'FOLLOW' : 'ORBIT';
    }

    // ---------- BUTTONS ----------
    function setupUI() {
      $('pauseBtn').onclick = () => {
        paused = !paused;
        $('pauseBtn').textContent = paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
      };
      $('camBtn').onclick = () => cycleCamera();
      $('netBtn').onclick = () => {
        showNetwork = !showNetwork;
        $('netBtn').textContent = `üï∏Ô∏è Network Lines: ${showNetwork ? 'ON' : 'OFF'}`;
      };
      $('funBtn').onclick = () => markFunBoost();
      $('resetBtn').onclick = () => resetWorld();
    }

    // ---------- RESET ----------
    function resetWorld() {
      // clear scene items that rebuild
      if (edgeLines) scene.remove(edgeLines);
      edgeLines = null;
      edgeGeom = null;

      // pool + demo
      loadTokenPool();
      initDemo();

      // agents
      agents = [];
      player = newAgent(0, true);
      agents.push(player);
      for (let i=1;i<=CFG.AGENTS;i++) agents.push(newAgent(i, false));

      $('agents').textContent = agents.length;
      $('poolSize').textContent = poolSize();

      // lines
      makeEdgeLines();
      updateEdges();

      $('modeLabel').textContent = `PLAYER: ${player.mode}`;
    }

    // ---------- UTIL ----------
    function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }
    function clamp01(x){ return clamp(x, 0, 1); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    // ---------- MAIN ----------
    function animate() {
      requestAnimationFrame(animate);

      // fps
      fpsS.frames++;
      const now = performance.now();
      if (now - fpsS.t0 > 600) {
        fpsS.fps = Math.round((fpsS.frames * 1000) / (now - fpsS.t0));
        fpsS.frames = 0;
        fpsS.t0 = now;
        $('fps').textContent = fpsS.fps;
      }

      const dt = Math.min(clock.getDelta(), CFG.DT_CLAMP);
      if (!paused) step(dt);

      renderer.render(scene, camera);
    }

    // bootstrap
    function boot() {
      loadTokenPool();
      initDemo();
      buildRoads();
      initThree();
      buildGroundAndRoadMeshes();
      buildAgentsInst();
      makeEdgeLines();
      setupInput();
      setupUI();
      resetWorld();
      animate();
    }

    boot();
  })();
  </script>
</body>
</html>
