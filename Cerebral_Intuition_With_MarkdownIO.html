<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cerebral Intuition - Neural Biodome</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        #canvas { display: block; }
       
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
       
        #title {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 8px;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #00ffff, #ff00ff, #00ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s infinite;
        }
       
        @keyframes shimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
        }
       
        #subtitle {
            font-size: 0.9em;
            letter-spacing: 4px;
            opacity: 0.7;
        }
       
        #stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #00ffff;
            font-size: 0.8em;
            opacity: 0.6;
        }
       
        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #00ffff;
            font-size: 0.75em;
            text-align: right;
            opacity: 0.5;
        }
       
        #neural-activity {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            padding: 15px;
            background: rgba(0, 20, 40, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            color: #00ffff;
            font-size: 0.8em;
        }
       
        #neural-activity h3 {
            margin-bottom: 10px;
            font-weight: 300;
            letter-spacing: 2px;
        }
       
        .activity-bar {
            height: 4px;
            background: rgba(0, 255, 255, 0.2);
            margin: 8px 0;
            border-radius: 2px;
            overflow: hidden;
        }
       
        .activity-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            border-radius: 2px;
            transition: width 0.3s;
        }
       
        .activity-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            opacity: 0.8;
        }

        /* New scene controls styles */
        #scene-controls {
            position: fixed;
            top: 80px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .scene-btn {
            background: rgba(0, 20, 40, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px;
            color: #00ffff;
            padding: 8px 16px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 5px #00ffff;
        }

        .scene-btn:hover {
            background: rgba(0, 40, 80, 0.7);
            transform: scale(1.05);
        }

        #file-input {
            display: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="title">CEREBRAL INTUITION</div>
        <div id="subtitle">NEURAL BIODOME COLONY • TITAN ORBIT</div>
    </div>
   
    <div id="neural-activity">
        <h3>⚡ NEURAL ACTIVITY</h3>
        <div class="activity-label"><span>Synaptic Flow</span><span id="syn-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="syn-bar" style="width: 0%"></div></div>
        <div class="activity-label"><span>Consciousness Net</span><span id="con-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="con-bar" style="width: 0%"></div></div>
        <div class="activity-label"><span>Intuition Matrix</span><span id="int-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="int-bar" style="width: 0%"></div></div>
        <div class="activity-label"><span>Drone Swarm</span><span id="drone-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="drone-bar" style="width: 0%"></div></div>
    </div>
   
    <div id="stats">
        <div>Population: 12,847 minds</div>
        <div>Drones Active: <span id="drone-count">0</span></div>
        <div>Neural Sync: <span id="sync-rate">0</span>%</div>
    </div>
   
    <div id="controls">
        Drag to orbit • Scroll to zoom<br>
        Click domes to highlight
    </div>

    <!-- New scene controls -->
    <div id="scene-controls">
        <button class="scene-btn" id="new-btn">New Scene</button>
        <button class="scene-btn" id="save-btn">Save Scene</button>
        <button class="scene-btn" id="open-btn">Open Scene</button>
        <input type="file" id="file-input" accept=".md">
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);
        // Camera position
        camera.position.set(0, 8, 25);
        camera.lookAt(0, 5, 0);
        // Orbit controls (simple implementation)
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let spherical = { theta: 0, phi: Math.PI / 3, radius: 30 };
        document.addEventListener('mousedown', (e) => { isDragging = true; });
        document.addEventListener('mouseup', () => { isDragging = false; });
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                spherical.theta -= e.movementX * 0.005;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi - e.movementY * 0.005));
            }
        });
        document.addEventListener('wheel', (e) => {
            spherical.radius = Math.max(15, Math.min(60, spherical.radius + e.deltaY * 0.02));
        });
        // Starfield
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = [];
        const starColors = [];
        for (let i = 0; i < 10000; i++) {
            const r = 500 + Math.random() * 500;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            starPositions.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
            const color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.5, 0.5, 0.7 + Math.random() * 0.3);
            starColors.push(color.r, color.g, color.b);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
        const starsMaterial = new THREE.PointsMaterial({ size: 1.5, vertexColors: true, transparent: true, opacity: 0.8 });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
        // Saturn
        const saturnGroup = new THREE.Group();
        saturnGroup.position.set(-80, 40, -150);
       
        const saturnGeometry = new THREE.SphereGeometry(40, 64, 64);
        const saturnMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4a574,
            roughness: 0.8,
            metalness: 0.1
        });
        const saturn = new THREE.Mesh(saturnGeometry, saturnMaterial);
        saturnGroup.add(saturn);
        // Saturn rings
        const ringGeometry = new THREE.RingGeometry(50, 80, 128);
        const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0xc9b896,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6
        });
        const rings = new THREE.Mesh(ringGeometry, ringMaterial);
        rings.rotation.x = Math.PI / 2.2;
        saturnGroup.add(rings);
        scene.add(saturnGroup);
        // Main biodome
        const domeGroup = new THREE.Group();
       
        // Dome shell (glass)
        const domeGeometry = new THREE.SphereGeometry(12, 64, 32, 0, Math.PI * 2, 0, Math.PI / 2);
        const domeMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x88ccff,
            transparent: true,
            opacity: 0.15,
            roughness: 0.1,
            metalness: 0.2,
            clearcoat: 1,
            clearcoatRoughness: 0.1,
            side: THREE.DoubleSide
        });
        const dome = new THREE.Mesh(domeGeometry, domeMaterial);
        domeGroup.add(dome);
        // Dome frame rings
        for (let i = 1; i <= 5; i++) {
            const ringRadius = 12 * Math.sin((i / 6) * Math.PI / 2);
            const ringHeight = 12 * Math.cos((i / 6) * Math.PI / 2);
            const frameGeometry = new THREE.TorusGeometry(ringRadius, 0.05, 8, 64);
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.3
            });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.y = ringHeight;
            frame.rotation.x = Math.PI / 2;
            domeGroup.add(frame);
        }
        // Base platform
        const baseGeometry = new THREE.CylinderGeometry(13, 14, 1, 64);
        const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x334455, metalness: 0.8, roughness: 0.2 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -0.5;
        domeGroup.add(base);
        scene.add(domeGroup);
        // NEURAL BRAIN TREE - The centerpiece!
        const brainTreeGroup = new THREE.Group();
       
        // Tree trunk (neural stem)
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.8, 4, 16);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x4488ff,
            emissive: 0x2244aa,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 2;
        brainTreeGroup.add(trunk);
        // Brain lobes
        function createBrainLobe(x, y, z, scale, color) {
            const lobeGroup = new THREE.Group();
           
            // Main lobe shape
            const lobeGeometry = new THREE.SphereGeometry(1, 32, 32);
            lobeGeometry.scale(1.2, 0.8, 1);
            const lobeMaterial = new THREE.MeshPhysicalMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.4,
                transparent: true,
                opacity: 0.7,
                roughness: 0.3,
                metalness: 0.5,
                clearcoat: 0.5
            });
            const lobe = new THREE.Mesh(lobeGeometry, lobeMaterial);
            lobeGroup.add(lobe);
            // Convolution lines (brain folds)
            for (let i = 0; i < 8; i++) {
                const curvePoints = [];
                const startAngle = (i / 8) * Math.PI * 2;
                for (let t = 0; t <= 1; t += 0.1) {
                    curvePoints.push(new THREE.Vector3(
                        Math.cos(startAngle + t * 2) * (0.8 - t * 0.3),
                        (t - 0.5) * 1.2,
                        Math.sin(startAngle + t * 2) * (0.8 - t * 0.3)
                    ));
                }
                const curve = new THREE.CatmullRomCurve3(curvePoints);
                const tubeGeometry = new THREE.TubeGeometry(curve, 20, 0.03, 8, false);
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.6
                });
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                lobeGroup.add(tube);
            }
            lobeGroup.position.set(x, y, z);
            lobeGroup.scale.setScalar(scale);
            return lobeGroup;
        }
        // Create brain structure
        const brain = new THREE.Group();
        brain.add(createBrainLobe(-1, 0, 0, 1.5, 0x4488ff)); // Left hemisphere
        brain.add(createBrainLobe(1, 0, 0, 1.5, 0x8844ff)); // Right hemisphere
        brain.add(createBrainLobe(0, -0.5, 0.8, 0.8, 0xff44aa)); // Frontal
        brain.add(createBrainLobe(0, 0, -0.8, 0.7, 0x44ffaa)); // Occipital
        brain.position.y = 6;
        brain.scale.setScalar(1.2);
        brainTreeGroup.add(brain);
        // Neural pathways (glowing tendrils)
        const pathways = [];
        for (let i = 0; i < 20; i++) {
            const points = [];
            const startAngle = (i / 20) * Math.PI * 2;
            const height = 4 + Math.random() * 3;
           
            for (let t = 0; t <= 1; t += 0.05) {
                const spread = t * 2;
                points.push(new THREE.Vector3(
                    Math.cos(startAngle + t * 0.5) * spread + Math.sin(t * 5) * 0.2,
                    t * height,
                    Math.sin(startAngle + t * 0.5) * spread + Math.cos(t * 5) * 0.2
                ));
            }
           
            const curve = new THREE.CatmullRomCurve3(points);
            const geometry = new THREE.TubeGeometry(curve, 50, 0.02 + Math.random() * 0.03, 8, false);
            const hue = 0.5 + Math.random() * 0.3;
            const material = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(hue, 1, 0.5),
                transparent: true,
                opacity: 0.7
            });
            const pathway = new THREE.Mesh(geometry, material);
            pathway.userData = { phase: Math.random() * Math.PI * 2, speed: 0.5 + Math.random() };
            pathways.push(pathway);
            brainTreeGroup.add(pathway);
        }
        // Synaptic particles
        let synapseCount = 500;
        let synapseGeometry = new THREE.BufferGeometry();
        let synapsePositions = new Float32Array(synapseCount * 3);
        let synapseSpeeds = [];
        function initSynapses(count) {
            synapseCount = count;
            synapsePositions = new Float32Array(synapseCount * 3);
            synapseSpeeds = [];
            for (let i = 0; i < synapseCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 3;
                const height = Math.random() * 8;
                synapsePositions[i * 3] = Math.cos(angle) * radius;
                synapsePositions[i * 3 + 1] = height;
                synapsePositions[i * 3 + 2] = Math.sin(angle) * radius;
                synapseSpeeds.push({
                    angle: angle,
                    radius: radius,
                    speed: 0.5 + Math.random() * 1.5,
                    vertSpeed: (Math.random() - 0.5) * 0.5
                });
            }
            synapseGeometry.setAttribute('position', new THREE.BufferAttribute(synapsePositions, 3));
        }
        initSynapses(synapseCount);
       
        const synapseMaterial = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.15,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const synapses = new THREE.Points(synapseGeometry, synapseMaterial);
        brainTreeGroup.add(synapses);
        scene.add(brainTreeGroup);
        // Small domes (buildings)
        const smallDomes = [];
        const defaultDomePositions = [
            { x: -6, z: 3, scale: 0.8 },
            { x: 6, z: 3, scale: 0.7 },
            { x: -4, z: -5, scale: 0.6 },
            { x: 5, z: -4, scale: 0.75 },
            { x: -7, z: -2, scale: 0.5 },
            { x: 7, z: 0, scale: 0.55 },
            { x: 0, z: 7, scale: 0.65 },
            { x: 3, z: 6, scale: 0.5 }
        ];
        function createSmallDome(index, pos = {x: 0, z: 0}, scale = 0.5) {
            const smallDomeGroup = new THREE.Group();
           
            const sdGeometry = new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const sdMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xaaddff,
                transparent: true,
                opacity: 0.3,
                roughness: 0.1,
                metalness: 0.3,
                clearcoat: 1
            });
            const sdMesh = new THREE.Mesh(sdGeometry, sdMaterial);
            smallDomeGroup.add(sdMesh);
            // Base
            const sdBase = new THREE.Mesh(
                new THREE.CylinderGeometry(1.6, 1.7, 0.3, 32),
                new THREE.MeshStandardMaterial({ color: 0x556677, metalness: 0.7 })
            );
            sdBase.position.y = -0.15;
            smallDomeGroup.add(sdBase);
            // Interior glow
            const glowGeometry = new THREE.SphereGeometry(1, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(0.3 + index * 0.05, 0.8, 0.5),
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 0.3;
            smallDomeGroup.add(glow);
            smallDomeGroup.position.set(pos.x, 0, pos.z);
            smallDomeGroup.scale.setScalar(scale);
            smallDomeGroup.userData = { pulsePhase: Math.random() * Math.PI * 2 };
            return smallDomeGroup;
        }
        defaultDomePositions.forEach((pos, index) => {
            const dome = createSmallDome(index, pos, pos.scale);
            smallDomes.push(dome);
            scene.add(dome);
        });
        // Vegetation patches
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 3 + Math.random() * 8;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
           
            // Simple bush geometry
            const bushGeometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.4, 8, 8);
            const bushMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.7, 0.3 + Math.random() * 0.2),
                roughness: 0.8
            });
            const bush = new THREE.Mesh(bushGeometry, bushMaterial);
            bush.position.set(x, 0.2, z);
            bush.scale.y = 0.6 + Math.random() * 0.4;
            scene.add(bush);
        }
        // Drones
        const drones = [];
        function createDrone() {
            const droneGroup = new THREE.Group();
           
            // Drone body
            const bodyGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.3);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.9 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            droneGroup.add(body);
            // Rotors
            for (let r = 0; r < 4; r++) {
                const rotorGeometry = new THREE.TorusGeometry(0.1, 0.02, 8, 16);
                const rotorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const rotor = new THREE.Mesh(rotorGeometry, rotorMaterial);
                rotor.position.set(
                    (r % 2 === 0 ? 1 : -1) * 0.2,
                    0.05,
                    (r < 2 ? 1 : -1) * 0.2
                );
                rotor.rotation.x = Math.PI / 2;
                droneGroup.add(rotor);
            }
            // Light
            const lightGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.y = -0.1;
            droneGroup.add(light);
            // Random orbit parameters
            droneGroup.userData = {
                orbitRadius: 5 + Math.random() * 7,
                orbitHeight: 3 + Math.random() * 6,
                orbitSpeed: 0.2 + Math.random() * 0.3,
                orbitPhase: Math.random() * Math.PI * 2,
                bobSpeed: 1 + Math.random() * 2,
                bobAmount: 0.1 + Math.random() * 0.2
            };
            droneGroup.scale.setScalar(0.8);
            return droneGroup;
        }
        for (let i = 0; i < 15; i++) {
            const drone = createDrone();
            drones.push(drone);
            scene.add(drone);
        }
        // Floating holographic sign
        const signGroup = new THREE.Group();
        const signGeometry = new THREE.PlaneGeometry(4, 1);
        const signMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
        });
        const sign = new THREE.Mesh(signGeometry, signMaterial);
        signGroup.position.set(-5, 4, 2);
        signGroup.add(sign);
       
        // Sign border
        const borderGeometry = new THREE.EdgesGeometry(signGeometry);
        const borderMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const border = new THREE.LineSegments(borderGeometry, borderMaterial);
        signGroup.add(border);
        scene.add(signGroup);
        // People/robots (simplified figures)
        for (let i = 0; i < 20; i++) {
            const figureGroup = new THREE.Group();
           
            const isRobot = Math.random() > 0.5;
            const color = isRobot ? 0x88aacc : new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 0.5, 0.5);
           
            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.3, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: color, metalness: isRobot ? 0.8 : 0.1 });
            const figBody = new THREE.Mesh(bodyGeo, bodyMat);
            figBody.position.y = 0.25;
            figureGroup.add(figBody);
            // Head
            const headGeo = new THREE.SphereGeometry(0.06, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({
                color: isRobot ? 0xaaccee : 0xffcc99,
                metalness: isRobot ? 0.8 : 0.1
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.45;
            figureGroup.add(head);
            if (isRobot) {
                // Robot eye
                const eyeGeo = new THREE.SphereGeometry(0.02, 8, 8);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                const eye = new THREE.Mesh(eyeGeo, eyeMat);
                eye.position.set(0, 0.45, 0.05);
                figureGroup.add(eye);
            }
            const angle = Math.random() * Math.PI * 2;
            const radius = 2 + Math.random() * 9;
            figureGroup.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            );
            figureGroup.rotation.y = Math.random() * Math.PI * 2;
            figureGroup.scale.setScalar(0.8 + Math.random() * 0.4);
           
            scene.add(figureGroup);
        }
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x334466, 0.5);
        scene.add(ambientLight);
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(10, 20, 10);
        scene.add(mainLight);
        const brainLight = new THREE.PointLight(0x00ffff, 2, 20);
        brainLight.position.set(0, 6, 0);
        scene.add(brainLight);
        const purpleLight = new THREE.PointLight(0xff00ff, 1, 15);
        purpleLight.position.set(0, 8, 0);
        scene.add(purpleLight);
        // Ground plane
        const groundGeometry = new THREE.CircleGeometry(12, 64);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x223344,
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0.01;
        scene.add(ground);
        // Pathways on ground
        for (let i = 0; i < 8; i++) {
            const pathGeometry = new THREE.PlaneGeometry(0.3, 10);
            const pathMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.2
            });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.rotation.x = -Math.PI / 2;
            path.rotation.z = (i / 8) * Math.PI * 2;
            path.position.y = 0.02;
            scene.add(path);
        }
        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            // Update camera
            camera.position.x = Math.sin(spherical.theta) * Math.sin(spherical.phi) * spherical.radius;
            camera.position.y = Math.cos(spherical.phi) * spherical.radius;
            camera.position.z = Math.cos(spherical.theta) * Math.sin(spherical.phi) * spherical.radius;
            camera.lookAt(0, 5, 0);
            // Rotate brain slowly
            brain.rotation.y = time * 0.1;
            // Pulse brain light
            brainLight.intensity = 2 + Math.sin(time * 2) * 0.5;
            purpleLight.intensity = 1 + Math.sin(time * 2.5 + 1) * 0.3;
            // Animate pathways
            pathways.forEach((pathway, i) => {
                pathway.material.opacity = 0.4 + Math.sin(time * pathway.userData.speed + pathway.userData.phase) * 0.3;
            });
            // Animate synapses
            const positions = synapses.geometry.attributes.position.array;
            for (let i = 0; i < synapseCount; i++) {
                const s = synapseSpeeds[i];
                s.angle += s.speed * 0.01;
               
                positions[i * 3] = Math.cos(s.angle) * s.radius;
                positions[i * 3 + 1] += s.vertSpeed * 0.05;
                positions[i * 3 + 2] = Math.sin(s.angle) * s.radius;
                // Reset if too high or low
                if (positions[i * 3 + 1] > 8) positions[i * 3 + 1] = 0;
                if (positions[i * 3 + 1] < 0) positions[i * 3 + 1] = 8;
            }
            synapses.geometry.attributes.position.needsUpdate = true;
            // Animate drones
            drones.forEach((drone, i) => {
                const d = drone.userData;
                const angle = time * d.orbitSpeed + d.orbitPhase;
                drone.position.x = Math.cos(angle) * d.orbitRadius;
                drone.position.z = Math.sin(angle) * d.orbitRadius;
                drone.position.y = d.orbitHeight + Math.sin(time * d.bobSpeed) * d.bobAmount;
                drone.rotation.y = angle + Math.PI;
               
                // Rotor spin
                drone.children.forEach((child, ci) => {
                    if (ci > 0 && ci < 5) {
                        child.rotation.z = time * 20;
                    }
                });
            });
            // Pulse small domes
            smallDomes.forEach((dome, i) => {
                const pulse = Math.sin(time * 1.5 + dome.userData.pulsePhase) * 0.1 + 1;
                dome.children[2].material.opacity = 0.2 + Math.sin(time * 2 + i) * 0.1;
            });
            // Float the sign
            signGroup.position.y = 4 + Math.sin(time) * 0.2;
            signGroup.rotation.y = Math.sin(time * 0.5) * 0.1;
            // Slowly rotate Saturn
            saturn.rotation.y = time * 0.02;
            rings.rotation.z = time * 0.01;
            // Update UI
            const synVal = Math.floor(50 + Math.sin(time * 1.2) * 30 + Math.random() * 10);
            const conVal = Math.floor(60 + Math.sin(time * 0.8 + 1) * 25 + Math.random() * 8);
            const intVal = Math.floor(70 + Math.sin(time * 1.5 + 2) * 20 + Math.random() * 5);
            const droneVal = Math.floor(80 + Math.sin(time * 0.5) * 15);
           
            document.getElementById('syn-val').textContent = synVal + '%';
            document.getElementById('syn-bar').style.width = synVal + '%';
            document.getElementById('con-val').textContent = conVal + '%';
            document.getElementById('con-bar').style.width = conVal + '%';
            document.getElementById('int-val').textContent = intVal + '%';
            document.getElementById('int-bar').style.width = intVal + '%';
            document.getElementById('drone-val').textContent = droneVal + '%';
            document.getElementById('drone-bar').style.width = droneVal + '%';
           
            document.getElementById('drone-count').textContent = drones.length;
            document.getElementById('sync-rate').textContent = Math.floor((synVal + conVal + intVal) / 3);
            renderer.render(scene, camera);
        }
        animate();
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Save function (now to Markdown)
        function saveBiodomeState() {
            let mdContent = `# Neural Biodome Configuration Recipe\n\n`;
            mdContent += `**Saved at:** ${new Date().toISOString()}\n\n`;
            mdContent += `This README.md acts as a procedural recipe for configuring your Neural Biodome. `;
            mdContent += `Follow the sections below like steps in a recipe: edit tables and values to tweak the simulation. `;
            mdContent += `For example, add/remove rows in tables to change counts (e.g., more drones), adjust positions, scales, or other parameters. `;
            mdContent += `The app will recreate objects based on your changes when loading. Save often to create reproducible edit loops!\n\n`;

            // Globals section (as table)
            mdContent += `## Step 1: Set Global Parameters\n\n`;
            mdContent += `Adjust these overall settings. For example, change \`brain_scale\` to resize the brain model, or \`synapse_count\` to add more particles (they'll regenerate randomly).\n\n`;
            mdContent += `| Key | Value | Description |\n`;
            mdContent += `|-----|-------|-------------|\n`;
            mdContent += `| time | ${time.toFixed(3)} | Simulation time (usually leave as-is) |\n`;
            mdContent += `| camera_theta | ${spherical.theta.toFixed(3)} | Camera horizontal angle |\n`;
            mdContent += `| camera_phi | ${spherical.phi.toFixed(3)} | Camera vertical angle |\n`;
            mdContent += `| camera_radius | ${spherical.radius.toFixed(3)} | Camera distance |\n`;
            mdContent += `| brain_scale | ${brain.scale.x.toFixed(3)} | Scale of the brain structure (e.g., 1.5 for larger) |\n`;
            mdContent += `| population | 12847 | Population count (edit for display) |\n`;
            mdContent += `| synapse_count | ${synapseCount} | Number of synaptic particles (edit to change density) |\n\n`;

            // Drones section (as table)
            mdContent += `## Step 2: Configure Drones\n\n`;
            mdContent += `This table is your recipe for the drone swarm. `;
            mdContent += `- To change drone count: Add rows (copy an existing one, increment id sequentially from 0) or remove rows.\n`;
            mdContent += `- Tweak initial positions: Edit currentX/Y/Z to set starting points.\n`;
            mdContent += `- Adjust behavior: Change orbitRadius for wider paths, orbitSpeed for faster movement, etc.\n`;
            mdContent += `The app will recreate the swarm based on this table.\n\n`;
            mdContent += `| id | orbitRadius | orbitHeight | orbitSpeed | orbitPhase | bobSpeed | bobAmount | currentX | currentY | currentZ |\n`;
            mdContent += `|----|-------------|-------------|------------|------------|----------|-----------|----------|----------|----------|\n`;
            drones.forEach((drone, i) => {
                const ud = drone.userData;
                mdContent += `| ${i} | ${ud.orbitRadius.toFixed(3)} | ${ud.orbitHeight.toFixed(3)} | ${ud.orbitSpeed.toFixed(3)} | ${ud.orbitPhase.toFixed(3)} | ${ud.bobSpeed.toFixed(3)} | ${ud.bobAmount.toFixed(3)} | ${drone.position.x.toFixed(3)} | ${drone.position.y.toFixed(3)} | ${drone.position.z.toFixed(3)} |\n`;
            });
            mdContent += `\n`;

            // Small Domes section (as table)
            mdContent += `## Step 3: Configure Small Domes\n\n`;
            mdContent += `Recipe for the colony buildings. `;
            mdContent += `- Change count: Add/remove rows (increment id from 0).\n`;
            mdContent += `- Tweak positions: Edit posX/Z to move domes around the biodome.\n`;
            mdContent += `- Adjust size: Change scale for larger/smaller domes.\n`;
            mdContent += `- Phase: pulsePhase controls animation timing.\n`;
            mdContent += `Glow colors auto-adjust based on id order.\n\n`;
            mdContent += `| id | posX | posZ | scale | pulsePhase |\n`;
            mdContent += `|----|------|------|-------|------------|\n`;
            smallDomes.forEach((dome, i) => {
                mdContent += `| ${i} | ${dome.position.x.toFixed(3)} | ${dome.position.z.toFixed(3)} | ${dome.scale.x.toFixed(3)} | ${dome.userData.pulsePhase.toFixed(3)} |\n`;
            });
            mdContent += `\n`;

            // Download as .md
            const blob = new Blob([mdContent], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `NeuralBiodome_Recipe_${new Date().toISOString().slice(0,19)}.md`;
            a.click();
            URL.revokeObjectURL(url);
            console.log("✅ Recipe saved to Markdown");
        }

        // Parse Markdown function
        function parseMarkdown(text) {
            const sections = {};
            const lines = text.split('\n');
            let currentSection = null;
            let inTable = false;
            for (let line of lines) {
                line = line.trim();
                if (line.startsWith('## ')) {
                    currentSection = line.slice(3).trim().replace('Step 1: ', '').replace('Step 2: ', '').replace('Step 3: ', '');
                    sections[currentSection] = [];
                    inTable = false;
                } else if (currentSection && line.startsWith('|') && line.endsWith('|')) {
                    if (!inTable) {
                        // Header row
                        inTable = true;
                    }
                    const row = line.slice(1, -1).split('|').map(c => c.trim());
                    sections[currentSection].push(row);
                } else if (inTable && line.startsWith('|---')) {
                    // Separator row, skip
                } else {
                    inTable = false;
                }
            }

            // Process Globals
            const globals = {};
            const globalsTable = sections['Set Global Parameters'] || sections['Globals'] || [];
            if (globalsTable.length > 1) {
                const headers = globalsTable[0];
                for (let i = 1; i < globalsTable.length; i++) {
                    const row = globalsTable[i];
                    const keyIndex = headers.indexOf('Key');
                    const valueIndex = headers.indexOf('Value');
                    if (keyIndex !== -1 && valueIndex !== -1) {
                        globals[row[keyIndex]] = row[valueIndex];
                    }
                }
            }

            // Process Drones
            const dronesData = [];
            const dronesTable = sections['Configure Drones'] || sections['Drones'] || [];
            if (dronesTable.length > 1) {
                const headers = dronesTable[0];
                for (let i = 1; i < dronesTable.length; i++) {
                    const row = dronesTable[i];
                    const obj = {};
                    headers.forEach((h, j) => {
                        obj[h] = parseFloat(row[j]) || row[j];
                    });
                    dronesData.push(obj);
                }
            }

            // Process Small Domes
            const domesData = [];
            const domesTable = sections['Configure Small Domes'] || sections['Small Domes'] || [];
            if (domesTable.length > 1) {
                const headers = domesTable[0];
                for (let i = 1; i < domesTable.length; i++) {
                    const row = domesTable[i];
                    const obj = {};
                    headers.forEach((h, j) => {
                        obj[h] = parseFloat(row[j]) || row[j];
                    });
                    domesData.push(obj);
                }
            }

            return { globals, drones: dronesData, smallDomes: domesData };
        }

        // Load function (from Markdown)
        function loadBiodomeState(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const data = parseMarkdown(text);

                // Load Globals
                if (data.globals) {
                    time = parseFloat(data.globals.time) || 0;
                    spherical.theta = parseFloat(data.globals.camera_theta) || 0;
                    spherical.phi = parseFloat(data.globals.camera_phi) || Math.PI / 3;
                    spherical.radius = parseFloat(data.globals.camera_radius) || 30;
                    brain.scale.setScalar(parseFloat(data.globals.brain_scale) || 1.2);
                    const population = parseInt(data.globals.population) || 12847;
                    document.querySelector('#stats > div:first-child').textContent = `Population: ${population} minds`;
                    const newSynapseCount = parseInt(data.globals.synapse_count) || 500;
                    if (newSynapseCount !== synapseCount) {
                        brainTreeGroup.remove(synapses);
                        synapseGeometry.dispose();
                        initSynapses(newSynapseCount);
                        synapses.geometry = synapseGeometry;
                        brainTreeGroup.add(synapses);
                    }
                }

                // Load Drones (recreate based on table)
                while (drones.length > 0) {
                    scene.remove(drones.pop());
                }
                if (data.drones) {
                    data.drones.forEach((row) => {
                        const drone = createDrone();
                        Object.assign(drone.userData, {
                            orbitRadius: row.orbitRadius || 5 + Math.random() * 7,
                            orbitHeight: row.orbitHeight || 3 + Math.random() * 6,
                            orbitSpeed: row.orbitSpeed || 0.2 + Math.random() * 0.3,
                            orbitPhase: row.orbitPhase || Math.random() * Math.PI * 2,
                            bobSpeed: row.bobSpeed || 1 + Math.random() * 2,
                            bobAmount: row.bobAmount || 0.1 + Math.random() * 0.2
                        });
                        drone.position.set(row.currentX || 0, row.currentY || 3, row.currentZ || 0);
                        scene.add(drone);
                        drones.push(drone);
                    });
                }

                // Load Small Domes (recreate based on table)
                while (smallDomes.length > 0) {
                    scene.remove(smallDomes.pop());
                }
                if (data.smallDomes) {
                    data.smallDomes.forEach((row, i) => {
                        const dome = createSmallDome(i, {x: row.posX || 0, z: row.posZ || 0}, row.scale || 0.5);
                        dome.position.set(row.posX || 0, 0, row.posZ || 0);
                        dome.scale.setScalar(row.scale || 0.5);
                        dome.userData.pulsePhase = row.pulsePhase || Math.random() * Math.PI * 2;
                        scene.add(dome);
                        smallDomes.push(dome);
                    });
                }

                console.log("✅ Recipe loaded from Markdown!");
            };
            reader.readAsText(file);
        }

        // Reset/New Scene function
        function resetScene() {
            // Reset time
            time = 0;

            // Reset camera
            spherical = { theta: 0, phi: Math.PI / 3, radius: 30 };

            // Reset drones
            while (drones.length > 0) {
                scene.remove(drones.pop());
            }
            for (let i = 0; i < 15; i++) {
                const drone = createDrone();
                drones.push(drone);
                scene.add(drone);
            }

            // Reset small domes
            while (smallDomes.length > 0) {
                scene.remove(smallDomes.pop());
            }
            defaultDomePositions.forEach((pos, i) => {
                const dome = createSmallDome(i, pos, pos.scale);
                smallDomes.push(dome);
                scene.add(dome);
            });

            // Reset brain scale
            brain.scale.setScalar(1.2);

            // Reset synapses
            initSynapses(500);
            synapses.geometry.attributes.position.needsUpdate = true;

            // Reset population UI
            document.querySelector('#stats > div:first-child').textContent = 'Population: 12,847 minds';

            console.log("✅ New scene created (reset to initial state)");
        }

        // Button event listeners
        document.getElementById('new-btn').addEventListener('click', resetScene);
        document.getElementById('save-btn').addEventListener('click', saveBiodomeState);
        document.getElementById('open-btn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });
        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadBiodomeState(file);
            }
        });
    </script>
</body>
</html>
