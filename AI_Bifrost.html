<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bifrost-1 Inspired 3D Interactive Model Tuner</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        #controls { position: absolute; bottom: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        input { margin: 5px; }
    </style>
</head>
<body>
    <div id="info">
        <h3>Bifrost-1 Inspired 3D Model Tuner</h3>
        <p>Interactive demo visualizing a tunable 3D model. Use mouse to orbit, scroll to zoom. Adjust parameters below to morph the model in real-time, simulating latent space tuning with CLIP-like embeddings.</p>
    </div>
    <div id="controls">
        <label>Wave Amplitude: <input type="range" id="amplitude" min="0" max="5" value="1" step="0.1"></label><br>
        <label>Wave Frequency: <input type="range" id="frequency" min="1" max="10" value="3" step="0.1"></label><br>
        <label>Noise Scale: <input type="range" id="noise" min="0" max="2" value="0.5" step="0.1"></label>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // Model parameters (simulating latent tuners)
        let amplitude = 1;
        let frequency = 3;
        let noise = 0.5;

        // Create geometry
        let geometry = createTunedGeometry();
        const material = new THREE.MeshStandardMaterial({ color: 0x00ff88, wireframe: false });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        camera.position.z = 5;

        // Function to create/update geometry based on parameters
        function createTunedGeometry() {
            const geo = new THREE.PlaneGeometry(4, 4, 64, 64);
            const positions = geo.attributes.position.array;

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];

                // Wave distortion (simulating diffusion-like generation)
                const wave = Math.sin(x * frequency) * Math.cos(y * frequency) * amplitude;

                // Noise (simulating CLIP patch-level variations)
                const noiseValue = (Math.sin(x * 10 + Date.now() * 0.001) * Math.cos(y * 10)) * noise;

                positions[i + 2] = wave + noiseValue;
            }

            geo.attributes.position.needsUpdate = true;
            geo.computeVertexNormals();
            return geo;
        }

        // Update parameters
        document.getElementById('amplitude').addEventListener('input', (e) => {
            amplitude = parseFloat(e.target.value);
            updateModel();
        });
        document.getElementById('frequency').addEventListener('input', (e) => {
            frequency = parseFloat(e.target.value);
            updateModel();
        });
        document.getElementById('noise').addEventListener('input', (e) => {
            noise = parseFloat(e.target.value);
            updateModel();
        });

        function updateModel() {
            const newGeo = createTunedGeometry();
            mesh.geometry.dispose();
            mesh.geometry = newGeo;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
