<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thor Starship #7 - Advanced 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        .comic-title {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            color: #ff6b35;
            font-size: 3rem;
            font-weight: 900;
            text-shadow: 
                0 0 10px #ff6b35,
                3px 3px 0px #000, 
                -1px -1px 0px #000, 
                1px -1px 0px #000, 
                -1px 1px 0px #000;
            transform: skew(-5deg, -2deg);
            pointer-events: none;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            0% { text-shadow: 0 0 10px #ff6b35, 3px 3px 0px #000, -1px -1px 0px #000, 1px -1px 0px #000, -1px 1px 0px #000; }
            100% { text-shadow: 0 0 20px #ff6b35, 0 0 30px #ff6b35, 3px 3px 0px #000, -1px -1px 0px #000, 1px -1px 0px #000, -1px 1px 0px #000; }
        }

        .ui-frame {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 280px;
            height: 140px;
            border: 3px solid #00ffff;
            background: rgba(0, 0, 0, 0.95);
            font-family: 'Orbitron', monospace;
            color: #00ffff;
            padding: 15px;
            clip-path: polygon(0 0, 88% 0, 100% 25%, 100% 100%, 15% 100%, 0 75%);
            backdrop-filter: blur(10px);
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .ui-text {
            font-size: 0.85rem;
            line-height: 1.4;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            text-shadow: 0 0 5px #00ffff;
        }

        .ui-bar {
            width: 100%;
            height: 6px;
            background: #003333;
            margin: 6px 0;
            position: relative;
            border: 1px solid #00ffff;
            box-shadow: inset 0 0 5px rgba(0, 255, 255, 0.3);
        }

        .ui-bar::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #00ffff 0%, #0080ff 50%, #00ff80 100%);
            width: 89%;
            animation: powerLevel 3s ease-in-out infinite alternate;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        @keyframes powerLevel {
            0% { width: 75%; }
            100% { width: 95%; }
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 1.4rem;
            z-index: 100;
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body>
    <div class="comic-title">THOR #7</div>
    
    <div id="canvas-container">
        <div class="loading">Charging Mjolnir...</div>
    </div>
    
    <div class="ui-frame">
        <div class="ui-text">CHITAURI VESSEL ACQUIRED</div>
        <div class="ui-bar"></div>
        <div class="ui-text">POWER: 89% // ALL SYSTEMS OPTIMAL</div>
        <div class="ui-text">THOR COMMANDING</div>
        <div class="ui-text">MJOLNIR: FULLY CHARGED</div>
        <div class="ui-text">LIGHTNING: ACTIVE</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup with enhanced renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000008, 1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        document.querySelector('.loading').style.display = 'none';

        // Add fog for atmospheric depth
        scene.fog = new THREE.FogExp2(0x000020, 0.002);

        // Advanced lighting setup
        const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
        mainLight.position.set(20, 20, 10);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 4096;
        mainLight.shadow.mapSize.height = 4096;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 500;
        scene.add(mainLight);

        // Multiple colored rim lights
        const rimLight1 = new THREE.DirectionalLight(0x4080ff, 0.6);
        rimLight1.position.set(-15, 5, -10);
        scene.add(rimLight1);

        const rimLight2 = new THREE.DirectionalLight(0xff4080, 0.4);
        rimLight2.position.set(10, -10, 15);
        scene.add(rimLight2);

        // Lightning point lights
        const lightningLights = [];
        for (let i = 0; i < 3; i++) {
            const light = new THREE.PointLight(0x87ceeb, 3, 50);
            lightningLights.push(light);
            scene.add(light);
        }

        // Engine glow lights
        const engineLight1 = new THREE.PointLight(0x00ffff, 2, 30);
        const engineLight2 = new THREE.PointLight(0x00ffff, 2, 30);
        scene.add(engineLight1, engineLight2);

        // Create advanced starfield with multiple layers
        function createAdvancedStarfield() {
            const starsGroup = new THREE.Group();
            
            // Distant stars
            const distantStarsGeometry = new THREE.BufferGeometry();
            const distantStarsCount = 3000;
            const distantPositions = new Float32Array(distantStarsCount * 3);
            const distantColors = new Float32Array(distantStarsCount * 3);
            
            for (let i = 0; i < distantStarsCount; i++) {
                const i3 = i * 3;
                distantPositions[i3] = (Math.random() - 0.5) * 600;
                distantPositions[i3 + 1] = (Math.random() - 0.5) * 600;
                distantPositions[i3 + 2] = (Math.random() - 0.5) * 600;
                
                // Color variation for stars
                const temp = Math.random();
                if (temp > 0.8) {
                    distantColors[i3] = 1; distantColors[i3 + 1] = 0.8; distantColors[i3 + 2] = 0.6; // Orange
                } else if (temp > 0.6) {
                    distantColors[i3] = 0.8; distantColors[i3 + 1] = 0.8; distantColors[i3 + 2] = 1; // Blue
                } else {
                    distantColors[i3] = 1; distantColors[i3 + 1] = 1; distantColors[i3 + 2] = 1; // White
                }
            }
            
            distantStarsGeometry.setAttribute('position', new THREE.BufferAttribute(distantPositions, 3));
            distantStarsGeometry.setAttribute('color', new THREE.BufferAttribute(distantColors, 3));
            
            const distantStarsMaterial = new THREE.PointsMaterial({
                size: 2,
                transparent: true,
                opacity: 0.8,
                vertexColors: true,
                sizeAttenuation: true
            });
            
            const distantStars = new THREE.Points(distantStarsGeometry, distantStarsMaterial);
            starsGroup.add(distantStars);
            
            // Bright nearby stars
            for (let i = 0; i < 50; i++) {
                const starGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const starMaterial = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xffffff : 0x87ceeb,
                    transparent: true,
                    opacity: 0.8 + Math.random() * 0.2
                });
                const star = new THREE.Mesh(starGeometry, starMaterial);
                star.position.set(
                    (Math.random() - 0.5) * 400,
                    (Math.random() - 0.5) * 400,
                    (Math.random() - 0.5) * 400
                );
                starsGroup.add(star);
            }
            
            scene.add(starsGroup);
            return starsGroup;
        }

        // Create dynamic nebula clouds
        function createDynamicNebula() {
            const nebulaGroup = new THREE.Group();
            
            for (let i = 0; i < 5; i++) {
                const nebulaGeometry = new THREE.SphereGeometry(30 + Math.random() * 20, 16, 16);
                const nebulaMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.7, 0.7, 0.5),
                    transparent: true,
                    opacity: 0.05 + Math.random() * 0.1,
                    side: THREE.DoubleSide
                });
                
                const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                nebula.position.set(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 300 - 50
                );
                nebula.userData.rotationSpeed = (Math.random() - 0.5) * 0.002;
                nebulaGroup.add(nebula);
            }
            
            scene.add(nebulaGroup);
            return nebulaGroup;
        }

        // Create detailed Chitauri warship with organic curves
        function createAdvancedWarship() {
            const warshipGroup = new THREE.Group();
            
            // Main organic hull using custom geometry
            const hullPoints = [];
            for (let i = 0; i <= 20; i++) {
                const t = i / 20;
                const radius = 3 * Math.sin(Math.PI * t) + 1;
                hullPoints.push(new THREE.Vector2(radius, (t - 0.5) * 25));
            }
            const hullGeometry = new THREE.LatheGeometry(hullPoints, 12);
            
            const hullMaterial = new THREE.MeshPhongMaterial({
                color: 0x2a2a2a,
                shininess: 80,
                specular: 0x444444,
                transparent: true,
                opacity: 0.95
            });
            
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.rotation.z = Math.PI / 2;
            hull.castShadow = true;
            hull.receiveShadow = true;
            
            // Organic wings using curve geometry
            const wingCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-8, 0, 0),
                new THREE.Vector3(-4, 3, 0),
                new THREE.Vector3(4, 4, 0),
                new THREE.Vector3(12, 2, 0),
                new THREE.Vector3(15, 0, 0)
            ]);
            
            const wingGeometry = new THREE.TubeGeometry(wingCurve, 20, 0.8, 8, false);
            const wingMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333,
                shininess: 60
            });
            
            const topWing = new THREE.Mesh(wingGeometry, wingMaterial);
            topWing.position.y = 2;
            topWing.castShadow = true;
            
            const bottomWing = new THREE.Mesh(wingGeometry, wingMaterial);
            bottomWing.position.y = -2;
            bottomWing.rotation.x = Math.PI;
            bottomWing.castShadow = true;
            
            // Multiple engine pods with glow
            const engines = [];
            for (let i = 0; i < 6; i++) {
                const engineGeometry = new THREE.ConeGeometry(1, 3, 8);
                const engineMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.9
                });
                
                const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                const angle = (i / 6) * Math.PI * 2;
                engine.position.set(-10 + Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
                engine.rotation.z = -Math.PI / 2;
                engines.push(engine);
                warshipGroup.add(engine);
            }
            
            // Weapon emplacements
            for (let i = 0; i < 8; i++) {
                const weaponGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 8);
                const weaponMaterial = new THREE.MeshPhongMaterial({
                    color: 0x444444,
                    shininess: 100
                });
                const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
                const angle = (i / 8) * Math.PI * 2;
                weapon.position.set(Math.cos(angle) * 4, Math.sin(angle) * 4, Math.random() * 6 - 3);
                weapon.lookAt(10, 0, 0);
                warshipGroup.add(weapon);
            }
            
            warshipGroup.add(hull, topWing, bottomWing);
            warshipGroup.position.set(0, -8, -15);
            warshipGroup.userData.engines = engines;
            
            scene.add(warshipGroup);
            return warshipGroup;
        }

        // Create highly detailed Thor with better proportions
        function createDetailedThor() {
            const thorGroup = new THREE.Group();
            
            // Torso with muscle definition
            const torsoGeometry = new THREE.CylinderGeometry(1.8, 2.2, 5, 12);
            const torsoMaterial = new THREE.MeshPhongMaterial({
                color: 0xcc0000,
                shininess: 30,
                specular: 0x444444
            });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.castShadow = true;
            
            // Detailed head with better geometry
            const headGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({
                color: 0xffdbac,
                shininess: 20
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 4;
            head.castShadow = true;
            
            // Hair using multiple small geometries
            const hairGroup = new THREE.Group();
            for (let i = 0; i < 20; i++) {
                const hairGeometry = new THREE.SphereGeometry(0.3, 6, 6);
                const hairMaterial = new THREE.MeshLambertMaterial({ color: 0xffd700 });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                const angle = (i / 20) * Math.PI * 2;
                hair.position.set(
                    Math.cos(angle) * 1.1,
                    0.3 + Math.random() * 0.4,
                    Math.sin(angle) * 1.1
                );
                hairGroup.add(hair);
            }
            hairGroup.position.y = 4.5;
            
            // Animated cape with multiple segments
            const capeSegments = [];
            for (let i = 0; i < 6; i++) {
                const capeGeometry = new THREE.PlaneGeometry(4, 2);
                const capeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x990000,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9
                });
                const capeSegment = new THREE.Mesh(capeGeometry, capeMaterial);
                capeSegment.position.set(0, 2 - i * 1.5, -1 - i * 0.2);
                capeSegment.rotation.x = 0.1 + i * 0.05;
                capeSegments.push(capeSegment);
                thorGroup.add(capeSegment);
            }
            
            // Detailed arms with joints
            const createArm = (side) => {
                const armGroup = new THREE.Group();
                
                // Upper arm
                const upperArmGeometry = new THREE.CylinderGeometry(0.6, 0.7, 3, 10);
                const armMaterial = new THREE.MeshPhongMaterial({ color: 0xffdbac });
                const upperArm = new THREE.Mesh(upperArmGeometry, armMaterial);
                upperArm.position.y = 1;
                upperArm.castShadow = true;
                
                // Lower arm
                const lowerArm = new THREE.Mesh(upperArmGeometry, armMaterial);
                lowerArm.position.y = -2;
                lowerArm.scale.y = 0.8;
                lowerArm.castShadow = true;
                
                // Hand
                const handGeometry = new THREE.SphereGeometry(0.5, 10, 10);
                const hand = new THREE.Mesh(handGeometry, armMaterial);
                hand.position.y = -4;
                hand.castShadow = true;
                
                armGroup.add(upperArm, lowerArm, hand);
                armGroup.position.x = side * 2.5;
                armGroup.position.y = 2;
                armGroup.rotation.z = side * -0.3;
                
                return armGroup;
            };
            
            const leftArm = createArm(-1);
            const rightArm = createArm(1);
            
            // Legs
            const createLeg = (side) => {
                const legGroup = new THREE.Group();
                
                const upperLegGeometry = new THREE.CylinderGeometry(0.8, 0.9, 4, 10);
                const legMaterial = new THREE.MeshPhongMaterial({ color: 0xffdbac });
                const upperLeg = new THREE.Mesh(upperLegGeometry, legMaterial);
                upperLeg.position.y = -1;
                upperLeg.castShadow = true;
                
                const lowerLeg = new THREE.Mesh(upperLegGeometry, legMaterial);
                lowerLeg.position.y = -5;
                lowerLeg.scale.y = 0.9;
                lowerLeg.castShadow = true;
                
                const bootGeometry = new THREE.BoxGeometry(1.2, 1, 2);
                const bootMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
                const boot = new THREE.Mesh(bootGeometry, bootMaterial);
                boot.position.y = -8;
                boot.position.z = 0.5;
                boot.castShadow = true;
                
                legGroup.add(upperLeg, lowerLeg, boot);
                legGroup.position.x = side * 1.2;
                legGroup.position.y = -3;
                
                return legGroup;
            };
            
            const leftLeg = createLeg(-1);
            const rightLeg = createLeg(1);
            
            thorGroup.add(torso, head, hairGroup, leftArm, rightArm, leftLeg, rightLeg);
            thorGroup.position.set(0, 2, 0);
            thorGroup.userData.capeSegments = capeSegments;
            thorGroup.userData.arms = { left: leftArm, right: rightArm };
            
            scene.add(thorGroup);
            return thorGroup;
        }

        // Create legendary Mjolnir with runic details
        function createLegendaryMjolnir() {
            const mjolnirGroup = new THREE.Group();
            
            // Main hammer head with detailed geometry
            const hammerGeometry = new THREE.BoxGeometry(4, 2.5, 2.5);
            const hammerMaterial = new THREE.MeshPhongMaterial({
                color: 0xc0c0c0,
                shininess: 150,
                specular: 0x888888,
                emissive: 0x001122,
                emissiveIntensity: 0.2
            });
            const hammer = new THREE.Mesh(hammerGeometry, hammerMaterial);
            hammer.castShadow = true;
            
            // Runic inscriptions (simplified as surface details)
            for (let i = 0; i < 6; i++) {
                const runeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.3);
                const runeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x4488ff,
                    transparent: true,
                    opacity: 0.8
                });
                const rune = new THREE.Mesh(runeGeometry, runeMaterial);
                rune.position.set(
                    -1.5 + (i * 0.6),
                    1.3,
                    0
                );
                mjolnirGroup.add(rune);
            }
            
            // Ornate handle with wrapping
            const handleGeometry = new THREE.CylinderGeometry(0.25, 0.25, 6, 12);
            const handleMaterial = new THREE.MeshPhongMaterial({
                color: 0x8b4513,
                shininess: 40
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0, -4, 0);
            handle.castShadow = true;
            
            // Handle wrapping details
            for (let i = 0; i < 8; i++) {
                const wrapGeometry = new THREE.TorusGeometry(0.3, 0.05, 4, 8);
                const wrapMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
                const wrap = new THREE.Mesh(wrapGeometry, wrapMaterial);
                wrap.position.set(0, -2 - i * 0.5, 0);
                wrap.rotation.x = Math.PI / 2;
                mjolnirGroup.add(wrap);
            }
            
            // Pommel
            const pommelGeometry = new THREE.SphereGeometry(0.4, 12, 12);
            const pommel = new THREE.Mesh(pommelGeometry, hammerMaterial);
            pommel.position.set(0, -7, 0);
            pommel.castShadow = true;
            
            mjolnirGroup.add(hammer, handle, pommel);
            mjolnirGroup.position.set(4, 3, 3);
            mjolnirGroup.rotation.z = 0.5;
            
            scene.add(mjolnirGroup);
            return mjolnirGroup;
        }

        // Advanced lightning particle system
        function createAdvancedLightning() {
            const lightningGroup = new THREE.Group();
            const lightningBolts = [];
            
            // Multiple lightning branches
            for (let i = 0; i < 15; i++) {
                const points = [];
                const segments = 8 + Math.floor(Math.random() * 6);
                
                for (let j = 0; j < segments; j++) {
                    const t = j / (segments - 1);
                    const x = t * 8 + (Math.random() - 0.5) * 2;
                    const y = (Math.random() - 0.5) * 4;
                    const z = (Math.random() - 0.5) * 4;
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const boltGeometry = new THREE.TubeGeometry(curve, segments * 2, 0.05, 4, false);
                const boltMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.55 + Math.random() * 0.1, 1, 0.8),
                    transparent: true,
                    opacity: 0.9
                });
                
                const bolt = new THREE.Mesh(boltGeometry, boltMaterial);
                bolt.position.set(2, 1, 1);
                lightningBolts.push(bolt);
                lightningGroup.add(bolt);
            }
            
            scene.add(lightningGroup);
            return { group: lightningGroup, bolts: lightningBolts };
        }

        // Advanced particle systems
        function createParticleSystems() {
            const particleSystems = [];
            
            // Engine trail particles
            const engineTrailGeometry = new THREE.BufferGeometry();
            const engineTrailCount = 1000;
            const enginePositions = new Float32Array(engineTrailCount * 3);
            const engineVelocities = new Float32Array(engineTrailCount * 3);
            const engineColors = new Float32Array(engineTrailCount * 3);
            
            for (let i = 0; i < engineTrailCount; i++) {
                const i3 = i * 3;
                enginePositions[i3] = -20 + Math.random() * 40;
                enginePositions[i3 + 1] = -8 + Math.random() * 4;
                enginePositions[i3 + 2] = -15 + Math.random() * 10;
                
                engineVelocities[i3] = -0.2 - Math.random() * 0.3;
                engineVelocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
                engineVelocities[i3 + 2] = (Math.random() - 0.5) * 0.1;
                
                engineColors[i3] = 0.2 + Math.random() * 0.8;
                engineColors[i3 + 1] = 0.8 + Math.random() * 0.2;
                engineColors[i3 + 2] = 1;
            }
            
            engineTrailGeometry.setAttribute('position', new THREE.BufferAttribute(enginePositions, 3));
            engineTrailGeometry.setAttribute('color', new THREE.BufferAttribute(engineColors, 3));
            
            const engineTrailMaterial = new THREE.PointsMaterial({
                size: 0.8,
                transparent: true,
                opacity: 0.6,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const engineTrail = new THREE.Points(engineTrailGeometry, engineTrailMaterial);
            engineTrail.userData = { velocities: engineVelocities };
            particleSystems.push(engineTrail);
            scene.add(engineTrail);
            
            // Magic dust around Thor
            const magicDustGeometry = new THREE.BufferGeometry();
            const dustCount = 300;
            const dustPositions = new Float32Array(dustCount * 3);
            const dustColors = new Float32Array(dustCount * 3);
            
            for (let i = 0; i < dustCount; i++) {
                const i3 = i * 3;
                const radius = 2 + Math.random() * 6;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                dustPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                dustPositions[i3 + 1] = 2 + radius * Math.cos(phi);
                dustPositions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
                
                dustColors[i3] = 1;
                dustColors[i3 + 1] = 0.8 + Math.random() * 0.2;
                dustColors[i3 + 2] = 0.2 + Math.random() * 0.3;
            }
            
            magicDustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
            magicDustGeometry.setAttribute('color', new THREE.BufferAttribute(dustColors, 3));
            
            const magicDustMaterial = new THREE.PointsMaterial({
                size: 1.2,
                transparent: true,
                opacity: 0.7,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            const magicDust = new THREE.Points(magicDustGeometry, magicDustMaterial);
            particleSystems.push(magicDust);
            scene.add(magicDust);
            
            return particleSystems;
        }

        // Initialize all advanced scene objects
        const stars = createAdvancedStarfield();
        const nebulas = createDynamicNebula();
        const warship = createAdvancedWarship();
        const thor = createDetailedThor();
        const mjolnir = createLegendaryMjolnir();
        const lightning = createAdvancedLightning();
        const particleSystems = createParticleSystems();

        // Enhanced camera setup
        camera.position.set(15, 8, 20);
        camera.lookAt(0, 0, 0);

        // Animation variables
        let time = 0;
        const clock = new THREE.Clock();

        // Advanced animation loop
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            time += deltaTime;
            
            // Smooth starfield rotation
            stars.rotation.y += 0.0003;
            stars.rotation.x += 0.0001;
            
            // Dynamic nebula animation
            nebulas.children.forEach((nebula, index) => {
                nebula.rotation.x += nebula.userData.rotationSpeed;
                nebula.rotation.y += nebula.userData.rotationSpeed * 0.7;
                nebula.material.opacity = 0.05 + Math.sin(time * (0.5 + index * 0.2)) * 0.03;
            });
            
            // Advanced warship movement with organic motion
            warship.position.y = -8 + Math.sin(time * 0.6) * 1.2;
            warship.position.x = Math.sin(time * 0.3) * 2;
            warship.rotation.z = Math.sin(time * 0.4) * 0.1;
            warship.rotation.x = Math.sin(time * 0.5) * 0.05;
            
            // Engine effects
            if (warship.userData.engines) {
                warship.userData.engines.forEach((engine, index) => {
                    engine.material.opacity = 0.7 + Math.sin(time * 3 + index) * 0.3;
                    engine.scale.z = 1 + Math.sin(time * 4 + index) * 0.3;
                });
            }
            
            // Engine light positioning
            engineLight1.position.set(-10, -6, -15);
            engineLight2.position.set(-10, -10, -15);
            engineLight1.intensity = 1.5 + Math.sin(time * 3) * 0.5;
            engineLight2.intensity = 1.5 + Math.sin(time * 3.2) * 0.5;
            
            // Complex Thor animation with inverse kinematics-like arm movement
            thor.position.y = 2 + Math.sin(time * 1.1) * 0.8;
            thor.rotation.y = Math.sin(time * 0.2) * 0.15;
            
            // Animated cape with realistic flow
            if (thor.userData.capeSegments) {
                thor.userData.capeSegments.forEach((segment, index) => {
                    segment.rotation.x = 0.1 + index * 0.05 + Math.sin(time * 2 + index * 0.5) * 0.1;
                    segment.position.x = Math.sin(time * 1.5 + index * 0.3) * 0.5;
                });
            }
            
            // Arm animation reaching toward Mjolnir
            if (thor.userData.arms) {
                const armReach = Math.sin(time * 0.8) * 0.3;
                thor.userData.arms.right.rotation.z = -0.3 + armReach;
                thor.userData.arms.right.rotation.y = armReach * 0.5;
            }
            
            // Mjolnir complex motion
            mjolnir.position.y = 3 + Math.sin(time * 1.8) * 0.6;
            mjolnir.position.x = 4 + Math.sin(time * 1.3) * 0.8;
            mjolnir.rotation.y += 0.02;
            mjolnir.rotation.z = 0.5 + Math.sin(time * 1.6) * 0.2;
            
            // Advanced lightning system
            lightning.bolts.forEach((bolt, index) => {
                const flickerTime = time * 10 + index * 0.5;
                bolt.visible = Math.sin(flickerTime) > 0.3;
                bolt.material.opacity = Math.random() > 0.4 ? 0.9 : 0.3;
                bolt.scale.setScalar(0.8 + Math.random() * 0.4);
                
                // Color variation
                bolt.material.color.setHSL(
                    0.55 + Math.sin(time * 2 + index) * 0.1,
                    1,
                    0.7 + Math.random() * 0.3
                );
            });
            
            // Lightning lights animation
            lightningLights.forEach((light, index) => {
                light.position.set(
                    4 + Math.sin(time * 3 + index) * 2,
                    3 + Math.cos(time * 2.5 + index) * 1.5,
                    3 + Math.sin(time * 2 + index) * 1
                );
                light.intensity = Math.random() > 0.6 ? 3 : 0;
            });
            
            // Particle system updates
            particleSystems.forEach((system, systemIndex) => {
                const positions = system.geometry.attributes.position.array;
                
                if (systemIndex === 0) { // Engine trail
                    const velocities = system.userData.velocities;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += velocities[i];
                        positions[i + 1] += velocities[i + 1];
                        positions[i + 2] += velocities[i + 2];
                        
                        if (positions[i] < -50) {
                            positions[i] = 20;
                            positions[i + 1] = -8 + Math.random() * 4;
                            positions[i + 2] = -15 + Math.random() * 10;
                        }
                    }
                } else if (systemIndex === 1) { // Magic dust
                    for (let i = 0; i < positions.length; i += 3) {
                        const index = i / 3;
                        const radius = 4 + Math.sin(time + index * 0.1) * 2;
                        const theta = time * 0.5 + index * 0.1;
                        const phi = time * 0.3 + index * 0.05;
                        
                        positions[i] = radius * Math.sin(phi) * Math.cos(theta);
                        positions[i + 1] = 2 + radius * Math.cos(phi) * 0.5;
                        positions[i + 2] = radius * Math.sin(phi) * Math.sin(theta);
                    }
                }
                
                system.geometry.attributes.position.needsUpdate = true;
            });
            
            // Dynamic camera with cinematic movement
            const cameraRadius = 25 + Math.sin(time * 0.3) * 5;
            const cameraHeight = 8 + Math.sin(time * 0.2) * 4;
            camera.position.x = Math.cos(time * 0.1) * cameraRadius;
            camera.position.z = Math.sin(time * 0.1) * cameraRadius;
            camera.position.y = cameraHeight;
            
            // Look at Thor with slight offset for drama
            const lookTarget = new THREE.Vector3(
                Math.sin(time * 0.5) * 2,
                Math.sin(time * 0.3) * 1,
                0
            );
            camera.lookAt(lookTarget);
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start the epic animation
        animate();
    </script>
</body>
</html>
