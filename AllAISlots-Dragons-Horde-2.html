<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dragon's Horde MEGA SLOTS - 5x5 Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Arial Black', sans-serif;
            background: radial-gradient(ellipse at center, #8b0000 0%, #0a0a0a 100%);
            overflow: hidden;
            touch-action: pan-x pan-y;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #game-container {
            position: fixed;
            width: 100vw;
            height: 100vh;
            display: grid;
            grid-template-rows: auto auto 1fr;
            gap: 0;
            padding: 0;
        }
        #canvas-3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            pointer-events: none;
        }
        #particles-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
            pointer-events: none;
        }
        #leprechaun {
            position: fixed;
            bottom: 10%;
            left: 5%;
            width: 150px;
            height: 150px;
            z-index: 50;
            pointer-events: none;
            font-size: 120px;
            animation: leprechaunBounce 2s ease-in-out infinite;
            filter: drop-shadow(0 10px 20px rgba(255,0,0,0.5));
        }
        @keyframes leprechaunBounce {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }
        .header {
            background: linear-gradient(180deg, #ff8c00 0%, #b22222 100%);
            border-bottom: 6px solid #4a2d18;
            padding: 8px 10px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.8), inset 0 -3px 10px rgba(0,0,0,0.3);
            position: relative;
            z-index: 20;
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .header h1 {
            color: #ffffff;
            font-size: clamp(16px, 3.5vw, 28px);
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px rgba(255,69,0,0.8);
            margin: 0;
            letter-spacing: 1px;
            animation: titleGlow 2s ease-in-out infinite;
            flex: 1 1 auto;
            min-width: 200px;
            text-align: center;
        }
        @keyframes titleGlow {
            0%, 100% { text-shadow: 3px 3px 6px rgba(0,0,0,0.5), 0 0 20px rgba(255,69,0,0.8); }
            50% { text-shadow: 3px 3px 6px rgba(0,0,0,0.5), 0 0 40px rgba(255,69,0,1); }
        }
        .header-left, .header-right {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }
        .balance-display {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
        }
        .balance-item {
            background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(74,45,24,0.5));
            padding: 4px 10px;
            border-radius: 10px;
            color: #ff8c00;
            font-size: clamp(11px, 2.2vw, 14px);
            border: 2px solid rgba(255,69,0,0.5);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
            white-space: nowrap;
        }
        .balance-item span {
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #ff8c00;
        }
        .accumulation-piles {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .pile {
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(74,45,24,0.6));
            border: 2px solid #ff8c00;
            border-radius: 10px;
            padding: 4px 8px;
            text-align: center;
            box-shadow: 
                0 3px 10px rgba(0,0,0,0.7),
                inset 0 2px 5px rgba(255,69,0,0.2);
            transition: transform 0.3s ease;
            min-width: 70px;
        }
        .pile:hover {
            transform: scale(1.05);
        }
        .pile.pulse {
            animation: pilePulse 0.6s ease;
        }
        @keyframes pilePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); box-shadow: 0 0 30px rgba(255,69,0,0.8); }
        }
        .pile-label {
            color: #ff8c00;
            font-size: clamp(9px, 1.8vw, 11px);
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        .pile-amount {
            color: white;
            font-size: clamp(12px, 2.5vw, 16px);
            font-weight: bold;
            text-shadow: 0 0 10px #ff8c00;
        }
        .pile-icon {
            font-size: clamp(18px, 4vw, 24px);
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.5));
        }
        .controls-section {
            background: linear-gradient(180deg, #3d2817 0%, #291c12 100%);
            border-bottom: 4px solid #4a2d18;
            padding: 8px 10px;
            position: relative;
            z-index: 20;
            box-shadow: 0 5px 15px rgba(0,0,0,0.6);
        }
        .controls {
            display: flex;
            justify-content: center;
            align-items: stretch;
            gap: 8px;
            flex-wrap: nowrap;
            max-width: 900px;
            margin: 0 auto;
        }
        .btn {
            padding: clamp(8px, 1.8vh, 14px) clamp(12px, 2.5vw, 20px);
            font-size: clamp(12px, 2.8vw, 16px);
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 
                0 4px 12px rgba(0,0,0,0.5),
                inset 0 2px 5px rgba(255,255,255,0.3);
            transition: all 0.2s ease;
            touch-action: manipulation;
            user-select: none;
            position: relative;
            overflow: hidden;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            white-space: nowrap;
        }
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        .btn:hover::before {
            left: 100%;
        }
        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: linear-gradient(135deg, #ff4500, #ff8c00);
            color: white;
            flex: 1;
            min-width: 80px;
        }
        .btn-secondary {
            background: linear-gradient(135deg, #4169e1, #1e90ff);
            color: white;
            flex: 1;
            min-width: 80px;
        }
        .btn-tertiary {
            background: linear-gradient(135deg, #228b22, #32cd32);
            color: white;
            flex: 1;
            min-width: 80px;
        }
        .btn.active {
            animation: btnPulse 1s ease-in-out infinite;
        }
        @keyframes btnPulse {
            0%, 100% { box-shadow: 0 4px 12px rgba(0,0,0,0.5), 0 0 20px rgba(255,69,0,0.5); }
            50% { box-shadow: 0 4px 12px rgba(0,0,0,0.5), 0 0 30px rgba(255,69,0,0.8); }
        }
        .game-area {
            position: relative;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            overflow-y: auto;
        }
        .slot-machine {
            background: linear-gradient(135deg, rgba(74,45,24,0.95), rgba(26,13,0,0.95));
            border: 8px solid #ff8c00;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 
                0 10px 50px rgba(0,0,0,0.8),
                inset 0 0 30px rgba(255,69,0,0.3);
            max-width: 600px;
            width: 100%;
        }
        .reels-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }
        .reel {
            background: linear-gradient(180deg, rgba(0,0,0,0.8), rgba(74,45,24,0.4));
            border: 3px solid #ff8c00;
            border-radius: 12px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            box-shadow: inset 0 4px 10px rgba(0,0,0,0.7);
        }
        .symbol {
            font-size: clamp(28px, 6vw, 48px);
            text-align: center;
            padding: clamp(4px, 1vh, 8px);
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            transition: all 0.3s ease;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
            position: relative;
        }
        .symbol.locked {
            background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,140,0,0.3));
            border: 3px solid #FFD700;
            box-shadow: 0 0 20px rgba(255,215,0,0.8), inset 0 0 10px rgba(255,215,0,0.3);
            animation: lockedPulse 1.5s ease-in-out infinite;
        }
        @keyframes lockedPulse {
            0%, 100% { 
                box-shadow: 0 0 20px rgba(255,215,0,0.8), inset 0 0 10px rgba(255,215,0,0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 35px rgba(255,215,0,1), inset 0 0 15px rgba(255,215,0,0.5);
                transform: scale(1.05);
            }
        }
        .symbol.locked::after {
            content: '🔒';
            position: absolute;
            top: -8px;
            right: -8px;
            font-size: 16px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8));
        }
        .symbol.wildcard {
            background: linear-gradient(135deg, rgba(138,43,226,0.4), rgba(75,0,130,0.4));
            animation: wildcardGlow 1s ease-in-out infinite;
        }
        @keyframes wildcardGlow {
            0%, 100% { box-shadow: 0 0 15px rgba(138,43,226,0.8); }
            50% { box-shadow: 0 0 30px rgba(138,43,226,1); }
        }
        .symbol.winning {
            animation: symbolWin 0.8s ease-in-out;
            background: linear-gradient(135deg, rgba(255,215,0,0.5), rgba(255,69,0,0.5));
        }
        @keyframes symbolWin {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.2) rotate(-5deg); }
            75% { transform: scale(1.2) rotate(5deg); }
        }
        .symbol.spinning {
            animation: symbolSpin 0.1s linear infinite;
        }
        @keyframes symbolSpin {
            0% { transform: translateY(0); opacity: 1; }
            50% { opacity: 0.5; }
            100% { transform: translateY(-20px); opacity: 0; }
        }
        .message-display {
            position: fixed;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(74,45,24,0.95));
            border: 4px solid #ff8c00;
            border-radius: 20px;
            padding: 20px 40px;
            font-size: clamp(20px, 4vw, 36px);
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 20px rgba(255,215,0,0.8);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            box-shadow: 0 10px 50px rgba(0,0,0,0.9), 0 0 50px rgba(255,69,0,0.5);
            text-align: center;
            max-width: 90vw;
        }
        .message-display.show {
            opacity: 1;
        }
        #bonus-indicator {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translate(-50%, 0) scale(0);
            background: linear-gradient(135deg, rgba(255,69,0,0.95), rgba(255,140,0,0.95));
            border: 6px solid #FFD700;
            border-radius: 30px;
            padding: 30px 50px;
            font-size: clamp(28px, 5vw, 56px);
            font-weight: bold;
            color: white;
            text-shadow: 0 0 30px rgba(255,215,0,1);
            z-index: 150;
            pointer-events: none;
            transition: transform 0.5s ease;
            box-shadow: 0 20px 80px rgba(0,0,0,0.9), 0 0 100px rgba(255,69,0,0.8);
            text-align: center;
        }
        #bonus-indicator.active {
            transform: translate(-50%, 0) scale(1);
            animation: bonusBounce 0.5s ease 0.5s;
        }
        @keyframes bonusBounce {
            0%, 100% { transform: translate(-50%, 0) scale(1); }
            50% { transform: translate(-50%, 0) scale(1.1); }
        }
        #free-spins-indicator {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(138,43,226,0.95), rgba(75,0,130,0.95));
            border: 4px solid #FFD700;
            border-radius: 20px;
            padding: 15px 30px;
            font-size: clamp(18px, 4vw, 32px);
            font-weight: bold;
            color: white;
            text-shadow: 0 0 20px rgba(255,215,0,0.8);
            z-index: 100;
            pointer-events: none;
            display: none;
            box-shadow: 0 10px 40px rgba(0,0,0,0.9), 0 0 40px rgba(138,43,226,0.8);
            animation: freeSpinsPulse 2s ease-in-out infinite;
        }
        #free-spins-indicator.active {
            display: block;
        }
        @keyframes freeSpinsPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }
        .win-line {
            position: absolute;
            background: rgba(255,215,0,0.3);
            border: 2px solid #FFD700;
            pointer-events: none;
            z-index: 5;
            animation: winLinePulse 1s ease-in-out infinite;
        }
        @keyframes winLinePulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="canvas-3d"></canvas>
    <canvas id="particles-canvas"></canvas>
    <div id="leprechaun">🐉</div>
    
    <div id="game-container">
        <div class="header">
            <div class="header-content">
                <div class="header-left">
                    <div class="balance-display">
                        <div class="balance-item">
                            Balance: <span id="balance">10000</span>¢
                        </div>
                        <div class="balance-item">
                            Bet: <span id="bet">50</span>¢
                        </div>
                    </div>
                </div>
                <h1>🐉 DRAGON'S HORDE 🐉</h1>
                <div class="header-right">
                    <div class="accumulation-piles">
                        <div class="pile">
                            <div class="pile-icon">🥚</div>
                            <div class="pile-label">Eggs</div>
                            <div class="pile-amount" id="pile-gold">0</div>
                        </div>
                        <div class="pile">
                            <div class="pile-icon">🔥</div>
                            <div class="pile-label">Flames</div>
                            <div class="pile-amount" id="pile-ruby">0</div>
                        </div>
                        <div class="pile">
                            <div class="pile-icon">💎</div>
                            <div class="pile-label">Gems</div>
                            <div class="pile-amount" id="pile-emerald">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls-section">
            <div class="controls">
                <button id="btn-spin" class="btn btn-primary">🎰 SPIN</button>
                <button id="btn-bet" class="btn btn-secondary">💰 BET</button>
                <button id="btn-autoplay" class="btn btn-tertiary">⚡ AUTO</button>
            </div>
        </div>
        
        <div class="game-area">
            <div class="slot-machine">
                <div class="reels-container" id="reels-container"></div>
            </div>
        </div>
    </div>
    
    <div id="message-display" class="message-display"></div>
    <div id="bonus-indicator">
        🎊 FREE SPINS! 🎊
        <div style="font-size: 0.5em; margin-top: 10px;">
            <span id="bonus-spins-count">0</span> SPINS REMAINING
        </div>
    </div>
    <div id="free-spins-indicator">
        🌟 FREE SPINS: <span id="free-spins-remaining">0</span> 🌟
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        const gameState = {
            balance: 10000,
            bet: 50,
            betOptions: [10, 25, 50, 100, 250, 500],
            currentBetIndex: 2,
            isSpinning: false,
            autoPlay: false,
            autoPlayCount: 0,
            piles: { gold: 0, ruby: 0, emerald: 0 },
            freeSpinsMode: false,
            freeSpinsRemaining: 0,
            freeSpinsWinnings: 0, // Track total winnings during free spins
            lockedSymbols: [], // Track locked positions during free spins
            reelSymbols: [] // Current reel state
        };
        
        // Symbols with wildcard
        const symbols = [
            '🐉', '🥚', '🔥', '💰', '💎', 
            '🗡️', '🛡️', '👑', '🏆', '⭐'
        ];
        
        const symbolWeights = {
            '🐉': 8, '🥚': 12, '🔥': 12, '💰': 10, '💎': 10,
            '🗡️': 10, '🛡️': 10, '👑': 8, '🏆': 8, '⭐': 5 // Wildcard is rare
        };
        
        const symbolValues = {
            '🐉': 500, '👑': 300, '🏆': 250, '💰': 150, '💎': 150,
            '🔥': 100, '🗡️': 80, '🛡️': 80, '🥚': 50, '⭐': 0 // Wildcard has no value itself
        };
        
        // Three.js Setup
        let scene, camera, renderer, coins = [];
        
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas-3d'),
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0xffd700, 1, 100);
            pointLight.position.set(0, 0, 10);
            scene.add(pointLight);
            
            animate3D();
        }
        
        function animate3D() {
            requestAnimationFrame(animate3D);
            
            coins.forEach((coin, index) => {
                coin.position.y -= coin.userData.speed;
                coin.rotation.x += 0.1;
                coin.rotation.y += 0.1;
                
                if (coin.position.y < -6) {
                    scene.remove(coin);
                    coins.splice(index, 1);
                }
            });
            
            renderer.render(scene, camera);
        }
        
        function createCoin(x, y, color) {
            const geometry = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 32);
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                shininess: 100,
                emissive: color,
                emissiveIntensity: 0.3
            });
            const coin = new THREE.Mesh(geometry, material);
            
            const worldX = (x / window.innerWidth) * 10 - 5;
            const worldY = -(y / window.innerHeight) * 10 + 5;
            
            coin.position.set(worldX, worldY, 0);
            coin.userData.speed = Math.random() * 0.05 + 0.02;
            
            scene.add(coin);
            coins.push(coin);
        }
        
        // 2D Particles
        const particlesCanvas = document.getElementById('particles-canvas');
        const particlesCtx = particlesCanvas.getContext('2d');
        particlesCanvas.width = window.innerWidth;
        particlesCanvas.height = window.innerHeight;
        
        let particles2D = [];
        
        function createParticle2D(x, y, color, size) {
            particles2D.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8 - 2,
                color: color,
                size: size,
                life: 1.0
            });
        }
        
        function animateParticles2D() {
            particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
            
            particles2D.forEach((p, index) => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3;
                p.life -= 0.02;
                
                if (p.life <= 0) {
                    particles2D.splice(index, 1);
                    return;
                }
                
                particlesCtx.globalAlpha = p.life;
                particlesCtx.fillStyle = p.color;
                particlesCtx.beginPath();
                particlesCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                particlesCtx.fill();
            });
            
            particlesCtx.globalAlpha = 1.0;
            requestAnimationFrame(animateParticles2D);
        }
        animateParticles2D();
        
        // Sound effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'spin':
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'win':
                    oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'bigwin':
                    for (let i = 0; i < 3; i++) {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.setValueAtTime(400 + i * 200, audioContext.currentTime + i * 0.1);
                        gain.gain.setValueAtTime(0.2, audioContext.currentTime + i * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.1 + 0.3);
                        osc.start(audioContext.currentTime + i * 0.1);
                        osc.stop(audioContext.currentTime + i * 0.1 + 0.3);
                    }
                    break;
                case 'click':
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;
                case 'bonus':
                    for (let i = 0; i < 5; i++) {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.setValueAtTime(300 + i * 150, audioContext.currentTime + i * 0.08);
                        gain.gain.setValueAtTime(0.25, audioContext.currentTime + i * 0.08);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.08 + 0.4);
                        osc.start(audioContext.currentTime + i * 0.08);
                        osc.stop(audioContext.currentTime + i * 0.08 + 0.4);
                    }
                    break;
            }
        }
        
        // Initialize reels
        function createReels() {
            const container = document.getElementById('reels-container');
            container.innerHTML = '';
            gameState.reelSymbols = [];
            
            for (let col = 0; col < 5; col++) {
                const reel = document.createElement('div');
                reel.className = 'reel';
                reel.dataset.reel = col;
                
                const columnSymbols = [];
                for (let row = 0; row < 5; row++) {
                    const symbol = document.createElement('div');
                    symbol.className = 'symbol';
                    symbol.dataset.row = row;
                    symbol.dataset.col = col;
                    symbol.textContent = getRandomSymbol();
                    reel.appendChild(symbol);
                    columnSymbols.push(symbol.textContent);
                }
                
                container.appendChild(reel);
                gameState.reelSymbols.push(columnSymbols);
            }
        }
        
        function getRandomSymbol() {
            const totalWeight = Object.values(symbolWeights).reduce((a, b) => a + b, 0);
            let random = Math.random() * totalWeight;
            
            for (const [symbol, weight] of Object.entries(symbolWeights)) {
                random -= weight;
                if (random <= 0) return symbol;
            }
            return symbols[0];
        }
        
        // Update UI
        function updateUI() {
            document.getElementById('balance').textContent = gameState.balance;
            document.getElementById('bet').textContent = gameState.bet;
            document.getElementById('pile-gold').textContent = gameState.piles.gold;
            document.getElementById('pile-ruby').textContent = gameState.piles.ruby;
            document.getElementById('pile-emerald').textContent = gameState.piles.emerald;
            
            if (gameState.freeSpinsMode) {
                document.getElementById('free-spins-remaining').textContent = gameState.freeSpinsRemaining;
            }
        }
        
        // Show message
        function showMessage(text, color) {
            const msgDisplay = document.getElementById('message-display');
            msgDisplay.textContent = text;
            msgDisplay.style.color = color;
            msgDisplay.classList.add('show');
            
            setTimeout(() => {
                msgDisplay.classList.remove('show');
            }, 2500);
        }
        
        // Spin function
        async function spin() {
            if (gameState.isSpinning) return;
            
            // Check balance (free spins don't cost)
            if (!gameState.freeSpinsMode && gameState.balance < gameState.bet) {
                showMessage('Insufficient balance!', '#FF0000');
                return;
            }
            
            gameState.isSpinning = true;
            
            // Deduct bet if not in free spins mode
            if (!gameState.freeSpinsMode) {
                gameState.balance -= gameState.bet;
                updateUI();
            }
            
            playSound('spin');
            
            // Disable buttons during spin
            document.getElementById('btn-spin').disabled = true;
            document.getElementById('btn-bet').disabled = true;
            
            // Animate reels
            await animateReels();
            
            // Check for wins
            const { totalWin, winningCombos, hasFourMatch } = checkWins();
            
            if (totalWin > 0) {
                gameState.balance += totalWin;
                
                // Highlight winning symbols
                highlightWins(winningCombos);
                
                if (totalWin >= gameState.bet * 10) {
                    playSound('bigwin');
                    showMessage(`🔥 MEGA WIN! +${totalWin}¢ 🔥`, '#FFD700');
                    spawnCoins(totalWin);
                } else {
                    playSound('win');
                    showMessage(`WIN! +${totalWin}¢`, '#00FF00');
                }
                
                // Update piles
                updatePiles(winningCombos);
                
                // Check for free spins trigger (need 4+ in a row)
                if (!gameState.freeSpinsMode && hasFourMatch) {
                    setTimeout(() => {
                        triggerFreeSpins();
                    }, 1500);
                }
            }
            
            // Handle free spins
            if (gameState.freeSpinsMode) {
                // Track winnings during free spins
                if (totalWin > 0) {
                    gameState.freeSpinsWinnings += totalWin;
                }
                
                gameState.freeSpinsRemaining--;
                updateUI();
                
                // Lock winning symbols during free spins (only 4+ matches)
                const fourPlusMatches = winningCombos.filter(c => c.count >= 4);
                if (fourPlusMatches.length > 0) {
                    lockWinningSymbols(fourPlusMatches);
                    showMessage(`🔒 SYMBOLS LOCKED! 🔒`, '#FFD700');
                }
                
                // End free spins when counter reaches 0
                if (gameState.freeSpinsRemaining <= 0) {
                    setTimeout(() => {
                        endFreeSpins();
                    }, 2000);
                }
            }
            
            updateUI();
            
            // Re-enable buttons
            document.getElementById('btn-spin').disabled = false;
            if (!gameState.freeSpinsMode) {
                document.getElementById('btn-bet').disabled = false;
            }
            
            gameState.isSpinning = false;
            
            // Auto-play
            if (gameState.autoPlay && gameState.autoPlayCount > 0) {
                gameState.autoPlayCount--;
                if (gameState.autoPlayCount > 0 && gameState.balance >= gameState.bet) {
                    setTimeout(() => spin(), 1500);
                } else {
                    gameState.autoPlay = false;
                    document.getElementById('btn-autoplay').classList.remove('active');
                }
            }
        }
        
        // Animate reels spinning
        function animateReels() {
            return new Promise(resolve => {
                const reels = document.querySelectorAll('.reel');
                let completed = 0;
                
                reels.forEach((reel, reelIndex) => {
                    const symbols = reel.querySelectorAll('.symbol');
                    
                    // Don't spin locked symbols during free spins
                    if (gameState.freeSpinsMode) {
                        const allLocked = Array.from(symbols).every(s => s.classList.contains('locked'));
                        if (allLocked) {
                            completed++;
                            if (completed === reels.length) resolve();
                            return;
                        }
                    }
                    
                    symbols.forEach(symbol => {
                        if (!symbol.classList.contains('locked')) {
                            symbol.classList.add('spinning');
                        }
                    });
                    
                    const spinDuration = 1000 + reelIndex * 200;
                    let spinInterval;
                    let spinCount = 0;
                    
                    spinInterval = setInterval(() => {
                        symbols.forEach((symbol, row) => {
                            if (!symbol.classList.contains('locked')) {
                                symbol.textContent = getRandomSymbol();
                            }
                        });
                        spinCount++;
                    }, 100);
                    
                    setTimeout(() => {
                        clearInterval(spinInterval);
                        
                        // Set final symbols
                        symbols.forEach((symbol, row) => {
                            if (!symbol.classList.contains('locked')) {
                                symbol.classList.remove('spinning');
                                const newSymbol = getRandomSymbol();
                                symbol.textContent = newSymbol;
                                gameState.reelSymbols[reelIndex][row] = newSymbol;
                                
                                if (newSymbol === '⭐') {
                                    symbol.classList.add('wildcard');
                                } else {
                                    symbol.classList.remove('wildcard');
                                }
                            }
                        });
                        
                        completed++;
                        if (completed === reels.length) {
                            resolve();
                        }
                    }, spinDuration);
                });
            });
        }
        
        // Check for winning combinations
        function checkWins() {
            const wins = [];
            let totalWin = 0;
            let hasFourMatch = false;
            
            // Check horizontal lines (all 5 rows)
            for (let row = 0; row < 5; row++) {
                const line = [];
                for (let col = 0; col < 5; col++) {
                    line.push({ row, col, symbol: gameState.reelSymbols[col][row] });
                }
                const lineWin = checkLine(line);
                if (lineWin.win > 0) {
                    wins.push(lineWin);
                    totalWin += lineWin.win;
                    if (lineWin.count >= 4) hasFourMatch = true;
                }
            }
            
            // Check vertical lines (all 5 columns)
            for (let col = 0; col < 5; col++) {
                const line = [];
                for (let row = 0; row < 5; row++) {
                    line.push({ row, col, symbol: gameState.reelSymbols[col][row] });
                }
                const lineWin = checkLine(line);
                if (lineWin.win > 0) {
                    wins.push(lineWin);
                    totalWin += lineWin.win;
                    if (lineWin.count >= 4) hasFourMatch = true;
                }
            }
            
            // Check diagonals (top-left to bottom-right)
            const diag1 = [];
            for (let i = 0; i < 5; i++) {
                diag1.push({ row: i, col: i, symbol: gameState.reelSymbols[i][i] });
            }
            const diag1Win = checkLine(diag1);
            if (diag1Win.win > 0) {
                wins.push(diag1Win);
                totalWin += diag1Win.win;
                if (diag1Win.count >= 4) hasFourMatch = true;
            }
            
            // Check diagonals (top-right to bottom-left)
            const diag2 = [];
            for (let i = 0; i < 5; i++) {
                diag2.push({ row: i, col: 4 - i, symbol: gameState.reelSymbols[4 - i][i] });
            }
            const diag2Win = checkLine(diag2);
            if (diag2Win.win > 0) {
                wins.push(diag2Win);
                totalWin += diag2Win.win;
                if (diag2Win.count >= 4) hasFourMatch = true;
            }
            
            return { totalWin, winningCombos: wins, hasFourMatch };
        }
        
        // Check a single line for wins
        function checkLine(line) {
            // Find the most common non-wildcard symbol
            const symbolCounts = {};
            
            line.forEach(pos => {
                const symbol = pos.symbol;
                if (symbol !== '⭐') {
                    if (!symbolCounts[symbol]) {
                        symbolCounts[symbol] = 0;
                    }
                    symbolCounts[symbol]++;
                }
            });
            
            // Find which symbol appears most (this is what wildcards will match)
            let targetSymbol = null;
            let maxCount = 0;
            
            for (const [symbol, count] of Object.entries(symbolCounts)) {
                if (count > maxCount) {
                    maxCount = count;
                    targetSymbol = symbol;
                }
            }
            
            // If no target symbol found (all wildcards), use first wildcard
            if (!targetSymbol && line.some(pos => pos.symbol === '⭐')) {
                targetSymbol = '⭐';
            }
            
            if (!targetSymbol) {
                return { win: 0, positions: [] };
            }
            
            // Count how many positions match the target symbol (including wildcards)
            const matchingPositions = [];
            let matchCount = 0;
            
            line.forEach(pos => {
                if (pos.symbol === targetSymbol || pos.symbol === '⭐') {
                    matchingPositions.push(pos);
                    matchCount++;
                }
            });
            
            // Need at least 3 matches
            if (matchCount >= 3) {
                const value = symbolValues[targetSymbol] || 50;
                let multiplier = matchCount === 3 ? 1 : matchCount === 4 ? 3 : 10;
                
                // Bonus multiplier during free spins
                if (gameState.freeSpinsMode) {
                    multiplier *= 2;
                }
                
                const win = value * multiplier * (gameState.bet / 50);
                
                return {
                    win: Math.floor(win),
                    symbol: targetSymbol,
                    count: matchCount,
                    positions: matchingPositions
                };
            }
            
            return { win: 0, positions: [] };
        }
        
        // Highlight winning symbols
        function highlightWins(winningCombos) {
            winningCombos.forEach(combo => {
                combo.positions.forEach(pos => {
                    const symbol = document.querySelector(`[data-row="${pos.row}"][data-col="${pos.col}"]`);
                    if (symbol) {
                        symbol.classList.add('winning');
                        setTimeout(() => symbol.classList.remove('winning'), 1500);
                    }
                });
            });
        }
        
        // Lock winning symbols during free spins
        function lockWinningSymbols(winningCombos) {
            winningCombos.forEach(combo => {
                combo.positions.forEach(pos => {
                    const symbol = document.querySelector(`[data-row="${pos.row}"][data-col="${pos.col}"]`);
                    if (symbol && !symbol.classList.contains('locked')) {
                        symbol.classList.add('locked');
                        gameState.lockedSymbols.push({ row: pos.row, col: pos.col, symbol: pos.symbol });
                    }
                });
            });
        }
        
        // Count specific symbol on reels
        function countSymbolOnReels(targetSymbol) {
            let count = 0;
            for (let col = 0; col < 5; col++) {
                for (let row = 0; row < 5; row++) {
                    if (gameState.reelSymbols[col][row] === targetSymbol) {
                        count++;
                    }
                }
            }
            return count;
        }
        
        // Update accumulation piles
        function updatePiles(winningCombos) {
            winningCombos.forEach(combo => {
                if (combo.symbol === '🥚') {
                    gameState.piles.gold += combo.count;
                    triggerPileAnimation('gold');
                } else if (combo.symbol === '🔥') {
                    gameState.piles.ruby += combo.count;
                    triggerPileAnimation('ruby');
                } else if (combo.symbol === '💎') {
                    gameState.piles.emerald += combo.count;
                    triggerPileAnimation('emerald');
                }
            });
        }
        
        function triggerPileAnimation(type) {
            const pile = document.querySelector(`#pile-${type}`).closest('.pile');
            pile.classList.add('pulse');
            setTimeout(() => pile.classList.remove('pulse'), 600);
        }
        
        // Spawn coin particles
        function spawnCoins(amount) {
            const types = ['gold', 'ruby', 'emerald'];
            const colors = {
                gold: 0xFFD700,
                ruby: 0xFF4500,
                emerald: 0x00FF7F
            };
            
            const type = types[Math.floor(Math.random() * types.length)];
            const rect = document.querySelector('.slot-machine').getBoundingClientRect();
            
            for (let i = 0; i < Math.min(30, amount / 10); i++) {
                setTimeout(() => {
                    createCoin(
                        rect.left + rect.width / 2 + (Math.random() - 0.5) * rect.width,
                        rect.top + rect.height / 2,
                        colors[type]
                    );
                    createParticle2D(
                        rect.left + rect.width / 2 + (Math.random() - 0.5) * rect.width,
                        rect.top + rect.height / 2,
                        '#FFD700',
                        Math.random() * 4 + 2
                    );
                }, i * 50);
            }
        }
        
        // Free Spins Feature
        function triggerFreeSpins() {
            gameState.freeSpinsMode = true;
            gameState.freeSpinsRemaining = 3; // Always 3 spins total
            gameState.freeSpinsWinnings = 0; // Reset winnings tracker
            gameState.lockedSymbols = [];
            
            playSound('bonus');
            
            const indicator = document.getElementById('bonus-indicator');
            const freeSpinsIndicator = document.getElementById('free-spins-indicator');
            
            indicator.classList.add('active');
            document.getElementById('bonus-spins-count').textContent = gameState.freeSpinsRemaining;
            
            setTimeout(() => {
                indicator.classList.remove('active');
                freeSpinsIndicator.classList.add('active');
                document.getElementById('free-spins-remaining').textContent = gameState.freeSpinsRemaining;
                document.getElementById('btn-bet').disabled = true;
                
                showMessage(`🌟 3 FREE SPINS! GET 4+ TO LOCK! 🌟`, '#FFD700');
            }, 2500);
        }
        
        function endFreeSpins() {
            const totalWinnings = gameState.freeSpinsWinnings;
            
            // Disable spin button during transition
            document.getElementById('btn-spin').disabled = true;
            
            // Show completion message with total winnings
            if (totalWinnings > 0) {
                playSound('bigwin');
                showMessage(`🎊 FREE SPINS COMPLETE! WON ${totalWinnings}¢! 🎊`, '#FFD700');
            } else {
                showMessage(`FREE SPINS COMPLETE!`, '#FF8C00');
            }
            
            setTimeout(() => {
                // Reset free spins state
                gameState.freeSpinsMode = false;
                gameState.freeSpinsWinnings = 0;
                gameState.lockedSymbols = [];
                
                // Hide free spins indicator
                document.getElementById('free-spins-indicator').classList.remove('active');
                
                // Re-enable bet button
                document.getElementById('btn-bet').disabled = false;
                
                // Clear all locked symbols
                document.querySelectorAll('.symbol.locked').forEach(symbol => {
                    symbol.classList.remove('locked');
                });
                
                // Create fresh reels for next spin
                createReels();
                
                // Re-enable spin button
                document.getElementById('btn-spin').disabled = false;
                gameState.isSpinning = false;
            }, 3000);
        }
        
        // Event Listeners
        document.getElementById('btn-spin').addEventListener('click', spin);
        
        document.getElementById('btn-bet').addEventListener('click', () => {
            playSound('click');
            gameState.currentBetIndex = (gameState.currentBetIndex + 1) % gameState.betOptions.length;
            gameState.bet = gameState.betOptions[gameState.currentBetIndex];
            updateUI();
        });
        
        document.getElementById('btn-autoplay').addEventListener('click', () => {
            playSound('click');
            gameState.autoPlay = !gameState.autoPlay;
            
            if (gameState.autoPlay) {
                gameState.autoPlayCount = 10;
                document.getElementById('btn-autoplay').classList.add('active');
                if (!gameState.isSpinning) {
                    spin();
                }
            } else {
                gameState.autoPlayCount = 0;
                document.getElementById('btn-autoplay').classList.remove('active');
            }
        });
        
        // Resize handler
        window.addEventListener('resize', () => {
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            particlesCanvas.width = window.innerWidth;
            particlesCanvas.height = window.innerHeight;
        });
        
        // Initialize
        initThreeJS();
        createReels();
        updateUI();
        
        setTimeout(() => {
            showMessage('🐉 Welcome to Dragon\'s Horde! 🐉', '#FF4500');
        }, 500);
        
        console.log('🐉 Dragon\'s Horde MEGA SLOTS - 5x5 Edition loaded! 🐉');
        console.log('Features: 5x5 Grid, Wilds (⭐), Free Spins on 4+ Match!');
        console.log('Free Spins: Get 4-in-a-row → 3 Free Spins. 4+ wins during free spins lock symbols!');
    </script>
</body>
</html>
