<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ðŸŽµ Musical Simon â€“ Audio Fixed</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; background:#0b1020; font-family: system-ui; }
    canvas { display: block; }

    #overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.85);
      z-index: 10;
      color: white;
      text-align: center;
    }

    #overlay button {
      font-size: 18px;
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      background: #7dd3fc;
      font-weight: bold;
    }
  </style>
</head>
<body>

<div id="overlay">
  <div>
    <h2>ðŸŽ§ Musical Simon</h2>
    <p>Click once to enable audio</p>
    <button id="enableAudio">ðŸ”Š Enable Audio</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.min.js"></script>
<script>
/* ===============================
   THREE.JS SCENE
================================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b1020);

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  100
);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(5, 10, 5);
scene.add(dir);

/* ===============================
   AUDIO (FIXED)
================================ */
let audioCtx = null;

function getAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return audioCtx;
}

async function unlockAudio() {
  const ctx = getAudioCtx();
  if (ctx.state !== "running") {
    await ctx.resume();
  }
  console.log("Audio state:", ctx.state);
}

function playNote(freq) {
  const ctx = getAudioCtx();

  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = "sine";
  osc.frequency.value = freq;

  const t = ctx.currentTime;
  gain.gain.setValueAtTime(0.0001, t);
  gain.gain.exponentialRampToValueAtTime(0.25, t + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.35);

  osc.connect(gain);
  gain.connect(ctx.destination);

  osc.start(t);
  osc.stop(t + 0.36);
}

/* ===============================
   NOTES / SPHERES
================================ */
const notes = [
  { freq: 261.63, color: 0xff5555, x: -3 }, // C
  { freq: 329.63, color: 0x55ff55, x: -1 }, // E
  { freq: 392.00, color: 0x5555ff, x:  1 }, // G
  { freq: 523.25, color: 0xffff55, x:  3 }  // C5
];

const spheres = [];
const materials = [];

notes.forEach((n, i) => {
  const geo = new THREE.SphereGeometry(1, 32, 32);
  const mat = new THREE.MeshStandardMaterial({
    color: n.color,
    emissive: 0x000000
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.x = n.x;
  mesh.userData.index = i;

  scene.add(mesh);
  spheres.push(mesh);
  materials.push(mat);
});

/* ===============================
   GAME LOGIC
================================ */
let sequence = [];
let player = [];
let isPlaying = false;

function flash(i) {
  materials[i].emissive.setHex(notes[i].color);
  setTimeout(() => materials[i].emissive.setHex(0x000000), 300);
}

function addStep() {
  sequence.push(Math.floor(Math.random() * notes.length));
}

function playSequence() {
  isPlaying = true;
  let i = 0;

  const interval = setInterval(() => {
    if (i >= sequence.length) {
      clearInterval(interval);
      isPlaying = false;
      return;
    }
    const idx = sequence[i];
    playNote(notes[idx].freq);
    flash(idx);
    i++;
  }, 600);
}

function startGame() {
  sequence = [];
  player = [];
  addStep();
  playSequence();
}

function checkInput(i) {
  if (isPlaying) return;

  player.push(i);
  playNote(notes[i].freq);
  flash(i);

  if (player[player.length - 1] !== sequence[player.length - 1]) {
    alert("âŒ Wrong! Restarting.");
    startGame();
    return;
  }

  if (player.length === sequence.length) {
    player = [];
    addStep();
    setTimeout(playSequence, 800);
  }
}

/* ===============================
   INTERACTION
================================ */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("click", (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const hits = raycaster.intersectObjects(spheres);
  if (hits.length) {
    checkInput(hits[0].object.userData.index);
  }
});

/* ===============================
   AUDIO UNLOCK BUTTON
================================ */
document.getElementById("enableAudio").addEventListener("click", async () => {
  await unlockAudio();
  document.getElementById("overlay").remove();
  startGame();
});

/* ===============================
   RENDER LOOP
================================ */
function animate() {
  requestAnimationFrame(animate);
  spheres.forEach(s => s.rotation.y += 0.01);
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
