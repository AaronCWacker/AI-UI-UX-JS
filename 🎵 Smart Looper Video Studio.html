<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>‚ú® üéµ Smart Looper Video Studio</title>
  <style>
    /* --- CSS RESET & BASICS --- */
    * { box-sizing: border-box; }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #0d0d0d;
      color: #e0e0e0;
      margin: 0;
      padding: 0;
      height: 100vh;
      width: 100vw;
      overflow: hidden; /* Prevent body scroll, handle internally */
    }

    /* --- MAIN GRID LAYOUT --- */
    .app-layout {
      display: grid;
      grid-template-columns: 1fr 400px;
      grid-template-rows: 100%;
      height: 100vh;
      width: 100%;
    }

    /* --- LEFT: STAGE / PREVIEW AREA --- */
    .stage-area {
      background-color: #000;
      background-image: radial-gradient(#1a1a1a 1px, transparent 1px);
      background-size: 20px 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      position: relative;
      padding: 20px;
      overflow: hidden;
    }

    .canvas-wrapper {
      position: relative;
      max-width: 100%;
      max-height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 0 50px rgba(0,0,0,0.8);
    }

    canvas {
      /* This ensures the visual display fits the screen, 
         while internal resolution remains high for recording */
      max-width: 100%;
      max-height: 90vh;
      width: auto;
      height: auto;
      object-fit: contain;
      background: #000;
      border: 1px solid #333;
    }

    #overlay-text {
      position: absolute;
      top: 10px; left: 10px;
      pointer-events: none;
      color: rgba(255,255,255,0.7);
      background: rgba(0,0,0,0.6);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* --- RIGHT: SIDEBAR CONTROLS --- */
    .sidebar {
      background-color: #1a1a1a;
      border-left: 1px solid #333;
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow-y: auto; /* Scrollable controls */
    }

    .sidebar-header {
      padding: 20px 20px 10px 20px;
      border-bottom: 1px solid #2a2a2a;
      background: #1a1a1a;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .sidebar-header h1 {
      margin: 0;
      font-size: 1.2rem;
      color: #bb86fc;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .sidebar-content {
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* --- CONTROL GROUPS --- */
    .control-group {
      background: #242424;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .control-group label {
      display: block;
      margin-bottom: 10px;
      font-size: 0.9rem;
      font-weight: 700;
      color: #03dac6;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-group .hint {
      font-size: 11px;
      color: #888;
      margin-top: 8px;
      font-style: italic;
    }

    /* --- INPUTS & BUTTONS --- */
    input[type="file"], select, input[type="number"] {
      width: 100%;
      background: #121212;
      border: 1px solid #444;
      color: #fff;
      padding: 8px;
      border-radius: 4px;
      font-size: 13px;
    }
    
    input[type="file"]::file-selector-button {
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 4px 10px;
      margin-right: 10px;
      cursor: pointer;
    }

    .btn-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .mini-btn {
      flex: 1;
      padding: 8px 10px;
      font-size: 12px;
      font-weight: 600;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s;
    }
    .mini-btn:hover:not(:disabled) { background: #444; border-color: #777; }
    .mini-btn:disabled { opacity: 0.5; cursor: default; }

    .action-btn {
      width: 100%;
      padding: 15px;
      font-size: 16px;
      font-weight: bold;
      background-color: #bb86fc;
      color: #000;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 10px;
      transition: filter 0.2s;
    }
    .action-btn:hover { filter: brightness(1.1); }
    .action-btn:disabled { background-color: #555; color: #888; cursor: not-allowed; }

    /* --- RADIO BUTTONS STYLING --- */
    .radio-select {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .radio-option {
      display: flex;
      align-items: center;
      background: #1e1e1e;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #333;
      cursor: pointer;
      transition: background 0.2s;
    }
    .radio-option:hover { background: #2a2a2a; }
    .radio-option input { margin-right: 10px; }
    .radio-option span { font-size: 13px; }

    /* --- VIDEO LIST --- */
    .video-list {
      list-style: none;
      padding: 0;
      margin: 10px 0 0 0;
      border: 1px solid #333;
      border-radius: 4px;
      max-height: 150px;
      overflow-y: auto;
      background: #121212;
    }
    .video-item {
      padding: 8px;
      border-bottom: 1px solid #333;
      font-size: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .video-item:last-child { border-bottom: none; }
    .video-info { display: flex; flex-direction: column; gap: 2px; }
    .video-name { font-weight: bold; color: #fff; max-width: 180px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .video-meta { color: #888; font-size: 10px; }

    /* --- PROGRESS & STATUS --- */
    .status-bar {
      margin-top: 10px;
      padding: 10px;
      background: #333;
      border-radius: 4px;
      font-family: monospace;
      font-size: 11px;
      color: #bbb;
      white-space: pre-wrap;
    }

    .progress-track {
      height: 4px;
      background: #333;
      margin-top: 15px;
      border-radius: 2px;
      overflow: hidden;
    }
    #progress-bar {
      height: 100%;
      background: #03dac6;
      width: 0%;
      transition: width 0.2s;
    }

    /* --- UTILS --- */
    .hidden-media { display: none; }
    .disabled-group { opacity: 0.4; pointer-events: none; filter: grayscale(1); }
    
    /* Scrollbar Styling */
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #121212; }
    ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #555; }

    /* --- RESPONSIVE MOBILE BREAKPOINT --- */
    @media (max-width: 900px) {
      .app-layout {
        grid-template-columns: 1fr;
        grid-template-rows: 50vh 1fr; /* Split screen vertical */
        overflow-y: auto; /* Allow window scroll on mobile */
      }
      body { height: auto; overflow: auto; }
      .sidebar { border-left: none; border-top: 1px solid #333; height: auto; overflow: visible; }
      .stage-area { height: 50vh; }
    }
  </style>
</head>
<body>

  <div class="app-layout">
    <main class="stage-area" id="previewContainer">
      <div class="canvas-wrapper">
        <canvas id="renderCanvas"></canvas>
        <div id="overlay-text">Preview Mode</div>
      </div>
    </main>

    <aside class="sidebar">
      <div class="sidebar-header">
        <h1>üéµ Smart Looper Studio</h1>
        <div class="progress-track"><div id="progress-bar"></div></div>
      </div>

      <div class="sidebar-content">
        
        <button id="renderBtn" class="action-btn">Start Rendering</button>
        <div id="status" class="status-bar">Waiting for source...</div>

        <div class="control-group">
          <label>0. Video Source</label>
          <div class="btn-row">
            <label class="radio-option" style="flex:1">
              <input type="radio" name="videoSource" value="file" checked /> üìÅ File
            </label>
            <label class="radio-option" style="flex:1">
              <input type="radio" name="videoSource" value="webcam" /> üì∑ Cam
            </label>
            <label class="radio-option" style="flex:1">
              <input type="radio" name="videoSource" value="screen" /> üñ•Ô∏è Screen
            </label>
          </div>
        </div>

        <div class="control-group">
          <label>1. Audio Track</label>
          <input type="file" id="audioInput" accept="audio/*" />
          
          <div style="margin-top:10px; border-top:1px solid #333; padding-top:10px;">
            <label style="font-size:11px; margin-bottom:5px; color:#aaa;">Timeline Duration Strategy:</label>
            <div class="radio-select">
              <label class="radio-option">
                <input type="radio" name="timelineMode" value="audio" checked /> 
                <span>üé∂ Match Audio Length</span>
              </label>
              <label class="radio-option">
                <input type="radio" name="timelineMode" value="manual" /> 
                <span>‚úÇ Manual Seconds</span>
              </label>
            </div>
          </div>
          
          <input type="number" id="manualSeconds" min="1" step="1" placeholder="Enter seconds (e.g. 15)" style="margin-top:8px;" disabled />
          
          <label class="radio-option" style="margin-top:10px;">
            <input type="checkbox" id="includeAudio" checked /> 
            <span>Include Audio in Output</span>
          </label>
        </div>

        <div class="control-group" id="fileVideoGroup">
          <label>2. Video Files</label>
          <div class="btn-row" style="margin-bottom:10px;">
            <label class="radio-option" style="flex:1">
              <input type="radio" name="fileMode" value="single" checked /> üîÅ Loop 1
            </label>
            <label class="radio-option" style="flex:1">
              <input type="radio" name="fileMode" value="playlist" /> üé¨ Playlist
            </label>
          </div>
          
          <input type="file" id="videoListInput" accept="video/*" multiple />
          <ul class="video-list" id="videoList">
            </ul>
        </div>

        <div class="control-group disabled-group" id="webcamGroup">
          <label>üì∑ Webcam Live</label>
          <select id="cameraSelect" style="margin-bottom:8px;"></select>
          <div class="btn-row">
            <button class="mini-btn" id="refreshCamsBtn">üîÑ Refresh</button>
            <button class="mini-btn" id="startWebcamBtn">‚ñ∂ Start</button>
            <button class="mini-btn" id="stopWebcamBtn" disabled>‚èπ Stop</button>
          </div>
        </div>

        <div class="control-group disabled-group" id="photoGroup">
          <label>üì∏ Snapshot</label>
          <div class="btn-row" style="margin-bottom:8px;">
            <select id="photoFormat" style="flex:1">
              <option value="image/png">PNG</option>
              <option value="image/jpeg">JPG</option>
            </select>
            <input id="photoQuality" type="number" min="0.1" max="1" step="0.05" value="0.92" title="Quality (0-1)" style="flex:1" />
          </div>
          <input id="photoScaleWidth" type="number" placeholder="Resize Width (0=Orig)" style="margin-bottom:8px;" />
          <button class="mini-btn" id="snapPhotoBtn" style="width:100%; padding:10px;">üì∏ Take Photo</button>
        </div>

        <div class="control-group disabled-group" id="screenGroup">
          <label>üñ•Ô∏è Screen Capture</label>
          <div class="btn-row">
            <button class="mini-btn" id="startScreenBtn">‚ñ∂ Start Share</button>
            <button class="mini-btn" id="stopScreenBtn" disabled>‚èπ Stop Share</button>
          </div>
        </div>

      </div> </aside>
  </div>

  <video id="sourceVideo" class="hidden-media" playsinline muted crossorigin="anonymous"></video>
  <audio id="sourceAudio" class="hidden-media" crossorigin="anonymous"></audio>

  <script>
    // ===== Elements =====
    const canvas = document.getElementById("renderCanvas");
    const ctx = canvas.getContext("2d");
    const video = document.getElementById("sourceVideo");
    const audio = document.getElementById("sourceAudio");

    const renderBtn = document.getElementById("renderBtn");
    const statusDiv = document.getElementById("status");
    const progressBar = document.getElementById("progress-bar");
    const overlay = document.getElementById("overlay-text");
    const previewContainer = document.getElementById("previewContainer");

    const fileVideoGroup = document.getElementById("fileVideoGroup");
    const webcamGroup = document.getElementById("webcamGroup");
    const photoGroup  = document.getElementById("photoGroup"); 
    const screenGroup = document.getElementById("screenGroup");

    const cameraSelect = document.getElementById("cameraSelect");
    const refreshCamsBtn = document.getElementById("refreshCamsBtn");
    const startWebcamBtn = document.getElementById("startWebcamBtn");
    const stopWebcamBtn = document.getElementById("stopWebcamBtn");

    const startScreenBtn = document.getElementById("startScreenBtn");
    const stopScreenBtn = document.getElementById("stopScreenBtn");

    const videoListInput = document.getElementById("videoListInput");
    const videoListEl = document.getElementById("videoList");

    const manualSecondsInput = document.getElementById("manualSeconds");
    const includeAudioEl = document.getElementById("includeAudio");

    const snapPhotoBtn = document.getElementById("snapPhotoBtn");
    const photoFormat = document.getElementById("photoFormat");
    const photoQuality = document.getElementById("photoQuality");
    const photoScaleWidth = document.getElementById("photoScaleWidth");

    // ===== State =====
    let audioContext, audioSource, destination, recorder;
    let animationId;
    let isRecording = false;

    let activeVideoSource = "file"; 
    let activeStream = null;        

    let fileMode = "single";        
    let timelineMode = "audio";     

    let clips = [];
    let nextClipId = 1;

    let renderStartPerfMs = 0;
    let targetDurationSec = 0;

    let lastSyncMs = 0;
    let currentClipIndex = -1;

    let outputW = 1280, outputH = 720;
    let outputLocked = false;

    // ===== Recorder MIME selection =====
    const mimeTypes = [
      'video/mp4; codecs="avc1.42E01E, mp4a.40.2"',
      "video/mp4",
      "video/webm; codecs=vp9",
      "video/webm; codecs=vp8",
      "video/webm"
    ];

    function getSupportedMimeType() {
      for (const type of mimeTypes) {
        if (window.MediaRecorder && MediaRecorder.isTypeSupported(type)) return type;
      }
      return "";
    }

    // ===== UI: Timeline mode =====
    function setTimelineMode(mode) {
      timelineMode = mode;
      const manual = mode === "manual";
      manualSecondsInput.disabled = !manual;
      log(`Timeline mode: ${mode}`);
    }
    document.querySelectorAll('input[name="timelineMode"]').forEach(r => {
      r.addEventListener("change", (e) => setTimelineMode(e.target.value));
    });
    setTimelineMode("audio");

    // ===== UI: File mode =====
    function setFileMode(mode) {
      fileMode = mode;
      log(`File mode: ${mode}`);
    }
    document.querySelectorAll('input[name="fileMode"]').forEach(r => {
      r.addEventListener("change", (e) => setFileMode(e.target.value));
    });
    setFileMode("single");

    // ===== UI: Source toggle =====
    function setSourceUI(source) {
      activeVideoSource = source;

      if (source === "file") stopLiveStream();
      if (source !== "webcam") stopWebcamUIOnly();
      if (source !== "screen") stopScreenUIOnly();

      fileVideoGroup.classList.toggle("disabled-group", source !== "file");
      webcamGroup.classList.toggle("disabled-group", source !== "webcam");
      photoGroup.classList.toggle("disabled-group", source !== "webcam");
      screenGroup.classList.toggle("disabled-group", source !== "screen");

      overlay.style.display = "block";
      overlay.textContent =
        source === "file" ? "Preview (File)" :
        source === "webcam" ? "Preview (Webcam)" :
        "Preview (Screen)";
      log(`Video source set to: ${source}`);
    }

    document.querySelectorAll('input[name="videoSource"]').forEach(r => {
      r.addEventListener("change", (e) => setSourceUI(e.target.value));
    });
    setSourceUI("file");

    // ===== Helpers =====
    function fmtTime(sec) {
      if (!isFinite(sec)) return "--:--";
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60).toString().padStart(2, "0");
      return `${m}:${s}`;
    }

    function waitForMetadata(el) {
      return new Promise((resolve, reject) => {
        if (el.readyState >= 1 && (el === audio ? isFinite(el.duration || 0) : true)) return resolve();
        const onMeta = () => { cleanup(); resolve(); };
        const onErr = () => { cleanup(); reject(new Error("Failed to load metadata")); };
        const cleanup = () => {
          el.removeEventListener("loadedmetadata", onMeta);
          el.removeEventListener("error", onErr);
        };
        el.addEventListener("loadedmetadata", onMeta, { once: true });
        el.addEventListener("error", onErr, { once: true });
      });
    }

    async function probeVideoMeta(file) {
      const url = URL.createObjectURL(file);
      const tmp = document.createElement("video");
      tmp.preload = "metadata";
      tmp.muted = true;
      tmp.src = url;

      try {
        await waitForMetadata(tmp);
        const meta = {
          duration: tmp.duration,
          width: tmp.videoWidth || 1280,
          height: tmp.videoHeight || 720
        };
        return { url, ...meta };
      } catch (e) {
        URL.revokeObjectURL(url);
        throw e;
      }
    }

    function lockOutputSize(w, h) {
      if (outputLocked) return;
      outputW = w || 1280;
      outputH = h || 720;
      // Set the internal resolution for recording
      canvas.width = outputW;
      canvas.height = outputH;
      // We do NOT set style width/height here anymore, CSS handles "auto fit"
      outputLocked = true;
      log(`Output locked: ${outputW}x${outputH}`);
    }

    function drawContain(videoEl) {
      const vw = videoEl.videoWidth || outputW;
      const vh = videoEl.videoHeight || outputH;
      const cw = canvas.width, ch = canvas.height;

      const vAspect = vw / vh;
      const cAspect = cw / ch;

      let dw, dh, dx, dy;
      if (vAspect > cAspect) {
        dw = cw;
        dh = Math.round(cw / vAspect);
        dx = 0;
        dy = Math.round((ch - dh) / 2);
      } else {
        dh = ch;
        dw = Math.round(ch * vAspect);
        dy = 0;
        dx = Math.round((cw - dw) / 2);
      }

      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, cw, ch);
      ctx.drawImage(videoEl, dx, dy, dw, dh);
    }

    function masterTimeSec() {
      if (includeAudioEl.checked && audio && !audio.paused && isFinite(audio.currentTime)) {
        return audio.currentTime;
      }
      return (performance.now() - renderStartPerfMs) / 1000;
    }

    function computeTargetDurationSec() {
      if (timelineMode === "manual") {
        const v = Number(manualSecondsInput.value);
        if (!v || v <= 0) throw new Error("Manual seconds must be > 0.");
        return v;
      }
      if (!audio.src) throw new Error("Timeline is set to Audio Duration, but no audio is loaded.");
      if (!isFinite(audio.duration) || audio.duration <= 0) throw new Error("Audio duration not ready yet.");
      return audio.duration;
    }

    function renderVideoList() {
      videoListEl.innerHTML = "";
      if (clips.length === 0) {
        const li = document.createElement("li");
        li.className = "video-item";
        li.innerHTML = `<div class="video-info"><span class="video-name">No Videos Loaded</span></div>`;
        videoListEl.appendChild(li);
        return;
      }

      clips.forEach((c, idx) => {
        const li = document.createElement("li");
        li.className = "video-item";
        li.innerHTML = `
          <div class="video-info">
            <span class="video-name" title="${escapeHtml(c.file.name)}">${idx+1}. ${escapeHtml(c.file.name)}</span>
            <span class="video-meta">${fmtTime(c.duration)} | ${c.width}x${c.height}</span>
          </div>
          <div class="btn-row">
            <button class="mini-btn" data-act="up" data-id="${c.id}" ${idx===0 ? "disabled":""}>‚¨Ü</button>
            <button class="mini-btn" data-act="down" data-id="${c.id}" ${idx===clips.length-1 ? "disabled":""}>‚¨á</button>
            <button class="mini-btn" data-act="remove" data-id="${c.id}">‚úñ</button>
          </div>
        `;
        videoListEl.appendChild(li);
      });

      videoListEl.querySelectorAll("button[data-act]").forEach(btn => {
        btn.addEventListener("click", () => {
          const act = btn.getAttribute("data-act");
          const id = Number(btn.getAttribute("data-id"));
          const i = clips.findIndex(x => x.id === id);
          if (i < 0) return;

          if (act === "remove") {
            const [removed] = clips.splice(i, 1);
            try { URL.revokeObjectURL(removed.url); } catch {}
          } else if (act === "up" && i > 0) {
            [clips[i-1], clips[i]] = [clips[i], clips[i-1]];
          } else if (act === "down" && i < clips.length - 1) {
            [clips[i+1], clips[i]] = [clips[i], clips[i+1]];
          }
          renderVideoList();
          outputLocked = false;
          if (clips[0]) lockOutputSize(clips[0].width, clips[0].height);
        });
      });
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    // ===== File Loading =====
    document.getElementById("audioInput").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (file) {
        audio.src = URL.createObjectURL(file);
        log(`Audio loaded: ${file.name}`);
      }
    });

    videoListInput.addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;

      stopLiveStream();
      video.srcObject = null;
      video.loop = false;
      video.src = "";

      log(`Probing ${files.length} video file(s)...`);

      for (const f of files) {
        try {
          const meta = await probeVideoMeta(f);
          clips.push({
            id: nextClipId++,
            file: f,
            url: meta.url,
            duration: meta.duration,
            width: meta.width,
            height: meta.height
          });
        } catch (err) {
          log(`Failed to read metadata for ${f.name}: ${err.message}`);
        }
      }

      if (clips[0]) lockOutputSize(clips[0].width, clips[0].height);
      renderVideoList();

      if (clips[0]) {
        await switchToClip(0, 0);
        setTimeout(() => paintPreviewFrame(), 150);
      }
    });

    async function paintPreviewFrame() {
      try {
        if (video.readyState < 2) return;
        drawContain(video);
      } catch {}
    }

    video.addEventListener("playing", () => {
      if (!outputLocked && (video.videoWidth && video.videoHeight)) {
        lockOutputSize(video.videoWidth, video.videoHeight);
      }
      setTimeout(paintPreviewFrame, 120);
    });

    // ===== Device Enumeration (Cameras) =====
    async function ensureDeviceLabels() {
      try {
        const tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        tmp.getTracks().forEach(t => t.stop());
      } catch (e) {
        log(`Camera permission error: ${e.message}`);
      }
    }

    async function refreshCameraList() {
      if (!navigator.mediaDevices?.enumerateDevices) {
        alert("enumerateDevices() not supported.");
        return;
      }

      await ensureDeviceLabels();

      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === "videoinput");

      cameraSelect.innerHTML = "";
      if (cams.length === 0) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No cameras found";
        cameraSelect.appendChild(opt);
        return;
      }

      cams.forEach((cam, idx) => {
        const opt = document.createElement("option");
        opt.value = cam.deviceId;
        const niceLabel = cam.label && cam.label.trim() ? cam.label : `Camera ${idx + 1}`;
        opt.textContent = `${niceLabel}`;
        cameraSelect.appendChild(opt);
      });
      log(`Cameras enumerated: ${cams.length}`);
    }
    refreshCamsBtn.addEventListener("click", refreshCameraList);

    // ===== Webcam start/stop =====
    async function startWebcam() {
      if (!navigator.mediaDevices?.getUserMedia) {
        alert("getUserMedia not supported.");
        return;
      }
      stopLiveStream();

      const deviceId = cameraSelect.value;
      if (!deviceId) await refreshCameraList();

      const constraints = {
        video: deviceId ? { deviceId: { exact: deviceId } } : true,
        audio: false
      };

      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        activeStream = stream;

        video.loop = false;
        video.src = "";
        video.srcObject = stream;

        const [track] = stream.getVideoTracks();
        if (track) {
          track.onended = () => {
            log("Webcam ended.");
            stopLiveStream();
          };
        }

        await video.play();
        startWebcamBtn.disabled = true;
        stopWebcamBtn.disabled = false;

        if (!outputLocked && (video.videoWidth && video.videoHeight)) {
          lockOutputSize(video.videoWidth, video.videoHeight);
        }
        log("Webcam started.");
      } catch (e) {
        log(`Webcam error: ${e.message}`);
      }
    }

    function stopWebcamUIOnly() {
      startWebcamBtn.disabled = false;
      stopWebcamBtn.disabled = true;
    }

    function stopWebcam() {
      stopLiveStream();
      stopWebcamUIOnly();
      log("Webcam stopped.");
    }

    startWebcamBtn.addEventListener("click", async () => {
      setSourceUI("webcam");
      await refreshCameraList();
      await startWebcam();
    });
    stopWebcamBtn.addEventListener("click", stopWebcam);

    // ===== Photo snap =====
    snapPhotoBtn.addEventListener("click", async () => {
      try {
        if (isRecording) {
          alert("Stop rendering before snapping.");
          return;
        }
        if (activeVideoSource !== "webcam") setSourceUI("webcam");
        if (!video.srcObject) {
          await refreshCameraList();
          await startWebcam();
        }
        if (video.readyState < 2) {
          await new Promise(r => setTimeout(r, 150));
        }

        const vw = video.videoWidth || 1280;
        const vh = video.videoHeight || 720;
        const targetW = Math.max(0, Number(photoScaleWidth.value || 0));
        let outW = vw, outH = vh;
        if (targetW && targetW > 0 && targetW !== vw) {
          const scale = targetW / vw;
          outW = Math.round(vw * scale);
          outH = Math.round(vh * scale);
        }

        const capCanvas = document.createElement("canvas");
        capCanvas.width = outW;
        capCanvas.height = outH;
        const capCtx = capCanvas.getContext("2d", { alpha: true });
        capCtx.drawImage(video, 0, 0, outW, outH);

        const mime = photoFormat.value;
        let q = Number(photoQuality.value || 0.92);
        q = Math.min(1, Math.max(0.1, q));

        const blob = await new Promise((resolve, reject) => {
          capCanvas.toBlob(b => (b ? resolve(b) : reject(new Error("Encoding failed"))), mime, mime==="image/jpeg"?q:undefined);
        });

        const ts = new Date();
        const pad = n => String(n).padStart(2, "0");
        const name = `snap_${ts.getTime()}`;
        const ext = mime === "image/png" ? "png" : "jpg";
        
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${name}.${ext}`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 500);
        log(`Saved: ${name}.${ext}`);
      } catch (e) {
        log(`Snap failed: ${e.message}`);
      }
    });

    // ===== Screen Capture =====
    async function startScreenCapture() {
      if (!navigator.mediaDevices?.getDisplayMedia) {
        alert("getDisplayMedia not supported.");
        return;
      }
      stopLiveStream();
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({ video: { frameRate: 30 }, audio: false });
        activeStream = stream;
        video.loop = false;
        video.src = "";
        video.srcObject = stream;
        const [track] = stream.getVideoTracks();
        if (track) {
          track.onended = () => {
            log("Screen share ended.");
            stopLiveStream();
            stopScreenUIOnly();
          };
        }
        await video.play();
        startScreenBtn.disabled = true;
        stopScreenBtn.disabled = false;
        if (!outputLocked && (video.videoWidth && video.videoHeight)) {
          lockOutputSize(video.videoWidth, video.videoHeight);
        }
        log("Screen capture started.");
      } catch (e) {
        log(`Screen error: ${e.message}`);
      }
    }

    function stopScreenUIOnly() {
      startScreenBtn.disabled = false;
      stopScreenBtn.disabled = true;
    }
    function stopScreenCapture() {
      stopLiveStream();
      stopScreenUIOnly();
      log("Screen capture stopped.");
    }
    startScreenBtn.addEventListener("click", async () => {
      setSourceUI("screen");
      await startScreenCapture();
    });
    stopScreenBtn.addEventListener("click", stopScreenCapture);

    function stopLiveStream() {
      if (activeStream) {
        try { activeStream.getTracks().forEach(t => t.stop()); } catch {}
        activeStream = null;
      }
      if (video.srcObject) video.srcObject = null;
    }

    // ===== Playback Logic =====
    async function switchToClip(index, clipTimeSec = 0) {
      if (!clips[index]) throw new Error("Index out of range.");
      const c = clips[index];
      const already = (video.src && video.src.includes(c.url));
      if (!already) {
        video.pause();
        video.srcObject = null;
        video.loop = false;
        video.src = c.url;
        await waitForMetadata(video);
      }
      lockOutputSize(outputW || c.width, outputH || c.height);
      try { video.currentTime = Math.max(0, Math.min(clipTimeSec, Math.max(0, (video.duration||c.duration)-0.001))); } catch {}
      try { await video.play(); } catch {}
      currentClipIndex = index;
      return c;
    }

    function playlistMapTimeToClip(tSec) {
      if (!clips.length) return { index: -1, clipTime: 0 };
      if (fileMode === "single") {
        const d = Math.max(0.001, clips[0].duration || 0.001);
        return { index: 0, clipTime: tSec % d };
      }
      const durs = clips.map(c => Math.max(0.001, c.duration || 0.001));
      const cycle = durs.reduce((a,b) => a+b, 0);
      const cycT = (cycle > 0) ? (tSec % cycle) : 0;
      let acc = 0;
      for (let i=0; i<durs.length; i++) {
        const next = acc + durs[i];
        if (cycT < next) return { index: i, clipTime: Math.max(0, cycT - acc) };
        acc = next;
      }
      return { index: 0, clipTime: 0 };
    }

    // ===== Render Loop =====
    renderBtn.addEventListener("click", async () => {
      try {
        const supportedType = getSupportedMimeType();
        if (!supportedType) {
          alert("Browser doesn't support MediaRecorder types.");
          return;
        }
        if (timelineMode === "audio" && !audio.src) {
          alert("Upload audio or use Manual Seconds.");
          return;
        }
        if (timelineMode === "manual") {
          const v = Number(manualSecondsInput.value);
          if (!v || v <= 0) {
            alert("Enter manual seconds (> 0).");
            return;
          }
        }
        if (activeVideoSource === "file" && !clips.length) {
          alert("Upload a video first.");
          return;
        }
        if (activeVideoSource !== "file" && !video.srcObject) {
          alert("Start camera/screen first.");
          return;
        }

        await startRendering(supportedType);
      } catch (e) {
        alert(e.message);
      }
    });

    async function startRendering(mimeType) {
      isRecording = true;
      renderBtn.disabled = true;
      renderBtn.innerText = "Rendering...";
      overlay.style.display = "none";
      progressBar.style.width = "0%";
      statusDiv.textContent = "Initializing...";

      if (timelineMode === "audio") try { await waitForMetadata(audio); } catch {}
      targetDurationSec = computeTargetDurationSec();

      if (!outputLocked) {
         if (activeVideoSource === "file" && clips[0]) lockOutputSize(clips[0].width, clips[0].height);
         else if (video.videoWidth) lockOutputSize(video.videoWidth, video.videoHeight);
         else lockOutputSize(1280, 720);
      }

      const pixelCount = canvas.width * canvas.height;
      const calculatedBitrate = Math.min(Math.max(pixelCount * 30 * 0.2, 2500000), 15000000);
      
      const canvasStream = canvas.captureStream(30);
      let combinedStream;
      if (includeAudioEl.checked) {
        if (!audio.src) {
          combinedStream = new MediaStream([...canvasStream.getVideoTracks()]);
        } else {
          if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
          if (audioContext.state === "suspended") await audioContext.resume();
          destination = audioContext.createMediaStreamDestination();
          if (!audioSource) audioSource = audioContext.createMediaElementSource(audio);
          audioSource.connect(destination);
          audioSource.connect(audioContext.destination);
          combinedStream = new MediaStream([...canvasStream.getVideoTracks(), ...destination.stream.getAudioTracks()]);
        }
      } else {
        combinedStream = new MediaStream([...canvasStream.getVideoTracks()]);
      }

      const recordedChunks = [];
      recorder = new MediaRecorder(combinedStream, { mimeType, videoBitsPerSecond: calculatedBitrate });
      recorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
      recorder.onstop = () => {
        isRecording = false;
        cancelAnimationFrame(animationId);
        if (activeVideoSource === "file") video.pause();
        try { audio.pause(); } catch {}

        const blob = new Blob(recordedChunks, { type: mimeType });
        const ext = mimeType.includes("mp4") ? "mp4" : "webm";
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.style.display = "none";
        a.href = url;
        a.download = `output_${Math.round(targetDurationSec)}s.${ext}`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 150);

        renderBtn.disabled = false;
        renderBtn.innerText = "Start Rendering";
        overlay.style.display = "block";
        statusDiv.textContent = "Done! Downloading...";
      };

      renderStartPerfMs = performance.now();
      lastSyncMs = renderStartPerfMs;
      currentClipIndex = -1;
      recorder.start(1000);

      if (includeAudioEl.checked && audio.src) try { audio.currentTime = 0; } catch {}
      if (activeVideoSource === "file") await switchToClip(0, 0);
      else try { if (video.paused) await video.play(); } catch {}
      if (includeAudioEl.checked && audio.src) try { await audio.play(); } catch {}

      drawFrame();

      const stopCheck = setInterval(() => {
        if (!isRecording) { clearInterval(stopCheck); return; }
        const t = masterTimeSec();
        const progress = Math.min(1, t / Math.max(0.001, targetDurationSec));
        progressBar.style.width = `${(progress * 100).toFixed(1)}%`;
        statusDiv.textContent = `REC: ${fmtTime(t)} / ${fmtTime(targetDurationSec)}`;

        if (t >= targetDurationSec) {
          clearInterval(stopCheck);
          try { recorder.stop(); } catch {}
        }
      }, 200);
    }

    async function syncVideoToTimeline(tSec) {
      if (activeVideoSource !== "file") return;
      if (!clips.length) return;
      const map = playlistMapTimeToClip(tSec);
      if (map.index < 0) return;
      if (map.index !== currentClipIndex) {
        await switchToClip(map.index, map.clipTime);
        return;
      }
      const now = performance.now();
      if (now - lastSyncMs > 500) {
        lastSyncMs = now;
        try {
          const drift = Math.abs((video.currentTime || 0) - map.clipTime);
          if (drift > 0.20 && video.readyState >= 2) video.currentTime = map.clipTime;
        } catch {}
      }
    }

    function drawFrame() {
      if (!isRecording) return;
      const t = masterTimeSec();
      syncVideoToTimeline(t).then(() => {
        try { if (video.readyState >= 2) drawContain(video); } catch {}
        animationId = requestAnimationFrame(drawFrame);
      });
    }

    function log(msg) {
      statusDiv.textContent = msg;
      console.log(msg);
    }

    // Init
    (async () => { try { await refreshCameraList(); } catch {} })();
    renderVideoList();
  </script>
</body>
</html>
