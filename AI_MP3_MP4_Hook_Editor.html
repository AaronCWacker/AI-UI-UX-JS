<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio-Video Looper & Merger</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        h1 { margin-bottom: 20px; color: #bb86fc; }

        .container {
            background-color: #1e1e1e;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 800px;
            text-align: center;
        }

        .preview-area {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            background: #000;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #333;
        }

        canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Hidden elements used for processing */
        .hidden-media { display: none; }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
            text-align: left;
        }

        .file-input-group {
            background: #2c2c2c;
            padding: 15px;
            border-radius: 8px;
        }

        label { display: block; margin-bottom: 8px; font-weight: bold; color: #bb86fc; }
        input[type="file"] { width: 100%; color: #ccc; }

        .action-btn {
            grid-column: span 2;
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            background-color: #03dac6;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .action-btn:hover { background-color: #018786; }
        .action-btn:disabled { background-color: #555; cursor: not-allowed; }

        #status {
            margin-top: 15px;
            font-size: 14px;
            color: #aaa;
            white-space: pre-wrap;
        }

        #progress-bar {
            width: 0%;
            height: 5px;
            background-color: #bb86fc;
            transition: width 0.2s;
            margin-top: 10px;
        }
        
        .progress-container {
            width: 100%;
            background-color: #333;
            height: 5px;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <h1>ðŸŽµ Audio + Loop Video Merger</h1>

    <div class="container">
        <div class="preview-area">
            <canvas id="renderCanvas" width="1280" height="720"></canvas>
            <div id="overlay-text" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); pointer-events:none;">Preview</div>
        </div>

        <div class="progress-container">
            <div id="progress-bar"></div>
        </div>

        <div class="controls">
            <div class="file-input-group">
                <label>1. Select Audio (MP3/WAV)</label>
                <input type="file" id="audioInput" accept="audio/*">
            </div>
            <div class="file-input-group">
                <label>2. Select Video (MP4)</label>
                <input type="file" id="videoInput" accept="video/*">
            </div>
            
            <button id="renderBtn" class="action-btn">Start Rendering (Real-time)</button>
        </div>

        <div id="status">Waiting for files...</div>
    </div>

    <video id="sourceVideo" class="hidden-media" playsinline muted loop crossorigin="anonymous"></video>
    <audio id="sourceAudio" class="hidden-media" crossorigin="anonymous"></audio>

    <script>
        const canvas = document.getElementById('renderCanvas');
        const ctx = canvas.getContext('2d');
        const video = document.getElementById('sourceVideo');
        const audio = document.getElementById('sourceAudio');
        const renderBtn = document.getElementById('renderBtn');
        const statusDiv = document.getElementById('status');
        const progressBar = document.getElementById('progress-bar');
        const overlay = document.getElementById('overlay-text');

        let audioContext, audioSource, destination, recorder;
        let animationId;
        let isRecording = false;

        // Configuration for "Valid MP4" attempts
        // Chrome/Edge support specific codec flags to generate mp4 containers
        const mimeTypes = [
            'video/mp4; codecs="avc1.42E01E, mp4a.40.2"', // H.264 (Best for Windows/Mac)
            'video/mp4',
            'video/webm; codecs=vp9', // Fallback High Quality
            'video/webm' // Universal Fallback
        ];

        function getSupportedMimeType() {
            for (const type of mimeTypes) {
                if (MediaRecorder.isTypeSupported(type)) {
                    return type;
                }
            }
            return '';
        }

        // Handle File Loads
        document.getElementById('audioInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file) {
                audio.src = URL.createObjectURL(file);
                log(`Audio loaded: ${file.name}`);
            }
        });

        document.getElementById('videoInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file) {
                video.src = URL.createObjectURL(file);
                // Wait for metadata to set canvas size
                video.onloadedmetadata = () => {
                    // Optional: Resize canvas to match video resolution, or stick to 720p/1080p
                    // canvas.width = video.videoWidth;
                    // canvas.height = video.videoHeight;
                    log(`Video loaded: ${file.name} (${video.videoWidth}x${video.videoHeight})`);
                    // Draw first frame
                    video.currentTime = 0;
                };
            }
        });

        renderBtn.addEventListener('click', async () => {
            if (!audio.src || !video.src) {
                alert("Please upload both audio and video files first.");
                return;
            }

            const supportedType = getSupportedMimeType();
            if (!supportedType) {
                alert("Your browser does not support media recording. Please use Chrome, Edge, or Firefox.");
                return;
            }

            startRendering(supportedType);
        });

        async function startRendering(mimeType) {
            isRecording = true;
            renderBtn.disabled = true;
            renderBtn.innerText = "Rendering... (Do not close tab)";
            overlay.style.display = 'none';
            progressBar.style.width = '0%';
            log(`Initializing recorder with format: ${mimeType}`);

            // 1. Setup Audio Context for mixing
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            // Create stream destination (this is what the recorder listens to)
            destination = audioContext.createMediaStreamDestination();
            
            // Connect audio element to destination AND speakers (so user can hear progress)
            if (!audioSource) {
                audioSource = audioContext.createMediaElementSource(audio);
            }
            audioSource.connect(destination);
            audioSource.connect(audioContext.destination); // Mute this line if you want silent rendering

            // 2. Setup Canvas Stream
            // 30 FPS is standard for broad compatibility
            const canvasStream = canvas.captureStream(30);
            
            // Add the audio track to the canvas stream
            const combinedStream = new MediaStream([
                ...canvasStream.getVideoTracks(),
                ...destination.stream.getAudioTracks()
            ]);

            // 3. Setup Recorder
            let recordedChunks = [];
            try {
                recorder = new MediaRecorder(combinedStream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000 // 5 Mbps quality
                });
            } catch (e) {
                log(`Error initializing recorder: ${e.message}`);
                return;
            }

            recorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    recordedChunks.push(e.data);
                }
            };

            recorder.onstop = () => {
                isRecording = false;
                cancelAnimationFrame(animationId);
                video.pause();
                
                log("Finalizing file...");
                const blob = new Blob(recordedChunks, { type: mimeType });
                
                // Determine extension based on mimetype
                const ext = mimeType.includes('mp4') ? 'mp4' : 'webm';
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `merged_video.${ext}`;
                document.body.appendChild(a);
                a.click();
                
                // Cleanup
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 100);

                renderBtn.disabled = false;
                renderBtn.innerText = "Start Rendering (Real-time)";
                log(`Download started! Format: ${ext}`);
                overlay.style.display = 'block';
            };

            // 4. Start Playback and Recording
            recorder.start(1000); // Save chunks every second to manage memory
            
            // Ensure video loops
            video.loop = true;
            
            try {
                await audio.play();
                await video.play();
            } catch (err) {
                log("Auto-play blocked. Please interact with the page or check permissions.");
            }

            drawFrame();

            // 5. Watch for Audio End
            audio.onended = () => {
                log("Audio finished. Stopping recording.");
                recorder.stop();
            };

            // Status Update Loop
            const updateStatus = setInterval(() => {
                if (!isRecording) {
                    clearInterval(updateStatus);
                    return;
                }
                const progress = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = `${progress}%`;
                
                const curM = Math.floor(audio.currentTime / 60);
                const curS = Math.floor(audio.currentTime % 60).toString().padStart(2, '0');
                const totM = Math.floor(audio.duration / 60);
                const totS = Math.floor(audio.duration % 60).toString().padStart(2, '0');
                
                log(`Rendering: ${curM}:${curS} / ${totM}:${totS}`);
            }, 500);
        }

        function drawFrame() {
            if (!isRecording) return;

            // Draw Video to Canvas (Scaling to 'Cover')
            drawImageProp(ctx, video, 0, 0, canvas.width, canvas.height);
            
            animationId = requestAnimationFrame(drawFrame);
        }

        // Helper: Object-fit Cover for Canvas
        function drawImageProp(ctx, img, x, y, w, h, offsetX, offsetY) {
            if (arguments.length === 2) {
                x = y = 0;
                w = ctx.canvas.width;
                h = ctx.canvas.height;
            }

            offsetX = typeof offsetX === "number" ? offsetX : 0.5;
            offsetY = typeof offsetY === "number" ? offsetY : 0.5;

            if (offsetX < 0) offsetX = 0;
            if (offsetY < 0) offsetY = 0;
            if (offsetX > 1) offsetX = 1;
            if (offsetY > 1) offsetY = 1;

            var iw = img.videoWidth,
                ih = img.videoHeight,
                r = Math.min(w / iw, h / ih),
                nw = iw * r,   // new prop. width
                nh = ih * r,   // new prop. height
                cx, cy, cw, ch, ar = 1;

            // decide which gap to fill    
            if (nw < w) ar = w / nw;                             
            if (Math.abs(ar - 1) < 1e-14 && nh < h) ar = h / nh;  // updated
            nw *= ar;
            nh *= ar;

            // calc source rectangle
            cw = iw / (nw / w);
            ch = ih / (nh / h);

            cx = (iw - cw) * offsetX;
            cy = (ih - ch) * offsetY;

            // make sure source rectangle is valid
            if (cx < 0) cx = 0;
            if (cy < 0) cy = 0;
            if (cw > iw) cw = iw;
            if (ch > ih) ch = ih;

            ctx.drawImage(img, cx, cy, cw, ch,  x, y, w, h);
        }

        function log(msg) {
            statusDiv.textContent = msg;
            console.log(msg);
        }
    </script>
</body>
</html>
