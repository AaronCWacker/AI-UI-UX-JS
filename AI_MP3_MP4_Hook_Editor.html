<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎵 Hook Editor 🎵</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f0f0f0; }
        #controls { margin-bottom: 10px; }
        button { margin: 5px; padding: 8px 12px; font-size: 14px; cursor: pointer; }
        #timeline-canvas { border: 1px solid #ccc; width: 100%; height: 120px; background: #fff; cursor: crosshair; }
        #video-player { border: 1px solid #ccc; width: 100%; height: 300px; background: #000; display: block; position: relative; }
        #video-player.no-video::after { content: 'No video'; color: white; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        input[type="file"], select { margin: 5px; }
        #status { color: #666; font-size: 12px; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>🎵 Hook Editor 🎵</h1>
    <div id="controls">
        <label>📁 Upload Audio (MP3):</label>
        <input type="file" id="audio-upload" accept="audio/*">
        <br>
        <label>🎥 Upload Video Clips (MP4/WebM):</label>
        <input type="file" id="video-upload" accept="video/*" multiple>
        <br>
        <label>💾 Export Format:</label>
        <select id="export-format">
            <option value="webm">WebM (default)</option>
            <option value="mp4">MP4</option>
        </select>
        <br>
        <button id="reset-btn">🔄 Reset 🔄</button>
        <button id="play-btn">▶️ Play ▶️</button>
        <button id="stop-btn">⏹️ Stop ⏹️</button>
        <button id="rewind-btn">⏪ Rewind ⏪</button>
        <button id="loop-toggle">🔁 Loop Off 🔁</button>
        <button id="download-btn">💾 Download Hook 💾</button>
    </div>
    <video id="video-player" class="no-video" controls>
        <source id="video-source" src="" type="video/mp4">
        Your browser does not support the video tag.
    </video>
    <canvas id="timeline-canvas"></canvas>
    <div id="status">Ready. Upload audio and video clips to start.</div>

    <script>
        class HookEditor {
            constructor() {
                console.log('Hook Editor initialized');
                this.audioContext = null;
                this.audioBuffer = null;
                this.audioElement = new Audio();
                this.videoClips = [];
                this.timelineCanvas = document.getElementById('timeline-canvas');
                this.videoPlayer = document.getElementById('video-player');
                this.videoSource = document.getElementById('video-source');
                this.timelineCtx = this.timelineCanvas.getContext('2d');
                this.timelineWidth = 800;
                this.timelineHeight = 120;
                this.timelineCanvas.width = this.timelineWidth;
                this.timelineCanvas.height = this.timelineHeight;
                this.startTime = 0;
                this.endTime = 0;
                this.isPlaying = false;
                this.isLooping = false;
                this.currentTime = 0;
                this.playInterval = null;
                this.isDragging = false;
                this.dragType = null;
                this.dragIndex = -1;
                this.dragOffset = 0;
                this.recorder = null;
                this.mediaStream = null;
                this.canvas = document.createElement('canvas');
                this.canvas.width = 800;
                this.canvas.height = 300;
                this.canvasCtx = this.canvas.getContext('2d');
                this.currentClipIndex = -1;
                this.initEventListeners();
                this.drawTimeline();
                this.animatePreview();
            }

            initEventListeners() {
                document.getElementById('audio-upload').addEventListener('change', (e) => this.loadAudio(e.target.files[0]));
                document.getElementById('video-upload').addEventListener('change', (e) => this.loadVideos(e.target.files));
                document.getElementById('reset-btn').addEventListener('click', () => this.reset());
                document.getElementById('play-btn').addEventListener('click', () => this.play());
                document.getElementById('stop-btn').addEventListener('click', () => this.stop());
                document.getElementById('rewind-btn').addEventListener('click', () => this.rewind());
                document.getElementById('loop-toggle').addEventListener('click', () => this.toggleLoop());
                document.getElementById('download-btn').addEventListener('click', () => this.downloadHook());
                this.timelineCanvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.timelineCanvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.timelineCanvas.addEventListener('mouseup', () => this.handleMouseUp());
                this.timelineCanvas.addEventListener('wheel', (e) => this.handleWheel(e));
                this.audioElement.addEventListener('timeupdate', () => this.updateCurrentTime());
                this.audioElement.addEventListener('ended', () => this.onPlaybackEnd());
                this.videoPlayer.addEventListener('error', (e) => {
                    console.error('Video player error:', e);
                    this.updateStatus(`Video error: ${e.target.error ? e.target.error.message : 'Unknown'}`);
                });
            }

            async loadAudio(file) {
                if (!file) return;
                console.log('Loading audio file:', file.name);
                const arrayBuffer = await file.arrayBuffer();
                if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer).catch(e => {
                    console.error('Audio decode error:', e);
                    this.updateStatus(`Audio decode error: ${e.message}`);
                });
                if (!this.audioBuffer) return;
                this.audioElement.src = URL.createObjectURL(file);
                this.endTime = Math.min(this.audioBuffer.duration, 60);
                this.startTime = 0;
                this.videoClips = [];
                this.drawTimeline();
                this.updateStatus(`Audio loaded: ${this.formatTime(this.audioBuffer.duration)}`);
                console.log(`Audio loaded: duration ${this.audioBuffer.duration}s`);
            }

            loadVideos(files) {
                console.log(`Loading ${files.length} video file(s)`);
                Array.from(files).forEach((file, index) => {
                    const video = document.createElement('video');
                    const src = URL.createObjectURL(file);
                    video.src = src;
                    video.muted = true;
                    video.preload = 'auto';
                    video.crossOrigin = 'anonymous';
                    const fileType = file.type || (file.name.endsWith('.webm') ? 'video/webm' : 'video/mp4');
                    
                    video.onloadedmetadata = () => {
                        console.log(`Video ${index} metadata loaded:`, {
                            name: file.name,
                            duration: video.duration,
                            readyState: video.readyState,
                            videoWidth: video.videoWidth,
                            videoHeight: video.videoHeight
                        });
                        
                        if (video.duration < 1) {
                            this.updateStatus(`Clip too short: ${file.name}`);
                            URL.revokeObjectURL(src);
                            return;
                        }
                        
                        const duration = video.duration;
                        const clipStart = this.videoClips.length === 0 ? 0 : this.videoClips[this.videoClips.length - 1].start + this.videoClips[this.videoClips.length - 1].duration;
                        
                        this.videoClips.push({ 
                            file, 
                            video, 
                            src,
                            start: clipStart, 
                            duration, 
                            fileType 
                        });
                        
                        video.load();
                        
                        this.drawTimeline();
                        this.updateStatus(`Added clip ${this.videoClips.length}: ${file.name} (${this.formatTime(duration)}) at ${this.formatTime(clipStart)}`);
                    };
                    
                    video.onerror = (e) => {
                        console.error(`Video ${index} error:`, e);
                        this.updateStatus(`Error loading video: ${file.name}`);
                        URL.revokeObjectURL(src);
                    };
                    
                    video.oncanplay = () => {
                        console.log(`Video ${index} can play:`, file.name, 'readyState:', video.readyState);
                    };
                });
            }

            getTotalDuration() {
                return this.audioBuffer ? this.audioBuffer.duration : this.videoClips.reduce((sum, clip) => sum + clip.duration, 0);
            }

            drawTimeline() {
                this.timelineCtx.clearRect(0, 0, this.timelineWidth, this.timelineHeight);
                const duration = Math.max(this.endTime, this.getTotalDuration()) || 1;
                const pxPerSec = this.timelineWidth / duration;

                // Draw waveform
                if (this.audioBuffer) {
                    const data = this.audioBuffer.getChannelData(0);
                    const step = Math.floor(data.length / this.timelineWidth);
                    this.timelineCtx.strokeStyle = '#007bff';
                    this.timelineCtx.beginPath();
                    for (let i = 0; i < this.timelineWidth; i++) {
                        let min = 1, max = -1;
                        for (let j = 0; j < step; j++) {
                            const val = data[i * step + j] || 0;
                            min = Math.min(min, val);
                            max = Math.max(max, val);
                        }
                        const x = i;
                        const yMid = this.timelineHeight / 2;
                        const y1 = yMid + min * (yMid - 20);
                        const y2 = yMid + max * (yMid - 20);
                        if (i === 0) this.timelineCtx.moveTo(x, y1);
                        else this.timelineCtx.lineTo(x, y1);
                        this.timelineCtx.lineTo(x, y2);
                    }
                    this.timelineCtx.stroke();
                }

                // Draw video clips
                this.videoClips.forEach((clip, index) => {
                    const x = clip.start * pxPerSec;
                    const width = clip.duration * pxPerSec;
                    this.timelineCtx.fillStyle = index % 2 ? '#28a745' : '#ffc107';
                    this.timelineCtx.fillRect(x, 10, width, 20);
                    this.timelineCtx.strokeStyle = '#000';
                    this.timelineCtx.strokeRect(x, 10, width, 20);
                    this.timelineCtx.fillStyle = '#000';
                    this.timelineCtx.font = '10px Arial';
                    this.timelineCtx.fillText(`Clip ${index + 1}`, x + 5, 25);
                });

                // Draw window handles
                const startX = this.startTime * pxPerSec;
                const endX = this.endTime * pxPerSec;
                this.timelineCtx.fillStyle = 'red';
                this.timelineCtx.fillRect(startX - 2, 0, 4, this.timelineHeight);
                this.timelineCtx.fillRect(endX - 2, 0, 4, this.timelineHeight);
                this.timelineCtx.fillStyle = 'rgba(255,0,0,0.1)';
                this.timelineCtx.fillRect(startX, 0, endX - startX, this.timelineHeight);

                // Draw playhead
                if (this.isPlaying) {
                    const headX = this.currentTime * pxPerSec;
                    this.timelineCtx.fillStyle = 'blue';
                    this.timelineCtx.fillRect(headX - 1, 0, 2, this.timelineHeight);
                }
            }

            handleMouseDown(e) {
                const rect = this.timelineCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const duration = Math.max(this.endTime, this.getTotalDuration()) || 1;
                const pxPerSec = this.timelineWidth / duration;
                const time = x / pxPerSec;

                // Check for clip drag
                for (let i = 0; i < this.videoClips.length; i++) {
                    const clip = this.videoClips[i];
                    if (time >= clip.start && time <= clip.start + clip.duration) {
                        this.isDragging = true;
                        this.dragType = 'clip';
                        this.dragIndex = i;
                        this.dragOffset = time - clip.start;
                        return;
                    }
                }

                // Check start/end handles
                if (Math.abs(time - this.startTime) < 0.5) {
                    this.dragType = 'start';
                } else if (Math.abs(time - this.endTime) < 0.5) {
                    this.dragType = 'end';
                } else {
                    this.startTime = time;
                    this.endTime = Math.min(time + 10, duration);
                }
                this.isDragging = true;
                this.drawTimeline();
            }

            handleMouseMove(e) {
                if (!this.isDragging) return;
                const rect = this.timelineCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const duration = Math.max(this.endTime, this.getTotalDuration()) || 1;
                const pxPerSec = this.timelineWidth / duration;
                let time = x / pxPerSec;

                if (this.dragType === 'start') {
                    this.startTime = Math.max(0, Math.min(time, this.endTime - 1));
                } else if (this.dragType === 'end') {
                    this.endTime = Math.min(duration, Math.max(time, this.startTime + 1));
                } else if (this.dragType === 'clip') {
                    const clip = this.videoClips[this.dragIndex];
                    clip.start = Math.max(0, Math.min(time - this.dragOffset, duration - clip.duration));
                }
                this.drawTimeline();
            }

            handleMouseUp() {
                this.isDragging = false;
                this.dragType = null;
                this.dragIndex = -1;
                this.dragOffset = 0;
            }

            handleWheel(e) {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                const windowSize = this.endTime - this.startTime;
                const center = (this.startTime + this.endTime) / 2;
                const newSize = windowSize * zoomFactor;
                this.startTime = Math.max(0, center - newSize / 2);
                this.endTime = Math.min(this.getTotalDuration(), this.startTime + newSize);
                this.drawTimeline();
            }

            play() {
                if (!this.audioBuffer) {
                    this.updateStatus('No audio loaded');
                    return;
                }
                
                if (this.isPlaying) {
                    // Pause
                    this.audioElement.pause();
                    this.videoPlayer.pause();
                    this.isPlaying = false;
                    clearInterval(this.playInterval);
                    document.getElementById('play-btn').textContent = '▶️ Play ▶️';
                    this.updateStatus('Paused');
                    console.log('Playback paused');
                    return;
                }
                
                // Start playing
                this.currentTime = this.startTime;
                this.audioElement.currentTime = this.startTime;
                
                this.audioElement.play().then(() => {
                    console.log('Audio playback started at', this.startTime);
                    this.updateStatus(`Playing ${this.formatTime(this.endTime - this.startTime)} hook`);
                }).catch(e => {
                    console.error('Audio play error:', e);
                    this.updateStatus(`Audio play error: ${e.message}`);
                });
                
                this.updateVideoPlayer();
                this.isPlaying = true;
                this.playInterval = setInterval(() => this.drawTimeline(), 33);
                document.getElementById('play-btn').textContent = '⏸️ Pause ⏸️';
            }

            stop() {
                console.log('Stopping playback');
                this.audioElement.pause();
                this.videoPlayer.pause();
                this.videoSource.src = '';
                this.videoPlayer.classList.add('no-video');
                this.videoPlayer.load();
                this.isPlaying = false;
                clearInterval(this.playInterval);
                this.currentTime = this.startTime;
                this.currentClipIndex = -1;
                document.getElementById('play-btn').textContent = '▶️ Play ▶️';
                this.drawTimeline();
                this.updateStatus('Stopped');
            }

            rewind() {
                console.log('Rewinding to', this.startTime);
                this.currentTime = this.startTime;
                this.audioElement.currentTime = this.startTime;
                this.updateVideoPlayer();
                if (this.isPlaying) {
                    this.audioElement.play().catch(e => this.updateStatus(`Audio play error: ${e.message}`));
                }
                this.drawTimeline();
                this.updateStatus(`Rewound to ${this.formatTime(this.startTime)}`);
            }

            toggleLoop() {
                this.isLooping = !this.isLooping;
                document.getElementById('loop-toggle').textContent = this.isLooping ? '🔁 Loop On 🔁' : '🔁 Loop Off 🔁';
                this.updateStatus(`Loop ${this.isLooping ? 'enabled' : 'disabled'}`);
            }

            updateCurrentTime() {
                this.currentTime = this.audioElement.currentTime;
                this.updateVideoPlayer();
                if (this.currentTime >= this.endTime && this.isPlaying) {
                    this.onPlaybackEnd();
                }
            }

            updateVideoPlayer() {
                let activeClip = null;
                let newClipIndex = -1;
                
                for (let i = 0; i < this.videoClips.length; i++) {
                    const clip = this.videoClips[i];
                    if (this.currentTime >= clip.start && this.currentTime < clip.start + clip.duration && this.currentTime <= this.endTime) {
                        activeClip = clip;
                        newClipIndex = i;
                        break;
                    }
                }

                if (activeClip) {
                    // Switch to new clip if needed
                    if (this.currentClipIndex !== newClipIndex) {
                        console.log(`Switching to clip ${newClipIndex + 1}:`, {
                            src: activeClip.src,
                            type: activeClip.fileType,
                            duration: activeClip.duration,
                            videoReadyState: activeClip.video.readyState
                        });
                        
                        this.videoSource.src = activeClip.src;
                        this.videoSource.type = activeClip.fileType;
                        this.videoPlayer.classList.remove('no-video');
                        this.videoPlayer.load();
                        this.currentClipIndex = newClipIndex;
                        
                        // Wait for video to be ready
                        this.videoPlayer.onloadeddata = () => {
                            const videoTime = Math.max(0, Math.min(this.currentTime - activeClip.start, activeClip.duration));
                            this.videoPlayer.currentTime = videoTime;
                            
                            if (this.isPlaying) {
                                this.videoPlayer.play().catch(e => {
                                    console.error(`Play error for clip ${newClipIndex + 1}:`, e);
                                    this.updateStatus(`Play error: ${e.message}`);
                                });
                            }
                            console.log(`Video ${newClipIndex + 1} ready, seeking to ${videoTime}s`);
                        };
                    } else {
                        // Same clip, just update time
                        const videoTime = Math.max(0, Math.min(this.currentTime - activeClip.start, activeClip.duration));
                        
                        if (Math.abs(this.videoPlayer.currentTime - videoTime) > 0.3) {
                            this.videoPlayer.currentTime = videoTime;
                        }
                        
                        if (this.isPlaying && this.videoPlayer.paused && this.videoPlayer.readyState >= 2) {
                            this.videoPlayer.play().catch(e => {
                                console.error('Play error:', e);
                            });
                        }
                    }
                } else {
                    // No active clip
                    if (this.currentClipIndex !== -1) {
                        console.log('No active clip at', this.currentTime);
                        this.videoPlayer.pause();
                        this.videoSource.src = '';
                        this.videoPlayer.classList.add('no-video');
                        this.videoPlayer.load();
                        this.currentClipIndex = -1;
                    }
                }
            }

            onPlaybackEnd() {
                console.log('Playback ended');
                if (this.isLooping) {
                    this.currentTime = this.startTime;
                    this.audioElement.currentTime = this.startTime;
                    this.audioElement.play().catch(e => this.updateStatus(`Audio play error: ${e.message}`));
                    this.updateVideoPlayer();
                } else {
                    this.stop();
                }
            }

            async downloadHook() {
                if (!this.audioBuffer || this.endTime - this.startTime < 1) {
                    return this.updateStatus('Invalid hook: Min 1s required');
                }
                const format = document.getElementById('export-format').value;
                this.updateStatus(`Recording hook as ${format.toUpperCase()}...`);
                console.log('Starting recording');
                await this.setupRecorder(format);
                if (!this.recorder) return;
                
                this.recorder.start();
                this.currentTime = this.startTime;
                this.audioElement.currentTime = this.startTime;
                this.audioElement.play().catch(e => this.updateStatus(`Audio play error: ${e.message}`));
                this.updateVideoPlayer();
                this.isPlaying = true;
                
                setTimeout(() => {
                    this.recorder.stop();
                    this.stop();
                    console.log('Recording stopped');
                }, (this.endTime - this.startTime) * 1000);
            }

            async setupRecorder(format) {
                const canvasStream = this.canvas.captureStream(30);
                
                // Get audio stream
                let audioStream;
                if (this.audioElement.captureStream) {
                    audioStream = this.audioElement.captureStream();
                } else if (this.audioElement.mozCaptureStream) {
                    audioStream = this.audioElement.mozCaptureStream();
                } else {
                    this.updateStatus('Audio capture not supported in this browser');
                    console.error('captureStream not supported');
                    return;
                }
                
                const audioTrack = audioStream.getAudioTracks()[0];
                if (audioTrack) {
                    canvasStream.addTrack(audioTrack);
                    console.log('Added audio track to stream');
                } else {
                    console.warn('No audio track found');
                }
                
                this.mediaStream = canvasStream;
                const mimeType = format === 'mp4' ? 'video/mp4' : 'video/webm';
                
                try {
                    this.recorder = new MediaRecorder(canvasStream, { mimeType });
                    console.log(`MediaRecorder created with ${mimeType}`);
                } catch (e) {
                    this.updateStatus(`Error: ${format.toUpperCase()} not supported, try WebM`);
                    console.error(`Recorder setup error: ${e.message}`);
                    return;
                }
                
                const chunks = [];
                this.recorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                        console.log(`Recorded chunk: ${e.data.size} bytes`);
                    }
                };
                
                this.recorder.onstop = () => {
                    console.log(`Recording stopped, total chunks: ${chunks.length}`);
                    const blob = new Blob(chunks, { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hook_${Date.now()}.${format}`;
                    a.click();
                    URL.revokeObjectURL(url);
                    this.updateStatus(`Hook downloaded as ${format.toUpperCase()}! (${(blob.size / 1024 / 1024).toFixed(2)} MB)`);
                };
                
                this.recorder.onerror = (e) => {
                    console.error('Recorder error:', e);
                    this.updateStatus('Recording error occurred');
                };
            }

            animatePreview() {
                requestAnimationFrame(() => this.animatePreview());
                this.canvasCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.canvasCtx.fillStyle = '#000';
                this.canvasCtx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                let activeClip = null;
                for (const clip of this.videoClips) {
                    if (this.currentTime >= clip.start && this.currentTime < clip.start + clip.duration && this.currentTime <= this.endTime) {
                        activeClip = clip;
                        break;
                    }
                }
                
                if (activeClip && activeClip.video.readyState >= 2) {
                    const video = activeClip.video;
                    const videoTime = this.currentTime - activeClip.start;
                    
                    if (Math.abs(video.currentTime - videoTime) > 0.5) {
                        video.currentTime = Math.max(0, Math.min(videoTime, activeClip.duration));
                    }
                    
                    if (video.videoWidth > 0 && video.videoHeight > 0) {
                        const aspect = video.videoWidth / video.videoHeight;
                        const canvasAspect = this.canvas.width / this.canvas.height;
