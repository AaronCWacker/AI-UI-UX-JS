<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎵 Hook Editor 🎵</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f0f0f0; }
        #controls { margin-bottom: 10px; }
        button { margin: 5px; padding: 8px 12px; font-size: 14px; cursor: pointer; }
        #timeline-canvas { border: 1px solid #ccc; width: 100%; height: 100px; background: #fff; }
        #preview-canvas { border: 1px solid #ccc; width: 100%; height: 200px; background: #000; }
        input[type="file"] { margin: 5px; }
        #status { color: #666; font-size: 12px; }
    </style>
</head>
<body>
    <h1>🎵 Hook Editor 🎵</h1>
    <div id="controls">
        <label>📁 Upload Audio (MP3):</label>
        <input type="file" id="audio-upload" accept="audio/*">
        <br>
        <label>🎥 Upload Video Clips (MP4/WebM):</label>
        <input type="file" id="video-upload" accept="video/*" multiple>
        <br>
        <button id="reset-btn">🔄 Reset 🔄</button>
        <button id="play-btn">▶️ Play ▶️</button>
        <button id="stop-btn">⏹️ Stop ⏹️</button>
        <button id="loop-toggle">🔁 Loop Off 🔁</button>
        <button id="download-btn">💾 Download Hook 💾</button>
    </div>
    <canvas id="timeline-canvas"></canvas>
    <br>
    <canvas id="preview-canvas"></canvas>
    <div id="status">Ready. Upload audio to start.</div>

    <script>
        class HookEditor {
            constructor() {
                this.audioContext = null;
                this.audioBuffer = null;
                this.audioElement = new Audio();
                this.videoClips = [];
                this.timelineCanvas = document.getElementById('timeline-canvas');
                this.previewCanvas = document.getElementById('preview-canvas');
                this.timelineCtx = this.timelineCanvas.getContext('2d');
                this.previewCtx = this.previewCanvas.getContext('2d');
                this.timelineWidth = 800;
                this.timelineHeight = 100;
                this.previewWidth = 800;
                this.previewHeight = 200;
                this.timelineCanvas.width = this.timelineWidth;
                this.previewCanvas.width = this.previewWidth;
                this.timelineCanvas.height = this.timelineHeight;
                this.previewCanvas.height = this.previewHeight;
                this.startTime = 0;
                this.endTime = 0;
                this.isPlaying = false;
                this.isLooping = false;
                this.currentTime = 0;
                this.playInterval = null;
                this.isDragging = false;
                this.dragType = null; // 'start', 'end', or 'clip'
                this.dragIndex = -1;
                this.recorder = null;
                this.mediaStream = null;
                this.initEventListeners();
                this.drawTimeline();
                this.animatePreview();
            }

            initEventListeners() {
                document.getElementById('audio-upload').addEventListener('change', (e) => this.loadAudio(e.target.files[0]));
                document.getElementById('video-upload').addEventListener('change', (e) => this.loadVideos(e.target.files));
                document.getElementById('reset-btn').addEventListener('click', () => this.reset());
                document.getElementById('play-btn').addEventListener('click', () => this.play());
                document.getElementById('stop-btn').addEventListener('click', () => this.stop());
                document.getElementById('loop-toggle').addEventListener('click', () => this.toggleLoop());
                document.getElementById('download-btn').addEventListener('click', () => this.downloadHook());
                this.timelineCanvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.timelineCanvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.timelineCanvas.addEventListener('mouseup', () => this.handleMouseUp());
                this.timelineCanvas.addEventListener('wheel', (e) => this.handleWheel(e)); // Basic zoom
                this.audioElement.addEventListener('timeupdate', () => this.updateCurrentTime());
                this.audioElement.addEventListener('ended', () => this.onPlaybackEnd());
            }

            async loadAudio(file) {
                if (!file) return;
                const arrayBuffer = await file.arrayBuffer();
                if (!this.audioContext) this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                this.audioElement.src = URL.createObjectURL(file);
                this.endTime = this.audioBuffer.duration;
                if (this.endTime > 60) this.endTime = 60; // Cap at 60s
                this.startTime = 0;
                this.videoClips = []; // Clear clips on new audio
                this.drawTimeline();
                this.updateStatus(`Audio loaded: ${this.formatTime(this.audioBuffer.duration)}`);
            }

            loadVideos(files) {
                Array.from(files).forEach(file => {
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(file);
                    video.onloadedmetadata = () => {
                        const duration = video.duration;
                        if (duration < 10) {
                            this.updateStatus(`Clip too short: ${file.name}`);
                            return;
                        }
                        this.videoClips.push({ file, video, start: this.getTotalDuration(), duration: Math.min(duration, 60 - this.getTotalDuration()) });
                        this.drawTimeline();
                        this.updateStatus(`Added clip: ${file.name} (${this.formatTime(this.videoClips[this.videoClips.length - 1].duration)})`);
                    };
                });
            }

            getTotalDuration() {
                return this.videoClips.reduce((sum, clip) => sum + clip.duration, 0);
            }

            drawTimeline() {
                this.timelineCtx.clearRect(0, 0, this.timelineWidth, this.timelineHeight);
                const duration = Math.max(this.endTime, this.getTotalDuration()) || 1;
                const pxPerSec = this.timelineWidth / duration;

                // Draw waveform if audio loaded
                if (this.audioBuffer) {
                    const data = this.audioBuffer.getChannelData(0);
                    const step = Math.floor(data.length / this.timelineWidth);
                    this.timelineCtx.strokeStyle = '#007bff';
                    this.timelineCtx.beginPath();
                    for (let i = 0; i < this.timelineWidth; i++) {
                        let min = 1, max = -1;
                        for (let j = 0; j < step; j++) {
                            const val = data[i * step + j];
                            if (val < min) min = val;
                            if (val > max) max = val;
                        }
                        const x = i;
                        const yMid = this.timelineHeight / 2;
                        const y1 = yMid + min * (this.timelineHeight / 2);
                        const y2 = yMid + max * (this.timelineHeight / 2);
                        if (i === 0) this.timelineCtx.moveTo(x, y1);
                        else this.timelineCtx.lineTo(x, y1);
                        this.timelineCtx.lineTo(x, y2);
                    }
                    this.timelineCtx.stroke();
                }

                // Draw video clips
                this.videoClips.forEach((clip, index) => {
                    const x = clip.start * pxPerSec;
                    const width = clip.duration * pxPerSec;
                    this.timelineCtx.fillStyle = index % 2 ? '#28a745' : '#ffc107';
                    this.timelineCtx.fillRect(x, 10, width, 20);
                    this.timelineCtx.strokeStyle = '#000';
                    this.timelineCtx.strokeRect(x, 10, width, 20);
                });

                // Draw window handles
                const startX = this.startTime * pxPerSec;
                const endX = this.endTime * pxPerSec;
                this.timelineCtx.fillStyle = 'red';
                this.timelineCtx.fillRect(startX - 2, 0, 4, this.timelineHeight);
                this.timelineCtx.fillRect(endX - 2, 0, 4, this.timelineHeight);
                this.timelineCtx.fillStyle = 'rgba(255,0,0,0.1)';
                this.timelineCtx.fillRect(startX, 0, endX - startX, this.timelineHeight);
            }

            handleMouseDown(e) {
                const rect = this.timelineCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const duration = Math.max(this.endTime, this.getTotalDuration()) || 1;
                const pxPerSec = this.timelineWidth / duration;
                const time = x / pxPerSec;

                // Check for clip drag
                for (let i = 0; i < this.videoClips.length; i++) {
                    const clip = this.videoClips[i];
                    if (time >= clip.start && time <= clip.start + clip.duration) {
                        this.isDragging = true;
                        this.dragType = 'clip';
                        this.dragIndex = i;
                        return;
                    }
                }

                // Check start/end handles
                if (Math.abs(time - this.startTime) < 0.5 / pxPerSec) {
                    this.dragType = 'start';
                } else if (Math.abs(time - this.endTime) < 0.5 / pxPerSec) {
                    this.dragType = 'end';
                } else {
                    this.startTime = time;
                    this.endTime = Math.min(time + 10, duration); // Min 10s
                }
                this.isDragging = true;
                this.drawTimeline();
            }

            handleMouseMove(e) {
                if (!this.isDragging) return;
                const rect = this.timelineCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const duration = Math.max(this.endTime, this.getTotalDuration()) || 1;
                const pxPerSec = this.timelineWidth / duration;
                let time = x / pxPerSec;

                if (this.dragType === 'start') {
                    this.startTime = Math.max(0, time);
                    this.endTime = Math.max(this.startTime + 10, this.endTime);
                } else if (this.dragType === 'end') {
                    this.endTime = Math.min(duration, time);
                    this.startTime = Math.min(this.startTime, this.endTime - 10);
                } else if (this.dragType === 'clip') {
                    const clip = this.videoClips[this.dragIndex];
                    const delta = time - (clip.start + clip.duration / 2);
                    clip.start = Math.max(0, clip.start + delta);
                    clip.start = Math.min(duration - clip.duration, clip.start);
                }
                this.drawTimeline();
            }

            handleMouseUp() {
                this.isDragging = false;
                this.dragType = null;
                this.dragIndex = -1;
            }

            handleWheel(e) {
                e.preventDefault();
                // Simple zoom: adjust endTime relative to current
                const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                const center = (this.startTime + this.endTime) / 2;
                this.endTime = Math.min(center + (this.endTime - this.startTime) * zoomFactor / 2 * 2, this.audioBuffer ? this.audioBuffer.duration : 60);
                this.startTime = Math.max(center - (this.endTime - this.startTime) / 2, 0);
                this.drawTimeline();
            }

            play() {
                if (!this.audioBuffer) return this.updateStatus('No audio loaded');
                this.currentTime = this.startTime;
                this.audioElement.currentTime = this.startTime;
                this.audioElement.play();
                this.isPlaying = true;
                this.playInterval = setInterval(() => this.updatePreview(), 50);
                document.getElementById('play-btn').textContent = '⏸️ Pause ⏸️';
                this.updateStatus(`Playing ${this.formatTime(this.endTime - this.startTime)} hook`);
            }

            stop() {
                this.audioElement.pause();
                this.isPlaying = false;
                clearInterval(this.playInterval);
                this.currentTime = 0;
                document.getElementById('play-btn').textContent = '▶️ Play ▶️';
                this.updateStatus('Stopped');
            }

            toggleLoop() {
                this.isLooping = !this.isLooping;
                document.getElementById('loop-toggle').textContent = this.isLooping ? '🔁 Loop On 🔁' : '🔁 Loop Off 🔁';
            }

            onPlaybackEnd() {
                if (this.isLooping && this.isPlaying) {
                    this.currentTime = this.startTime;
                    this.audioElement.currentTime = this.startTime;
                    this.audioElement.play();
                } else {
                    this.stop();
                }
            }

            updateCurrentTime() {
                this.currentTime = this.audioElement.currentTime;
                if (this.currentTime >= this.endTime) this.onPlaybackEnd();
            }

            async downloadHook() {
                if (!this.audioBuffer || this.endTime - this.startTime < 10) {
                    return this.updateStatus('Invalid hook: Min 10s required');
                }
                this.updateStatus('Recording hook...');
                await this.setupRecorder();
                if (!this.recorder) return;
                this.recorder.start();
                this.audioElement.currentTime = this.startTime;
                this.audioElement.play();
                setTimeout(() => {
                    this.recorder.stop();
                    this.audioElement.pause();
                    this.stop();
                }, (this.endTime - this.startTime) * 1000);
            }

            async setupRecorder() {
                // Create canvas stream for video
                const canvasStream = this.previewCanvas.captureStream(30); // 30 FPS
                // Create audio stream from audio element (playhead at start)
                const audioStream = this.audioElement.captureStream ? this.audioElement.captureStream() : new MediaStream([this.audioContext.createMediaElementSource(this.audioElement).connect(this.audioContext.destination).context.destination]);
                // Combine streams
                const audioTrack = audioStream.getAudioTracks()[0];
                if (audioTrack) canvasStream.addTrack(audioTrack);
                this.mediaStream = canvasStream;
                this.recorder = new MediaRecorder(canvasStream, { mimeType: 'video/webm' });
                const chunks = [];
                this.recorder.ondataavailable = (e) => chunks.push(e.data);
                this.recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hook_${this.formatTime(this.endTime - this.startTime)}.webm`;
                    a.click();
                    URL.revokeObjectURL(url);
                    this.updateStatus('Hook downloaded!');
                };
            }

            animatePreview() {
                requestAnimationFrame(() => this.animatePreview());
                this.updatePreview();
            }

            updatePreview() {
                this.previewCtx.clearRect(0, 0, this.previewWidth, this.previewHeight);
                if (!this.audioBuffer) return;

                // Draw black background
                this.previewCtx.fillStyle = '#000';
                this.previewCtx.fillRect(0, 0, this.previewWidth, this.previewHeight);

                // Draw video clips if in window
                let clipOffset = 0;
                this.videoClips.forEach(clip => {
                    if (clip.start < this.endTime && clip.start + clip.duration > this.startTime) {
                        const clipStart = Math.max(0, this.startTime - clip.start);
                        const drawDuration = Math.min(clip.duration - clipStart, this.endTime - this.startTime);
                        if (clip.video.readyState >= 2) {
                            this.previewCtx.drawImage(clip.video, clipOffset * this.previewWidth / (this.endTime - this.startTime), 0, 
                                (drawDuration / (this.endTime - this.startTime)) * this.previewWidth, this.previewHeight);
                        }
                        clipOffset += drawDuration;
                    }
                });

                // Overlay simple waveform in preview (scaled)
                if (this.audioBuffer) {
                    const data = this.audioBuffer.getChannelData(0);
                    const sliceWidth = this.previewWidth / (this.endTime - this.startTime) / this.audioBuffer.sampleRate * data.length; // Approx
                    // Simplified: draw lines for current window
                    this.previewCtx.strokeStyle = 'rgba(255,255,255,0.5)';
                    this.previewCtx.beginPath();
                    const windowSamples = data.slice(this.startTime * this.audioBuffer.sampleRate, this.endTime * this.audioBuffer.sampleRate);
                    for (let i = 0; i < windowSamples.length; i += Math.floor(windowSamples.length / this.previewWidth)) {
                        const v = windowSamples[i];
                        const x = (i / windowSamples.length) * this.previewWidth;
                        const y = (v + 1) / 2 * this.previewHeight;
                        if (i === 0) this.previewCtx.moveTo(x, y);
                        else this.previewCtx.lineTo(x, y);
                    }
                    this.previewCtx.stroke();
                }

                // Draw playhead
                if (this.isPlaying) {
                    const pxPerSec = this.previewWidth / (this.endTime - this.startTime);
                    const headX = (this.currentTime - this.startTime) * pxPerSec;
                    this.previewCtx.fillStyle = 'red';
                    this.previewCtx.fillRect(headX, 0, 2, this.previewHeight);
                }
            }

            reset() {
                this.stop();
                this.audioBuffer = null;
                this.videoClips = [];
                this.startTime = 0;
                this.endTime = 0;
                this.drawTimeline();
                document.getElementById('audio-upload').value = '';
                document.getElementById('video-upload').value = '';
                this.updateStatus('Reset complete');
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            updateStatus(msg) {
                document.getElementById('status').textContent = msg;
            }
        }

        new HookEditor();
    </script>
</body>
</html>
