<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>FAMILIAR ARENA ‚Äî Card Flight Combat</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Exo+2:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg:#020309;--bg2:#080d1a;--bg3:#0f1628;
  --mint:#33ffbb;--cyan:#44ddff;--violet:#d4a0ff;
  --rose:#ff6b8a;--gold:#ffd04a;--ember:#ff8f5a;
  --text:#e8edf5;--text2:#a0b4cc;--text3:#5a7090;
  --glass:rgba(8,13,26,0.88);--glass2:rgba(15,22,40,0.8);
}
*{margin:0;padding:0;box-sizing:border-box;}
html,body{width:100%;height:100%;overflow:hidden;background:var(--bg);font-family:'Exo 2',sans-serif;color:var(--text);cursor:crosshair;}
canvas#gameCanvas{position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;}
#hud{position:fixed;inset:0;z-index:10;pointer-events:none;}
#hud>*{pointer-events:auto;}
#modeSelect{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(2,3,9,0.95);z-index:100;transition:opacity 0.6s;backdrop-filter:blur(20px);}
#modeSelect.hidden{opacity:0;pointer-events:none;}
.mode-title{font-family:'Orbitron',sans-serif;font-size:2.8rem;font-weight:900;background:linear-gradient(135deg,var(--mint),var(--cyan),var(--violet));-webkit-background-clip:text;-webkit-text-fill-color:transparent;letter-spacing:0.12em;margin-bottom:0.3rem;text-align:center;}
.mode-sub{font-family:'JetBrains Mono',monospace;font-size:0.8rem;color:var(--cyan);letter-spacing:0.15em;margin-bottom:2.5rem;text-align:center;}
.mode-cards{display:flex;gap:1.5rem;flex-wrap:wrap;justify-content:center;max-width:900px;}
.mode-card{width:260px;padding:2rem 1.5rem;background:var(--glass);border:1px solid rgba(51,255,187,0.12);border-radius:16px;cursor:pointer;transition:all 0.4s cubic-bezier(0.16,1,0.3,1);text-align:center;position:relative;overflow:hidden;}
.mode-card::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;border-radius:16px 16px 0 0;}
.mode-card:nth-child(1)::before{background:var(--mint);}
.mode-card:nth-child(2)::before{background:var(--rose);}
.mode-card:nth-child(3)::before{background:var(--violet);}
.mode-card:hover{transform:translateY(-6px);border-color:rgba(51,255,187,0.4);box-shadow:0 12px 40px rgba(0,0,0,0.5),0 0 30px rgba(51,255,187,0.1);}
.mode-card .mc-icon{font-size:3rem;margin-bottom:0.8rem;filter:drop-shadow(0 0 12px currentColor);}
.mode-card .mc-name{font-family:'Orbitron',sans-serif;font-size:1rem;font-weight:700;letter-spacing:0.1em;margin-bottom:0.5rem;}
.mode-card:nth-child(1) .mc-name{color:var(--mint);}
.mode-card:nth-child(2) .mc-name{color:var(--rose);}
.mode-card:nth-child(3) .mc-name{color:var(--violet);}
.mode-card .mc-desc{font-size:0.78rem;color:var(--text2);line-height:1.6;}
.mode-hint{margin-top:2rem;font-family:'JetBrains Mono',monospace;font-size:0.65rem;color:var(--text3);letter-spacing:0.1em;}
#flightHUD{position:absolute;inset:0;opacity:0;transition:opacity 0.5s;pointer-events:none;}
#flightHUD .flight-sidebars{position:absolute;inset:0;pointer-events:none;}
.flight-rail{position:absolute;top:78px;bottom:72px;width:150px;display:flex;flex-direction:column;gap:0.45rem;overflow:hidden;padding:0.25rem;}
.flight-rail.left{left:12px;align-items:flex-start;}
.flight-rail.right{right:12px;align-items:flex-end;}
.flight-card{width:138px;padding:0.45rem 0.5rem;border-radius:10px;background:rgba(8,13,26,0.82);border:1px solid rgba(255,255,255,0.08);backdrop-filter:blur(8px);box-shadow:0 8px 20px rgba(0,0,0,0.25);animation:flightCardIn 0.22s ease-out;}
.flight-card .fc-name{font-family:'Orbitron',sans-serif;font-size:0.56rem;font-weight:700;letter-spacing:0.06em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-bottom:0.2rem;}
.flight-card .fc-stats{display:flex;gap:0.3rem;flex-wrap:wrap;font-family:'JetBrains Mono',monospace;font-size:0.52rem;color:var(--text2);}
.flight-card .fc-stat{padding:0.08rem 0.28rem;border-radius:999px;background:rgba(255,255,255,0.05);}
.flight-card .fc-ability{margin-top:0.22rem;font-family:'JetBrains Mono',monospace;font-size:0.46rem;color:var(--text3);line-height:1.25;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;}
.flight-rail-label{font-family:'Orbitron',sans-serif;font-size:0.55rem;letter-spacing:0.12em;color:var(--gold);opacity:0.9;margin:0 0 0.2rem 0.15rem;}
@keyframes flightCardIn{from{opacity:0;transform:translateY(12px) scale(0.96);}to{opacity:1;transform:translateY(0) scale(1);}}
#flightHUD.active{opacity:1;}
.crosshair{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:48px;height:48px;border:2px solid rgba(51,255,187,0.25);border-radius:50%;}
.crosshair::before,.crosshair::after{content:'';position:absolute;background:var(--mint);opacity:0.4;}
.crosshair::before{top:50%;left:-12px;right:-12px;height:1px;}
.crosshair::after{left:50%;top:-12px;bottom:-12px;width:1px;}
#speedGauge{position:absolute;bottom:80px;left:30px;font-family:'JetBrains Mono',monospace;font-size:0.75rem;color:var(--cyan);text-shadow:0 0 8px var(--cyan);line-height:1.8;}
#altGauge{position:absolute;bottom:80px;right:30px;font-family:'JetBrains Mono',monospace;font-size:0.75rem;color:var(--mint);text-shadow:0 0 8px var(--mint);text-align:right;line-height:1.8;}
#cardCollector{position:absolute;top:15px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:0.8rem;letter-spacing:0.12em;color:var(--gold);text-shadow:0 0 10px var(--gold);text-align:center;}
#phaseTimer{font-family:'JetBrains Mono',monospace;font-size:1.4rem;color:var(--mint);display:block;margin-top:0.3rem;}
.controls-help{position:absolute;bottom:15px;left:50%;transform:translateX(-50%);font-family:'JetBrains Mono',monospace;font-size:0.6rem;color:var(--text3);text-align:center;background:rgba(0,0,0,0.5);padding:0.4rem 1.2rem;border-radius:6px;border:1px solid rgba(51,255,187,0.08);}
.controls-help kbd{background:rgba(51,255,187,0.15);color:var(--mint);padding:0.1rem 0.35rem;border-radius:3px;margin:0 0.1rem;font-size:0.6rem;}
.pickup-flash{position:fixed;inset:0;z-index:200;display:flex;align-items:center;justify-content:center;pointer-events:none;opacity:0;transition:opacity 0.25s,transform 0.3s;}
.pickup-flash.active{opacity:1;}
.pickup-flash-inner{font-family:'Orbitron',sans-serif;font-size:1.6rem;font-weight:800;padding:0.5rem 2rem;border-radius:10px;background:rgba(2,3,9,0.8);border:1px solid var(--gold);color:var(--gold);text-shadow:0 0 15px var(--gold);backdrop-filter:blur(8px);}
#battleHUD{position:absolute;inset:0;opacity:0;transition:opacity 0.5s;pointer-events:none;display:flex;flex-direction:column;}
#battleHUD.active{opacity:1;pointer-events:auto;}
.battle-top{display:flex;justify-content:space-between;align-items:flex-start;padding:1rem 1.5rem;}
.player-info{min-width:220px;padding:0.8rem 1rem;background:var(--glass);border-radius:10px;border:1px solid rgba(51,255,187,0.1);}
.player-info .pi-name{font-family:'Orbitron',sans-serif;font-size:0.75rem;letter-spacing:0.12em;margin-bottom:0.4rem;}
.player-info.human .pi-name{color:var(--mint);} .player-info.ai .pi-name{color:var(--rose);} .player-info.ally .pi-name{color:var(--violet);}
.hp-bar{height:8px;background:rgba(255,255,255,0.06);border-radius:4px;overflow:hidden;margin-bottom:0.3rem;}
.hp-fill{height:100%;border-radius:4px;transition:width 0.6s cubic-bezier(0.16,1,0.3,1);}
.player-info.human .hp-fill{background:linear-gradient(90deg,var(--mint),var(--cyan));}
.player-info.ai .hp-fill{background:linear-gradient(90deg,var(--rose),var(--ember));}
.player-info.ally .hp-fill{background:linear-gradient(90deg,var(--violet),var(--cyan));}
.pi-stats{font-family:'JetBrains Mono',monospace;font-size:0.6rem;color:var(--text3);display:flex;gap:0.8rem;}
.battle-vs{font-family:'Orbitron',sans-serif;font-size:1.2rem;font-weight:900;color:var(--gold);text-shadow:0 0 15px rgba(255,208,74,0.4);letter-spacing:0.2em;align-self:center;padding-top:0.5rem;}
.battle-center{flex:1;display:flex;align-items:center;justify-content:center;position:relative;}
#battleLog{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-family:'Orbitron',sans-serif;font-size:1.2rem;font-weight:700;text-align:center;text-shadow:0 0 20px currentColor;transition:all 0.3s;color:var(--cyan);max-width:500px;}
.battle-bottom{padding:0.8rem 1rem;}
.hand-label{font-family:'Orbitron',sans-serif;font-size:0.6rem;letter-spacing:0.15em;color:var(--text3);margin-bottom:0.5rem;text-align:center;}
#handContainer{display:flex;gap:0.6rem;justify-content:center;flex-wrap:wrap;padding:0 0.5rem;max-height:170px;overflow-y:auto;}
.hand-card{width:130px;padding:0.7rem;background:var(--glass);border:1px solid rgba(51,255,187,0.12);border-radius:10px;cursor:pointer;transition:all 0.35s cubic-bezier(0.16,1,0.3,1);position:relative;overflow:hidden;flex-shrink:0;}
.hand-card:hover{transform:translateY(-8px) scale(1.04);border-color:rgba(51,255,187,0.5);box-shadow:0 8px 30px rgba(0,0,0,0.4),0 0 20px rgba(51,255,187,0.1);}
.hand-card.selected{border-color:var(--gold);box-shadow:0 0 25px rgba(255,208,74,0.3);transform:translateY(-10px);}
.hand-card .hc-name{font-family:'Orbitron',sans-serif;font-size:0.6rem;font-weight:700;letter-spacing:0.05em;margin-bottom:0.3rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.hand-card .hc-stats{display:flex;gap:0.4rem;margin-bottom:0.3rem;}
.hand-card .hc-stat{font-family:'JetBrains Mono',monospace;font-size:0.55rem;padding:0.1rem 0.3rem;border-radius:3px;background:rgba(255,255,255,0.05);}
.hc-atk{color:var(--rose);} .hc-def{color:var(--cyan);} .hc-enr{color:var(--gold);}
.hand-card .hc-ability{font-family:'JetBrains Mono',monospace;font-size:0.5rem;color:var(--violet);line-height:1.4;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;}
.hand-card .hc-cost{position:absolute;top:0.4rem;right:0.4rem;font-family:'Orbitron',sans-serif;font-size:0.55rem;background:rgba(255,208,74,0.15);color:var(--gold);padding:0.1rem 0.3rem;border-radius:3px;}
#battleActions{display:flex;gap:0.5rem;justify-content:center;margin-top:0.6rem;}
.battle-btn{font-family:'Orbitron',sans-serif;font-size:0.7rem;letter-spacing:0.1em;padding:0.5rem 1.2rem;border-radius:8px;border:1px solid;cursor:pointer;transition:all 0.3s;font-weight:700;}
.battle-btn:hover{transform:translateY(-2px);} .btn-play{background:rgba(51,255,187,0.12);border-color:var(--mint);color:var(--mint);} .btn-defend{background:rgba(68,221,255,0.12);border-color:var(--cyan);color:var(--cyan);} .btn-special{background:rgba(212,160,255,0.12);border-color:var(--violet);color:var(--violet);} .btn-end{background:rgba(255,107,138,0.12);border-color:var(--rose);color:var(--rose);} 
.energy-display{display:flex;align-items:center;justify-content:center;gap:0.5rem;margin-top:0.4rem;}
.energy-display label{font-family:'JetBrains Mono',monospace;font-size:0.65rem;color:var(--gold);letter-spacing:0.1em;}
.energy-pips{display:flex;gap:0.2rem;}.energy-pip{width:10px;height:10px;border-radius:50%;border:1px solid var(--gold);transition:all 0.3s;}.energy-pip.full{background:var(--gold);box-shadow:0 0 6px var(--gold);}
#roundResult{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(2,3,9,0.85);z-index:30;opacity:0;pointer-events:none;transition:opacity 0.4s;backdrop-filter:blur(6px);}
#roundResult.active{opacity:1;pointer-events:auto;}
.rr-inner{text-align:center;padding:2rem 3rem;background:var(--glass);border-radius:16px;border:1px solid rgba(51,255,187,0.15);}
.rr-title{font-family:'Orbitron',sans-serif;font-size:2rem;font-weight:900;margin-bottom:0.5rem;}
.rr-sub{font-family:'JetBrains Mono',monospace;font-size:0.8rem;color:var(--text2);margin-bottom:1.5rem;}
.rr-btn{font-family:'Orbitron',sans-serif;font-size:0.8rem;padding:0.6rem 2rem;border-radius:8px;border:1px solid var(--mint);background:rgba(51,255,187,0.15);color:var(--mint);cursor:pointer;letter-spacing:0.1em;transition:all 0.3s;}
#coopStatus{position:absolute;top:50%;right:15px;transform:translateY(-50%);background:var(--glass);border:1px solid rgba(212,160,255,0.15);border-radius:10px;padding:0.6rem 0.8rem;font-family:'JetBrains Mono',monospace;font-size:0.6rem;color:var(--violet);display:none;max-width:160px;text-align:center;}
#coopStatus.active{display:block;}
.coop-label{font-family:'Orbitron',sans-serif;font-size:0.55rem;letter-spacing:0.12em;color:var(--violet);margin-bottom:0.3rem;}
.toast{position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:rgba(51,255,187,0.15);border:1px solid var(--mint);color:var(--mint);font-family:'JetBrains Mono',monospace;font-size:0.75rem;padding:0.5rem 1.5rem;border-radius:8px;z-index:400;opacity:0;transition:opacity 0.3s;pointer-events:none;backdrop-filter:blur(10px);}
.toast.visible{opacity:1;}
::-webkit-scrollbar{width:4px;}::-webkit-scrollbar-thumb{background:rgba(51,255,187,0.15);border-radius:4px;}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="hud">
  <div id="modeSelect">
    <div class="mode-title">FAMILIAR ARENA</div>
    <div class="mode-sub">CARD FLIGHT COMBAT ‚Äî 80 AI GUIDES</div>
    <div class="mode-cards">
      <div class="mode-card" onclick="startGame('versus')"><div class="mc-icon">‚öîÔ∏è</div><div class="mc-name">VS AI</div><div class="mc-desc">Battle an AI opponent. Fly to collect cards, then duel in turn-based combat.</div></div>
      <div class="mode-card" onclick="startGame('coop')"><div class="mc-icon">ü§ù</div><div class="mc-name">CO-OP</div><div class="mc-desc">Team up with an AI ally against enemy waves. Share energy, combo cards, and survive together.</div></div>
      <div class="mode-card" onclick="startGame('solo')"><div class="mc-icon">üß≠</div><div class="mc-name">SOLO FLIGHT</div><div class="mc-desc">Free flight through the neon city. Collect all 80 AI Guide cards at your own pace.</div></div>
    </div>
    <div class="mode-hint">WASD + MOUSE TO FLY ¬∑ COLLECT CARDS ¬∑ PLAY BATTLES</div>
  </div>
  <div id="flightHUD"><div class="crosshair"></div><div id="speedGauge">SPD: 0<br>THR: 0%</div><div id="altGauge">ALT: 0<br>CARDS: 0</div><div id="cardCollector">CARDS COLLECTED: 0 / 5<span id="phaseTimer">0:30</span></div><div class="flight-sidebars"><div class="flight-rail left"><div class="flight-rail-label">LOADOUT</div><div id="flightRailLeft"></div></div><div class="flight-rail right"><div class="flight-rail-label">PICKUPS</div><div id="flightRailRight"></div></div></div><div class="controls-help"><kbd>W</kbd> Thrust <kbd>S</kbd> Brake <kbd>A</kbd>/<kbd>D</kbd> Roll <kbd>Mouse</kbd> Aim <kbd>Space</kbd> Boost <kbd>B</kbd> Start Battle</div></div>
  <div id="battleHUD"><div class="battle-top"><div class="player-info human" id="playerInfo"><div class="pi-name">‚ö° OPERATOR</div><div class="hp-bar"><div class="hp-fill" id="playerHP" style="width:100%"></div></div><div class="pi-stats"><span>‚ù§Ô∏è <b id="playerHPText">100</b></span><span>üõ°Ô∏è <b id="playerDEF">0</b></span></div></div><div class="battle-vs" id="battleVsLabel">VS</div><div class="player-info ai" id="enemyInfo"><div class="pi-name">üî¥ NEURAL ADVERSARY</div><div class="hp-bar"><div class="hp-fill" id="enemyHP" style="width:100%"></div></div><div class="pi-stats"><span>‚ù§Ô∏è <b id="enemyHPText">100</b></span><span>üõ°Ô∏è <b id="enemyDEF">0</b></span></div></div></div><div class="battle-center"><div id="battleLog">BATTLE START</div></div><div id="coopStatus"><div class="coop-label">AI ALLY</div><div id="coopAction">Analyzing...</div></div><div class="battle-bottom"><div class="hand-label">YOUR HAND ‚Äî SELECT A CARD TO PLAY</div><div id="handContainer"></div><div id="battleActions"><button class="battle-btn btn-play" id="btnPlayCard" onclick="playSelectedCard()" disabled>‚ñ∂ PLAY CARD</button><button class="battle-btn btn-defend" onclick="defendTurn()">üõ°Ô∏è DEFEND</button><button class="battle-btn btn-special" id="btnSpecial" onclick="specialAbility()">‚ú® SPECIAL</button><button class="battle-btn btn-end" onclick="endBattle()">‚úï RETREAT</button></div><div class="energy-display"><label>ENERGY</label><div class="energy-pips" id="energyPips"></div></div></div></div>
  <div id="roundResult"><div class="rr-inner"><div class="rr-title" id="rrTitle">VICTORY</div><div class="rr-sub" id="rrSub">You defeated the Neural Adversary!</div><button class="rr-btn" onclick="returnToMenu()">RETURN TO MENU</button></div></div>
</div>
<div class="pickup-flash" id="pickupFlash"><div class="pickup-flash-inner" id="pickupFlashText">+1 CARD</div></div>
<div class="toast" id="toast"></div>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.183.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

const ARCANA = [
{id:0,name:"LLM OS Kernel",color:0x33ffbb,tags:["kernel","foundation"],atk:8,def:9,enr:3,ability:"System Override: +5 to all allies' DEF",type:"support"},
{id:1,name:"Agentic MeshOS",color:0x44ddff,tags:["mesh","swarm"],atk:7,def:6,enr:2,ability:"Swarm Link: Deal ATK to 2 targets",type:"attack"},
{id:2,name:"Goal Graph Nav",color:0xd4a0ff,tags:["planning","goals"],atk:5,def:7,enr:2,ability:"Pathfind: Draw 1 extra card next turn",type:"utility"},
{id:3,name:"Toolchain DSL",color:0x3b82f6,tags:["dsl","tools"],atk:6,def:5,enr:1,ability:"Compose: +3 ATK to next card played",type:"buff"},
{id:4,name:"Prompt IR Lang",color:0x10b981,tags:["prompt","compiler"],atk:7,def:4,enr:2,ability:"Compile: Double this card's ATK",type:"attack"},
{id:5,name:"Spec‚ÜíCode Gen",color:0xfbbf24,tags:["generation","synthesis"],atk:9,def:3,enr:3,ability:"Generate: Create a random 5/5 token",type:"summon"},
{id:6,name:"Code SynthOps",color:0xff6b8a,tags:["synthesis","pipeline"],atk:8,def:5,enr:2,ability:"Pipeline: ATK hits twice at half power",type:"attack"},
{id:7,name:"Eval Harness+",color:0x06b6d4,tags:["evaluation","testing"],atk:4,def:8,enr:2,ability:"Benchmark: Reveal enemy's next card",type:"utility"},
{id:8,name:"Safety Rails++",color:0xef4444,tags:["safety","guardrails"],atk:3,def:10,enr:2,ability:"Guardrail: Absorb next attack completely",type:"defense"},
{id:9,name:"Policy-as-Code",color:0x8b5cf6,tags:["policy","governance"],atk:5,def:8,enr:2,ability:"Enforce: Enemy loses 1 energy",type:"control"},
{id:10,name:"LongMem Stack",color:0x33ffbb,tags:["memory","persistence"],atk:6,def:7,enr:2,ability:"Recall: Recover a used card",type:"utility"},
{id:11,name:"Memory KG Ops",color:0x44ddff,tags:["knowledge-graph"],atk:7,def:6,enr:2,ability:"Connect: +2 ATK per card in hand",type:"scaling"},
{id:12,name:"Retrieval IDE",color:0xd4a0ff,tags:["retrieval","ide"],atk:5,def:5,enr:1,ability:"Search: Draw 2 cards",type:"utility"},
{id:13,name:"Hybrid RAG++",color:0x3b82f6,tags:["rag","hybrid"],atk:8,def:6,enr:3,ability:"Fuse: Combine ATK of 2 hand cards",type:"combo"},
{id:14,name:"Embed Fusion",color:0x10b981,tags:["embeddings","fusion"],atk:7,def:7,enr:2,ability:"Align: Copy opponent's last card ATK",type:"mirror"},
{id:15,name:"Vectorless RAG",color:0xfbbf24,tags:["vectorless","lightweight"],atk:6,def:4,enr:1,ability:"Lightweight: Costs 0 energy this turn",type:"free"},
{id:16,name:"DocOps Copilot",color:0xff6b8a,tags:["documents","copilot"],atk:5,def:6,enr:1,ability:"Assist: Heal 5 HP",type:"heal"},
{id:17,name:"PDF‚ÜíTruth Pipe",color:0x06b6d4,tags:["pdf","extraction"],atk:6,def:5,enr:2,ability:"Extract: Steal 2 DEF from enemy",type:"drain"},
{id:18,name:"Vision Parse++",color:0x8b5cf6,tags:["vision","parsing"],atk:7,def:5,enr:2,ability:"Parse: Ignore enemy DEF this attack",type:"pierce"},
{id:19,name:"Video2Insight",color:0xef4444,tags:["video","temporal"],atk:8,def:4,enr:2,ability:"Temporal: Deal damage over 3 turns",type:"dot"},
{id:20,name:"Audio2Signals",color:0x33ffbb,tags:["audio","signals"],atk:6,def:6,enr:2,ability:"Resonate: +3 DEF to self",type:"defense"},
{id:21,name:"Realtime Voice",color:0x44ddff,tags:["voice","realtime"],atk:9,def:3,enr:3,ability:"Interrupt: Play during enemy's turn",type:"counter"},
{id:22,name:"Neural TTS Lab",color:0xd4a0ff,tags:["tts","synthesis"],atk:5,def:7,enr:2,ability:"Voice: Stun enemy for 1 turn",type:"control"},
{id:23,name:"Live STT Loop",color:0x3b82f6,tags:["stt","streaming"],atk:6,def:5,enr:1,ability:"Transcribe: See enemy's hand",type:"intel"},
{id:24,name:"Multimodal IO",color:0x10b981,tags:["multimodal"],atk:8,def:8,enr:3,ability:"Omni: Can act as ATK, DEF, or HEAL",type:"flex"},
{id:25,name:"MoE Router AI",color:0xfbbf24,tags:["mixture-of-experts"],atk:9,def:5,enr:3,ability:"Route: Choose best card from top 3 of deck",type:"utility"},
{id:26,name:"Self-Reward RL",color:0xff6b8a,tags:["self-reward","rl"],atk:7,def:4,enr:2,ability:"Iterate: Gains +2 ATK each time played",type:"scaling"},
{id:27,name:"Debate Swarm",color:0x06b6d4,tags:["debate","adversarial"],atk:8,def:7,enr:3,ability:"Clash: Both players take 5 damage",type:"chaos"},
{id:28,name:"Planner+Critic",color:0x8b5cf6,tags:["planning","criticism"],atk:6,def:8,enr:2,ability:"Refine: +4 ATK if you defended last turn",type:"combo"},
{id:29,name:"Execute+Verify",color:0xef4444,tags:["execution","verification"],atk:7,def:7,enr:2,ability:"Verify: If ATK > enemy DEF, deal double",type:"execute"},
{id:30,name:"Guarded Tools",color:0x33ffbb,tags:["tools","safety"],atk:4,def:9,enr:2,ability:"Guard: Reflect 50% damage back",type:"reflect"},
{id:31,name:"Function Forge",color:0x44ddff,tags:["functions","creation"],atk:8,def:4,enr:2,ability:"Forge: Create custom 1-use tool card",type:"summon"},
{id:32,name:"Sandbox Runner",color:0xd4a0ff,tags:["sandbox","execution"],atk:7,def:6,enr:2,ability:"Isolate: Immune to enemy abilities this turn",type:"shield"},
{id:33,name:"DevAgent IDE",color:0x3b82f6,tags:["ide","development"],atk:6,def:6,enr:2,ability:"Pair: Play 2 cards this turn",type:"tempo"},
{id:34,name:"Patch Diff Gen",color:0x10b981,tags:["patches","diff"],atk:7,def:3,enr:1,ability:"Precision: Always hits (ignores dodge)",type:"pierce"},
{id:35,name:"UnitTest Gen+",color:0xfbbf24,tags:["testing","coverage"],atk:5,def:7,enr:2,ability:"Coverage: Heal 3 HP per card in hand",type:"heal"},
{id:36,name:"Bug Hunt Bot",color:0xff6b8a,tags:["debugging","hunting"],atk:9,def:2,enr:2,ability:"Hunt: Deal 12 DMG to weakest enemy",type:"snipe"},
{id:37,name:"Refactor Brain",color:0x06b6d4,tags:["refactoring"],atk:5,def:6,enr:2,ability:"Refactor: Swap ATK and DEF of target",type:"trick"},
{id:38,name:"FastAPI Mesh",color:0x8b5cf6,tags:["fastapi","backend"],atk:7,def:7,enr:2,ability:"Endpoint: Gain 1 energy",type:"ramp"},
{id:39,name:"Streamlit Forge",color:0xef4444,tags:["streamlit","dashboard"],atk:5,def:5,enr:1,ability:"Prototype: Cheap 4 ATK hit",type:"attack"},
{id:40,name:"Gradio Portal",color:0x33ffbb,tags:["gradio","portal"],atk:6,def:5,enr:1,ability:"Portal: Swap a card with enemy's",type:"steal"},
{id:41,name:"Observability",color:0x44ddff,tags:["monitoring","traces"],atk:4,def:8,enr:2,ability:"Trace: +3 DEF and see enemy intent",type:"defense"},
{id:42,name:"Telemetry Mesh",color:0xd4a0ff,tags:["telemetry","health"],atk:5,def:7,enr:2,ability:"Monitor: Heal 2 HP per turn for 3 turns",type:"regen"},
{id:43,name:"Synthetic Lab",color:0x3b82f6,tags:["synthetic-data"],atk:7,def:5,enr:2,ability:"Synthesize: Create 2 random token cards",type:"summon"},
{id:44,name:"Sim-First UX",color:0x10b981,tags:["simulation","ux"],atk:5,def:6,enr:1,ability:"Simulate: Preview outcome of next play",type:"intel"},
{id:45,name:"ThreeJS HUDOS",color:0xfbbf24,tags:["threejs","hud"],atk:8,def:6,enr:3,ability:"Render: All cards gain +2 ATK this turn",type:"buff"},
{id:46,name:"WebGPU Forge",color:0xff6b8a,tags:["webgpu","compute"],atk:10,def:3,enr:4,ability:"Compute Storm: 15 DMG ignoring DEF",type:"nuke"},
{id:47,name:"Geometry Ops",color:0x06b6d4,tags:["geometry","procedural"],atk:6,def:7,enr:2,ability:"Tessellate: +1 ATK per unique tag in hand",type:"scaling"},
{id:48,name:"NeRF/3D Repro",color:0x8b5cf6,tags:["nerf","3d"],atk:7,def:6,enr:2,ability:"Reconstruct: Restore 1 used card",type:"recycle"},
{id:49,name:"OBJ‚ÜîGLB Pipe",color:0xef4444,tags:["3d-formats","pipeline"],atk:5,def:5,enr:1,ability:"Convert: Change card type to any",type:"morph"},
{id:50,name:"LiveCam Agent",color:0x33ffbb,tags:["camera","live"],atk:8,def:4,enr:2,ability:"Detect: +5 ATK vs hidden enemies",type:"reveal"},
{id:51,name:"Gesture Vector",color:0x44ddff,tags:["gesture","spatial"],atk:7,def:5,enr:2,ability:"Swipe: Move enemy card to discard",type:"disruption"},
{id:52,name:"Arcade AI Core",color:0xd4a0ff,tags:["arcade","game-ai"],atk:9,def:5,enr:3,ability:"High Score: Deal +ATK equal to combo count",type:"combo"},
{id:53,name:"Autoplay Swarm",color:0x3b82f6,tags:["autoplay","agents"],atk:6,def:6,enr:2,ability:"Swarm: Play 3 random cards at half power",type:"swarm"},
{id:54,name:"RogueGen Lab",color:0x10b981,tags:["roguelike","procedural"],atk:8,def:4,enr:2,ability:"Randomize: Random effect (heal/dmg/buff)",type:"chaos"},
{id:55,name:"WorldSim Engine",color:0xfbbf24,tags:["simulation","world"],atk:9,def:8,enr:4,ability:"Simulate World: All stats doubled this turn",type:"ultimate"},
{id:56,name:"GeoSim Layer",color:0xff6b8a,tags:["geographic","terrain"],atk:6,def:7,enr:2,ability:"Terrain: +4 DEF, enemies have -2 ATK",type:"area"},
{id:57,name:"MapTiles 3D",color:0x06b6d4,tags:["maps","3d"],atk:5,def:6,enr:1,ability:"Navigate: Choose which card to draw",type:"utility"},
{id:58,name:"MN Geo Vault",color:0x8b5cf6,tags:["minnesota","geology"],atk:7,def:8,enr:3,ability:"Iron Range: +5 ATK, +5 DEF",type:"power"},
{id:59,name:"Maritime AI C2",color:0xef4444,tags:["maritime","command"],atk:9,def:7,enr:3,ability:"Command: All allies attack this turn",type:"rally"},
{id:60,name:"Fleet Autonomy",color:0x33ffbb,tags:["fleet","autonomous"],atk:8,def:6,enr:3,ability:"Fleet: Summon 3 drone tokens (3/1 each)",type:"swarm"},
{id:61,name:"Sensor Fusion",color:0x44ddff,tags:["sensors","fusion"],atk:7,def:8,enr:2,ability:"Fuse: Combine stats of 2 cards",type:"combo"},
{id:62,name:"TowerDefense AI",color:0xd4a0ff,tags:["tower-defense","strategy"],atk:4,def:10,enr:2,ability:"Fortify: Block all damage under 6",type:"wall"},
{id:63,name:"NPC Mind Stack",color:0x3b82f6,tags:["npc","behavior"],atk:6,def:6,enr:2,ability:"Personality: Adapts to counter enemy style",type:"adapt"},
{id:64,name:"Flock Dynamics",color:0x10b981,tags:["flocking","emergent"],atk:7,def:5,enr:2,ability:"Emerge: +1 ATK per ally card in play",type:"synergy"},
{id:65,name:"MultiBrain Zoo",color:0xfbbf24,tags:["multi-model","ensemble"],atk:8,def:7,enr:3,ability:"Ensemble: Play best card automatically",type:"auto"},
{id:66,name:"Lattice Rhythm",color:0xff6b8a,tags:["music","generative"],atk:6,def:5,enr:2,ability:"Rhythm: +3 ATK every other turn",type:"tempo"},
{id:67,name:"MythOS Tarot",color:0x06b6d4,tags:["mythology","tarot"],atk:7,def:7,enr:2,ability:"Arcana: Random powerful effect",type:"chaos"},
{id:68,name:"SaintsDeck 3D",color:0x8b5cf6,tags:["saints","deck"],atk:6,def:8,enr:2,ability:"Blessing: Heal 8 HP and cleanse debuffs",type:"heal"},
{id:69,name:"Oracle UX Neon",color:0xef4444,tags:["oracle","ux","neon"],atk:8,def:5,enr:2,ability:"Prophecy: Know enemy's play 2 turns ahead",type:"intel"},
{id:70,name:"MirrorMind Psych",color:0x33ffbb,tags:["mirror","psychology"],atk:5,def:5,enr:2,ability:"Reflect: Copy enemy's last ability",type:"mirror"},
{id:71,name:"Narrative Engine",color:0x44ddff,tags:["narrative","story"],atk:7,def:6,enr:2,ability:"Plot Twist: Swap HP with enemy",type:"chaos"},
{id:72,name:"CineGen Rig",color:0xd4a0ff,tags:["cinema","visual"],atk:8,def:4,enr:2,ability:"Cinematic: +5 ATK, looks amazing",type:"attack"},
{id:73,name:"SceneGraph Gen",color:0x3b82f6,tags:["scene","graph"],atk:6,def:7,enr:2,ability:"Compose: +2 to all stats per scene card",type:"synergy"},
{id:74,name:"Style Transfer",color:0x10b981,tags:["style","transfer"],atk:5,def:5,enr:1,ability:"Transfer: Copy another card's ability",type:"copy"},
{id:75,name:"Impasto Shader",color:0xfbbf24,tags:["shader","painting"],atk:7,def:6,enr:2,ability:"Texture: Reduce incoming damage by 3",type:"armor"},
{id:76,name:"MusicAgent Lab",color:0xff6b8a,tags:["music","agent"],atk:6,def:5,enr:2,ability:"Compose: All cards cost 1 less energy",type:"discount"},
{id:77,name:"Stem Split AI",color:0x06b6d4,tags:["audio","stems"],atk:7,def:4,enr:2,ability:"Separate: Split ATK into 3 separate hits",type:"multi"},
{id:78,name:"DeployOps Mesh",color:0x8b5cf6,tags:["deployment","mesh"],atk:8,def:7,enr:3,ability:"Ship It: Instantly play top card of deck",type:"tempo"},
{id:79,name:"ZeroTrust Auth",color:0xef4444,tags:["security","zero-trust"],atk:5,def:10,enr:3,ability:"Lockdown: Enemy can't use abilities for 2 turns",type:"lockdown"}
];

const FLOOR_Y = 0;
const MIN_ALT = 18;
const SOFT_ALT = 26;
const CRUISE_ALT = 58;

const canvas = document.getElementById('gameCanvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
renderer.shadowMap.enabled = true;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x020309, 0.006);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 600);
camera.position.set(0, 30, 50);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.35, 0.3));
composer.addPass(new OutputPass());

scene.add(new THREE.AmbientLight(0x1a2848, 0.5));
const sun = new THREE.DirectionalLight(0x8899bb, 0.7);
sun.position.set(20, 40, 20);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.far = 120;
sun.shadow.camera.left = -60; sun.shadow.camera.right = 60; sun.shadow.camera.top = 60; sun.shadow.camera.bottom = -60;
scene.add(sun);
const fillLight = new THREE.DirectionalLight(0x3344ff, 0.25);
fillLight.position.set(-15, 25, -10);
scene.add(fillLight);
const rimLight = new THREE.PointLight(0xd4a0ff, 1.5, 50);
rimLight.position.set(0, 5, 20);
scene.add(rimLight);

const starCount = 2500, sP = new Float32Array(starCount * 3), sS = new Float32Array(starCount), sC = new Float32Array(starCount * 3);
for (let i = 0; i < starCount; i++) {
  const th = Math.random() * Math.PI * 2, ph = Math.acos(2 * Math.random() - 1), r = 160 + Math.random() * 80;
  sP[i * 3] = r * Math.sin(ph) * Math.cos(th); sP[i * 3 + 1] = Math.abs(r * Math.sin(ph) * Math.sin(th)); sP[i * 3 + 2] = r * Math.cos(ph);
  sS[i] = 0.3 + Math.random() * 1.1;
  const t = Math.random(); sC[i * 3] = t > 0.7 ? 0.7 : 0.9; sC[i * 3 + 1] = t > 0.7 ? 0.8 : 0.92; sC[i * 3 + 2] = t > 0.7 ? 1 : 0.95;
}
const sGeo = new THREE.BufferGeometry();
sGeo.setAttribute('position', new THREE.BufferAttribute(sP, 3));
sGeo.setAttribute('size', new THREE.BufferAttribute(sS, 1));
sGeo.setAttribute('color', new THREE.BufferAttribute(sC, 3));
const starMat = new THREE.ShaderMaterial({
  uniforms: { time: { value: 0 } },
  vertexShader: `attribute float size;attribute vec3 color;varying vec3 vC;uniform float time;
  void main(){vC=color;vec4 mv=modelViewMatrix*vec4(position,1.0);float tw=0.7+0.3*sin(time*1.5+position.x*0.1);gl_PointSize=size*tw*(200.0/-mv.z);gl_Position=projectionMatrix*mv;}`,
  fragmentShader: `varying vec3 vC;void main(){float d=length(gl_PointCoord-vec2(0.5));if(d>0.5)discard;float a=smoothstep(0.5,0.1,d);gl_FragColor=vec4(vC*(a+exp(-d*4.0)*0.5),a);}`,
  transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
});
scene.add(new THREE.Points(sGeo, starMat));

const cityGroup = new THREE.Group();
scene.add(cityGroup);
const groundMat = new THREE.MeshPhysicalMaterial({ color: 0x08101c, metalness: 0.82, roughness: 0.22, clearcoat: 1, transparent: true, opacity: 0.96 });
const ground = new THREE.Mesh(new THREE.PlaneGeometry(520, 520), groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = FLOOR_Y;
ground.receiveShadow = true;
scene.add(ground);
const gridHelper = new THREE.GridHelper(520, 104, 0x12384a, 0x0a2230);
gridHelper.position.y = FLOOR_Y + 0.03;
scene.add(gridHelper);
const floorGlow = new THREE.Mesh(new THREE.CircleGeometry(180, 64), new THREE.MeshBasicMaterial({ color: 0x0aa8c8, transparent: true, opacity: 0.10, blending: THREE.AdditiveBlending, side: THREE.DoubleSide }));
floorGlow.rotation.x = -Math.PI / 2;
floorGlow.position.y = FLOOR_Y + 0.02;
scene.add(floorGlow);
const floorGlow2 = new THREE.Mesh(new THREE.CircleGeometry(260, 64), new THREE.MeshBasicMaterial({ color: 0x2244aa, transparent: true, opacity: 0.06, blending: THREE.AdditiveBlending, side: THREE.DoubleSide }));
floorGlow2.rotation.x = -Math.PI / 2;
floorGlow2.position.y = FLOOR_Y + 0.01;
scene.add(floorGlow2);
const horizonGeo = new THREE.RingGeometry(180, 200, 64);
const horizonMat = new THREE.MeshBasicMaterial({ color: 0x0a3050, transparent: true, opacity: 0.25, side: THREE.DoubleSide, blending: THREE.AdditiveBlending });
const horizon = new THREE.Mesh(horizonGeo, horizonMat);
horizon.rotation.x = -Math.PI / 2;
horizon.position.y = FLOOR_Y + 0.06;
scene.add(horizon);

const BLK = 16, RD = 4, LOT = BLK - RD, GR = 6;
const roadMat = new THREE.MeshBasicMaterial({ color: 0x0e1830, transparent: true, opacity: 0.7 });
for (let i = -GR; i <= GR; i++) {
  const p = i * BLK;
  const rH = new THREE.Mesh(new THREE.PlaneGeometry(GR * BLK * 2 + RD, RD), roadMat); rH.rotation.x = -Math.PI / 2; rH.position.set(0, FLOOR_Y + 0.04, p); cityGroup.add(rH);
  const rV = new THREE.Mesh(new THREE.PlaneGeometry(RD, GR * BLK * 2 + RD), roadMat); rV.rotation.x = -Math.PI / 2; rV.position.set(p, FLOOR_Y + 0.04, 0); cityGroup.add(rV);
}

function makeBuilding(x, z, mW, mD, h) {
  const g = new THREE.Group();
  const w = mW * (0.6 + Math.random() * 0.4), d = mD * (0.6 + Math.random() * 0.4);
  const bMat = new THREE.MeshPhysicalMaterial({ color: new THREE.Color().setHSL(0.6 + Math.random() * 0.1, 0.2, 0.06 + Math.random() * 0.04), metalness: 0.85 + Math.random() * 0.1, roughness: 0.1 + Math.random() * 0.1, clearcoat: 0.7 });
  const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), bMat); body.position.y = h / 2 + FLOOR_Y; body.castShadow = true; g.add(body);
  const faces = [{ a: 'z', s: 1, sp: w, dp: d }, { a: 'z', s: -1, sp: w, dp: d }, { a: 'x', s: 1, sp: d, dp: w }, { a: 'x', s: -1, sp: d, dp: w }];
  faces.forEach(f => {
    const cols = Math.max(2, Math.floor(f.sp / 2));
    const wW = (f.sp - 0.6) / cols;
    for (let r = 0; r < Math.floor(h / 2); r++) {
      for (let c = 0; c < cols; c++) {
        if (Math.random() < 0.3) continue;
        const lit = Math.random();
        let wc;
        if (lit > 0.6) wc = new THREE.Color().setHSL(0.12, 0.5, 0.4 + Math.random() * 0.3);
        else wc = new THREE.Color().setHSL(0.42 + Math.random() * 0.15, 0.7, 0.35);
        const wm = new THREE.MeshBasicMaterial({ color: wc, transparent: true, opacity: 0.3 + Math.random() * 0.5, blending: THREE.AdditiveBlending });
        const wp = new THREE.Mesh(new THREE.PlaneGeometry(wW * 0.6, 0.9), wm);
        const lx = (c - (cols - 1) / 2) * wW, ly = FLOOR_Y + 1.5 + r * 2;
        if (f.a === 'z') { wp.position.set(lx, ly, f.s * (d / 2 + 0.02)); if (f.s < 0) wp.rotation.y = Math.PI; }
        else { wp.position.set(f.s * (w / 2 + 0.02), ly, lx); wp.rotation.y = f.s * Math.PI / 2; }
        g.add(wp);
      }
    }
  });
  if (Math.random() > 0.4) { const rl = new THREE.PointLight([0x33ffbb, 0xff6b8a, 0x44ddff, 0xd4a0ff, 0xfbbf24][Math.floor(Math.random() * 5)], 0.5 + Math.random(), 8); rl.position.set(0, h + FLOOR_Y + 0.5, 0); g.add(rl); }
  g.position.set(x, 0, z); return g;
}
for (let bx = -GR; bx < GR; bx++) for (let bz = -GR; bz < GR; bz++) {
  const cx = bx * BLK + BLK / 2, cz = bz * BLK + BLK / 2; const dist = Math.sqrt(cx * cx + cz * cz) / BLK;
  if (dist < 1.2) continue; const h = Math.max(4, 28 - dist * 2.2 + Math.random() * 12);
  cityGroup.add(makeBuilding(cx, cz, LOT * 0.85, LOT * 0.85, h));
}

const pN = 1200, pP = new Float32Array(pN * 3), pC = new Float32Array(pN * 3);
const pCA = [new THREE.Color(0x00ffa3), new THREE.Color(0x00d4ff), new THREE.Color(0xc084fc)];
for (let i = 0; i < pN; i++) {
  const r = 10 + Math.random() * 70, th = Math.random() * Math.PI * 2, ph = Math.acos(2 * Math.random() - 1);
  pP[i * 3] = r * Math.sin(ph) * Math.cos(th); pP[i * 3 + 1] = Math.abs(r * Math.sin(ph) * Math.sin(th) * 0.3) + 2; pP[i * 3 + 2] = r * Math.cos(ph);
  const c = pCA[Math.floor(Math.random() * pCA.length)]; pC[i * 3] = c.r; pC[i * 3 + 1] = c.g; pC[i * 3 + 2] = c.b;
}
const pGeo = new THREE.BufferGeometry();
pGeo.setAttribute('position', new THREE.BufferAttribute(pP, 3));
pGeo.setAttribute('color', new THREE.BufferAttribute(pC, 3));
scene.add(new THREE.Points(pGeo, new THREE.PointsMaterial({ size: 0.08, vertexColors: true, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, depthWrite: false })));

const ship = new THREE.Group();
scene.add(ship);
const shipMat = new THREE.MeshPhysicalMaterial({ color: 0x050505, metalness: 1, roughness: 0.05, clearcoat: 1 });
const shipGlow = new THREE.MeshBasicMaterial({ color: 0x44ddff, blending: THREE.AdditiveBlending, wireframe: true, transparent: true, opacity: 0.6 });
const hull = new THREE.Mesh(new THREE.OctahedronGeometry(0.5, 0), shipMat); hull.scale.set(1, 0.3, 2); ship.add(hull);
const hw = new THREE.Mesh(new THREE.OctahedronGeometry(0.5, 0), shipGlow); hw.scale.set(1.05, 0.35, 2.05); ship.add(hw);
const wG = new THREE.TetrahedronGeometry(0.6, 0);
const wL = new THREE.Mesh(wG, shipMat); wL.scale.set(1.5, 0.1, 0.8); wL.position.set(-0.8, 0, -0.2); wL.rotation.z = Math.PI / 8; ship.add(wL);
const wR = new THREE.Mesh(wG, shipMat); wR.scale.set(1.5, 0.1, 0.8); wR.position.set(0.8, 0, -0.2); wR.rotation.z = -Math.PI / 8; ship.add(wR);
const engLight = new THREE.PointLight(0x33ffbb, 0, 10); engLight.position.set(0, 0, 1); ship.add(engLight);
const trailGeo = new THREE.CylinderGeometry(0.02, 0.15, 2, 6);
const trailMat = new THREE.MeshBasicMaterial({ color: 0x33ffbb, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
const trail = new THREE.Mesh(trailGeo, trailMat); trail.rotation.x = Math.PI / 2; trail.position.z = 1.3; ship.add(trail);
ship.position.set(0, 72, 78);
ship.quaternion.setFromEuler(new THREE.Euler(-0.08, Math.PI, 0, 'YXZ'));
ship.visible = false;

const cardPickups = [];
const cardPickupGroup = new THREE.Group();
scene.add(cardPickupGroup);
function spawnCardPickup(cardData) {
  const g = new THREE.Group();
  const color = new THREE.Color(cardData.color);
  const cardGeo = new THREE.BoxGeometry(1.8, 2.5, 0.08);
  const cardMat = new THREE.MeshPhysicalMaterial({ color: 0x111122, metalness: 0.8, roughness: 0.15, clearcoat: 0.5, emissive: color, emissiveIntensity: 0.15, transparent: true, opacity: 1 });
  const mesh = new THREE.Mesh(cardGeo, cardMat); g.add(mesh);
  const borderMat = new THREE.MeshBasicMaterial({ color: cardData.color, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending });
  const border = new THREE.Mesh(new THREE.BoxGeometry(1.9, 2.6, 0.04), borderMat); g.add(border);
  const pl = new THREE.PointLight(cardData.color, 2, 12); pl.position.set(0, 0, 0.5); g.add(pl);
  const ring = new THREE.Mesh(new THREE.TorusGeometry(1.6, 0.03, 8, 32), new THREE.MeshBasicMaterial({ color: cardData.color, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending })); g.add(ring);
  const angle = Math.random() * Math.PI * 2; const dist = 15 + Math.random() * 55;
  g.position.set(Math.cos(angle) * dist, 28 + Math.random() * 28, Math.sin(angle) * dist);
  g.userData = { card: cardData, ring, collected: false, bobPhase: Math.random() * Math.PI * 2, fadeMeshes: [mesh, border], light: pl };
  cardPickupGroup.add(g); cardPickups.push(g); return g;
}
function clearPickups() { cardPickups.forEach(p => cardPickupGroup.remove(p)); cardPickups.length = 0; }
function renderFlightRails() {
  const left = document.getElementById('flightRailLeft');
  const right = document.getElementById('flightRailRight');
  if (!left || !right) return;
  left.innerHTML = '';
  right.innerHTML = '';
  const recent = G.collectedCards.slice(-10);
  recent.forEach((card, i) => {
    const el = document.createElement('div');
    el.className = 'flight-card';
    const color = '#' + new THREE.Color(card.color).getHexString();
    el.style.borderColor = color + '66';
    el.innerHTML = `<div class="fc-name" style="color:${color}">${card.name}</div><div class="fc-stats"><span class="fc-stat">‚öî ${card.atk}</span><span class="fc-stat">üõ° ${card.def}</span><span class="fc-stat">‚ö° ${card.enr}</span></div><div class="fc-ability">${card.ability}</div>`;
    (i % 2 === 0 ? left : right).appendChild(el);
  });
}

const G = {
  mode: null, phase: 'menu', flightTime: 0, maxFlightTime: 45, collectedCards: [], velocity: new THREE.Vector3(), thrust: 0, maxSpeed: 35, drag: 0.97,
  playerHP: 100, playerMaxHP: 100, playerDef: 0, playerEnergy: 0, maxEnergy: 5, enemyHP: 100, enemyMaxHP: 100, enemyDef: 0, enemyHand: [], enemyEnergy: 0,
  hand: [], deck: [], selectedCard: null, turn: 0, comboCount: 0, defendedLastTurn: false, playerBuffs: [], enemyDebuffs: [], allyHP: 80, allyMaxHP: 80, allyHand: [], allyEnergy: 0,
  wave: 1, waveEnemies: [], inputLocked: false
};
const keys = { w: false, a: false, s: false, d: false, q: false, e: false, space: false, shift: false, b: false };
let mouseX = 0, mouseY = 0, mouseNormX = 0, mouseNormY = 0, mouseSmoothX = 0, mouseSmoothY = 0;
function showToast(msg) { const t = document.getElementById('toast'); t.textContent = msg; t.classList.add('visible'); setTimeout(() => t.classList.remove('visible'), 2500); }
function showPickupFlash(text) { const el = document.getElementById('pickupFlash'), t = document.getElementById('pickupFlashText'); t.textContent = text; el.classList.add('active'); setTimeout(() => el.classList.remove('active'), 1200); }

window.startGame = function(mode) {
  G.mode = mode;
  document.getElementById('modeSelect').classList.add('hidden');
  G.playerHP = 100; G.playerMaxHP = 100; G.playerDef = 0; G.playerEnergy = 3;
  G.enemyHP = mode === 'coop' ? 150 : 100; G.enemyMaxHP = G.enemyHP; G.enemyDef = 0; G.enemyEnergy = 3;
  G.collectedCards = []; G.hand = []; G.deck = []; G.selectedCard = null; G.turn = 0; G.comboCount = 0; G.defendedLastTurn = false; G.wave = 1; G.allyHP = 80; G.allyMaxHP = 80; G.inputLocked = false;
  G.maxFlightTime = mode === 'solo' ? 999 : 45;
  startFlightPhase();
};

function startFlightPhase() {$1renderFlightRails();
  showToast(`${G.mode === 'solo' ? 'FREE FLIGHT' : 'COLLECT CARDS!'} ‚Äî ${G.mode === 'solo' ? 'Explore freely' : 'Fly into glowing cards'}`);
}
function startBattlePhase() {
  if (G.collectedCards.length < 1) { showToast('Collect at least 1 card first!'); return; }
  G.phase = 'battle'; G.turn = 1; G.comboCount = 0; G.defendedLastTurn = false; G.playerDef = 0; G.enemyDef = 0; G.playerEnergy = 3; G.enemyEnergy = 3; G.inputLocked = false;
  G.deck = [...G.collectedCards].sort(() => Math.random() - 0.5); G.hand = G.deck.splice(0, Math.min(5, G.deck.length));
  const enemyPool = [...ARCANA].sort(() => Math.random() - 0.5); G.enemyHand = enemyPool.splice(0, 5); G.enemyDeck = enemyPool.splice(0, 15);
  if (G.mode === 'coop') { G.allyHand = [...ARCANA].sort(() => Math.random() - 0.5).splice(0, 4); G.allyHP = 80; G.allyEnergy = 3; }
  if (G.mode === 'coop') {
    document.getElementById('enemyInfo').querySelector('.pi-name').textContent = 'üî¥ WAVE ' + G.wave + ' ‚Äî HOSTILE SWARM';
    document.getElementById('battleVsLabel').textContent = 'CO-OP VS';
    document.getElementById('coopStatus').classList.add('active');
  } else {
    document.getElementById('enemyInfo').querySelector('.pi-name').textContent = 'üî¥ NEURAL ADVERSARY';
    document.getElementById('battleVsLabel').textContent = 'VS';
    document.getElementById('coopStatus').classList.remove('active');
  }
  document.getElementById('flightHUD').classList.remove('active');
  document.getElementById('battleHUD').classList.add('active');
  ship.visible = false;
  camera.position.set(0, 25, 35); camera.lookAt(0, 8, 0);
  updateBattleUI(); setBattleLog('‚öîÔ∏è BATTLE START ‚Äî Turn 1', 'var(--gold)');
}
function updateBattleUI() {
  document.getElementById('playerHP').style.width = (G.playerHP / G.playerMaxHP * 100) + '%';
  document.getElementById('playerHPText').textContent = Math.max(0, Math.round(G.playerHP));
  document.getElementById('playerDEF').textContent = G.playerDef;
  document.getElementById('enemyHP').style.width = (G.enemyHP / G.enemyMaxHP * 100) + '%';
  document.getElementById('enemyHPText').textContent = Math.max(0, Math.round(G.enemyHP));
  document.getElementById('enemyDEF').textContent = G.enemyDef;
  const pips = document.getElementById('energyPips'); pips.innerHTML = '';
  for (let i = 0; i < G.maxEnergy; i++) { const p = document.createElement('div'); p.className = 'energy-pip' + (i < G.playerEnergy ? ' full' : ''); pips.appendChild(p); }
  renderHand();
  if (G.mode === 'coop') document.getElementById('coopAction').innerHTML = `HP: ${Math.round(G.allyHP)}<br>ENR: ${G.allyEnergy}<br>Cards: ${G.allyHand.length}`;
}
function renderHand() {
  const container = document.getElementById('handContainer'); container.innerHTML = '';
  G.hand.forEach((card, idx) => {
    const el = document.createElement('div'); el.className = 'hand-card' + (G.selectedCard === idx ? ' selected' : '');
    const ch = '#' + new THREE.Color(card.color).getHexString();
    el.innerHTML = `<div style="position:absolute;top:0;left:0;right:0;height:2px;background:${ch};border-radius:10px 10px 0 0;"></div><div class="hc-cost">${card.enr}‚ö°</div><div class="hc-name" style="color:${ch}">${card.name}</div><div class="hc-stats"><span class="hc-stat hc-atk">‚öî${card.atk}</span><span class="hc-stat hc-def">üõ°${card.def}</span></div><div class="hc-ability">${card.ability}</div>`;
    el.addEventListener('click', () => { if (G.inputLocked) return; G.selectedCard = (G.selectedCard === idx ? null : idx); renderHand(); document.getElementById('btnPlayCard').disabled = G.selectedCard === null; });
    container.appendChild(el);
  });
  document.getElementById('btnPlayCard').disabled = G.selectedCard === null || G.inputLocked;
}
function setBattleLog(text, color = 'var(--cyan)') { const el = document.getElementById('battleLog'); el.textContent = text; el.style.color = color; el.style.transform = 'scale(1.1)'; setTimeout(() => el.style.transform = 'scale(1)', 300); }
window.playSelectedCard = function() {
  if (G.inputLocked || G.selectedCard === null || G.phase !== 'battle') return;
  const card = G.hand[G.selectedCard]; if (G.playerEnergy < card.enr) { showToast('Not enough energy!'); return; }
  G.inputLocked = true; G.playerEnergy -= card.enr; let dmg = Math.max(0, card.atk - G.enemyDef); let logText = `${card.name} ‚Üí ${dmg} DMG`; const abilityResult = applyAbility(card, 'player'); if (abilityResult) logText += ` | ${abilityResult}`; G.enemyHP -= dmg; G.comboCount++; G.hand.splice(G.selectedCard, 1); G.selectedCard = null; G.defendedLastTurn = false; setBattleLog('‚ö° ' + logText, 'var(--mint)'); if (G.deck.length > 0 && G.hand.length < 6) G.hand.push(G.deck.shift()); checkBattleEnd(); if (G.phase === 'battle') { if (G.mode === 'coop') setTimeout(() => coopAllyTurn(), 800); setTimeout(() => enemyTurn(), G.mode === 'coop' ? 1600 : 1000); } updateBattleUI();
};
window.defendTurn = function() {
  if (G.inputLocked || G.phase !== 'battle') return; G.inputLocked = true; G.playerDef += 4; G.defendedLastTurn = true; G.playerEnergy = Math.min(G.maxEnergy, G.playerEnergy + 1); setBattleLog('üõ°Ô∏è DEFENDING ‚Äî +4 DEF, +1 Energy', 'var(--cyan)'); if (G.mode === 'coop') setTimeout(() => coopAllyTurn(), 600); setTimeout(() => enemyTurn(), G.mode === 'coop' ? 1200 : 800); updateBattleUI();
};
window.specialAbility = function() {
  if (G.inputLocked || G.phase !== 'battle') return; if (G.playerEnergy < 2) { showToast('Need 2 energy for special!'); return; } G.inputLocked = true; G.playerEnergy -= 2; G.playerHP = Math.min(G.playerMaxHP, G.playerHP + 12); if (G.deck.length > 0 && G.hand.length < 6) G.hand.push(G.deck.shift()); setBattleLog('‚ú® NEURAL SURGE ‚Äî Heal 12, Draw 1', 'var(--violet)'); if (G.mode === 'coop') setTimeout(() => coopAllyTurn(), 600); setTimeout(() => enemyTurn(), G.mode === 'coop' ? 1200 : 800); updateBattleUI();
};
function applyAbility(card, source) { switch (card.type) { case 'heal': G.playerHP = Math.min(G.playerMaxHP, G.playerHP + (source === 'player' ? 5 : 3)); return '+5 HP healed'; case 'pierce': G.enemyDef = 0; return 'Pierce! Enemy DEF ‚Üí 0'; case 'buff': if (G.hand.length > 0) G.hand[0].atk += 3; return '+3 ATK to next card'; case 'defense': G.playerDef += 3; return '+3 DEF'; case 'drain': const stolen = Math.min(G.enemyDef, 2); G.enemyDef -= stolen; G.playerDef += stolen; return `Stole ${stolen} DEF`; case 'ramp': G.playerEnergy = Math.min(G.maxEnergy, G.playerEnergy + 1); return '+1 Energy'; case 'scaling': return `+${G.hand.length * 2} bonus ATK`; default: return ''; } }
function enemyTurn() {
  if (G.phase !== 'battle' || G.enemyHP <= 0) { G.inputLocked = false; return; }
  G.enemyEnergy = Math.min(G.maxEnergy, G.enemyEnergy + 2);
  const playable = G.enemyHand.filter(c => c.enr <= G.enemyEnergy).sort((a, b) => b.atk - a.atk);
  if (playable.length > 0) {
    const card = playable[0]; G.enemyEnergy -= card.enr; let dmg = Math.max(0, card.atk - G.playerDef); G.playerHP -= dmg; const idx = G.enemyHand.indexOf(card); G.enemyHand.splice(idx, 1);
    if (G.enemyDeck && G.enemyDeck.length > 0 && G.enemyHand.length < 5) G.enemyHand.push(G.enemyDeck.shift()); setBattleLog(`üî¥ ${card.name} ‚Üí ${dmg} DMG to you!`, 'var(--rose)'); G.playerDef = Math.max(0, G.playerDef - 1);
  } else { G.enemyDef += 3; setBattleLog('üî¥ Enemy defends ‚Äî +3 DEF', 'var(--ember)'); }
  G.turn++; G.playerEnergy = Math.min(G.maxEnergy, G.playerEnergy + 2); checkBattleEnd(); updateBattleUI(); G.inputLocked = false;
}
function coopAllyTurn() { if (G.phase !== 'battle' || G.allyHP <= 0) return; G.allyEnergy = Math.min(G.maxEnergy, G.allyEnergy + 1); if (G.allyHand.length > 0 && G.allyEnergy >= G.allyHand[0].enr) { const card = G.allyHand.shift(); G.allyEnergy -= card.enr; const dmg = Math.max(0, card.atk - G.enemyDef); G.enemyHP -= dmg; document.getElementById('coopAction').innerHTML = `ü§ñ Played ${card.name}<br>${dmg} DMG!<br>HP: ${Math.round(G.allyHP)}`; setBattleLog(`üü£ Ally: ${card.name} ‚Üí ${dmg} DMG`, 'var(--violet)'); } else { G.playerHP = Math.min(G.playerMaxHP, G.playerHP + 3); document.getElementById('coopAction').innerHTML = `ü§ñ Healing you...<br>+3 HP<br>HP: ${Math.round(G.allyHP)}`; } updateBattleUI(); }
function checkBattleEnd() { if (G.enemyHP <= 0) { G.phase = 'result'; const rr = document.getElementById('roundResult'); document.getElementById('rrTitle').textContent = '‚ö° VICTORY ‚ö°'; document.getElementById('rrTitle').style.color = 'var(--mint)'; document.getElementById('rrSub').textContent = G.mode === 'coop' ? `Wave ${G.wave} cleared! Collected ${G.collectedCards.length} cards.` : `Neural Adversary defeated in ${G.turn} turns!`; rr.classList.add('active'); } else if (G.playerHP <= 0) { G.phase = 'result'; const rr = document.getElementById('roundResult'); document.getElementById('rrTitle').textContent = 'üíÄ DEFEATED'; document.getElementById('rrTitle').style.color = 'var(--rose)'; document.getElementById('rrSub').textContent = `You fell at turn ${G.turn}. ${G.collectedCards.length} cards collected.`; rr.classList.add('active'); } }
window.endBattle = function() { G.phase = 'result'; document.getElementById('rrTitle').textContent = '‚Ü© RETREAT'; document.getElementById('rrTitle').style.color = 'var(--ember)'; document.getElementById('rrSub').textContent = 'Returning to base...'; document.getElementById('roundResult').classList.add('active'); };
window.returnToMenu = function() { G.phase = 'menu'; renderFlightRails(); document.getElementById('roundResult').classList.remove('active'); document.getElementById('battleHUD').classList.remove('active'); document.getElementById('flightHUD').classList.remove('active'); document.getElementById('coopStatus').classList.remove('active'); document.getElementById('modeSelect').classList.remove('hidden'); ship.visible = false; clearPickups(); camera.position.set(0, 30, 50); camera.lookAt(0, 8, 0); };

function updateFlight(dt) {
  let nearbyTarget = null;
  let nearbyDist = Infinity;
  mouseSmoothX = THREE.MathUtils.lerp(mouseSmoothX, mouseNormX, 0.08);
  mouseSmoothY = THREE.MathUtils.lerp(mouseSmoothY, mouseNormY, 0.08);
  const deadzone = 0.10;
  const mx = Math.abs(mouseSmoothX) < deadzone ? 0 : mouseSmoothX;
  const my = Math.abs(mouseSmoothY) < deadzone ? 0 : mouseSmoothY;
  const yawInput = -mx * 0.85;
  const pitchInput = my * 0.28;
  ship.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), yawInput * dt));
  ship.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), pitchInput * dt));
  if (keys.a) ship.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), 1.6 * dt));
  if (keys.d) ship.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -1.6 * dt));
  if (keys.q) ship.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), 1.0 * dt));
  if (keys.e) ship.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), -1.0 * dt));
  ship.quaternion.normalize();

  const up = new THREE.Vector3(0,1,0).applyQuaternion(ship.quaternion);
  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
  const rollError = -up.x;
  const rollStrength = (keys.a || keys.d) ? 0.8 : 3.2;
  ship.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), rollError * rollStrength * dt));
  const pitchTarget = -0.08;
  const pitchError = (fwd.y - pitchTarget);
  const pitchStrength = Math.abs(my) > 0.02 ? 0.45 : 2.0;
  ship.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), -pitchError * pitchStrength * dt));
  ship.quaternion.normalize();

  let th = 0;
  if (keys.w) th = 1;
  if (keys.shift || keys.space) th = 1.5;
  if (keys.s) { G.velocity.multiplyScalar(0.93); G.thrust *= 0.9; th = 0; }

  const fwdNow = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
  if (G.mode !== 'solo') {
    for (const pickup of cardPickups) {
      if (pickup.userData.collected) continue;
      const dist = ship.position.distanceTo(pickup.position);
      if (dist < 24 && dist < nearbyDist) {
        nearbyDist = dist;
        nearbyTarget = pickup;
      }
    }
    if (nearbyTarget) {
      const toTarget = nearbyTarget.position.clone().sub(ship.position).normalize();
      const steer = THREE.MathUtils.clamp((24 - nearbyDist) / 24, 0.08, 0.55);
      const desiredForward = fwdNow.clone().lerp(toTarget, steer * 0.12).normalize();
      const desiredUp = new THREE.Vector3(0,1,0);
      const steerMat = new THREE.Matrix4().lookAt(ship.position, ship.position.clone().add(desiredForward), desiredUp);
      const targetQ = new THREE.Quaternion().setFromRotationMatrix(steerMat);
      ship.quaternion.slerp(targetQ, Math.min(0.9 * dt + steer * 0.05, 0.12));
      G.thrust = Math.max(G.thrust, 12 + steer * 8);
    }
  }
  G.thrust += (th * G.maxSpeed - G.thrust) * 1.8 * dt;
  engLight.intensity = Math.max(0, G.thrust / G.maxSpeed) * 8;
  trail.scale.y = 0.3 + Math.max(0, G.thrust / G.maxSpeed) * 1.5;
  trail.material.opacity = 0.2 + Math.max(0, G.thrust / G.maxSpeed) * 0.6;
  const accel = fwdNow.clone().multiplyScalar(G.thrust);
  accel.y -= 1.65;
  G.velocity.add(accel.clone().multiplyScalar(dt));
  G.velocity.multiplyScalar(G.drag);
  const speed = G.velocity.length();
  if (speed < 8 && keys.w) G.velocity.add(fwdNow.clone().multiplyScalar(8 * dt));
  ship.position.add(G.velocity.clone().multiplyScalar(dt));

  if (ship.position.y < SOFT_ALT) {
    const t = THREE.MathUtils.clamp((SOFT_ALT - ship.position.y) / (SOFT_ALT - MIN_ALT), 0, 1);
    G.velocity.y += 18 * t * dt;
    if (G.velocity.y < 0) G.velocity.y *= (1 - 0.45 * t);
  }
  if (ship.position.y < MIN_ALT) {
    ship.position.y = MIN_ALT;
    G.velocity.y = Math.max(0, G.velocity.y * 0.15);
    const flatForward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
    flatForward.y = 0;
    if (flatForward.lengthSq() < 0.0001) flatForward.set(0,0,-1);
    flatForward.normalize();
    const targetMat = new THREE.Matrix4().lookAt(ship.position, ship.position.clone().add(flatForward), new THREE.Vector3(0,1,0));
    const targetQ = new THREE.Quaternion().setFromRotationMatrix(targetMat);
    ship.quaternion.slerp(targetQ, 5.5 * dt);
  }
  if (ship.position.y < CRUISE_ALT && !keys.s) G.velocity.y += (CRUISE_ALT - ship.position.y) * 0.22 * dt;
  const maxRange = 85;
  const dist2D = Math.sqrt(ship.position.x ** 2 + ship.position.z ** 2);
  if (dist2D > maxRange) {
    const pushBack = ship.position.clone().setY(0).normalize().multiplyScalar(-((dist2D - maxRange) * 2) * dt);
    G.velocity.x += pushBack.x; G.velocity.z += pushBack.z;
  }
  if (ship.position.y < 32) G.velocity.y += 10 * dt;

  const flatForward = fwdNow.clone();
  flatForward.y *= 0.35;
  flatForward.normalize();
  const camBack = flatForward.clone().multiplyScalar(-16);
  const camUp = new THREE.Vector3(0, 8, 0);
  const idealCamPos = ship.position.clone().add(camBack).add(camUp);
  idealCamPos.y = Math.max(idealCamPos.y, MIN_ALT + 8);
  camera.position.lerp(idealCamPos, 0.07);
  const lookTarget = ship.position.clone().add(flatForward.clone().multiplyScalar(24));
  lookTarget.y = Math.max(FLOOR_Y + 8, ship.position.y - 8);
  camera.lookAt(lookTarget);

  cardPickups.forEach(p => {
    if (p.userData.collected) return;
    const dist = ship.position.distanceTo(p.position);
    if (dist < 3.5) {
      p.userData.collected = true;
      G.collectedCards.push(p.userData.card);
      renderFlightRails();
      showPickupFlash(`‚ö° ${p.userData.card.name} ‚Äî ATK:${p.userData.card.atk} DEF:${p.userData.card.def}`);
      const startScale = p.scale.clone();
      const startTime = performance.now();
      const animatePickup = () => {
        const elapsed = (performance.now() - startTime) / 400;
        if (elapsed >= 1) { cardPickupGroup.remove(p); return; }
        p.scale.setScalar((1 - elapsed) * startScale.x);
        p.position.y += 0.15;
        p.userData.fadeMeshes.forEach(m => { if (m.material && 'opacity' in m.material) m.material.opacity = Math.max(0, 1 - elapsed); });
        if (p.userData.light) p.userData.light.intensity = Math.max(0, 2 * (1 - elapsed));
        requestAnimationFrame(animatePickup);
      };
      animatePickup();
    }
  });

  const spd = G.velocity.length();
  document.getElementById('speedGauge').innerHTML = `SPD: ${spd.toFixed(0)}<br>THR: ${Math.round(Math.max(0, G.thrust / G.maxSpeed * 100))}%`;
  document.getElementById('altGauge').innerHTML = `ALT: ${ship.position.y.toFixed(0)}<br>CARDS: ${G.collectedCards.length}`;
  let timerStr = '';
  if (G.mode !== 'solo') {
    G.flightTime += dt;
    const remaining = Math.max(0, G.maxFlightTime - G.flightTime);
    const mins = Math.floor(remaining / 60); const secs = Math.floor(remaining % 60);
    timerStr = `<span id="phaseTimer">${mins}:${String(secs).padStart(2, '0')}</span>`;
    if (remaining <= 0 && G.collectedCards.length > 0) startBattlePhase();
  }
  document.getElementById('cardCollector').innerHTML = G.mode === 'solo' ? `CARDS COLLECTED: ${G.collectedCards.length} / 80` : `CARDS: ${G.collectedCards.length} ‚Äî <kbd style="font-family:Orbitron;color:var(--gold)">B</kbd> TO BATTLE${timerStr}${nearbyTarget ? `<div style="font-family:JetBrains Mono,monospace;font-size:0.62rem;color:var(--cyan);margin-top:0.28rem;letter-spacing:0.06em;">TRACKING: ${nearbyTarget.userData.card.name}</div>` : ''}`;
  if (keys.b && G.collectedCards.length > 0 && G.mode !== 'solo') { keys.b = false; startBattlePhase(); }
}
function animatePickups(t) { cardPickups.forEach(p => { if (p.userData.collected) return; p.position.y += Math.sin(t * 1.5 + p.userData.bobPhase) * 0.005; p.rotation.y = t * 0.5 + p.userData.bobPhase; if (p.userData.ring) { p.userData.ring.rotation.x = t * 0.8; p.userData.ring.rotation.z = t * 0.4 + p.userData.bobPhase; } }); }

document.addEventListener('keydown', e => { const k = e.key.toLowerCase(); if (keys.hasOwnProperty(k)) keys[k] = true; if (e.code === 'Space') { keys.space = true; if (G.phase === 'flight') e.preventDefault(); } if (k === 'b') keys.b = true; });
document.addEventListener('keyup', e => { const k = e.key.toLowerCase(); if (keys.hasOwnProperty(k)) keys[k] = false; if (e.code === 'Space') keys.space = false; if (k === 'b') keys.b = false; });
document.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; mouseNormX = (e.clientX / window.innerWidth - 0.5) * 2; mouseNormY = (e.clientY / window.innerHeight - 0.5) * 2; });
canvas.addEventListener('contextmenu', e => e.preventDefault());

const startTime = performance.now(); let lastFrame = performance.now();
function animate() {
  requestAnimationFrame(animate);
  const now = performance.now(); const t = (now - startTime) * 0.001; const dt = Math.min((now - lastFrame) * 0.001, 0.1); lastFrame = now;
  starMat.uniforms.time.value = t;
  if (G.phase === 'flight') updateFlight(dt); else if (G.phase === 'menu') { camera.position.x = Math.sin(t * 0.1) * 40; camera.position.z = Math.cos(t * 0.1) * 40; camera.position.y = 30 + Math.sin(t * 0.15) * 6; camera.lookAt(0, 12, 0); }
  animatePickups(t);
  const pp = pGeo.attributes.position.array; for (let i = 0; i < pN; i++) { pp[i * 3 + 1] += Math.sin(t * 0.15 + i * 0.4) * 0.0006; pp[i * 3] += Math.cos(t * 0.1 + i * 0.3) * 0.0003; } pGeo.attributes.position.needsUpdate = true;
  rimLight.position.x = Math.sin(t * 0.3) * 8; rimLight.position.z = 12 + Math.cos(t * 0.2) * 4;
  composer.render();
}
animate();
window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); });
</script>
</body>
</html>
