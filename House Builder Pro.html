<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Detailed House with Working Lift</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">Architectural Model: Distinct Floors & Working Lift<br>Left Click Rotate | Right Click Pan | Scroll Zoom</div>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { BufferGeometryUtils } from 'three/addons/utils/BufferGeometryUtils.js';

        let scene, camera, renderer, controls;
        let liftPlatform, liftCage;
        const clock = new THREE.Clock();

        // --- Constants for Dimensions ---
        const level1Height = 5;
        const level2Height = 4.5;
        const deckLevel1Y = 4; // Slightly below floor height
        const deckLevel2Y = 4 + 4.5; // Upper floor height
        const towerCenter = new THREE.Vector3(8, 0, 8);
        const towerRadius = 3.5;

        // --- Materials ---
        const matSidingL1 = new THREE.MeshStandardMaterial({ color: 0x8B5A2B, roughness: 0.9 }); // Darker wood lower
        const matSidingL2 = new THREE.MeshStandardMaterial({ color: 0xA07040, roughness: 0.9 }); // Lighter wood upper
        const matRoof = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.6 });
        const matGlass = new THREE.MeshStandardMaterial({ color: 0xaaddff, transparent: true, opacity: 0.4, metalness: 0.8, roughness: 0.05, side: THREE.DoubleSide });
        const matDeck = new THREE.MeshStandardMaterial({ color: 0x9e6b42 });
        const matConcrete = new THREE.MeshStandardMaterial({ color: 0x999999 });
        const matMetal = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.2 });
        const matGrass = new THREE.MeshStandardMaterial({ color: 0x339933 });

        init();
        animate();

        function init() {
            // 1. Scene & Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 30, 150);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
            camera.position.set(35, 25, 45);

            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 3. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const sun = new THREE.DirectionalLight(0xffffff, 1);
            sun.position.set(50, 80, 30);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 200;
            const shadowSize = 50;
            sun.shadow.camera.left = -shadowSize; sun.shadow.camera.right = shadowSize;
            sun.shadow.camera.top = shadowSize; sun.shadow.camera.bottom = -shadowSize;
            scene.add(sun);

            // 4. Build Environment & House
            buildEnvironment();
            buildDetailedHouse();

            // 5. Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // Don't go under ground

            window.addEventListener('resize', onWindowResize);
        }

        // Helper for boxes
        function createBox(pos, size, mat, cast=true, receive=true) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), mat);
            mesh.position.copy(pos);
            mesh.castShadow = cast;
            mesh.receiveShadow = receive;
            scene.add(mesh);
            return mesh;
        }

        function buildEnvironment() {
            // Ground
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), matGrass);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function buildDetailedHouse() {
            const houseGroup = new THREE.Group();

            // --- LEVEL 1 (Lower Floor) ---
            // Main L-Shape Body + Garage section
            const l1MainGeo = new THREE.BoxGeometry(20, level1Height, 12);
            l1MainGeo.translate(0, level1Height/2, 0);
            const l1GarageGeo = new THREE.BoxGeometry(10, level1Height, 12);
            l1GarageGeo.translate(15, level1Height/2, -2); // Offset garage to the right

            // Merge geometries for a single mesh for the lower level
            // Note: In a real app, you'd carve windows here. We are doing solid blocks for massing.
            const l1CombinedGeo = BufferGeometryUtils.mergeGeometries([l1MainGeo, l1GarageGeo]);
            const level1Mesh = new THREE.Mesh(l1CombinedGeo, matSidingL1);
            level1Mesh.castShadow = true;
            level1Mesh.receiveShadow = true;
            houseGroup.add(level1Mesh);

            // --- LEVEL 1 DECK ---
            // Large wrap around deck
            const d1Geo = new THREE.BoxGeometry(28, 0.5, 8);
            const deck1 = new THREE.Mesh(d1Geo, matDeck);
            deck1.position.set(2, deckLevel1Y - 0.25, 10);
            deck1.castShadow = true;
            deck1.receiveShadow = true;
            houseGroup.add(deck1);

            // Concrete pillars for deck
            for(let x=-10; x<=14; x+=6) {
                 const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, deckLevel1Y, 16), matConcrete);
                 pillar.position.set(x, deckLevel1Y/2, 13);
                 pillar.castShadow = true;
                 houseGroup.add(pillar);
            }


            // --- LEVEL 2 (Upper Floor) ---
            // Distinct smaller footprint, sitting on top of Level 1
            const l2MainGeo = new THREE.BoxGeometry(18, level2Height, 10);
            // Positioned on top of level 1 height
            const level2Mesh = new THREE.Mesh(l2MainGeo, matSidingL2);
            level2Mesh.position.set(-1, level1Height + level2Height/2, 1);
            level2Mesh.castShadow = true;
            houseGroup.add(level2Mesh);

            // Catwalk connecting to tower (visual representation of plan)
            const catwalk = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 6), matSidingL2);
            catwalk.position.set(6, level1Height + 1.5, 5);
            houseGroup.add(catwalk);


            // --- LEVEL 2 DECK ---
            const d2Geo = new THREE.BoxGeometry(18, 0.5, 6);
            const deck2 = new THREE.Mesh(d2Geo, matDeck);
            // Positioned at the upper floor height
            deck2.position.set(-1, deckLevel2Y - 0.25, 9);
            deck2.castShadow = true;
            houseGroup.add(deck2);
            
            // Simple Railings (Glass panels)
            const railGeo = new THREE.BoxGeometry(18, 1.2, 0.1);
            const rail = new THREE.Mesh(railGeo, matGlass);
            rail.position.set(-1, deckLevel2Y + 0.6, 11.8);
            houseGroup.add(rail);


            // --- THE GLASS TOWER (GAZEBO) ---
            // It spans two floors.
            const towerTotalHeight = level1Height + level2Height + 2; // +2 for roof peak base
            
            // 1. The Glass Structure (Octagon)
            const towerGlassGeo = new THREE.CylinderGeometry(towerRadius, towerRadius, towerTotalHeight, 8, 1, true);
            // Rotate slightly so a flat face aligns with decks
            towerGlassGeo.rotateY(Math.PI/8); 
            const towerGlass = new THREE.Mesh(towerGlassGeo, matGlass);
            towerGlass.position.set(towerCenter.x, towerTotalHeight/2, towerCenter.z);
            houseGroup.add(towerGlass);

            // 2. The structure Frame (Octagon corners)
            for(let i=0; i<8; i++) {
                const angle = (i/8) * Math.PI * 2 + (Math.PI/8);
                const x = towerCenter.x + Math.cos(angle) * towerRadius;
                const z = towerCenter.z + Math.sin(angle) * towerRadius;
                const frame = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, towerTotalHeight, 8), matSidingL1);
                frame.position.set(x, towerTotalHeight/2, z);
                houseGroup.add(frame);
            }

            // 3. Tower Roof
            const towerRoofGeo = new THREE.ConeGeometry(towerRadius + 0.5, 3, 8);
            const towerRoof = new THREE.Mesh(towerRoofGeo, matRoof);
            towerRoof.position.set(towerCenter.x, towerTotalHeight + 1.5, towerCenter.z);
            houseGroup.add(towerRoof);

            // --- MAIN ROOF ---
            // A large hip roof covering the main Level 2 block
            const mainRoofGeo = new THREE.ConeGeometry(14, 5, 4);
            // Rotate to align square with house body
            mainRoofGeo.rotateY(Math.PI/4);
            // Scale to make it rectangular
            mainRoofGeo.scale(1.2, 1, 0.8); 
            const mainRoof = new THREE.Mesh(mainRoofGeo, matRoof);
            // Position on top of level 2
            mainRoof.position.set(-1, level1Height + level2Height + 2.5, 1);
            houseGroup.add(mainRoof);


            // --- THE WORKING LIFT ---
            // The Platform
            const liftGeo = new THREE.CylinderGeometry(towerRadius - 0.5, towerRadius - 0.5, 0.3, 8);
            liftGeo.rotateY(Math.PI/8);
            liftPlatform = new THREE.Mesh(liftGeo, matMetal);
            // Start position (Lower deck level)
            liftPlatform.position.set(towerCenter.x, deckLevel1Y, towerCenter.z);
            liftPlatform.castShadow = true;
            scene.add(liftPlatform); // Add directly to scene, not houseGroup, for easier animation

            // A simple "cage" visualization on the platform
            const cageGeo = new THREE.CylinderGeometry(towerRadius - 0.6, towerRadius - 0.6, 2.5, 8, 1, true);
            cageGeo.rotateY(Math.PI/8);
            liftCage = new THREE.Mesh(cageGeo, matMetal);
            liftCage.material.wireframe = true; // Make it look like a cage
            liftCage.position.set(0, 1.25, 0); // relative to platform
            liftPlatform.add(liftCage);


            scene.add(houseGroup);
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const elapsedTime = clock.getElapsedTime();

            // --- LIFT ANIMATION ---
            // Oscillate between Lower Deck (height ~4) and Upper Deck (height ~8.5)
            // Math.sin goes from -1 to 1.
            // We want a range of roughly 4.5 units, centered around height 6.25.
            const liftSpeed = 0.5;
            const liftHeight = 6.25 + Math.sin(elapsedTime * liftSpeed) * 2.25;
            
            if (liftPlatform) {
                liftPlatform.position.y = liftHeight;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
