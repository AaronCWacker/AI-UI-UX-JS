<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB Model Viewer - Phoenix Voltage</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #00ff88;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        #upload-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #00ff88;
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.3);
            text-align: center;
            z-index: 1000;
        }

        #upload-overlay.hidden {
            display: none;
        }

        #upload-overlay h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        #file-input {
            display: none;
        }

        #upload-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            color: #0a0a0a;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.3);
        }

        #upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 255, 136, 0.5);
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 10, 0.9);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #00ff88;
            max-width: 300px;
            z-index: 100;
        }

        #controls h3 {
            margin-bottom: 15px;
            font-size: 1.3em;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #controls p {
            margin: 8px 0;
            font-size: 0.9em;
            color: #88ffcc;
        }

        #button-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 10px;
            z-index: 100;
        }

        .control-btn {
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            border-radius: 10px;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
        }

        .control-btn:active {
            background: rgba(0, 255, 136, 0.5);
            transform: scale(0.95);
        }

        .control-btn.up { grid-column: 2; grid-row: 1; }
        .control-btn.left { grid-column: 1; grid-row: 2; }
        .control-btn.down { grid-column: 2; grid-row: 3; }
        .control-btn.right { grid-column: 3; grid-row: 2; }
        .control-btn.rise { grid-column: 3; grid-row: 1; }
        .control-btn.fall { grid-column: 3; grid-row: 3; }

        #action-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .action-btn {
            background: rgba(0, 255, 136, 0.2);
            border: 2px solid #00ff88;
            color: #00ff88;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .action-btn:hover {
            background: rgba(0, 255, 136, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .action-btn.active {
            background: rgba(0, 255, 136, 0.6);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            z-index: 999;
            display: none;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 10, 10, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            font-size: 0.9em;
            color: #88ffcc;
            z-index: 100;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-top-color: #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            #controls {
                max-width: 200px;
                font-size: 0.9em;
            }

            #action-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="viewer-canvas"></canvas>

        <div id="upload-overlay">
            <h1>üöÄ GLB Model Viewer</h1>
            <p style="margin-bottom: 30px; color: #88ffcc;">Load your 3D models and explore in full flight mode</p>
            <input type="file" id="file-input" accept=".glb,.gltf">
            <button id="upload-btn">Choose GLB File</button>
        </div>

        <div id="loading">
            Loading model<span class="spinner"></span>
        </div>

        <div id="controls">
            <h3>‚úàÔ∏è Flight Controls</h3>
            <p><strong>WASD / Arrows:</strong> Move</p>
            <p><strong>Space / Shift:</strong> Up / Down</p>
            <p><strong>Mouse Drag:</strong> Look around</p>
            <p><strong>Touch:</strong> Drag to look</p>
            <p><strong>Buttons:</strong> Touch controls</p>
        </div>

        <div id="action-buttons">
            <button class="action-btn" id="reset-btn">üéØ Reset View</button>
            <button class="action-btn" id="rotate-btn">üîÑ Auto-Rotate</button>
            <button class="action-btn" id="new-file-btn">üìÅ New File</button>
        </div>

        <div id="button-controls">
            <button class="control-btn up">‚ñ≤</button>
            <button class="control-btn left">‚óÑ</button>
            <button class="control-btn down">‚ñº</button>
            <button class="control-btn right">‚ñ∫</button>
            <button class="control-btn rise">‚Üë</button>
            <button class="control-btn fall">‚Üì</button>
        </div>

        <div id="info">
            <div>Camera Position: <span id="pos-info">0, 0, 0</span></div>
            <div>Model Loaded: <span id="model-info">None</span></div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 10, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        const canvas = document.getElementById('viewer-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0x00ff88, 1);
        directionalLight1.position.set(5, 10, 5);
        directionalLight1.castShadow = true;
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0x0088ff, 0.5);
        directionalLight2.position.set(-5, 5, -5);
        scene.add(directionalLight2);

        const pointLight = new THREE.PointLight(0x00ff88, 1, 50);
        pointLight.position.set(0, 10, 0);
        scene.add(pointLight);

        // Grid helper
        const gridHelper = new THREE.GridHelper(100, 100, 0x00ff88, 0x004433);
        scene.add(gridHelper);

        // Controls state
        const controls = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            up: false,
            down: false,
            speed: 0.2,
            rotationSpeed: 0.002,
            mouseDown: false,
            lastMouseX: 0,
            lastMouseY: 0,
            rotation: { x: 0, y: 0 }
        };

        let autoRotate = false;
        let loadedModel = null;
        let modelCenter = new THREE.Vector3();

        // File upload handling
        const fileInput = document.getElementById('file-input');
        const uploadBtn = document.getElementById('upload-btn');
        const uploadOverlay = document.getElementById('upload-overlay');
        const loading = document.getElementById('loading');
        const modelInfo = document.getElementById('model-info');

        uploadBtn.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadGLBFile(file);
            }
        });

        function loadGLBFile(file) {
            uploadOverlay.classList.add('hidden');
            loading.style.display = 'block';

            const reader = new FileReader();
            reader.onload = (e) => {
                const arrayBuffer = e.target.result;
                
                const loader = new GLTFLoader();
                
                loader.parse(
                    arrayBuffer,
                    '', // resource path
                    (gltf) => {
                        // Remove old model
                        if (loadedModel) {
                            scene.remove(loadedModel);
                            loadedModel.traverse((child) => {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) {
                                    if (Array.isArray(child.material)) {
                                        child.material.forEach(m => m.dispose());
                                    } else {
                                        child.material.dispose();
                                    }
                                }
                            });
                        }

                        loadedModel = gltf.scene;
                        
                        // Center and scale model
                        const box = new THREE.Box3().setFromObject(loadedModel);
                        const size = box.getSize(new THREE.Vector3());
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 5 / maxDim;
                        loadedModel.scale.multiplyScalar(scale);

                        box.setFromObject(loadedModel);
                        box.getCenter(modelCenter);
                        loadedModel.position.sub(modelCenter);

                        // Enable shadows and ensure proper material handling
                        loadedModel.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // Ensure materials render properly
                                if (child.material) {
                                    child.material.side = THREE.DoubleSide;
                                    child.material.needsUpdate = true;
                                }
                            }
                        });

                        scene.add(loadedModel);
                        loading.style.display = 'none';
                        modelInfo.textContent = file.name;

                        // Position camera to view model
                        camera.position.set(0, size.y * scale, size.z * scale * 2);
                        camera.lookAt(0, 0, 0);
                        controls.rotation = { x: 0, y: 0 };
                    },
                    (error) => {
                        console.error('Error loading GLB:', error);
                        loading.style.display = 'none';
                        alert('Error loading GLB file. Please check the console for details.');
                    }
                );
            };
            reader.onerror = () => {
                loading.style.display = 'none';
                alert('Error reading file.');
            };
            reader.readAsArrayBuffer(file);
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': controls.forward = true; break;
                case 's': case 'arrowdown': controls.backward = true; break;
                case 'a': case 'arrowleft': controls.left = true; break;
                case 'd': case 'arrowright': controls.right = true; break;
                case ' ': controls.up = true; e.preventDefault(); break;
                case 'shift': controls.down = true; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': controls.forward = false; break;
                case 's': case 'arrowdown': controls.backward = false; break;
                case 'a': case 'arrowleft': controls.left = false; break;
                case 'd': case 'arrowright': controls.right = false; break;
                case ' ': controls.up = false; break;
                case 'shift': controls.down = false; break;
            }
        });

        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            controls.mouseDown = true;
            controls.lastMouseX = e.clientX;
            controls.lastMouseY = e.clientY;
        });

        document.addEventListener('mouseup', () => {
            controls.mouseDown = false;
        });

        document.addEventListener('mousemove', (e) => {
            if (controls.mouseDown) {
                const deltaX = e.clientX - controls.lastMouseX;
                const deltaY = e.clientY - controls.lastMouseY;

                controls.rotation.y -= deltaX * controls.rotationSpeed;
                controls.rotation.x -= deltaY * controls.rotationSpeed;

                controls.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, controls.rotation.x));

                controls.lastMouseX = e.clientX;
                controls.lastMouseY = e.clientY;
            }
        });

        // Touch controls
        let touchStartX = 0, touchStartY = 0;

        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            controls.mouseDown = true;
        });

        canvas.addEventListener('touchend', () => {
            controls.mouseDown = false;
        });

        canvas.addEventListener('touchmove', (e) => {
            if (controls.mouseDown) {
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;

                controls.rotation.y -= deltaX * controls.rotationSpeed;
                controls.rotation.x -= deltaY * controls.rotationSpeed;

                controls.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, controls.rotation.x));

                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }
        });

        // Button controls
        const buttons = {
            up: document.querySelector('.control-btn.up'),
            down: document.querySelector('.control-btn.down'),
            left: document.querySelector('.control-btn.left'),
            right: document.querySelector('.control-btn.right'),
            rise: document.querySelector('.control-btn.rise'),
            fall: document.querySelector('.control-btn.fall')
        };

        function setupButton(button, controlKey) {
            button.addEventListener('mousedown', () => controls[controlKey] = true);
            button.addEventListener('mouseup', () => controls[controlKey] = false);
            button.addEventListener('mouseleave', () => controls[controlKey] = false);
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                controls[controlKey] = true;
            });
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                controls[controlKey] = false;
            });
        }

        setupButton(buttons.up, 'forward');
        setupButton(buttons.down, 'backward');
        setupButton(buttons.left, 'left');
        setupButton(buttons.right, 'right');
        setupButton(buttons.rise, 'up');
        setupButton(buttons.fall, 'down');

        // Action buttons
        document.getElementById('reset-btn').addEventListener('click', () => {
            camera.position.set(0, 5, 10);
            controls.rotation = { x: 0, y: 0 };
        });

        document.getElementById('rotate-btn').addEventListener('click', (e) => {
            autoRotate = !autoRotate;
            e.target.classList.toggle('active');
        });

        document.getElementById('new-file-btn').addEventListener('click', () => {
            fileInput.value = '';
            uploadOverlay.classList.remove('hidden');
        });

        // Camera update
        function updateCamera() {
            const direction = new THREE.Vector3();
            const right = new THREE.Vector3();

            camera.getWorldDirection(direction);
            right.crossVectors(camera.up, direction).normalize();

            if (controls.forward) camera.position.addScaledVector(direction, -controls.speed);
            if (controls.backward) camera.position.addScaledVector(direction, controls.speed);
            if (controls.left) camera.position.addScaledVector(right, controls.speed);
            if (controls.right) camera.position.addScaledVector(right, -controls.speed);
            if (controls.up) camera.position.y += controls.speed;
            if (controls.down) camera.position.y -= controls.speed;

            camera.rotation.order = 'YXZ';
            camera.rotation.y = controls.rotation.y;
            camera.rotation.x = controls.rotation.x;

            // Update info
            const pos = camera.position;
            document.getElementById('pos-info').textContent = 
                `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            updateCamera();

            if (autoRotate && loadedModel) {
                loadedModel.rotation.y += 0.01;
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
