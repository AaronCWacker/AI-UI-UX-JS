<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Draconic Riches: Fissure of Fire - MEGA EDITION</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Arial Black', sans-serif;
            background: radial-gradient(ellipse at center, #1a0505 0%, #000000 100%);
            overflow: hidden;
            touch-action: pan-x pan-y;
            position: fixed;
            width: 100%;
            height: 100%;
            color: white;
        }
        #game-container {
            position: fixed;
            width: 100vw;
            height: 100vh;
            display: grid;
            grid-template-rows: auto auto 1fr;
            gap: 0;
            padding: 0;
            z-index: 10;
        }
        #canvas-3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Behind UI */
            pointer-events: none;
        }
        #particles-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100; /* In front of UI for coin explosions */
            pointer-events: none;
        }
        /* START OVERLAY */
        #start-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        #start-overlay h1 {
            color: #ff4500;
            font-size: 2rem;
            text-shadow: 0 0 20px red;
            animation: pulse 1s infinite;
        }
        
        .header {
            background: linear-gradient(180deg, #333333 0%, #1a1a1a 100%);
            border-bottom: 4px solid #b22222;
            padding: 5px 10px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.8);
            position: relative;
            z-index: 20;
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .header h1 {
            color: #ffffff;
            font-size: clamp(14px, 3vw, 24px);
            text-shadow: 0 0 10px #ff4500;
            margin: 0;
            flex: 1 1 auto;
            text-align: center;
        }
        .balance-item {
            background: rgba(0,0,0,0.6);
            padding: 4px 10px;
            border-radius: 8px;
            color: #ffd700;
            border: 1px solid #b22222;
            font-size: 14px;
        }
        .accumulation-piles {
            display: flex;
            gap: 10px;
        }
        .pile {
            background: rgba(20,0,0,0.8);
            border: 1px solid #ff4500;
            border-radius: 5px;
            padding: 2px 8px;
            text-align: center;
            min-width: 60px;
        }
        .pile-amount { color: white; font-weight: bold; }
        
        /* CONTROLS */
        .controls-section {
            background: #111;
            padding: 10px;
            z-index: 20;
            border-bottom: 2px solid #500;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
        }
        .btn {
            padding: 15px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            color: white;
            text-shadow: 1px 1px 0 #000;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        #btn-spin { background: linear-gradient(to bottom, #ff4500, #8b0000); flex: 2; font-size: 20px;}
        #btn-bet { background: #333; flex: 1; border: 1px solid #666;}
        #btn-autoplay { background: #0044cc; flex: 1; }
        #btn-autoplay.active { background: #ff00ff; box-shadow: 0 0 15px #ff00ff; }

        /* GAME AREA */
        .game-area {
            position: relative;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            overflow: hidden;
        }
        .slot-machine {
            background: rgba(20, 0, 0, 0.85);
            border: 4px solid #b22222;
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 0 50px rgba(255, 69, 0, 0.3);
            max-width: 100%;
            max-height: 100%;
        }
        #reels-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
        }
        .reel {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .symbol {
            background: linear-gradient(135deg, #333, #111);
            border: 1px solid #444;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(24px, 5vw, 40px);
            aspect-ratio: 1;
            width: clamp(40px, 12vw, 70px);
            height: clamp(40px, 12vw, 70px);
            user-select: none;
            position: relative;
        }
        .symbol.winning {
            background: #554400;
            border-color: #ffd700;
            animation: winPulse 0.5s infinite alternate;
            z-index: 2;
        }
        .symbol.locked {
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px #00ffff;
        }
        .symbol.spinning {
            filter: blur(2px);
            transform: scale(0.9);
        }
        
        @keyframes winPulse { from { transform: scale(1); box-shadow: 0 0 10px gold; } to { transform: scale(1.1); box-shadow: 0 0 25px gold; } }
        @keyframes pulse { 0% { opacity: 0.5; } 100% { opacity: 1; } }

        /* OVERLAYS */
        .message-overlay {
            position: fixed; top: 30%; left: 50%; transform: translate(-50%, -50%);
            font-size: 30px; font-weight: bold; text-align: center;
            text-shadow: 0 0 10px black; pointer-events: none; opacity: 0; transition: opacity 0.3s;
            z-index: 200; width: 100%;
        }
        .message-overlay.show { opacity: 1; animation: floatUp 1s forwards; }
        @keyframes floatUp { 0% { transform: translate(-50%, 0); } 100% { transform: translate(-50%, -50px); } }

        #bonus-reels { display: none; flex-direction: column; gap: 5px; width: 100%; }
        #bonus-reels.active { display: flex; }
        .bonus-row { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; }
        .bonus-cell {
            background: #220000; border: 1px solid #550000; aspect-ratio: 1;
            display: flex; align-items: center; justify-content: center; font-size: 30px;
        }
        .bonus-cell.filled { background: #aa4400; border-color: gold; animation: cellPop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes cellPop { 0% { transform: scale(0); } 100% { transform: scale(1); } }

    </style>
</head>
<body>

    <div id="start-overlay" onclick="startGame()">
        <h1>DRACONIC RICHES</h1>
        <p style="color:white; margin-top:10px;">CLICK TO ENTER THE FISSURE</p>
        <p style="color:#666; font-size: 12px; margin-top:20px;">(Enables Audio & Graphics)</p>
    </div>

    <canvas id="canvas-3d"></canvas>
    <canvas id="particles-canvas"></canvas>
    
    <div id="game-container">
        <div class="header">
            <div class="header-content">
                <div style="display:flex; gap:10px;">
                    <div class="balance-item">Bal: <span id="balance">1000</span></div>
                    <div class="balance-item">Bet: <span id="bet-display">10</span></div>
                </div>
                <h1>ðŸ”¥ FISSURE OF FIRE ðŸ”¥</h1>
                <div class="accumulation-piles">
                    <div class="pile" id="pile-gold">ðŸ’° <span id="pile-gold-amount">0</span></div>
                    <div class="pile" id="pile-gems">ðŸ’Ž <span id="pile-gems-amount">0</span></div>
                </div>
            </div>
        </div>
        
        <div class="controls-section">
            <div class="controls">
                <button id="btn-spin" class="btn">SPIN ðŸŽ°</button>
                <button id="btn-bet" class="btn">BET</button>
                <button id="btn-autoplay" class="btn">AUTO</button>
            </div>
        </div>
        
        <div class="game-area">
            <div class="slot-machine">
                <div id="reels-container"></div>
                <div id="bonus-reels"></div>
            </div>
        </div>
    </div>
    
    <div id="message-overlay" class="message-overlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        /* ================= SOUND ENGINE (Web Audio API) ================= */
        // This generates sound using code, so no external files are needed.
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const SoundFX = {
            playTone: (freq, type, duration, vol=0.1) => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            spin: () => {
                SoundFX.playTone(600, 'square', 0.1, 0.05);
                setTimeout(() => SoundFX.playTone(400, 'square', 0.1, 0.05), 50);
            },
            stop: () => {
                SoundFX.playTone(200, 'sawtooth', 0.1, 0.1);
            },
            win: () => {
                // Major arpeggio
                [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                    setTimeout(() => SoundFX.playTone(freq, 'triangle', 0.3, 0.1), i * 100);
                });
            },
            bigWin: () => {
                for(let i=0; i<10; i++) {
                    setTimeout(() => SoundFX.playTone(800 + Math.random()*400, 'square', 0.1, 0.1), i * 80);
                }
            },
            lock: () => {
                SoundFX.playTone(100, 'sawtooth', 0.4, 0.2);
            },
            click: () => {
                SoundFX.playTone(800, 'sine', 0.05, 0.05);
            }
        };

        function startGame() {
            document.getElementById('start-overlay').style.display = 'none';
            if(audioCtx.state === 'suspended') audioCtx.resume();
            SoundFX.win(); // Play start sound
            initThreeJS(); // Start graphics
        }

        /* ================= GAME LOGIC ================= */
        const gameState = {
            balance: 1000,
            bet: 10,
            betOptions: [10, 20, 50, 100],
            currentBetIndex: 0,
            isSpinning: false,
            autoPlay: false,
            autoPlayCount: 0,
            piles: { gold: 0, gems: 0 },
            bonusMode: false,
            bonusSpins: 0,
            freeSpinsMode: false,
            freeSpinsCount: 0,
            lockedSymbols: []
        };
        
        const symbols = ['ðŸ¥š', 'ðŸ—¡ï¸', 'ðŸ›¡ï¸', 'ðŸ’°', 'ðŸ’Ž', 'ðŸ‘‘', 'ðŸ”¥', 'ðŸ‰', 'âš”ï¸', 'ðŸ†', 'ðŸ’', 'âš¡', 'ðŸŒ‹'];
        const wildSymbol = 'â­';
        
        // UI Helpers
        const els = {
            balance: document.getElementById('balance'),
            bet: document.getElementById('bet-display'),
            gold: document.getElementById('pile-gold-amount'),
            gems: document.getElementById('pile-gems-amount'),
            msg: document.getElementById('message-overlay')
        };

        function updateUI() {
            els.balance.textContent = Math.floor(gameState.balance);
            els.bet.textContent = gameState.bet;
            els.gold.textContent = gameState.piles.gold;
            els.gems.textContent = gameState.piles.gems;
        }

        function showMessage(text, color) {
            els.msg.textContent = text;
            els.msg.style.color = color;
            els.msg.classList.add('show');
            setTimeout(() => els.msg.classList.remove('show'), 2000);
        }

        /* ================= REELS & SPINNING ================= */
        const container = document.getElementById('reels-container');
        
        function createReels() {
            container.innerHTML = '';
            for(let c=0; c<5; c++) {
                const col = document.createElement('div');
                col.className = 'reel';
                for(let r=0; r<5; r++) {
                    const cell = document.createElement('div');
                    cell.className = 'symbol';
                    cell.dataset.c = c;
                    cell.dataset.r = r;
                    // Check locked
                    const lock = gameState.lockedSymbols.find(l => l.c === c && l.r === r);
                    cell.textContent = lock ? lock.s : symbols[Math.floor(Math.random() * symbols.length)];
                    if(lock) cell.classList.add('locked');
                    col.appendChild(cell);
                }
                container.appendChild(col);
            }
        }
        createReels();

        async function spin() {
            if(gameState.isSpinning) return;
            if(gameState.bonusMode) { handleBonusClick(); return; }
            if(!gameState.freeSpinsMode && gameState.balance < gameState.bet) {
                showMessage("NO GOLD!", "red"); gameState.autoPlay = false; return;
            }

            if(!gameState.freeSpinsMode) gameState.balance -= gameState.bet;
            gameState.isSpinning = true;
            updateUI();
            
            SoundFX.click();
            document.querySelectorAll('.symbol:not(.locked)').forEach(el => {
                el.classList.add('spinning');
            });

            // Spin Animation
            const grid = [];
            for(let c=0; c<5; c++) {
                // Audio tick for each reel stop
                setTimeout(() => SoundFX.stop(), 200 + (c*100));
                
                await new Promise(r => setTimeout(r, 200 + (c * 100))); // Staggered stop
                const colData = [];
                for(let r=0; r<5; r++) {
                    const el = document.querySelector(`.symbol[data-c="${c}"][data-r="${r}"]`);
                    el.classList.remove('spinning');
                    
                    const lock = gameState.lockedSymbols.find(l => l.c === c && l.r === r);
                    const sym = lock ? lock.s : (Math.random() < 0.05 ? wildSymbol : symbols[Math.floor(Math.random() * symbols.length)]);
                    
                    el.textContent = sym;
                    colData.push(sym);
                }
                grid.push(colData);
            }

            // Logic
            checkWin(grid);
            gameState.isSpinning = false;
            
            if(gameState.autoPlay && gameState.autoPlayCount > 0 && !gameState.bonusMode) {
                gameState.autoPlayCount--;
                setTimeout(spin, 1000);
            }
        }

        /* ================= WIN LOGIC (Cluster/Contiguous) ================= */
        function checkWin(grid) {
            let totalWin = 0;
            const visited = new Set();
            let matchedCoords = new Set();
            let has4Row = false;

            // Simple Flood Fill for contiguous matches
            for(let c=0; c<5; c++) {
                for(let r=0; r<5; r++) {
                    const key = `${c},${r}`;
                    if(visited.has(key)) continue;
                    
                    const sym = grid[c][r];
                    if(sym === wildSymbol) continue; // Don't start flood fill on wild

                    const cluster = [];
                    const queue = [{c,r}];
                    visited.add(key);

                    while(queue.length) {
                        const curr = queue.pop();
                        cluster.push(curr);
                        
                        // Check neighbors
                        [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dc, dr]) => {
                            const nc = curr.c + dc, nr = curr.r + dr;
                            if(nc>=0 && nc<5 && nr>=0 && nr<5) {
                                const nKey = `${nc},${nr}`;
                                if(!visited.has(nKey)) {
                                    const nSym = grid[nc][nr];
                                    if(nSym === sym || nSym === wildSymbol) {
                                        visited.add(nKey);
                                        queue.push({c:nc, r:nr});
                                    }
                                }
                            }
                        });
                    }

                    if(cluster.length >= 3) {
                        totalWin += cluster.length * (gameState.bet * 0.5);
                        cluster.forEach(pt => matchedCoords.add(`${pt.c},${pt.r}`));
                        // Fire Particles on win
                        const center = cluster[0];
                        createExplosion(window.innerWidth/2, window.innerHeight/2, 'gold'); 
                    }
                    if(cluster.length >= 4) has4Row = true;
                }
            }

            // Accumulate Piles
            let goldC = 0, gemC = 0;
            grid.flat().forEach(s => { if(s==='ðŸ’°') goldC++; if(s==='ðŸ’Ž') gemC++; });
            if(goldC) { gameState.piles.gold += goldC; highlightPile('pile-gold'); }
            if(gemC) { gameState.piles.gems += gemC; highlightPile('pile-gems'); }

            // Payout
            if(totalWin > 0) {
                gameState.balance += totalWin;
                matchedCoords.forEach(k => {
                    const [c,r] = k.split(',');
                    document.querySelector(`.symbol[data-c="${c}"][data-r="${r}"]`).classList.add('winning');
                });
                SoundFX.win();
                showMessage(`WIN: ${Math.floor(totalWin)}`, "#ffd700");
                setTimeout(() => document.querySelectorAll('.winning').forEach(e=>e.classList.remove('winning')), 1500);
            }

            // Free Spins Trigger
            if(has4Row && !gameState.freeSpinsMode && !gameState.bonusMode) {
                gameState.freeSpinsMode = true;
                gameState.freeSpinsCount = 3;
                SoundFX.bigWin();
                showMessage("FISSURE OPENED! FREE SPINS!", "red");
                // Lock winning symbols
                matchedCoords.forEach(k => {
                    const [c,r] = k.split(',').map(Number);
                    gameState.lockedSymbols.push({c,r,s:grid[c][r]});
                    document.querySelector(`.symbol[data-c="${c}"][data-r="${r}"]`).classList.add('locked');
                    SoundFX.lock();
                });
            } else if (gameState.freeSpinsMode) {
                gameState.freeSpinsCount--;
                if(totalWin > 0) {
                     gameState.freeSpinsCount = 3; // Reset
                     SoundFX.lock();
                     matchedCoords.forEach(k => {
                        const [c,r] = k.split(',').map(Number);
                        if(!gameState.lockedSymbols.find(l=>l.c===c && l.r===r)) {
                            gameState.lockedSymbols.push({c,r,s:grid[c][r]});
                            document.querySelector(`.symbol[data-c="${c}"][data-r="${r}"]`).classList.add('locked');
                        }
                    });
                }
                if(gameState.freeSpinsCount <= 0) {
                    gameState.freeSpinsMode = false;
                    gameState.lockedSymbols = [];
                    document.querySelectorAll('.locked').forEach(e => e.classList.remove('locked'));
                    showMessage("FISSURE CLOSED", "white");
                }
            }
            
            // Random Bonus Trigger via Piles
            if(gameState.piles.gold > 15 || gameState.piles.gems > 15) {
                startBonusGame();
            }
            
            updateUI();
        }

        function highlightPile(id) {
            const el = document.getElementById(id);
            el.style.transform = "scale(1.2)";
            el.style.borderColor = "white";
            setTimeout(() => { el.style.transform = "scale(1)"; el.style.borderColor = "#ff4500"; }, 200);
        }

        /* ================= BONUS GAME ================= */
        function startBonusGame() {
            gameState.bonusMode = true;
            gameState.bonusSpins = 5;
            gameState.piles.gold = 0; gameState.piles.gems = 0;
            document.getElementById('reels-container').style.display = 'none';
            const bContainer = document.getElementById('bonus-reels');
            bContainer.style.display = 'flex';
            bContainer.innerHTML = '<h2 style="text-align:center; color:gold">DRAGON EGG HUNT</h2>';
            
            // Create Grid
            for(let r=0; r<3; r++){
                const row = document.createElement('div');
                row.className = 'bonus-row';
                for(let c=0; c<5; c++){
                    const cell = document.createElement('div');
                    cell.className = 'bonus-cell';
                    cell.onclick = () => fillBonusCell(cell);
                    row.appendChild(cell);
                }
                bContainer.appendChild(row);
            }
            showMessage("BONUS! CLICK CELLS!", "gold");
            SoundFX.bigWin();
        }

        function handleBonusClick() {
            // If user clicks SPIN during bonus, fill random
            const cells = document.querySelectorAll('.bonus-cell:not(.filled)');
            if(cells.length > 0) fillBonusCell(cells[Math.floor(Math.random()*cells.length)]);
        }

        function fillBonusCell(cell) {
            if(cell.classList.contains('filled') || gameState.bonusSpins <= 0) return;
            
            const prizes = ['ðŸ’°','ðŸ’Ž','ðŸ‰','100','50'];
            const val = prizes[Math.floor(Math.random()*prizes.length)];
            
            cell.textContent = val;
            cell.classList.add('filled');
            createExplosion(cell.getBoundingClientRect().left + 20, cell.getBoundingClientRect().top + 20, 'orange');
            SoundFX.spin();
            
            let win = 0;
            if(val === 'ðŸ‰') win = gameState.bet * 20;
            else if (val === 'ðŸ’°') win = gameState.bet * 5;
            else if (!isNaN(val)) win = parseInt(val);
            
            gameState.balance += win;
            gameState.bonusSpins--;
            updateUI();
            
            if(gameState.bonusSpins <= 0) {
                setTimeout(() => {
                    document.getElementById('reels-container').style.display = 'grid';
                    document.getElementById('bonus-reels').style.display = 'none';
                    gameState.bonusMode = false;
                    showMessage("BONUS COMPLETE", "white");
                }, 1500);
            }
        }

        /* ================= INPUTS ================= */
        document.getElementById('btn-spin').onclick = spin;
        document.getElementById('btn-bet').onclick = () => {
            gameState.currentBetIndex = (gameState.currentBetIndex + 1) % gameState.betOptions.length;
            gameState.bet = gameState.betOptions[gameState.currentBetIndex];
            SoundFX.click();
            updateUI();
        };
        document.getElementById('btn-autoplay').onclick = () => {
            gameState.autoPlay = !gameState.autoPlay;
            gameState.autoPlayCount = 20;
            SoundFX.click();
            document.getElementById('btn-autoplay').classList.toggle('active');
            if(gameState.autoPlay && !gameState.isSpinning) spin();
        };

        /* ================= 2D PARTICLES (Explosions) ================= */
        const canvas2d = document.getElementById('particles-canvas');
        const ctx = canvas2d.getContext('2d');
        let particles = [];
        
        function resizeCanvas() {
            canvas2d.width = window.innerWidth;
            canvas2d.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function createExplosion(x, y, color) {
            for(let i=0; i<20; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color === 'gold' ? '#ffd700' : '#ff4500'
                });
            }
        }

        function loop2d() {
            ctx.clearRect(0,0,canvas2d.width, canvas2d.height);
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2; // Gravity
                p.life -= 0.02;
                
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                ctx.fill();
                
                if(p.life <= 0) particles.splice(i, 1);
            }
            requestAnimationFrame(loop2d);
        }
        loop2d();

        /* ================= 3D BACKGROUND (Three.js) ================= */
        // Replaced CDN check with try-catch to prevent crash if offline
        function initThreeJS() {
            if(typeof THREE === 'undefined') return;
            
            const scene = new THREE.Scene();
            // Fog matches background color
            scene.fog = new THREE.FogExp2(0x1a0505, 0.02);
            
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas-3d'), alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            const pGeo = new THREE.BufferGeometry();
            const pCount = 2000; // More particles
            const pos = new Float32Array(pCount * 3);
            
            for(let i=0; i<pCount*3; i++) {
                pos[i] = (Math.random() - 0.5) * 20; // Spread wide
            }
            
            pGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const pMat = new THREE.PointsMaterial({
                size: 0.05,
                color: 0xff3300, // Fire color
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const starField = new THREE.Points(pGeo, pMat);
            scene.add(starField);
            
            function animate() {
                requestAnimationFrame(animate);
                starField.rotation.y += 0.002;
                starField.rotation.x += 0.001;
                // Pulse effect
                const time = Date.now() * 0.001;
                pMat.size = 0.05 + Math.sin(time) * 0.02;
                renderer.render(scene, camera);
            }
            animate();
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>
