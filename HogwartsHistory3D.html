<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sovereign's Forge: Evolution</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body { background: #000; overflow: hidden; font-family: 'Cinzel', serif; color: #e0c097; }

        /* --- 3D VIEWPORT --- */
        #viewport { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: radial-gradient(circle at center, #0b0b15 0%, #000 100%); }

        /* --- UI OVERLAY --- */
        #ui-layer { position: fixed; bottom: 0; left: 0; width: 100%; z-index: 10; pointer-events: none; display: flex; justify-content: center; padding-bottom: 20px; perspective: 1000px; }

        /* --- LEVEL HUD --- */
        #level-hud {
            position: fixed; top: 20px; left: 20px; z-index: 20;
            font-family: 'Share Tech Mono', monospace;
            background: rgba(0,0,0,0.6); border-left: 4px solid #00ffcc;
            padding: 10px 20px; color: #00ffcc;
            text-shadow: 0 0 10px rgba(0,255,204,0.5);
            transition: all 0.5s;
        }
        .level-label { font-size: 12px; color: #888; }
        .level-val { font-size: 32px; font-weight: bold; }
        .xp-bar-bg { width: 150px; height: 6px; background: #333; margin-top: 5px; }
        .xp-bar-fill { height: 100%; width: 0%; background: #00ffcc; transition: width 0.3s; }

        /* --- SLOT MACHINE (Morphing) --- */
        .machine-frame {
            pointer-events: auto;
            background: linear-gradient(180deg, #1a1a20 0%, #050505 100%);
            border: 1px solid #444; border-top: 4px solid #d4af37;
            box-shadow: 0 0 80px rgba(0,0,0,0.9);
            padding: 15px;
            transition: width 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            width: 300px; /* Starts small (3 reels) */
            max-width: 95vw;
        }

        .hud-header { display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 14px; color: #666; font-family: 'Share Tech Mono'; }
        .hud-val { color: #fff; font-size: 16px; }

        /* --- DYNAMIC REELS --- */
        .reels-window {
            display: grid; 
            /* Grid template columns updated via JS */
            gap: 2px; background: #000; height: 140px; overflow: hidden; margin-bottom: 15px; border: 1px solid #333;
            transition: all 0.5s;
        }
        .symbol {
            height: 70px; display: flex; align-items: center; justify-content: center;
            font-size: 36px; background: #0f0f15; border-bottom: 1px solid #222;
            text-shadow: 0 0 10px rgba(255,255,255,0.1);
        }

        .controls { display: flex; gap: 5px; }
        .btn {
            background: #222; border: 1px solid #444; color: #888; padding: 12px; flex: 1;
            font-family: 'Share Tech Mono'; font-weight: bold; font-size: 14px; cursor: pointer; transition: 0.2s;
        }
        .btn:hover { background: #333; color: white; }
        .btn.active { background: #004433; border-color: #00ffcc; color: #00ffcc; box-shadow: 0 0 15px rgba(0,255,204,0.2); }
        #btn-spin { flex: 2; background: linear-gradient(180deg, #332200, #110a00); color: #ffa500; border-color: #ff8800; }
        #btn-spin:active { transform: scale(0.95); }

        /* --- TOAST --- */
        #toast {
            position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%) scale(0);
            font-size: 40px; color: #fff; text-shadow: 0 0 30px #00ffcc;
            pointer-events: none; z-index: 100; font-weight: 900;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center;
        }
        #toast.active { transform: translate(-50%, -50%) scale(1); }
        .sub-toast { font-size: 18px; color: #aaa; display: block; margin-top: 10px; font-family: 'Share Tech Mono'; }

        /* --- START OVERLAY --- */
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 200; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #overlay h1 { font-size: 3rem; color: #d4af37; text-shadow: 0 0 30px #ff4500; margin-bottom: 10px; }
        #overlay p { color: #666; margin-bottom: 40px; font-family: 'Share Tech Mono'; }
        #overlay button { padding: 15px 40px; font-size: 18px; background: #00ffcc; border: none; font-weight: bold; cursor: pointer; box-shadow: 0 0 20px #00ffcc; }

    </style>
</head>
<body>

<div id="overlay">
    <h1>SOVEREIGN'S FORGE</h1>
    <p>System: Evolutionary Architecture v9.0</p>
    <button onclick="initSystem()">INITIALIZE REALM</button>
</div>

<div id="level-hud">
    <div class="level-label">CIVILIZATION LEVEL</div>
    <div class="level-val" id="ui-level">1</div>
    <div class="xp-bar-bg"><div class="xp-bar-fill" id="ui-xp"></div></div>
</div>

<div id="viewport"></div>

<div id="toast">
    LEVEL UP!
    <span class="sub-toast">Slot Machine Expanded</span>
</div>

<div id="ui-layer">
    <div class="machine-frame" id="slot-machine">
        <div class="hud-header">
            <div>ENERGY: <span id="ui-gold" class="hud-val">500</span></div>
            <div>POPULATION: <span id="ui-pop" class="hud-val">0</span></div>
        </div>
        <div class="reels-window" id="reels-container" style="grid-template-columns: repeat(3, 1fr);">
            </div>
        <div class="controls">
            <button class="btn" id="btn-auto" onclick="toggleAuto()">AUTO-RUN</button>
            <button class="btn" id="btn-spin" onclick="spin()">CONSTRUCT</button>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
/* =========================================================================
   AUDIO ENGINE (Procedural)
   ========================================================================= */
const SFX = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    play: function(freq, type, dur, vol=0.1, slide=false) {
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide) osc.frequency.exponentialRampToValueAtTime(freq/2, this.ctx.currentTime + dur);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + dur);
    },
    spin: () => SFX.play(200, 'sawtooth', 0.05, 0.05),
    thud: () => SFX.play(50, 'square', 0.3, 0.4, true), // Building landing
    merge: () => [600, 800].forEach((f,i) => setTimeout(()=>SFX.play(f, 'sine', 0.2, 0.2), i*100)), // Upgrade sound
    levelUp: () => [220, 330, 440, 550, 660, 880].forEach((f,i) => setTimeout(()=>SFX.play(f, 'triangle', 0.4, 0.2), i*50)),
    pop: () => SFX.play(1200, 'sine', 0.05, 0.05) // Denizen spawn
};

/* =========================================================================
   3D WORLD ENGINE (The Biome)
   ========================================================================= */
const World = {
    scene: null, camera: null, renderer: null,
    buildings: [],
    denizens: [],
    particles: [],
    
    materials: {},
    
    init: function() {
        const vp = document.getElementById('viewport');
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x050510, 0.02);

        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
        this.camera.position.set(40, 50, 40);
        this.camera.lookAt(0, 0, 0);

        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        vp.appendChild(this.renderer.domElement);

        // Lights
        const amb = new THREE.AmbientLight(0x404060, 0.8);
        this.scene.add(amb);
        
        const spot = new THREE.SpotLight(0x00ffcc, 1);
        spot.position.set(0, 100, 0);
        spot.angle = Math.PI/4;
        spot.penumbra = 0.5;
        spot.castShadow = true;
        this.scene.add(spot);

        const sun = new THREE.DirectionalLight(0xffaa00, 0.5);
        sun.position.set(50, 50, 50);
        this.scene.add(sun);

        // Materials
        this.materials.tier1 = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 }); // Shack
        this.materials.tier2 = new THREE.MeshStandardMaterial({ color: 0x444455, roughness: 0.5 }); // House
        this.materials.tier3 = new THREE.MeshStandardMaterial({ color: 0x888899, metalness: 0.5 }); // Tower
        this.materials.tier4 = new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 1.0, emissive: 0x221100 }); // Keep
        this.materials.ground = new THREE.MeshStandardMaterial({ color: 0x08080c, roughness: 1 });
        this.materials.denizen = new THREE.MeshBasicMaterial({ color: 0x00ffcc });

        // Ground
        const ground = new THREE.Mesh(new THREE.CircleGeometry(200, 64), this.materials.ground);
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        this.scene.add(ground);

        this.animate();
        
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth/window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    },

    // --- Building Logic: The Evolution Tree ---
    addBuilding: function(amount) {
        for(let i=0; i<amount; i++) {
            setTimeout(() => {
                this.spawnBlock();
            }, i * 200);
        }
    },

    spawnBlock: function() {
        // Find empty spot spiral algorithm
        let x = 0, z = 0;
        let r = 0, theta = 0;
        let found = false;
        
        // Simple search for space
        for(let i=0; i<200; i++) {
            r = 2 + (i * 0.5);
            theta += 1.5;
            x = Math.floor(Math.cos(theta) * r) * 2; // Snap to grid 2
            z = Math.floor(Math.sin(theta) * r) * 2;
            
            // Collision Check
            const collision = this.buildings.find(b => Math.abs(b.pos.x - x) < 1.5 && Math.abs(b.pos.z - z) < 1.5);
            if(!collision) { found = true; break; }
        }

        if(found) {
            this.createStructure(x, z, 1);
            // Spawn Denizen
            if(Math.random() > 0.5) this.spawnDenizen(x, z);
        }
    },

    createStructure: function(x, z, tier) {
        let geo, mat, y;
        
        // EVOLUTION TREE
        if(tier === 1) { // Shack
            geo = new THREE.BoxGeometry(1.8, 1.8, 1.8);
            mat = this.materials.tier1;
            y = 0.9;
        } else if (tier === 2) { // House
            geo = new THREE.BoxGeometry(1.8, 4, 1.8);
            mat = this.materials.tier2;
            y = 2;
        } else if (tier === 3) { // Tower
            geo = new THREE.CylinderGeometry(0.8, 1.2, 8, 8);
            mat = this.materials.tier3;
            y = 4;
        } else { // Golden Keep
            geo = new THREE.OctahedronGeometry(2);
            mat = this.materials.tier4;
            y = 6;
        }

        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, 50, z); // Sky spawn
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        const bObj = { mesh: mesh, pos: {x,y,z}, tier: tier };
        this.buildings.push(bObj);
        this.scene.add(mesh);

        // Drop Anim
        new TWEEN.Tween(mesh.position)
            .to({ y: y }, 800)
            .easing(TWEEN.Easing.Bounce.Out)
            .onComplete(() => {
                SFX.thud();
                this.checkMerge(bObj); // Check for upgrades
            })
            .start();
    },

    checkMerge: function(newB) {
        // Look for neighbors of same tier to merge
        if(newB.tier >= 4) return; // Max level

        const range = 3;
        const neighborIdx = this.buildings.findIndex(b => 
            b !== newB && 
            b.tier === newB.tier &&
            Math.abs(b.pos.x - newB.pos.x) < range && 
            Math.abs(b.pos.z - newB.pos.z) < range
        );

        if(neighborIdx !== -1) {
            const neighbor = this.buildings[neighborIdx];
            
            // MERGE!
            SFX.merge();
            
            // Remove both
            this.scene.remove(newB.mesh);
            this.scene.remove(neighbor.mesh);
            
            this.buildings = this.buildings.filter(b => b !== newB && b !== neighbor);
            
            // Create evolved building at midpoint
            const mx = (newB.pos.x + neighbor.pos.x) / 2;
            const mz = (newB.pos.z + neighbor.pos.z) / 2;
            
            // Particle explosion
            this.spawnParticles(mx, newB.pos.y, mz, 10);
            
            // Spawn higher tier
            this.createStructure(mx, mz, newB.tier + 1);
            
            // Add XP
            Game.addXP(newB.tier * 20);
        }
    },

    spawnDenizen: function(x, z) {
        const geo = new THREE.BoxGeometry(0.3, 0.6, 0.3);
        const mesh = new THREE.Mesh(geo, this.materials.denizen);
        mesh.position.set(x, 0.3, z);
        
        // AI Logic
        const denizen = {
            mesh: mesh,
            target: { x: (Math.random()-0.5)*20, z: (Math.random()-0.5)*20 },
            speed: 0.05 + Math.random()*0.05
        };
        
        this.scene.add(mesh);
        this.denizens.push(denizen);
        Game.pop++;
        SFX.pop();
    },

    spawnParticles: function(x, y, z, count) {
        const pGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const pMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
        
        for(let i=0; i<count; i++) {
            const m = new THREE.Mesh(pGeo, pMat);
            m.position.set(x, y, z);
            const vel = {
                x: (Math.random()-0.5)*0.5,
                y: Math.random()*0.5,
                z: (Math.random()-0.5)*0.5
            };
            this.scene.add(m);
            this.particles.push({ mesh: m, vel: vel, life: 1.0 });
        }
    },

    animate: function(time) {
        requestAnimationFrame((t) => World.animate(t));
        TWEEN.update(time);

        // Denizen AI
        for(let d of this.denizens) {
            const dx = d.target.x - d.mesh.position.x;
            const dz = d.target.z - d.mesh.position.z;
            const dist = Math.sqrt(dx*dx + dz*dz);
            
            if(dist < 0.5) {
                // New random target
                d.target.x = (Math.random()-0.5) * 40;
                d.target.z = (Math.random()-0.5) * 40;
            } else {
                d.mesh.position.x += (dx/dist) * d.speed;
                d.mesh.position.z += (dz/dist) * d.speed;
                d.mesh.lookAt(d.target.x, 0.3, d.target.z);
            }
        }

        // Particles
        for(let i=this.particles.length-1; i>=0; i--) {
            const p = this.particles[i];
            p.mesh.position.add(p.vel);
            p.vel.y -= 0.01; // Gravity
            p.life -= 0.02;
            p.mesh.rotation.x += 0.2;
            if(p.life <= 0) {
                this.scene.remove(p.mesh);
                this.particles.splice(i, 1);
            }
        }

        // Camera Orbit
        const ct = Date.now() * 0.0001;
        this.camera.position.x = Math.cos(ct) * 60;
        this.camera.position.z = Math.sin(ct) * 60;
        this.camera.lookAt(0, 0, 0);

        this.renderer.render(this.scene, this.camera);
    }
};

/* =========================================================================
   GAME ENGINE: EVOLUTION LOGIC
   ========================================================================= */
const Game = {
    gold: 500,
    bet: 20,
    pop: 0,
    
    // Leveling System
    level: 1,
    xp: 0,
    xpToNext: 100,
    reelsCount: 3,
    
    auto: false,
    spinning: false,
    symbols: ['ðŸ§±', 'ðŸŒ²', 'ðŸ’Ž', 'âš›ï¸', 'âš¡'], // Wall, Tree, Gem, Core, Energy

    init: function() {
        this.updateHUD();
        this.createReels();
    },

    createReels: function() {
        const c = document.getElementById('reels-container');
        c.style.gridTemplateColumns = `repeat(${this.reelsCount}, 1fr)`;
        c.innerHTML = '';
        
        for(let i=0; i<this.reelsCount; i++) {
            const strip = document.createElement('div');
            strip.className = 'reel-strip';
            strip.id = `reel-${i}`;
            for(let j=0; j<2; j++) { // 2 rows visual
                const s = document.createElement('div');
                s.className = 'symbol';
                s.textContent = this.randSym();
                strip.appendChild(s);
            }
            c.appendChild(strip);
        }
        
        // Resize Machine Frame based on reels
        document.getElementById('slot-machine').style.width = `${100 * this.reelsCount}px`;
    },

    randSym: function() {
        return this.symbols[Math.floor(Math.random() * this.symbols.length)];
    },

    addXP: function(amount) {
        this.xp += amount;
        if(this.xp >= this.xpToNext) {
            this.xp -= this.xpToNext;
            this.levelUp();
        }
        this.updateHUD();
    },

    levelUp: function() {
        this.level++;
        this.xpToNext = Math.floor(this.xpToNext * 1.5);
        SFX.levelUp();
        
        // EVOLUTION: Add Reel
        if(this.level === 3 || this.level === 6) {
            this.reelsCount++;
            this.showToast(`EVOLUTION!`, `${this.reelsCount} Reels Unlocked`);
            this.createReels();
        } else {
            this.showToast(`LEVEL ${this.level}`, `Efficiency Increased`);
        }
    },

    toggleAuto: function() {
        this.auto = !this.auto;
        document.getElementById('btn-auto').classList.toggle('active');
        if(this.auto && !this.spinning) this.spin();
    },

    spin: async function() {
        if(this.spinning) return;
        if(this.gold < this.bet) { this.auto = false; this.toggleAuto(); return; }
        
        this.spinning = true;
        this.gold -= this.bet;
        this.updateHUD();
        SFX.spin();

        // Spin Logic
        const grid = [];
        for(let i=0; i<this.reelsCount; i++) {
            const col = [this.randSym(), this.randSym()];
            grid.push(col);
            
            const strip = document.getElementById(`reel-${i}`);
            strip.style.transition = 'transform 0.1s';
            strip.style.transform = 'translateY(10px)';
            await new Promise(r => setTimeout(r, 80)); // Cascade effect
            
            // Set Result
            Array.from(strip.children).forEach((el, idx) => el.textContent = col[idx]);
            strip.style.transform = 'translateY(0)';
        }

        await new Promise(r => setTimeout(r, 200));
        this.checkWin(grid);
    },

    checkWin: function(grid) {
        const flat = grid.flat();
        
        // Count symbols
        const walls = flat.filter(s => s === 'ðŸ§±').length;
        const gems = flat.filter(s => s === 'ðŸ’Ž').length;
        const cores = flat.filter(s => s === 'âš›ï¸').length;

        // Rewards
        if(walls > 0) {
            // More reels = more multiplier
            const buildAmt = walls * (this.level > 3 ? 2 : 1);
            World.addBuilding(buildAmt);
            this.addXP(10 * walls);
        }
        
        if(gems > 0) {
            this.gold += gems * 15;
            this.addXP(5 * gems);
        }

        if(cores > 1) {
            // Rare Drop
            this.gold += 100;
            this.addXP(50);
            World.addBuilding(5); // Burst build
        }

        this.spinning = false;
        this.updateHUD();
        
        if(this.auto) setTimeout(() => this.spin(), 500);
    },

    showToast: function(main, sub) {
        const t = document.getElementById('toast');
        t.innerHTML = `${main}<span class="sub-toast">${sub}</span>`;
        t.classList.add('active');
        setTimeout(() => t.classList.remove('active'), 2500);
    },

    updateHUD: function() {
        document.getElementById('ui-gold').innerText = this.gold;
        document.getElementById('ui-pop').innerText = this.pop;
        document.getElementById('ui-level').innerText = this.level;
        const pct = (this.xp / this.xpToNext) * 100;
        document.getElementById('ui-xp').style.width = `${pct}%`;
    }
};

window.initSystem = function() {
    document.getElementById('overlay').style.display = 'none';
    SFX.init();
    World.init();
    Game.init();
};
window.toggleAuto = () => Game.toggleAuto();
window.spin = () => Game.spin();

</script>
</body>
</html>
