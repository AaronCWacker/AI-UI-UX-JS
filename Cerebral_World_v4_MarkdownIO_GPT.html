<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cerebral Intuition - Neural Biodome v2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Rajdhani', sans-serif;
            cursor: crosshair;
        }
        canvas { display: block; }

        /* Toast notification */
        #toast {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(-120px);
            background: rgba(0, 10, 20, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            color: #00ffff;
            padding: 12px 28px;
            font-size: 0.95em;
            font-family: 'Rajdhani', sans-serif;
            letter-spacing: 2px;
            z-index: 999;
            transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: none;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
        }
        #toast.show {
            transform: translateX(-50%) translateY(0);
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }

        #title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.2em;
            font-weight: 900;
            letter-spacing: 6px;
            margin-bottom: 2px;
            background: linear-gradient(90deg, #00e5ff, #d500f9, #00e5ff);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 4s ease infinite;
            text-shadow: none;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        #subtitle {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85em;
            letter-spacing: 6px;
            color: rgba(0, 229, 255, 0.5);
            font-weight: 300;
        }

        #neural-activity {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 220px;
            padding: 16px 18px;
            background: rgba(0, 6, 18, 0.85);
            border: 1px solid rgba(0, 229, 255, 0.15);
            border-radius: 12px;
            color: #00e5ff;
            font-size: 0.8em;
            backdrop-filter: blur(12px);
            z-index: 100;
        }

        #neural-activity h3 {
            margin-bottom: 12px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 400;
            font-size: 0.85em;
            letter-spacing: 3px;
            color: rgba(0, 229, 255, 0.7);
        }

        .activity-bar {
            height: 3px;
            background: rgba(0, 229, 255, 0.1);
            margin: 6px 0 10px 0;
            border-radius: 2px;
            overflow: hidden;
        }

        .activity-fill {
            height: 100%;
            background: linear-gradient(90deg, #00e5ff, #d500f9);
            border-radius: 2px;
            transition: width 0.3s;
        }

        .activity-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            opacity: 0.7;
            font-weight: 400;
        }

        #stats {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(0, 229, 255, 0.5);
            font-size: 0.75em;
            letter-spacing: 1px;
            z-index: 100;
        }

        #controls-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: rgba(0, 229, 255, 0.3);
            font-size: 0.7em;
            text-align: right;
            letter-spacing: 1px;
            z-index: 100;
        }

        /* Scene controls */
        #scene-controls {
            position: fixed;
            top: 90px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .scene-btn {
            background: rgba(0, 6, 18, 0.85);
            border: 1px solid rgba(0, 229, 255, 0.2);
            border-radius: 6px;
            color: rgba(0, 229, 255, 0.8);
            padding: 8px 18px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85em;
            font-weight: 500;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.25s ease;
            backdrop-filter: blur(8px);
        }
        .scene-btn:hover {
            background: rgba(0, 30, 60, 0.85);
            border-color: rgba(0, 229, 255, 0.5);
            color: #00e5ff;
            transform: translateX(4px);
        }
        #file-input { display: none; }

        /* Inspector panel */
        #inspector {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%) translateY(120px);
            background: rgba(0, 6, 18, 0.9);
            border: 1px solid rgba(0, 229, 255, 0.25);
            border-radius: 10px;
            color: #00e5ff;
            padding: 14px 24px;
            font-size: 0.85em;
            letter-spacing: 1px;
            z-index: 100;
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: none;
            backdrop-filter: blur(12px);
            text-align: center;
            min-width: 280px;
        }
        #inspector.show {
            transform: translateX(-50%) translateY(0);
        }
        #inspector .label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8em;
            letter-spacing: 3px;
            color: rgba(213, 0, 249, 0.8);
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div id="toast"></div>

    <div id="ui">
        <div id="title">CEREBRAL INTUITION</div>
        <div id="subtitle">NEURAL BIODOME COLONY â€¢ TITAN ORBIT</div>
    </div>

    <div id="neural-activity">
        <h3>âš¡ NEURAL ACTIVITY</h3>
        <div class="activity-label"><span>Synaptic Flow</span><span id="syn-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="syn-bar" style="width:0%"></div></div>
        <div class="activity-label"><span>Consciousness</span><span id="con-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="con-bar" style="width:0%"></div></div>
        <div class="activity-label"><span>Intuition Matrix</span><span id="int-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="int-bar" style="width:0%"></div></div>
        <div class="activity-label"><span>Drone Swarm</span><span id="drone-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="drone-bar" style="width:0%"></div></div>
        <div class="activity-label"><span>Energy Grid</span><span id="energy-val">0%</span></div>
        <div class="activity-bar"><div class="activity-fill" id="energy-bar" style="width:0%"></div></div>
    </div>

    <div id="stats">
        <div id="stat-pop">Population: 12,847 minds</div>
        <div>Drones Active: <span id="drone-count">0</span></div>
        <div>Neural Sync: <span id="sync-rate">0</span>%</div>
        <div>Terrain Nodes: <span id="terrain-count">0</span></div>
    </div>

    <div id="controls-hint">
        Drag to orbit â€¢ Scroll to zoom<br>
        Click objects to inspect
    </div>

    <div id="scene-controls">
        <button class="scene-btn" id="new-btn">âŸ³ NEW SCENE</button>
        <button class="scene-btn" id="save-btn">â¬‡ SAVE .MD</button>
        <button class="scene-btn" id="open-btn">â¬† OPEN .MD</button>
        <input type="file" id="file-input" accept=".md">
    </div>

    <div id="inspector">
        <div class="label">â€”</div>
        <div id="inspector-body">â€”</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // â”€â”€â”€ TOAST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function toast(msg) {
        const el = document.getElementById('toast');
        el.textContent = msg;
        el.classList.add('show');
        clearTimeout(el._t);
        el._t = setTimeout(() => el.classList.remove('show'), 2500);
    }

    function showInspector(label, body) {
        const el = document.getElementById('inspector');
        el.querySelector('.label').textContent = label;
        document.getElementById('inspector-body').textContent = body;
        el.classList.add('show');
        clearTimeout(el._t);
        el._t = setTimeout(() => el.classList.remove('show'), 3500);
    }

    // â”€â”€â”€ SCENE SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000a14, 0.008);

    const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    // â”€â”€â”€ CAMERA ORBIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let isDragging = false;
    let spherical = { theta: 0, phi: Math.PI / 3, radius: 32 };

    renderer.domElement.addEventListener('mousedown', () => isDragging = true);
    window.addEventListener('mouseup', () => isDragging = false);
    window.addEventListener('mousemove', e => {
        if (isDragging) {
            spherical.theta -= e.movementX * 0.005;
            spherical.phi = Math.max(0.15, Math.min(Math.PI * 0.48, spherical.phi - e.movementY * 0.005));
        }
    });
    window.addEventListener('wheel', e => {
        spherical.radius = Math.max(12, Math.min(65, spherical.radius + e.deltaY * 0.025));
    });

    // Touch support
    let lastTouch = null;
    renderer.domElement.addEventListener('touchstart', e => {
        if (e.touches.length === 1) lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    });
    renderer.domElement.addEventListener('touchmove', e => {
        if (e.touches.length === 1 && lastTouch) {
            const dx = e.touches[0].clientX - lastTouch.x;
            const dy = e.touches[0].clientY - lastTouch.y;
            spherical.theta -= dx * 0.005;
            spherical.phi = Math.max(0.15, Math.min(Math.PI * 0.48, spherical.phi - dy * 0.005));
            lastTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
    });
    renderer.domElement.addEventListener('touchend', () => lastTouch = null);

    // â”€â”€â”€ RAYCASTER FOR CLICKS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const clickableObjects = [];

    renderer.domElement.addEventListener('click', e => {
        mouse.x = (e.clientX / innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObjects(clickableObjects, true);
        if (hits.length > 0) {
            let obj = hits[0].object;
            while (obj.parent && !obj.userData.inspectLabel) obj = obj.parent;
            if (obj.userData.inspectLabel) {
                showInspector(obj.userData.inspectLabel, obj.userData.inspectBody || '');
            }
        }
    });

    // â”€â”€â”€ STARFIELD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const starsGeo = new THREE.BufferGeometry();
    const starPos = [], starCol = [];
    for (let i = 0; i < 15000; i++) {
        const r = 400 + Math.random() * 600;
        const t = Math.random() * Math.PI * 2;
        const p = Math.acos(2 * Math.random() - 1);
        starPos.push(r * Math.sin(p) * Math.cos(t), r * Math.sin(p) * Math.sin(t), r * Math.cos(p));
        const c = new THREE.Color().setHSL(Math.random() * 0.15 + 0.55, 0.4, 0.7 + Math.random() * 0.3);
        starCol.push(c.r, c.g, c.b);
    }
    starsGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
    starsGeo.setAttribute('color', new THREE.Float32BufferAttribute(starCol, 3));
    scene.add(new THREE.Points(starsGeo, new THREE.PointsMaterial({ size: 1.2, vertexColors: true, transparent: true, opacity: 0.8 })));

    // â”€â”€â”€ NEBULA BACKDROP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Soft colored nebula clouds behind the scene
    for (let i = 0; i < 6; i++) {
        const nGeo = new THREE.PlaneGeometry(120 + Math.random() * 100, 80 + Math.random() * 60);
        const nMat = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(0.55 + i * 0.06, 0.6, 0.15),
            transparent: true,
            opacity: 0.04 + Math.random() * 0.03,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const nMesh = new THREE.Mesh(nGeo, nMat);
        nMesh.position.set(
            (Math.random() - 0.5) * 200,
            30 + Math.random() * 60,
            -150 - Math.random() * 100
        );
        nMesh.rotation.set(Math.random() * 0.3, Math.random() * 0.5, Math.random() * Math.PI);
        scene.add(nMesh);
    }

    // â”€â”€â”€ SATURN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const saturnGroup = new THREE.Group();
    saturnGroup.position.set(-80, 45, -160);

    const saturn = new THREE.Mesh(
        new THREE.SphereGeometry(40, 64, 64),
        new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.85, metalness: 0.1 })
    );
    saturnGroup.add(saturn);

    // Saturn bands
    for (let i = 0; i < 5; i++) {
        const bandGeo = new THREE.TorusGeometry(40.1, 0.6, 4, 128);
        const bandMat = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(0.08, 0.4, 0.4 + i * 0.06),
            transparent: true, opacity: 0.15
        });
        const band = new THREE.Mesh(bandGeo, bandMat);
        band.position.y = -15 + i * 8;
        band.rotation.x = Math.PI / 2;
        saturnGroup.add(band);
    }

    const saturnRings = new THREE.Mesh(
        new THREE.RingGeometry(52, 82, 128),
        new THREE.MeshBasicMaterial({ color: 0xc9b896, side: THREE.DoubleSide, transparent: true, opacity: 0.5 })
    );
    saturnRings.rotation.x = Math.PI / 2.2;
    saturnGroup.add(saturnRings);
    scene.add(saturnGroup);

    // â”€â”€â”€ MAIN BIODOME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const domeGroup = new THREE.Group();

    // Glass shell
    const domeMat = new THREE.MeshPhysicalMaterial({
        color: 0x88ccff, transparent: true, opacity: 0.12,
        roughness: 0.05, metalness: 0.15, clearcoat: 1, clearcoatRoughness: 0.05,
        side: THREE.DoubleSide
    });
    domeGroup.add(new THREE.Mesh(new THREE.SphereGeometry(12, 64, 32, 0, Math.PI * 2, 0, Math.PI / 2), domeMat));

    // Geodesic frame lines
    for (let i = 1; i <= 6; i++) {
        const ringR = 12 * Math.sin((i / 7) * Math.PI / 2);
        const ringH = 12 * Math.cos((i / 7) * Math.PI / 2);
        const frameM = new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.25 });
        const frame = new THREE.Mesh(new THREE.TorusGeometry(ringR, 0.03, 6, 96), frameM);
        frame.position.y = ringH;
        frame.rotation.x = Math.PI / 2;
        domeGroup.add(frame);
    }
    // Vertical meridians
    for (let i = 0; i < 12; i++) {
        const curve = new THREE.EllipseCurve(0, 0, 12, 12, 0, Math.PI / 2, false, 0);
        const pts = curve.getPoints(32).map(p => new THREE.Vector3(
            p.x * Math.cos(i / 12 * Math.PI * 2),
            p.y,
            p.x * Math.sin(i / 12 * Math.PI * 2)
        ));
        const lineGeo = new THREE.BufferGeometry().setFromPoints(pts);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.12 });
        domeGroup.add(new THREE.Line(lineGeo, lineMat));
    }

    // Base platform
    const base = new THREE.Mesh(
        new THREE.CylinderGeometry(13.5, 14.5, 1.2, 64),
        new THREE.MeshStandardMaterial({ color: 0x1a2a3a, metalness: 0.85, roughness: 0.15 })
    );
    base.position.y = -0.6;
    domeGroup.add(base);

    // Base rim glow
    const rimGlow = new THREE.Mesh(
        new THREE.TorusGeometry(13.8, 0.08, 8, 128),
        new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.6 })
    );
    rimGlow.rotation.x = Math.PI / 2;
    rimGlow.position.y = 0.01;
    domeGroup.add(rimGlow);
    scene.add(domeGroup);

    // â”€â”€â”€ PROCEDURAL TERRAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Terrain uses a simple noise-like function for elevation
    function pseudoNoise(x, z) {
        return Math.sin(x * 0.8) * Math.cos(z * 0.6) * 0.3 +
               Math.sin(x * 1.5 + 2) * Math.cos(z * 1.2 + 1) * 0.15 +
               Math.sin(x * 3 + z * 2) * 0.05;
    }

    const terrainRes = 48;
    const terrainSize = 22;
    const terrainGeo = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainRes, terrainRes);
    const terrainPositions = terrainGeo.attributes.position.array;
    const terrainColors = new Float32Array(terrainPositions.length);

    for (let i = 0; i < terrainPositions.length; i += 3) {
        const x = terrainPositions[i];
        const z = terrainPositions[i + 1]; // PlaneGeometry is XY before rotation
        const dist = Math.sqrt(x * x + z * z);
        const edgeFade = Math.max(0, 1 - dist / (terrainSize * 0.45));
        const h = pseudoNoise(x, z) * edgeFade;
        terrainPositions[i + 2] = h; // Z becomes Y after rotation

        // Color by elevation
        const t = (h + 0.3) / 0.6;
        const col = new THREE.Color().setHSL(0.35 - t * 0.15, 0.5 + t * 0.2, 0.18 + t * 0.12);
        terrainColors[i] = col.r;
        terrainColors[i + 1] = col.g;
        terrainColors[i + 2] = col.b;
    }
    terrainGeo.setAttribute('color', new THREE.BufferAttribute(terrainColors, 3));
    terrainGeo.computeVertexNormals();

    const terrain = new THREE.Mesh(terrainGeo, new THREE.MeshStandardMaterial({
        vertexColors: true, roughness: 0.95, metalness: 0.05, flatShading: true
    }));
    terrain.rotation.x = -Math.PI / 2;
    terrain.position.y = 0.02;
    scene.add(terrain);
    document.getElementById('terrain-count').textContent = terrainRes * terrainRes;

    // â”€â”€â”€ WATER FEATURE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Small reflective pool
    const waterGeo = new THREE.CircleGeometry(2.5, 48);
    const waterMat = new THREE.MeshPhysicalMaterial({
        color: 0x003355, roughness: 0.05, metalness: 0.8,
        transparent: true, opacity: 0.7, clearcoat: 1
    });
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.rotation.x = -Math.PI / 2;
    water.position.set(4, 0.06, 5);
    scene.add(water);

    // Water glow ring
    const waterRing = new THREE.Mesh(
        new THREE.TorusGeometry(2.5, 0.04, 6, 64),
        new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.3 })
    );
    waterRing.rotation.x = Math.PI / 2;
    waterRing.position.copy(water.position);
    waterRing.position.y = 0.07;
    scene.add(waterRing);

    // â”€â”€â”€ NEURAL BRAIN TREE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const brainTreeGroup = new THREE.Group();

    // Trunk
    const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.7, 4.5, 16),
        new THREE.MeshStandardMaterial({
            color: 0x4488ff, emissive: 0x1133aa, emissiveIntensity: 0.6,
            transparent: true, opacity: 0.85
        })
    );
    trunk.position.y = 2.25;
    brainTreeGroup.add(trunk);

    // Trunk tendrils (roots)
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const pts = [];
        for (let t = 0; t <= 1; t += 0.08) {
            pts.push(new THREE.Vector3(
                Math.cos(angle) * t * 2.5 + Math.sin(t * 4) * 0.15,
                -t * 0.5,
                Math.sin(angle) * t * 2.5 + Math.cos(t * 4) * 0.15
            ));
        }
        const curve = new THREE.CatmullRomCurve3(pts);
        const rootMesh = new THREE.Mesh(
            new THREE.TubeGeometry(curve, 20, 0.04 - 0.02 * Math.random(), 6, false),
            new THREE.MeshBasicMaterial({ color: 0x2266cc, transparent: true, opacity: 0.4 })
        );
        brainTreeGroup.add(rootMesh);
    }

    function createBrainLobe(x, y, z, scale, color) {
        const g = new THREE.Group();
        const geo = new THREE.SphereGeometry(1, 32, 32);
        geo.scale(1.2, 0.85, 1);
        g.add(new THREE.Mesh(geo, new THREE.MeshPhysicalMaterial({
            color, emissive: color, emissiveIntensity: 0.35,
            transparent: true, opacity: 0.7, roughness: 0.3, metalness: 0.5, clearcoat: 0.5
        })));
        // Convolution folds
        for (let i = 0; i < 10; i++) {
            const a = (i / 10) * Math.PI * 2;
            const cPts = [];
            for (let t = 0; t <= 1; t += 0.08) {
                cPts.push(new THREE.Vector3(
                    Math.cos(a + t * 2.5) * (0.85 - t * 0.35),
                    (t - 0.5) * 1.3,
                    Math.sin(a + t * 2.5) * (0.85 - t * 0.35)
                ));
            }
            const c = new THREE.CatmullRomCurve3(cPts);
            g.add(new THREE.Mesh(
                new THREE.TubeGeometry(c, 24, 0.025, 6, false),
                new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.5 })
            ));
        }
        g.position.set(x, y, z);
        g.scale.setScalar(scale);
        return g;
    }

    const brain = new THREE.Group();
    brain.add(createBrainLobe(-1, 0, 0, 1.5, 0x4488ff));
    brain.add(createBrainLobe(1, 0, 0, 1.5, 0x8844ff));
    brain.add(createBrainLobe(0, -0.5, 0.8, 0.8, 0xff44aa));
    brain.add(createBrainLobe(0, 0, -0.8, 0.7, 0x44ffaa));
    brain.position.y = 6.5;
    brain.scale.setScalar(1.2);
    brain.userData = { inspectLabel: 'NEURAL CORTEX', inspectBody: 'Central processing matrix â€” 4 lobes, 12.8k neural threads' };
    clickableObjects.push(brain);
    brainTreeGroup.add(brain);

    // Neural pathways
    const pathways = [];
    for (let i = 0; i < 24; i++) {
        const pts = [];
        const sa = (i / 24) * Math.PI * 2;
        const h = 4.5 + Math.random() * 3;
        for (let t = 0; t <= 1; t += 0.04) {
            const spread = t * 2.2;
            pts.push(new THREE.Vector3(
                Math.cos(sa + t * 0.6) * spread + Math.sin(t * 6) * 0.15,
                t * h,
                Math.sin(sa + t * 0.6) * spread + Math.cos(t * 6) * 0.15
            ));
        }
        const curve = new THREE.CatmullRomCurve3(pts);
        const hue = 0.5 + Math.random() * 0.3;
        const pw = new THREE.Mesh(
            new THREE.TubeGeometry(curve, 50, 0.015 + Math.random() * 0.025, 6, false),
            new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(hue, 1, 0.5),
                transparent: true, opacity: 0.6
            })
        );
        pw.userData = { phase: Math.random() * Math.PI * 2, speed: 0.4 + Math.random() * 0.8 };
        pathways.push(pw);
        brainTreeGroup.add(pw);
    }

    // Synaptic particles
    let synapseCount = 600;
    let synapseGeo = new THREE.BufferGeometry();
    let synapsePos, synapseSpeeds;

    function initSynapses(count) {
        synapseCount = count;
        synapsePos = new Float32Array(synapseCount * 3);
        synapseSpeeds = [];
        for (let i = 0; i < synapseCount; i++) {
            const a = Math.random() * Math.PI * 2;
            const r = Math.random() * 3.5;
            const h = Math.random() * 9;
            synapsePos[i * 3] = Math.cos(a) * r;
            synapsePos[i * 3 + 1] = h;
            synapsePos[i * 3 + 2] = Math.sin(a) * r;
            synapseSpeeds.push({ angle: a, radius: r, speed: 0.4 + Math.random() * 1.5, vertSpeed: (Math.random() - 0.5) * 0.5 });
        }
        synapseGeo.setAttribute('position', new THREE.BufferAttribute(synapsePos, 3));
    }
    initSynapses(synapseCount);

    const synapseMat = new THREE.PointsMaterial({
        color: 0x00e5ff, size: 0.12, transparent: true, opacity: 0.75,
        blending: THREE.AdditiveBlending, depthWrite: false
    });
    const synapses = new THREE.Points(synapseGeo, synapseMat);
    brainTreeGroup.add(synapses);
    scene.add(brainTreeGroup);

    // â”€â”€â”€ SMALL DOMES (REUSABLE FACTORY) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const smallDomes = [];
    const defaultDomeConfigs = [
        { x: -6, z: 3, scale: 0.8 }, { x: 6, z: 3, scale: 0.7 },
        { x: -4, z: -5, scale: 0.6 }, { x: 5, z: -4, scale: 0.75 },
        { x: -7, z: -2, scale: 0.5 }, { x: 7, z: 0, scale: 0.55 },
        { x: 0, z: 7, scale: 0.65 }, { x: 3, z: 6, scale: 0.5 },
        { x: -2, z: -7, scale: 0.45 }, { x: 8, z: -1, scale: 0.4 }
    ];

    function createSmallDome(index, pos, scale) {
        const g = new THREE.Group();
        g.add(new THREE.Mesh(
            new THREE.SphereGeometry(1.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2),
            new THREE.MeshPhysicalMaterial({
                color: 0xaaddff, transparent: true, opacity: 0.25,
                roughness: 0.05, metalness: 0.25, clearcoat: 1
            })
        ));
        g.add(new THREE.Mesh(
            new THREE.CylinderGeometry(1.6, 1.7, 0.25, 32),
            new THREE.MeshStandardMaterial({ color: 0x2a3a4a, metalness: 0.8 })
        ));
        g.children[1].position.y = -0.125;
        // Interior glow
        const glowCol = new THREE.Color().setHSL(0.3 + index * 0.045, 0.7, 0.45);
        const glow = new THREE.Mesh(
            new THREE.SphereGeometry(0.8, 12, 12),
            new THREE.MeshBasicMaterial({ color: glowCol, transparent: true, opacity: 0.25 })
        );
        glow.position.y = 0.3;
        g.add(glow);
        g.position.set(pos.x, 0, pos.z);
        g.scale.setScalar(scale);
        g.userData = {
            pulsePhase: Math.random() * Math.PI * 2,
            inspectLabel: `HABITAT ${index + 1}`,
            inspectBody: `Colony dome â€” pop. ${Math.floor(300 + Math.random() * 800)} â€¢ scale ${scale.toFixed(2)}`
        };
        clickableObjects.push(g);
        return g;
    }

    function spawnDefaultDomes() {
        defaultDomeConfigs.forEach((cfg, i) => {
            const d = createSmallDome(i, cfg, cfg.scale);
            smallDomes.push(d);
            scene.add(d);
        });
    }
    spawnDefaultDomes();

    // â”€â”€â”€ ENERGY BEAMS (connections between domes and brain) â”€â”€
    const energyBeams = [];
    function createEnergyBeams() {
        // Clear old
        energyBeams.forEach(b => scene.remove(b));
        energyBeams.length = 0;
        smallDomes.forEach(dome => {
            const startPt = dome.position.clone();
            startPt.y = 0.5;
            const endPt = new THREE.Vector3(0, 4, 0);
            const midPt = startPt.clone().lerp(endPt, 0.5);
            midPt.y += 2 + Math.random() * 2;
            const curve = new THREE.QuadraticBezierCurve3(startPt, midPt, endPt);
            const beamGeo = new THREE.TubeGeometry(curve, 24, 0.02, 4, false);
            const beam = new THREE.Mesh(beamGeo, new THREE.MeshBasicMaterial({
                color: 0x00e5ff, transparent: true, opacity: 0.08,
                blending: THREE.AdditiveBlending, depthWrite: false
            }));
            beam.userData = { phase: Math.random() * Math.PI * 2 };
            energyBeams.push(beam);
            scene.add(beam);
        });
    }
    createEnergyBeams();

    // â”€â”€â”€ DRONES (REUSABLE FACTORY) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const drones = [];

    function createDrone() {
        const g = new THREE.Group();
        // Body
        g.add(new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.08, 0.3),
            new THREE.MeshStandardMaterial({ color: 0x556677, metalness: 0.9, roughness: 0.2 })
        ));
        // Arms
        for (let r = 0; r < 4; r++) {
            const armGeo = new THREE.BoxGeometry(0.22, 0.02, 0.02);
            const arm = new THREE.Mesh(armGeo, new THREE.MeshStandardMaterial({ color: 0x445566, metalness: 0.8 }));
            arm.position.set((r % 2 === 0 ? 1 : -1) * 0.14, 0.02, (r < 2 ? 1 : -1) * 0.14);
            arm.rotation.y = Math.PI / 4;
            g.add(arm);
        }
        // Rotors glow
        for (let r = 0; r < 4; r++) {
            const rotor = new THREE.Mesh(
                new THREE.TorusGeometry(0.08, 0.015, 6, 16),
                new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.8 })
            );
            rotor.position.set((r % 2 === 0 ? 1 : -1) * 0.2, 0.04, (r < 2 ? 1 : -1) * 0.2);
            rotor.rotation.x = Math.PI / 2;
            g.add(rotor);
        }
        // Belly light
        const light = new THREE.Mesh(
            new THREE.SphereGeometry(0.035, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xff4444 })
        );
        light.position.y = -0.06;
        g.add(light);
        // Scan beam
        const beamGeo = new THREE.CylinderGeometry(0.01, 0.15, 1.5, 8, 1, true);
        const beamMat = new THREE.MeshBasicMaterial({
            color: 0x00e5ff, transparent: true, opacity: 0.06,
            blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
        });
        const beam = new THREE.Mesh(beamGeo, beamMat);
        beam.position.y = -0.8;
        g.add(beam);

        g.userData = {
            orbitRadius: 5 + Math.random() * 7,
            orbitHeight: 3 + Math.random() * 6,
            orbitSpeed: 0.15 + Math.random() * 0.25,
            orbitPhase: Math.random() * Math.PI * 2,
            bobSpeed: 1 + Math.random() * 2,
            bobAmount: 0.08 + Math.random() * 0.15,
            inspectLabel: 'SURVEY DRONE',
            inspectBody: `Altitude ${(3 + Math.random() * 6).toFixed(1)}m â€¢ scanning`
        };
        g.scale.setScalar(0.75);
        clickableObjects.push(g);
        return g;
    }

    function spawnDefaultDrones(count) {
        for (let i = 0; i < count; i++) {
            const d = createDrone();
            drones.push(d);
            scene.add(d);
        }
    }
    spawnDefaultDrones(18);

    // â”€â”€â”€ VEGETATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const vegetation = [];
    function spawnVegetation() {
        for (let i = 0; i < 40; i++) {
            const a = Math.random() * Math.PI * 2;
            const r = 2.5 + Math.random() * 8.5;
            const x = Math.cos(a) * r;
            const z = Math.sin(a) * r;
            const bush = new THREE.Mesh(
                new THREE.SphereGeometry(0.2 + Math.random() * 0.4, 8, 8),
                new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(0.25 + Math.random() * 0.12, 0.65, 0.2 + Math.random() * 0.18),
                    roughness: 0.85
                })
            );
            bush.position.set(x, 0.15 + pseudoNoise(x, z) * 0.3, z);
            bush.scale.y = 0.5 + Math.random() * 0.5;
            vegetation.push(bush);
            scene.add(bush);
        }
        // Bioluminescent mushrooms
        for (let i = 0; i < 12; i++) {
            const a = Math.random() * Math.PI * 2;
            const r = 3 + Math.random() * 7;
            const g = new THREE.Group();
            const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.03, 0.04, 0.3, 6),
                new THREE.MeshStandardMaterial({ color: 0x667788 })
            );
            stem.position.y = 0.15;
            g.add(stem);
            const cap = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.5 + Math.random() * 0.3, 0.9, 0.5),
                    transparent: true, opacity: 0.7
                })
            );
            cap.position.y = 0.3;
            g.add(cap);
            g.position.set(Math.cos(a) * r, 0, Math.sin(a) * r);
            g.scale.setScalar(0.6 + Math.random() * 0.8);
            vegetation.push(g);
            scene.add(g);
        }
    }
    spawnVegetation();

    // â”€â”€â”€ INHABITANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const inhabitants = [];
    function spawnInhabitants() {
        for (let i = 0; i < 25; i++) {
            const g = new THREE.Group();
            const isRobot = Math.random() > 0.45;
            const col = isRobot ? 0x8899aa : new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 0.45, 0.5).getHex();
            g.add(new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.09, 0.28, 8),
                new THREE.MeshStandardMaterial({ color: col, metalness: isRobot ? 0.85 : 0.1 })
            ));
            g.children[0].position.y = 0.22;
            g.add(new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 8, 8),
                new THREE.MeshStandardMaterial({ color: isRobot ? 0xaaccee : 0xffcc99, metalness: isRobot ? 0.85 : 0.1 })
            ));
            g.children[1].position.y = 0.42;
            if (isRobot) {
                const eye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.018, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0x00e5ff })
                );
                eye.position.set(0, 0.42, 0.05);
                g.add(eye);
            }
            const a = Math.random() * Math.PI * 2;
            const r = 2 + Math.random() * 9;
            g.position.set(Math.cos(a) * r, 0, Math.sin(a) * r);
            g.rotation.y = Math.random() * Math.PI * 2;
            g.scale.setScalar(0.7 + Math.random() * 0.4);
            g.userData = {
                walkAngle: a,
                walkRadius: r,
                walkSpeed: 0.02 + Math.random() * 0.04,
                inspectLabel: isRobot ? 'SYNTHETIC CITIZEN' : 'COLONIST',
                inspectBody: isRobot ? 'Neural-linked synthetic â€” role: maintenance' : 'Human resident â€” sector ' + Math.floor(Math.random() * 8 + 1)
            };
            clickableObjects.push(g);
            inhabitants.push(g);
            scene.add(g);
        }
    }
    spawnInhabitants();

    // â”€â”€â”€ GROUND PATHWAYS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    for (let i = 0; i < 10; i++) {
        const pMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(0.2, 11),
            new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.1 })
        );
        pMesh.rotation.x = -Math.PI / 2;
        pMesh.rotation.z = (i / 10) * Math.PI * 2;
        pMesh.position.y = 0.03;
        scene.add(pMesh);
    }

    // â”€â”€â”€ FLOATING HOLO-SIGNS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const signs = [];
    function createHoloSign(text, x, y, z) {
        const g = new THREE.Group();
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(3.5, 0.8),
            new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.04, side: THREE.DoubleSide })
        );
        g.add(plane);
        const border = new THREE.LineSegments(
            new THREE.EdgesGeometry(new THREE.PlaneGeometry(3.5, 0.8)),
            new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.25 })
        );
        g.add(border);
        g.position.set(x, y, z);
        g.userData = { inspectLabel: 'HOLOGRAPHIC DISPLAY', inspectBody: text };
        clickableObjects.push(g);
        signs.push(g);
        scene.add(g);
        return g;
    }
    createHoloSign('SECTOR A â€” NEURAL LABS', -5, 4, 2);
    createHoloSign('TITAN DOCKING BAY â†’', 5, 3.5, -3);

    // â”€â”€â”€ ATMOSPHERIC PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const dustCount = 300;
    const dustGeo = new THREE.BufferGeometry();
    const dustPos = new Float32Array(dustCount * 3);
    const dustVel = [];
    for (let i = 0; i < dustCount; i++) {
        dustPos[i * 3] = (Math.random() - 0.5) * 24;
        dustPos[i * 3 + 1] = Math.random() * 10;
        dustPos[i * 3 + 2] = (Math.random() - 0.5) * 24;
        dustVel.push({ vx: (Math.random() - 0.5) * 0.003, vy: Math.random() * 0.005 + 0.001, vz: (Math.random() - 0.5) * 0.003 });
    }
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    scene.add(new THREE.Points(dustGeo, new THREE.PointsMaterial({
        color: 0x88ccff, size: 0.06, transparent: true, opacity: 0.35,
        blending: THREE.AdditiveBlending, depthWrite: false
    })));

    // â”€â”€â”€ LIGHTING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    scene.add(new THREE.AmbientLight(0x223344, 0.6));
    const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);
    mainLight.position.set(10, 25, 10);
    scene.add(mainLight);
    const brainLight = new THREE.PointLight(0x00e5ff, 2.5, 22);
    brainLight.position.set(0, 6.5, 0);
    scene.add(brainLight);
    const purpleLight = new THREE.PointLight(0xd500f9, 1.2, 18);
    purpleLight.position.set(0, 8, 0);
    scene.add(purpleLight);
    // Accent fill lights
    const accentA = new THREE.PointLight(0x00ffaa, 0.4, 12);
    accentA.position.set(-6, 2, 4);
    scene.add(accentA);
    const accentB = new THREE.PointLight(0xff6600, 0.3, 10);
    accentB.position.set(6, 2, -3);
    scene.add(accentB);

    // â”€â”€â”€ ANIMATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let time = 0;

    function animate() {
        requestAnimationFrame(animate);
        const dt = 0.016;
        time += dt;

        // Camera
        camera.position.x = Math.sin(spherical.theta) * Math.sin(spherical.phi) * spherical.radius;
        camera.position.y = Math.cos(spherical.phi) * spherical.radius;
        camera.position.z = Math.cos(spherical.theta) * Math.sin(spherical.phi) * spherical.radius;
        camera.lookAt(0, 4.5, 0);

        // Brain rotation + bob
        brain.rotation.y = time * 0.08;
        brain.position.y = 6.5 + Math.sin(time * 0.6) * 0.15;

        // Lights pulse
        brainLight.intensity = 2.5 + Math.sin(time * 2) * 0.6;
        purpleLight.intensity = 1.2 + Math.sin(time * 2.5 + 1) * 0.4;

        // Pathways glow
        pathways.forEach(pw => {
            pw.material.opacity = 0.35 + Math.sin(time * pw.userData.speed + pw.userData.phase) * 0.25;
        });

        // Energy beams pulse
        energyBeams.forEach(b => {
            b.material.opacity = 0.04 + Math.sin(time * 1.5 + b.userData.phase) * 0.04;
        });

        // Synapses
        const sp = synapses.geometry.attributes.position.array;
        for (let i = 0; i < synapseCount; i++) {
            const s = synapseSpeeds[i];
            s.angle += s.speed * 0.01;
            sp[i * 3] = Math.cos(s.angle) * s.radius;
            sp[i * 3 + 1] += s.vertSpeed * 0.04;
            sp[i * 3 + 2] = Math.sin(s.angle) * s.radius;
            if (sp[i * 3 + 1] > 9) sp[i * 3 + 1] = 0;
            if (sp[i * 3 + 1] < 0) sp[i * 3 + 1] = 9;
        }
        synapses.geometry.attributes.position.needsUpdate = true;

        // Drones
        drones.forEach(drone => {
            const d = drone.userData;
            const a = time * d.orbitSpeed + d.orbitPhase;
            drone.position.x = Math.cos(a) * d.orbitRadius;
            drone.position.z = Math.sin(a) * d.orbitRadius;
            drone.position.y = d.orbitHeight + Math.sin(time * d.bobSpeed) * d.bobAmount;
            drone.rotation.y = a + Math.PI;
        });

        // Small domes pulse
        smallDomes.forEach((dome, i) => {
            if (dome.children[2]) {
                dome.children[2].material.opacity = 0.2 + Math.sin(time * 1.8 + dome.userData.pulsePhase) * 0.1;
            }
        });

        // Inhabitants walk slowly
        inhabitants.forEach(fig => {
            const d = fig.userData;
            d.walkAngle += d.walkSpeed * dt;
            fig.position.x = Math.cos(d.walkAngle) * d.walkRadius;
            fig.position.z = Math.sin(d.walkAngle) * d.walkRadius;
            fig.rotation.y = d.walkAngle + Math.PI / 2;
        });

        // Signs float
        signs.forEach((s, i) => {
            s.position.y = (i === 0 ? 4 : 3.5) + Math.sin(time * 0.8 + i * 2) * 0.15;
            s.rotation.y = Math.sin(time * 0.4 + i) * 0.08;
        });

        // Dust particles drift
        const dp = dustGeo.attributes.position.array;
        for (let i = 0; i < dustCount; i++) {
            dp[i * 3] += dustVel[i].vx;
            dp[i * 3 + 1] += dustVel[i].vy;
            dp[i * 3 + 2] += dustVel[i].vz;
            if (dp[i * 3 + 1] > 10) { dp[i * 3 + 1] = 0; dp[i * 3] = (Math.random() - 0.5) * 24; dp[i * 3 + 2] = (Math.random() - 0.5) * 24; }
        }
        dustGeo.attributes.position.needsUpdate = true;

        // Water shimmer
        waterMat.opacity = 0.65 + Math.sin(time * 1.2) * 0.08;

        // Saturn
        saturn.rotation.y = time * 0.015;
        saturnRings.rotation.z = time * 0.008;

        // UI
        const synVal = Math.floor(50 + Math.sin(time * 1.2) * 30 + Math.random() * 8);
        const conVal = Math.floor(60 + Math.sin(time * 0.8 + 1) * 25 + Math.random() * 6);
        const intVal = Math.floor(70 + Math.sin(time * 1.5 + 2) * 20 + Math.random() * 4);
        const droneVal = Math.floor(80 + Math.sin(time * 0.5) * 15);
        const energyVal = Math.floor(65 + Math.sin(time * 0.7 + 3) * 28 + Math.random() * 5);

        document.getElementById('syn-val').textContent = synVal + '%';
        document.getElementById('syn-bar').style.width = synVal + '%';
        document.getElementById('con-val').textContent = conVal + '%';
        document.getElementById('con-bar').style.width = conVal + '%';
        document.getElementById('int-val').textContent = intVal + '%';
        document.getElementById('int-bar').style.width = intVal + '%';
        document.getElementById('drone-val').textContent = droneVal + '%';
        document.getElementById('drone-bar').style.width = droneVal + '%';
        document.getElementById('energy-val').textContent = energyVal + '%';
        document.getElementById('energy-bar').style.width = energyVal + '%';
        document.getElementById('drone-count').textContent = drones.length;
        document.getElementById('sync-rate').textContent = Math.floor((synVal + conVal + intVal) / 3);

        renderer.render(scene, camera);
    }
    animate();

    // â”€â”€â”€ RESIZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â”€â”€â”€ SAVE / LOAD SYSTEM (Markdown Recipe) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function saveBiodomeState() {
        let md = `# ðŸ§  Neural Biodome â€” Configuration Recipe\n\n`;
        md += `> **Saved:** ${new Date().toISOString()}  \n`;
        md += `> Edit this file and re-open it to customize your world.\n`;
        md += `> Add/remove table rows to change object counts. Tweak values to reshape the simulation.\n\n`;
        md += `---\n\n`;

        // â”€â”€ Step 1: Globals â”€â”€
        md += `## Step 1: Set Global Parameters\n\n`;
        md += `| Key | Value | Description |\n`;
        md += `|-----|-------|-------------|\n`;
        md += `| time | ${time.toFixed(3)} | Simulation clock |\n`;
        md += `| camera_theta | ${spherical.theta.toFixed(4)} | Horizontal orbit angle |\n`;
        md += `| camera_phi | ${spherical.phi.toFixed(4)} | Vertical orbit angle |\n`;
        md += `| camera_radius | ${spherical.radius.toFixed(2)} | Zoom distance |\n`;
        md += `| brain_scale | ${brain.scale.x.toFixed(3)} | Brain tree size |\n`;
        md += `| brain_y | ${brain.position.y.toFixed(3)} | Brain height |\n`;
        md += `| population | 12847 | Display population |\n`;
        md += `| synapse_count | ${synapseCount} | Particle density |\n`;
        md += `| fog_density | ${scene.fog.density.toFixed(4)} | Atmospheric fog |\n\n`;

        // â”€â”€ Step 2: Drones â”€â”€
        md += `## Step 2: Configure Drones\n\n`;
        md += `Add/remove rows to change drone count. Adjust orbit parameters for behavior.\n\n`;
        md += `| id | orbitRadius | orbitHeight | orbitSpeed | orbitPhase | bobSpeed | bobAmount |\n`;
        md += `|----|-------------|-------------|------------|------------|----------|----------|\n`;
        drones.forEach((d, i) => {
            const u = d.userData;
            md += `| ${i} | ${u.orbitRadius.toFixed(3)} | ${u.orbitHeight.toFixed(3)} | ${u.orbitSpeed.toFixed(3)} | ${u.orbitPhase.toFixed(3)} | ${u.bobSpeed.toFixed(3)} | ${u.bobAmount.toFixed(3)} |\n`;
        });
        md += `\n`;

        // â”€â”€ Step 3: Small Domes â”€â”€
        md += `## Step 3: Configure Small Domes\n\n`;
        md += `Colony habitats. Add rows for new domes. Glow color auto-set by id.\n\n`;
        md += `| id | posX | posZ | scale | pulsePhase |\n`;
        md += `|----|------|------|-------|------------|\n`;
        smallDomes.forEach((d, i) => {
            md += `| ${i} | ${d.position.x.toFixed(3)} | ${d.position.z.toFixed(3)} | ${d.scale.x.toFixed(3)} | ${d.userData.pulsePhase.toFixed(3)} |\n`;
        });
        md += `\n`;

        // â”€â”€ Step 4: Inhabitants â”€â”€
        md += `## Step 4: Configure Inhabitants\n\n`;
        md += `Walking figures. Edit walkRadius/walkSpeed for patrol routes.\n\n`;
        md += `| id | walkAngle | walkRadius | walkSpeed | scale |\n`;
        md += `|----|-----------|------------|-----------|-------|\n`;
        inhabitants.forEach((fig, i) => {
            const u = fig.userData;
            md += `| ${i} | ${u.walkAngle.toFixed(3)} | ${u.walkRadius.toFixed(3)} | ${u.walkSpeed.toFixed(4)} | ${fig.scale.x.toFixed(3)} |\n`;
        });
        md += `\n`;

        // â”€â”€ Step 5: Signs â”€â”€
        md += `## Step 5: Configure Holo-Signs\n\n`;
        md += `| id | posX | posY | posZ | text |\n`;
        md += `|----|------|------|------|------|\n`;
        signs.forEach((s, i) => {
            md += `| ${i} | ${s.position.x.toFixed(2)} | ${s.position.y.toFixed(2)} | ${s.position.z.toFixed(2)} | ${s.userData.inspectBody} |\n`;
        });
        md += `\n`;

        // Download
        const blob = new Blob([md], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `NeuralBiodome_${new Date().toISOString().slice(0, 16).replace(':', '')}.md`;
        a.click();
        URL.revokeObjectURL(url);
        toast('âœ… Recipe saved to Markdown');
    }

    // â”€â”€â”€ MARKDOWN PARSER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function parseMarkdownTables(text) {
        const sections = {};
        let currentKey = null;
        let headers = null;

        for (const raw of text.split('\n')) {
            const line = raw.trim();
            if (line.startsWith('## ')) {
                // Normalize section name: strip "Step N: "
                currentKey = line.replace(/^##\s*/, '').replace(/^Step \d+:\s*/, '').trim();
                sections[currentKey] = [];
                headers = null;
                continue;
            }
            if (!currentKey || !line.startsWith('|') || !line.endsWith('|')) continue;
            // Separator row
            if (/^\|[\s\-:|]+\|$/.test(line)) continue;

            const cells = line.slice(1, -1).split('|').map(c => c.trim());
            if (!headers) {
                headers = cells;
            } else {
                const obj = {};
                headers.forEach((h, i) => {
                    const v = cells[i] || '';
                    const num = parseFloat(v);
                    obj[h] = isNaN(num) ? v : num;
                });
                sections[currentKey].push(obj);
            }
        }
        return sections;
    }

    // â”€â”€â”€ LOAD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function loadBiodomeState(file) {
        const reader = new FileReader();
        reader.onload = e => {
            const sections = parseMarkdownTables(e.target.result);

            // Globals
            const globalsArr = sections['Set Global Parameters'] || [];
            const globals = {};
            globalsArr.forEach(row => { if (row.Key) globals[row.Key] = row.Value; });

            if (Object.keys(globals).length) {
                time = parseFloat(globals.time) || 0;
                spherical.theta = parseFloat(globals.camera_theta) || 0;
                spherical.phi = parseFloat(globals.camera_phi) || Math.PI / 3;
                spherical.radius = parseFloat(globals.camera_radius) || 32;
                brain.scale.setScalar(parseFloat(globals.brain_scale) || 1.2);
                const pop = parseInt(globals.population) || 12847;
                document.getElementById('stat-pop').textContent = `Population: ${pop.toLocaleString()} minds`;
                if (globals.fog_density) scene.fog.density = parseFloat(globals.fog_density);

                const newSyn = parseInt(globals.synapse_count) || 600;
                if (newSyn !== synapseCount) {
                    brainTreeGroup.remove(synapses);
                    synapseGeo.dispose();
                    synapseGeo = new THREE.BufferGeometry();
                    initSynapses(newSyn);
                    synapses.geometry = synapseGeo;
                    brainTreeGroup.add(synapses);
                }
            }

            // Drones
            const droneData = sections['Configure Drones'] || [];
            drones.forEach(d => { scene.remove(d); clickableObjects.splice(clickableObjects.indexOf(d), 1); });
            drones.length = 0;
            droneData.forEach(row => {
                const d = createDrone();
                Object.assign(d.userData, {
                    orbitRadius: row.orbitRadius ?? 8,
                    orbitHeight: row.orbitHeight ?? 5,
                    orbitSpeed: row.orbitSpeed ?? 0.2,
                    orbitPhase: row.orbitPhase ?? 0,
                    bobSpeed: row.bobSpeed ?? 1.5,
                    bobAmount: row.bobAmount ?? 0.1
                });
                drones.push(d);
                scene.add(d);
            });

            // Small Domes
            const domeData = sections['Configure Small Domes'] || [];
            smallDomes.forEach(d => { scene.remove(d); clickableObjects.splice(clickableObjects.indexOf(d), 1); });
            smallDomes.length = 0;
            domeData.forEach((row, i) => {
                const d = createSmallDome(i, { x: row.posX || 0, z: row.posZ || 0 }, row.scale || 0.5);
                d.userData.pulsePhase = row.pulsePhase || 0;
                smallDomes.push(d);
                scene.add(d);
            });
            createEnergyBeams(); // Reconnect energy links

            // Inhabitants
            const inhData = sections['Configure Inhabitants'] || [];
            if (inhData.length) {
                inhabitants.forEach(f => { scene.remove(f); clickableObjects.splice(clickableObjects.indexOf(f), 1); });
                inhabitants.length = 0;
                // Re-spawn with loaded params (keeping same visual generation)
                inhData.forEach((row, i) => {
                    const g = new THREE.Group();
                    const isRobot = i % 2 === 0;
                    const col = isRobot ? 0x8899aa : 0x996644;
                    g.add(new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.09, 0.28, 8), new THREE.MeshStandardMaterial({ color: col, metalness: isRobot ? 0.85 : 0.1 })));
                    g.children[0].position.y = 0.22;
                    g.add(new THREE.Mesh(new THREE.SphereGeometry(0.055, 8, 8), new THREE.MeshStandardMaterial({ color: isRobot ? 0xaaccee : 0xffcc99, metalness: isRobot ? 0.85 : 0.1 })));
                    g.children[1].position.y = 0.42;
                    if (isRobot) {
                        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.018, 6, 6), new THREE.MeshBasicMaterial({ color: 0x00e5ff }));
                        eye.position.set(0, 0.42, 0.05);
                        g.add(eye);
                    }
                    g.scale.setScalar(row.scale || 0.85);
                    g.userData = {
                        walkAngle: row.walkAngle || 0,
                        walkRadius: row.walkRadius || 5,
                        walkSpeed: row.walkSpeed || 0.03,
                        inspectLabel: isRobot ? 'SYNTHETIC CITIZEN' : 'COLONIST',
                        inspectBody: isRobot ? 'Neural-linked synthetic' : 'Human resident'
                    };
                    g.position.set(Math.cos(g.userData.walkAngle) * g.userData.walkRadius, 0, Math.sin(g.userData.walkAngle) * g.userData.walkRadius);
                    clickableObjects.push(g);
                    inhabitants.push(g);
                    scene.add(g);
                });
            }

            // Signs
            const signData = sections['Configure Holo-Signs'] || [];
            if (signData.length) {
                signs.forEach(s => { scene.remove(s); clickableObjects.splice(clickableObjects.indexOf(s), 1); });
                signs.length = 0;
                signData.forEach(row => {
                    createHoloSign(row.text || 'SIGN', row.posX || 0, row.posY || 4, row.posZ || 0);
                });
            }

            toast('âœ… Recipe loaded â€” world rebuilt');
        };
        reader.readAsText(file);
    }

    // â”€â”€â”€ RESET â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function resetScene() {
        time = 0;
        spherical = { theta: 0, phi: Math.PI / 3, radius: 32 };
        brain.scale.setScalar(1.2);
        scene.fog.density = 0.008;

        // Drones
        drones.forEach(d => { scene.remove(d); clickableObjects.splice(clickableObjects.indexOf(d), 1); });
        drones.length = 0;
        spawnDefaultDrones(18);

        // Domes
        smallDomes.forEach(d => { scene.remove(d); clickableObjects.splice(clickableObjects.indexOf(d), 1); });
        smallDomes.length = 0;
        spawnDefaultDomes();
        createEnergyBeams();

        // Synapses
        brainTreeGroup.remove(synapses);
        synapseGeo.dispose();
        synapseGeo = new THREE.BufferGeometry();
        initSynapses(600);
        synapses.geometry = synapseGeo;
        brainTreeGroup.add(synapses);

        document.getElementById('stat-pop').textContent = 'Population: 12,847 minds';
        toast('âŸ³ New scene â€” reset to defaults');
    }

    // â”€â”€â”€ BUTTON WIRING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('new-btn').addEventListener('click', resetScene);
    document.getElementById('save-btn').addEventListener('click', saveBiodomeState);
    document.getElementById('open-btn').addEventListener('click', () => document.getElementById('file-input').click());
    document.getElementById('file-input').addEventListener('change', e => {
        if (e.target.files[0]) loadBiodomeState(e.target.files[0]);
        e.target.value = '';
    });

    toast('ðŸ§  Neural Biodome v2 â€” click objects to inspect');
    </script>
</body>
</html>
