<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ü´Ä Organ Affliction Arena</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;800;900&family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#06070d;--bg2:#0d1020;--panel:rgba(14,18,34,.88);--panel2:rgba(20,25,46,.88);
  --line:rgba(255,255,255,.10);--text:#eef3ff;--muted:#9fb0cf;--dim:#5d7094;
  --mint:#33ffbb;--cyan:#44ddff;--violet:#c69dff;--rose:#ff6f91;--gold:#ffd35e;--amber:#ff9d5c;
  --good:#66f0a8;--bad:#ff6b7a;--heal:#6ce0ff;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:radial-gradient(circle at top, #152040 0%, #090c17 42%, #05060b 100%);color:var(--text);font-family:Inter,sans-serif;overflow:hidden}
body{display:grid;grid-template-rows:auto 1fr auto}
button{font:inherit}
#app{display:grid;grid-template-columns:280px 1fr 300px;gap:14px;padding:14px;height:100%}
.panel{background:var(--panel);border:1px solid var(--line);border-radius:18px;backdrop-filter:blur(12px);box-shadow:0 18px 50px rgba(0,0,0,.35)}
.leftPanel,.rightPanel{padding:14px;overflow:auto}
.centerPanel{display:grid;grid-template-rows:auto auto 1fr auto;gap:12px;padding:14px;overflow:hidden}
.titleBar{padding:12px 16px;border-bottom:1px solid var(--line);display:flex;align-items:center;justify-content:space-between;background:rgba(255,255,255,.03)}
.titleMain{font-family:Orbitron,sans-serif;font-size:1.12rem;font-weight:900;letter-spacing:.12em;background:linear-gradient(135deg,var(--rose),var(--gold),var(--cyan));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.subtitle{font-family:'JetBrains Mono',monospace;font-size:.73rem;color:var(--muted);letter-spacing:.1em}
.statRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
.badge{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.05);border:1px solid var(--line);font-size:.74rem;color:var(--muted)}
.badge strong{color:var(--text)}
.turnStrip{display:grid;grid-template-columns:1fr auto 1fr;align-items:center;gap:10px;padding:12px 14px;background:var(--panel2);border-radius:16px;border:1px solid var(--line)}
.sideInfo{display:flex;align-items:center;gap:10px}
.sideOrb{width:14px;height:14px;border-radius:50%}
.playerOrb{background:var(--mint);box-shadow:0 0 14px var(--mint)}
.aiOrb{background:var(--rose);box-shadow:0 0 14px var(--rose)}
.turnBadge{padding:8px 14px;border-radius:999px;border:1px solid rgba(255,211,94,.35);background:rgba(255,211,94,.08);font-family:Orbitron,sans-serif;font-size:.8rem;letter-spacing:.12em;color:var(--gold)}
.boardSection{display:grid;grid-template-rows:auto auto auto auto;gap:10px;overflow:auto;padding-right:2px}
.zoneTitle{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:.78rem;font-weight:700;letter-spacing:.08em;text-transform:uppercase}
.organGrid{display:grid;grid-template-columns:repeat(5,minmax(120px,1fr));gap:10px}
.organCard{position:relative;padding:10px;border-radius:16px;border:1px solid var(--line);background:linear-gradient(180deg,rgba(255,255,255,.08),rgba(255,255,255,.03));min-height:116px;cursor:pointer;transition:.2s transform,.2s border-color,.2s box-shadow}
.organCard:hover{transform:translateY(-2px)}
.organCard.selected{border-color:rgba(68,221,255,.7);box-shadow:0 0 0 1px rgba(68,221,255,.35),0 12px 24px rgba(0,0,0,.24)}
.organCard.destroyed{opacity:.22;filter:grayscale(.9);pointer-events:none}
.organHeader{display:flex;justify-content:space-between;gap:8px;align-items:flex-start}
.organName{font-weight:800;font-size:.86rem;line-height:1.1}
.organType{font-size:.66rem;color:var(--dim);text-transform:uppercase;letter-spacing:.08em}
.organHP{font-family:'JetBrains Mono',monospace;font-size:.76rem;color:var(--heal)}
.organStatus{display:flex;flex-wrap:wrap;gap:5px;margin-top:8px}
.tag{padding:3px 6px;border-radius:999px;font-size:.64rem;border:1px solid var(--line);background:rgba(255,255,255,.05);color:var(--muted)}
.tag.poison{color:var(--amber);border-color:rgba(255,157,92,.35)}
.tag.resist{color:var(--mint);border-color:rgba(51,255,187,.35)}
.organBody{margin-top:10px;font-size:.72rem;color:var(--muted);line-height:1.35}
.handRow{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.modeBanner{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:12px 14px;border:1px solid var(--line);border-radius:16px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03))}
.modeText{display:flex;flex-direction:column;gap:4px}
.modeTitle{font-family:Orbitron,sans-serif;font-size:.82rem;letter-spacing:.12em;color:var(--gold)}
.modeSub{font-size:.74rem;color:var(--muted);line-height:1.4}
.livePill{padding:6px 10px;border-radius:999px;font-family:JetBrains Mono,monospace;font-size:.7rem;border:1px solid rgba(51,255,187,.35);background:rgba(51,255,187,.08);color:var(--mint)}
.spotlight{display:grid;grid-template-columns:1fr 1fr;gap:12px;padding:12px 14px;border:1px solid var(--line);border-radius:16px;background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02))}
.spotCard{padding:12px;border-radius:16px;border:1px solid var(--line);background:rgba(255,255,255,.04);min-height:120px;box-shadow:0 10px 24px rgba(0,0,0,.18)}
.spotLabel{font-family:Orbitron,sans-serif;font-size:.68rem;letter-spacing:.12em;color:var(--cyan);margin-bottom:8px}
.spotName{font-size:1rem;font-weight:800;margin-bottom:6px}
.spotText{font-size:.78rem;color:var(--muted);line-height:1.45}
.spotMeta{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
.spotChip{padding:5px 9px;border-radius:999px;font-size:.68rem;border:1px solid var(--line);background:rgba(255,255,255,.05);color:var(--text2)}
.flashAction{animation:flashAction 0.7s ease-out}
@keyframes flashAction{0%{transform:scale(1);box-shadow:0 0 0 rgba(255,211,94,0)}25%{transform:scale(1.02);box-shadow:0 0 0 2px rgba(255,211,94,.2),0 0 30px rgba(255,211,94,.18)}100%{transform:scale(1);box-shadow:0 0 0 rgba(255,211,94,0)}}
.handPanel{padding:10px;border-radius:16px;background:var(--panel2);border:1px solid var(--line)}
.handPanel h3{margin:0 0 8px;font-size:.82rem;letter-spacing:.08em;text-transform:uppercase;color:var(--muted)}
.handCards{display:flex;gap:10px;flex-wrap:wrap;min-height:168px}
.handCard{width:172px;padding:12px;border-radius:16px;border:1px solid var(--line);background:linear-gradient(180deg,rgba(255,255,255,.08),rgba(255,255,255,.04));cursor:pointer;transition:.18s transform,.18s border-color,.18s box-shadow;position:relative;box-shadow:0 14px 28px rgba(0,0,0,.18)}
.handCard:hover{transform:translateY(-3px)}
.handCard.selected{border-color:rgba(255,211,94,.7);box-shadow:0 0 0 1px rgba(255,211,94,.3),0 10px 24px rgba(0,0,0,.25)}
.handCard.ai{cursor:default;opacity:.92}
.handType{font-family:Orbitron,sans-serif;font-size:.66rem;letter-spacing:.11em;text-transform:uppercase;margin-bottom:8px}
.handName{font-weight:900;font-size:1rem;line-height:1.1;margin-bottom:8px}
.handText{font-size:.8rem;color:var(--muted);line-height:1.45;min-height:64px}
.handMeta{display:flex;justify-content:space-between;align-items:center;margin-top:8px;font-size:.66rem;color:var(--dim)}
.type-wild{color:var(--gold)} .type-necrosis{color:var(--rose)} .type-metastasis{color:#ff8da8} .type-mayhem{color:var(--amber)}
.type-instant{color:var(--cyan)} .type-resist{color:var(--mint)} .type-cure{color:var(--heal)} .type-poison{color:#ffb15a} .type-boost{color:var(--violet)}
.actionBar{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:12px 14px;border:1px solid var(--line);border-radius:16px;background:var(--panel2)}
.actionLeft{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.btn{padding:10px 14px;border-radius:12px;border:1px solid var(--line);background:rgba(255,255,255,.05);color:var(--text);font-weight:800;cursor:pointer;transition:.18s transform,.18s background,.18s border-color}
.btn:hover{transform:translateY(-1px)}
.btn.primary{background:rgba(51,255,187,.12);border-color:rgba(51,255,187,.45);color:var(--mint)}
.btn.attack{background:rgba(255,111,145,.12);border-color:rgba(255,111,145,.45);color:var(--rose)}
.btn.support{background:rgba(68,221,255,.12);border-color:rgba(68,221,255,.45);color:var(--cyan)}
.btn.end{background:rgba(255,211,94,.1);border-color:rgba(255,211,94,.38);color:var(--gold)}
.btn:disabled{opacity:.34;cursor:not-allowed;transform:none}
.log{height:190px;overflow:auto;padding:10px;border-radius:14px;background:rgba(255,255,255,.03);border:1px solid var(--line)}
.logLine{padding:7px 8px;border-bottom:1px solid rgba(255,255,255,.05);font-size:.75rem;line-height:1.45;color:var(--muted)}
.logLine strong{color:var(--text)}
.tips h3,.legend h3{margin:0 0 10px;font-family:Orbitron,sans-serif;font-size:.8rem;letter-spacing:.09em;color:var(--gold)}
.tipList,.legendList{display:grid;gap:8px}
.tip,.legendItem{padding:10px;border-radius:12px;background:rgba(255,255,255,.04);border:1px solid var(--line);font-size:.74rem;line-height:1.45;color:var(--muted)}
.legendType{font-weight:800}
.ruleBlock{margin-top:14px;padding:12px;border-radius:14px;background:rgba(255,255,255,.04);border:1px solid var(--line)}
.ruleBlock h4{margin:0 0 8px;color:var(--cyan);font-size:.8rem;letter-spacing:.08em;text-transform:uppercase}
.ruleBlock p{margin:0;color:var(--muted);font-size:.74rem;line-height:1.5}
.overlay{position:fixed;inset:0;background:rgba(3,4,8,.72);display:none;align-items:center;justify-content:center;z-index:50;backdrop-filter:blur(8px)}
.overlay.active{display:flex}
.modal{width:min(580px,92vw);padding:24px;border-radius:24px;background:linear-gradient(180deg,rgba(24,29,52,.98),rgba(10,12,22,.98));border:1px solid var(--line);box-shadow:0 30px 80px rgba(0,0,0,.45);text-align:center}
.modal h2{margin:0 0 8px;font-family:Orbitron,sans-serif;letter-spacing:.12em}
.modal p{margin:0 0 18px;color:var(--muted);line-height:1.6}
.footerBar{padding:10px 16px;border-top:1px solid var(--line);display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,.03)}
.small{font-size:.72rem;color:var(--muted)}
@media (max-width:1300px){#app{grid-template-columns:250px 1fr 260px}.organGrid{grid-template-columns:repeat(5,minmax(108px,1fr))}}
@media (max-width:1100px){#app{grid-template-columns:1fr;grid-template-rows:auto auto auto;overflow:auto;height:auto}body{overflow:auto}.organGrid{grid-template-columns:repeat(2,minmax(140px,1fr))}.handRow{grid-template-columns:1fr}.leftPanel,.rightPanel,.centerPanel{overflow:visible}}
</style>
</head>
<body>
  <div class="titleBar">
    <div>
      <div class="titleMain">ORGAN AFFLICTION ARENA</div>
      <div class="subtitle">20 ORGAN CARDS ¬∑ 60 AFFLICTION CARDS ¬∑ FACE-UP ORGANS ¬∑ VISIBLE 5-CARD HANDS</div>
    </div>
    <div class="statRow">
      <div class="badge"><strong>Goal</strong> remove all 10 enemy organs</div>
      <div class="badge"><strong>Setup</strong> 10 organs each ¬∑ 5 afflictions each</div>
      <div class="badge"><strong>Turns</strong> human ‚áÑ AI</div>
    </div>
  </div>

  <div id="app">
    <aside class="panel leftPanel">
      <div class="tips">
        <h3>üß† Strategy Tips</h3>
        <div class="tipList">
          <div class="tip"><strong>Open with poison + metastasis.</strong> Poison softens a target over time, then metastasis spreads that pressure onto adjacent organs.</div>
          <div class="tip"><strong>Use resist before your key organs get focused.</strong> Heart, Brain, and Lungs tend to swing the match because they carry higher HP or stronger protection value.</div>
          <div class="tip"><strong>Boost is best on necrosis or mayhem.</strong> Multiplying a large hit is stronger than spending boost on a weak poke.</div>
          <div class="tip"><strong>Cure intelligently.</strong> Cleanse poisoned or nearly-fallen organs first; overhealing weak damage is usually wasted tempo.</div>
          <div class="tip"><strong>Wild cards are flexible finishers.</strong> Save them until the board state tells you whether you need damage, defense, or recovery.</div>
          <div class="tip"><strong>AI hand is visible on purpose.</strong> This version plays like a readable tactics game, not hidden-information poker.</div>
        </div>
      </div>
      <div class="ruleBlock">
        <h4>How Turns Work</h4>
        <p>On your turn, select one affliction card from your 5-card hand, then select a valid target organ. After resolution, draw back to 5 if cards remain. Ongoing poison ticks at the start of each side‚Äôs turn. The first side to destroy all 10 opposing organs wins.</p>
      </div>
      <div class="ruleBlock">
        <h4>Card Types</h4>
        <p><strong>Wild</strong>, <strong>Necrosis</strong>, <strong>Metastasis</strong>, <strong>Mayhem</strong>, <strong>Instant</strong>, <strong>Resist</strong>, <strong>Cure</strong>, <strong>Poison</strong>, and <strong>Boost</strong> are all included in the 60-card affliction deck.</p>
      </div>
    </aside>

    <main class="panel centerPanel">
      <div class="modeBanner">
        <div class="modeText">
          <div class="modeTitle">üéÆ PLAYER MODE CONTROL</div>
          <div class="modeSub">Switch between self-play spectator mode and manual play vs AI. In manual mode, you choose your card, choose a target organ, and press play.</div>
        </div>
              </div>

      <div class="turnStrip">
        <div class="sideInfo">
          <div class="sideOrb playerOrb"></div>
          <div>
            <div style="font-weight:800">PLAYER 1</div>
            <div class="small">Organs standing: <span id="playerAliveCount">10</span>/10</div>
          </div>
        </div>
        <div class="turnBadge" id="turnBadge">PLAYER TURN</div>
        <div class="sideInfo" style="justify-self:end;text-align:right">
          <div>
            <div style="font-weight:800">AI OPPONENT</div>
            <div class="small">Organs standing: <span id="aiAliveCount">10</span>/10</div>
          </div>
          <div class="sideOrb aiOrb"></div>
        </div>
      </div>

      <div class="boardSection">
        <div class="spotlight">
          <div class="spotCard" id="playerSpotlight">
            <div class="spotLabel">PLAYER ACTION</div>
            <div class="spotName">Waiting...</div>
            <div class="spotText">The next player-side action will appear here with clear card and target detail.</div>
            <div class="spotMeta"></div>
          </div>
          <div class="spotCard" id="aiSpotlight">
            <div class="spotLabel">AI ACTION</div>
            <div class="spotName">Waiting...</div>
            <div class="spotText">The next AI-side action will appear here with clear card and target detail.</div>
            <div class="spotMeta"></div>
          </div>
        </div>
        <div class="zoneTitle"><span>AI Organs ‚Äî face up</span><span id="aiDeckCount">Deck 25</span></div>
        <div class="organGrid" id="aiOrgans"></div>

        <div class="handRow">
          <div class="handPanel">
            <h3>üî¥ AI Hand ‚Äî visible</h3>
            <div class="handCards" id="aiHand"></div>
          </div>
          <div class="handPanel">
            <h3>üü¢ Your Hand</h3>
            <div class="handCards" id="playerHand"></div>
          </div>
        </div>

        <div class="zoneTitle"><span>Your Organs ‚Äî face up</span><span id="playerDeckCount">Deck 25</span></div>
        <div class="organGrid" id="playerOrgans"></div>
      </div>

      <div class="actionBar">
        <div class="actionLeft">
          <button class="btn primary" id="playerModeBtn">üïπ Player: Auon class="btn end" id="restartBtn">‚Üª New Match</button>
          <span class="small" id="selectionHint">Auto mode watches both sides. Manual mode lets you choose a card and a valid target, then press Play Selected.</span>
        </div>
        <div class="small"><strong>Focus:</strong> <span id="selectedStatus">player auto mode active</span></div>
      </div>
    </main>

    <aside class="panel rightPanel">
      <div class="legend">
        <h3>üß¨ Affliction Legend</h3>
        <div class="legendList" id="legendList"></div>
      </div>
      <div class="ruleBlock" style="margin-top:14px">
        <h4>Battle Log</h4>
        <div cladiv class="small">Visible hands + face-up organs make this a readable strategy duel.</div>
    <div class="small">Targeting: damage ‚Üí enemy organs ¬∑ cure/resist/boost ‚Üí your own organs.</div>
  </div>

  <div class="overlay" id="endOverlay">
    <div class="modal">
      <h2 id="endTitle">VICTORY</h2>
      <p id="endText">You removed all AI organs.</p>
      <button class="btn primary" id="overlayRestartBtn">Start New Match</button>
    </div>
  </div>

<script>
const ORGAN_POOL = [
  { name:'Heart', hp:4, lore:'Central pump. High-value survival anchor.' },
  { name:'Brain', hp:4, lore:'Command center. Often worth protecting early.' },
  { name:'Lungs', hp:3, lore:'Respiration pair merged as one organ card.' },
  { name:'Liver', hp:3, lore:'Detox powerhouse with solid staying power.' },
  { name:'Kidneys', hp:3, lore:'Filter system with steady midline durability.' },
  { name:'Pancreas', hp:2, lore:'Fragile metabolic support organ.' },
  { name:'Stomach', hp:2, lore:'Digestion core. Often a good poison target.' },
  { name:'Spleen', hp:2, lore:'Immune support but vulnerable to burst.' },
  { name:'Intestines', hp:3, lore:'Long-form endurance organ.' },
  { name:'Spinal Cord', hp:2, lore:'Critical channel but lightly armored.' }
];

const TYPE_META = {
  Wild:{color:'var(--gold)',desc:'Flexible cards that adapt to the board.'},
  Necrosis:{color:'var(--rose)',desc:'Direct tissue destruction and efficient finishing damage.'},
  Metastasis:{color:'#ff8da8',desc:'Spreads pressure to adjacent organs.'},
  Mayhem:{color:'var(--amber)',desc:'Chaotic heavy hits and multi-target disruption.'},
  Instant:{color:'var(--cyan)',desc:'Immediate tempo swings, card flow, or surprise effects.'},
  Resist:{color:'var(--mint)',desc:'Prevents or reduces incoming harm to your own organs.'},
  Cure:{color:'var(--heal)',desc:'Heals and cleanses poison from friendly organs.'},
  Poison:{color:'#ffb15a',desc:'Applies ongoing damage over future turns.'},
  Boost:{color:'var(--violet)',desc:'Empowers your next offensive or defensive play.'}
};

const AFFLICTION_LIBRARY = [
  {name:'Wild Surge', type:'Wild', text:'Deal 1 damage or heal 1 HP.', effect:'wildSmall'},
  {name:'Wild Rewrite', type:'Wild', text:'Choose damage 2 or grant Resist 1.', effect:'wildSplit'},
  {name:'Wild Exchange', type:'Wild', text:'Draw 1, then either deal 1 or heal 1.', effect:'wildDraw'},
  {name:'Wild Pivot', type:'Wild', text:'If target is poisoned, deal +1 damage.', effect:'wildPivot'},
  {name:'Wild Bloom', type:'Wild', text:'Heal 2 or remove poison from a friendly organ.', effect:'wildCleanse'},
  {name:'Wild Collapse', type:'Wild', text:'Deal 2 damage. If boosted, deal 3 instead.', effect:'wildCollapse'},

  {name:'Necrosis Bite', type:'Necrosis', text:'Deal 2 damage to target organ.', effect:'damage2'},
  {name:'Necrosis Wave', type:'Necrosis', text:'Deal 3 damage to target organ.', effect:'damage3'},
  {name:'Necrosis Lance', type:'Necrosis', text:'Deal 2 damage. Ignores Resist.', effect:'pierce2'},
  {name:'Necrosis Spiral', type:'Necrosis', text:'Deal 2 damage. If target poisoned, +1 more.', effect:'necrosisSpiral'},
  {name:'Necrosis Fracture', type:'Necrosis', text:'Deal 1 damage to target and its adjacent organ.', effect:'split1'},
  {name:'Necrosis Finality', type:'Necrosis', text:'Deal 4 damage to an organ at 2 HP or less.', effect:'execute4'},
  {name:'Necrosis Pulse', type:'Necrosis', text:'Deal 2 damage and draw 1.', effect:'damage2draw1'},
  {name:'Necrosis Bloom', type:'Necrosis', text:'Deal 3 damage, then self-discard without draw bonus.', effect:'damage3nodraw'},
  {name:'Necrosis Drill', type:'Necrosis', text:'Deal 2 damage. Gain +1 if boosted.', effect:'damage2boosted'},
  {name:'Necrosis Ruin', type:'Necrosis', text:'Deal 3 damage to the weakest enemy organ.', effect:'ruinWeakest'},
  {name:'Necrosis Echo', type:'Necrosis', text:'Deal 1 damage now and 1 at next enemy turn.', effect:'echoStrike'},
  {name:'Necrosis Rift', type:'Necrosis', text:'Deal 2 damage to any organ.', effect:'damage2'},

  {name:'Metastasis Seed', type:'Metastasis', text:'Deal 1 damage to target and an adjacent organ.', effect:'spread1'},
  {name:'Metastasis Thread', type:'Metastasis', text:'Poison target and one adjacent organ.', effect:'spreadPoison'},
  {name:'Metastasis Bloom', type:'Metastasis', text:'Deal 2 damage. Adjacent organs take 1.', effect:'blastSpread'},
  {name:'Metastasis Crawl', type:'Metastasis', text:'If target is poisoned, adjacent organ takes 2.', effect:'crawl'},
  {name:'Metastasis Nest', type:'Metastasis', text:'Apply Poison 2 to target.', effect:'poison2'},
  {name:'Metastasis Rain', type:'Metastasis', text:'Deal 1 damage to three random enemy organs.', effect:'rain'},
  {name:'Metastasis Weave', type:'Metastasis', text:'Deal 1 damage and copy poison from adjacent organ.', effect:'weave'},
  {name:'Metastasis Choir', type:'Metastasis', text:'All poisoned enemy organs take 1 damage.', effect:'poisonSweep'},

  {name:'Mayhem Crash', type:'Mayhem', text:'Deal 3 damage to target and 1 to yourself.', effect:'mayhemCrash'},
  {name:'Mayhem Storm', type:'Mayhem', text:'Deal 2 damage to two enemy organs.', effect:'twoTargets2'},
  {name:'Mayhem Roulette', type:'Mayhem', text:'Deal 4 damage to a random enemy organ.', effect:'roulette4'},
  {name:'Mayhem Burst', type:'Mayhem', text:'Deal 5 damage to target. Skip your next draw.', effect:'burst5'},
  {name:'Mayhem Cascade', type:'Mayhem', text:'Destroy all Resist on enemy organs.', effect:'clearResistEnemy'},
  {name:'Mayhem Quake', type:'Mayhem', text:'All enemy organs take 1 damage.', effect:'quake1'},

  {name:'Instant Patch', type:'Instant', text:'Draw 2 cards.', effect:'draw2'},
  {name:'Instant Scan', type:'Instant', text:'Reveal strongest AI organ and draw 1.', effect:'scanDraw'},
  {name:'Instant Shift', type:'Instant', text:'Remove poison from one friendly organ and draw 1.', effect:'cleanseDraw'},
  {name:'Instant Countercare', type:'Instant', text:'Grant Resist 1 to two friendly organs.', effect:'resistTwo'},
  {name:'Instant Tempo', type:'Instant', text:'Play this and draw 1 immediately.', effect:'tempoDraw'},
  {name:'Instant Refill', type:'Instant', text:'Heal 1 to all friendly organs.', effect:'healAll1'},

  {name:'Resist Shell', type:'Resist', text:'Grant Resist 2 to target friendly organ.', effect:'resist2'},
  {name:'Resist Mesh', type:'Resist', text:'Grant Resist 1 to two adjacent friendly organs.', effect:'resistAdjacent'},
  {name:'Resist Brace', type:'Resist', text:'Grant Resist 3 to target at 2 HP or less.', effect:'brace3'},
  {name:'Resist Halo', type:'Resist', text:'Grant Resist 1 and remove poison.', effect:'resistCleanse'},
  {name:'Resist Protocol', type:'Resist', text:'Grant Resist 2 and draw 1.', effect:'resist2draw'},
  {name:'Resist Aura', type:'Resist', text:'All friendly organs gain Resist 1.', effect:'resistAll1'},

  {name:'Cure Drip', type:'Cure', text:'Heal 2 HP to target friendly organ.', effect:'heal2'},
  {name:'Cure Flush', type:'Cure', text:'Heal 1 and remove poison.', effect:'heal1cleanse'},
  {name:'Cure Reservoir', type:'Cure', text:'Heal 3 HP to target friendly organ.', effect:'heal3'},
  {name:'Cure Arc', type:'Cure', text:'Heal 1 HP to three friendly organs.', effect:'healThree1'},
  {name:'Cure Reset', type:'Cure', text:'Fully cleanse poison from all friendly organs.', effect:'cleanseAll'},
  {name:'Cure Recovery', type:'Cure', text:'Heal 2, then grant Resist 1.', effect:'heal2resist1'},

  {name:'Poison Drip', type:'Poison', text:'Apply Poison 1 to target organ.', effect:'poison1'},
  {name:'Poison Flood', type:'Poison', text:'Apply Poison 2 to target organ.', effect:'poison2'},
  {name:'Poison Needle', type:'Poison', text:'Deal 1 damage and apply Poison 1.', effect:'needle'},
  {name:'Poison Cloud', type:'Poison', text:'Apply Poison 1 to all enemy organs.', effect:'poisonAll1'},
  {name:'Poison Leach', type:'Poison', text:'Apply Poison 1 and heal yourself 1.', effect:'poisonLeach'},
  {name:'Poison Vessel', type:'Poison', text:'Apply Poison 3 to an organ at full HP.', effect:'poison3full'},

  {name:'Boost Charge', type:'Boost', text:'Next offensive card you play gets +1 damage.', effect:'boost1'},
  {name:'Boost Amp', type:'Boost', text:'Next offensive card gets +2 damage.', effect:'boost2'},
  {name:'Boost Guard', type:'Boost', text:'Next Resist or Cure card gets +1 value.', effect:'boostGuard'},
  {name:'Boost Surge', type:'Boost', text:'Draw 1 and gain +1 offensive boost.', effect:'boost1draw1'},
  {name:'Boost Mirror', type:'Boost', text:'Your next card copies to an adjacent valid organ if possible.', effect:'boostMirror'},
  {name:'Boost Finale', type:'Boost', text:'Your next offensive card deals +3, then discard your boost.', effect:'boost3'}
];

function clone(obj){ return JSON.parse(JSON.stringify(obj)); }
function shuffle(arr){ const a=[...arr]; for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

function buildDeck(){
  return shuffle(AFFLICTION_LIBRARY.map((card, idx)=>({ ...clone(card), uid:`card-${idx}-${Math.random().toString(36).slice(2,8)}` })));
}

function createOrgans(owner){
  return ORGAN_POOL.map((org, idx)=>(
    { id:`${owner}-${idx}`, slot:idx, owner, name:org.name, maxHp:org.hp, hp:org.hp, resist:0, poison:0, alive:true, lore:org.lore }
  ));
}

const state = {
  playerMode:'auto',
  autoplay:true,
  autoplayTimer:null,
  lastAction:null,
  turn:'player',
  selectedCardId:null,
  selectedTargetId:null,
  player:{ organs:[], hand:[], deck:[], boost:{attack:0,support:0,mirror:false,skipDraw:false} },
  ai:{ organs:[], hand:[], deck:[], boost:{attack:0,support:0,mirror:false,skipDraw:false} },
  gameOver:false
};

const els = {
  aiOrgans:document.getElementById('aiOrgans'),
  playerOrgans:document.getElementById('playerOrgans'),
  aiHand'),
  playerHand:document.getElementById('playerHand'),
  battleLog:document.getElementById('battleLog'),
  turnBadge:document.getElementById('turnBadge'),
  selectedStatus:document.getElementById('selectedStatus'),
  selectionHint:document.getElementById('selectionHint'),
  playerModeBtn:document.getElementById('playerModeBtn'),
  autoplayToggleBtn:document.getElementById('autoplayToggleBtn'),
  playBtn:document.getElementById('playBtn'),
  clearBtn:document.getElementById('clearBtn'),
  stepBtn:document.getElementById('stepBtn'),
  restartBtn:document.getElementById('restartBtn'),
  aiAliveCount:document.getElementById('aiAliveCount'),
  playerAliveCount:document.getElementById('playerAliveCount'),
  aiDeckCount:document.getElementById('aiDeckCount'),
  playerDeckCount:document.getElementById(ndTitle'),
  endText:document.getElementById('endText'),
  overlayRestartBtn:document.getElementById('overlayRestartBtn'),
  legendList:document.getElementById('legendList')
};

function initLegend(){
  els.legendList.innerHTML = Object.entries(TYPE_META).map(([type,meta])=>`<div class="legendItem"><div class="legendType type-${type.toLowerCase()}">${type}</div><div>${meta.desc}</div></div>`).join('');
}

function newGame(){
  clearTimeout(state.autoplayTimer);
  state.turn='player'; state.selectedCardId=null; state.selectedTargetId=null; state.gameOver=false;
  state.player.organs=createOrgans('player');
  state.ai.organs=createOrgans('ai');
  state.player.deck=buildDeck();
  state.ai.deck=buildDeck();
  state.player.hand=[]; state.ai.hand=[];
  state.player.boost={attack:0,support:0,mirror:false,skipDraw:false};
  state.ai.boost={attack:0,support:0,mirror:false,skipDraw:false};
  for(let i=0;i<5;i++){ drawCard('player'); drawCard('ai'); }
  els.endOverlay.classList.remove('active');
  state.lastAction='new match';
  setSpotlight('UTO']);
  log('ü´Ä <strong>New match.</strong> Ten organs per side deployed face up. Five affliction cards dealt to each hand.');
  render();
  scheduleAutoplay();
}

function drawCard(side){
  const actor=state[side];
  if(actor.deck.length && actor.hand.length<5) actor.hand.push(actor.deck.shift());
}

function getOrgan(side,id){ return state[side].organs.find(o=>o.id===id); }
function getCard(side,id){ return state[side].hand.find(c=>c.uid===id); }
function enemySide(side){ return side==='player' ? 'ai' : 'player'; }

function organClass(organ){
  return `organCard ${organ.alive?'':'destroyed'} ${state.selectedTargetId===organ.id?'selected':''}`;
}

function renderOrgans(side, mount){
  mount.innerHTML='';
  state[side].organs.forEach(org=>{
    const card=document.createElement('button');
    card.className=organClass(org);
    card.innerHTML=`
      <div class="organHeader">
        <div>
          <div class=         <div class="organType">${side==='player'?'Player Organ':'AI Organ'}</div>
        </div>
        <div class="organHP">HP ${Math.max(0,org.hp)}/${org.maxHp}</div>
      </div>
      <div class="organStatus">
        ${org.resist>0?`<span class="tag resist">Resist ${org.resist}</span>`:''}
        ${org.poison>0?`<span class="tag poison">Poison ${org.poison}</span>`:''}
        ${!org.alive?`<span class="tag">Destroyed</span>`:''}
      </div>
      <div class="organBody">${org.lore}</div>
    `;
    card.disabled=!org.alive || state.gameOver;
    card.addEventListener('click',()=>handleOrganSelect(org.id));
    mount.appendChild(card);
  });
}

function renderHand(side, mount){
  mount.innerHTML='';
  state[side].hand.forEach(card=>{
    const div=document.createElement('div');
    const selected = state.selectedCardId===card.uid;
    div.className=`handCard ${side==='ai'?'ai':''} ${selected?'selected':''}`;
    div.innerHTML=`
      <div class="handType type-${card.type.toLowerCase()}">${card.type}</div>
      <div class="handName">${card.name}</div>
      <div class="handText">${card.text}</div>
      <div class="handMeta"><span>${card.effect}</span><span>${side==='player'?'Click to select':'AI ready'}</span></div>
    `;
    if(side==='player') div.addEventListener('click',()=>handleCardSelect(card.uid));
    mount.appendChild(div);
  });
  if(!state[side].hand.length){
    const empty=document.createElement('div');
    empty.className='small';
    empty.textContent='No cards left.';
    mount.appendChild(empty);
  }
}

function setSpotlight(side, title, text, chips=[]){
  const el = document.getElementById(side === 'player' ? 'playerSpotlight' : 'aiSpotlight');
  if(!el) return;
  el.classList.remove('flashAction');
  void el.offsetWidth;
  el.classList.add('flashAction');
  el.querySelector('.spotName').textContent = title;
  el.querySelector('.spotText').textContent = text;
  el.querySelector('.spotMeta').innerHTML = chips.map(ch => `<span class="spotChip">${ch}</span>`).join('');
}

function scheduleAutoplay(){
  if(!state.autoplay || state.gameOver) return;
  clearTimeout(state.autoplayTimer);
  if(state.turn === 'player' && state.playerMode !== 'auto') return;
  state.autoplayTimer = setTimeout(()=>{
    if(state.turn === 'player') autoPlayerTurn();
    else aiTurn();
  }, 950);
}

function setTurn(nextTurn){
  state.turn = nextTurn;
  state.selectedCardId = null;
  state.selectedTargetId = null;
  if(nextTurn === 'player' && state.playerMode === 'manual'){
    processTurnStart('player');
    if(checkWin()) return;
  }
  render();
  scheduleAutoplay();
}

function render(){
  renderOrgans('ai', els.aiOrgans)e.ai.organs.filter(o=>o.alive).length;
  els.playerAliveCount.textContent = state.player.organs.filter(o=>o.alive).length;
  els.aiDeckCount.textContent = `Deck ${state.ai.deck.length}`;
  els.playerDeckCount.textContent = `Deck ${state.player.deck.length}`;
  const selectedCard = state.selectedCardId ? getCard('player', state.selectedCardId) : null;
  const target = state.selectedTargetId ? [...state.playerate.selectedTargetId) : null;
  els.selectedStatus.textContent = selectedCard ? `${selectedCard.name}${target?` ‚Üí ${target.name}`:''}` : 'none';
  els.selectionHint.textContent = selectedCard ? validTargetHint(selectedCard) : 'Select a card, then choose a valid target organ.';
  els.autoplayToggleBtn.tcument.getElementById('autoplayBadge').textContent = state.autoplay ? 'AUTO-PLAY: ON' : 'AUTO-PLAY: PAUSED';
  els.stepBtn.disabled = state.gameOver;
  els.selectedStatus.textContent = state.lastAction || 'self-play active';
}

function validTargetHint(card){
  if(['Necrosis','Metastasis','Mayhem','Poison','Wild'].includes(card.type)) return 'Choose an AI organ unless the Wild card says heal.';
  return 'Choose one of yourate.selectedCardId){
    const card=getCard('player', state.selectedCardId);
    if(card && isTargetCompatible(card, organId)){
      state.selectedTargetId=organId;
    } else {
      log('‚ö†Ô∏è <strong>Invalid target.</strong> That card cannot target this organ.');
    }
  } else if(state.turn==='player' && state.playerMode==='manual') {
    state.selectedTargetId = state.selectedTargetId===organId ? null : organId;
  }
  render();
}

function isTargetCompatible(card, organId){
  if(!card || !organId) return false;
  const organ=[...state.player.organs,...state.ai.organs].find(o=>o.id===organId);
  if(!organ || !organ.alive) return false;
  const offensive=['Necrosis','Metastasis','Mayhem','Poison'];
  const supportive=['Resist','Cure','Boost','Instant'];
  if(offensive.includes(card.type)) return organ.owner==='ai';
  if(supportive.includes(card.type)) return organ.owner==='player';
  if(card.type==='Wild') return true;
  return false;
}

function isValidTargetForSelected(){
  const card=getCard('player', state.selectedCardId);
  return !!(card && isTargetCompatible(card, state.selectedTargetId));
}

function applyDamage(side, organ, amount, opts={ignoreResist:false}){
  if(!organ.alive || amount<=0) return 0;
  let dealt=amount;
  if(!opts.ignoreResist && organ.resist>0){
    const absorbed=Math.min(organ.resist, dealt);
    organ.resist -= absorbed;
    dealt -= absorbed;
  }
  organ.hp -= dealt;
  if(organ.hp<=0){ organ.hp=0; organ.alive=false; organ.poison=0; organ.resist=0; }
  return dealt;
}

function healOrgan(organ, amount){ if(!organ.alive || amount<=0) return 0; const before=organ.hp; organ.hp=Math.min(organ.maxHp, organ.hp+amount); return organ.hp-before; }
function adjacentOrgans(side, slot){ return state[side].organs.filter(o=>o.alive && Math.abs(o.slot-slot)===1); }

function processTurnStart(side){
  state[side].organs.forEach(org=>{
    if(org.alive && org.poison>0){
      const dmg = applyDamage(side, org, org.poison, {ignoreResist:false});
      log(`‚ò£Ô∏è <strong>${side==='player'?'Your':'AI'} ${org.name}</strong> suffers ${dmg} poison damage.`);
    }
  });
  cleanupDestroyed();
}

function cleanupDestroyed(){
  ['player','ai'].forEach(side=>state[side].organs.forEach(org=>uid){ const hand=state[side].hand; const idx=hand.findIndex(c=>c.uid===uid); if(idx>=0) hand.splice(idx,1); }

function getWeakestAlive(side){ return state[side].organs.filter(o=>o.alive).sort((a,b)=>a.hp-b.hp)[0] || null; }
function getStrongestAlive(side){ return state[side].organs.filter(o=>o.alive).sort((a,b)=>b.hp-a.hp)[0] || null; }
function getPoisonedAlive(side){ return  && o.poison>0).sort((a,b)=>b.poison-a.poison)[0] || null; }
function randomAlive(side){ const arr=state[side].organs.filter(o=>o.alive); return arr[Math.floor(Math.random()*arr.length)] || null; }

function offensiveBonus(side){ const bonus=state[side].boost.attack||0; state[side].boost.attack=0; return bonus; }
function supportBonus(side){ const bonus=state[side].boost.support||0; state[side].boost.support=0; return bonus; }

function mirrorIfNeeded(side, card, primaryTargetSide, primboost.mirror) return null;
  state[side].boost.mirror=false;
  const adj = adjacentOrgans(primaryTargetSide, primaryTargetSlot)[0];
  return adj || null;
}

function executeCard(side, card, targetId){
  const actor = state[side];
  const foeSide = enemySide(side);
  const target = [...state.player.organs,...state.ai.organs].find(o=>o.id===targetId);
  let notes=[];
  const atkBonus=offensiveBonus(side);
  const supBonus=supportBonus(side);

  function damageTarget(org, amount, opts={}){ if(!org) return 0; return applyDamage(org.owner, org, amount + (opts.useAttackBonus?atkBonus:0), opts); }
  function healTarget(org, amount){ return healOrgan(org, amount + supBonus); }

  switch(card.effect){
    case 'wildSmall':
      if(target.owner===side){ notes.push(`healed ${healTarget(target,1)} HP`); }
      else { notes.push(`dealt ${damageTarget(target,1,{useAttackBonus:true})} damage`); }
      break;
    case 'wildSplit':
      if(target.owner===side){ target.resist += 1 + supBonus; notes.push(`granted Resist ${1+supBonus}`); }
      else { notes.push(`dealt ${damageTarget(target,2,{useAttackBonus:true})} damage`); }
      break;
    case 'wildDraw':
      drawCard(side);
      if(target.owner===side) notes.push(`healed ${healTarget(target,1)} HP and drew 1`);
      else notes.push(`dealt ${damageTarget(target,1,{useAttackBonus:true})} damage and drew 1`);
      break;
    case 'wildPivot':
      if(target.owner===side) notes.push(`healed ${healTarget(target,1)} HP`);
      else notes.push(`dealt ${damageTarget(target, target.poison>0?2:1,{useAttackBonus:true})} damage`);
      break;
    case 'wildCleanse':
      target.poison=0; notes.push(`cleansed poison and healed ${healTarget(target,2)} HP`); break;
    case 'wildCollapse':
      notes.push(`dealt ${damageTarget(target,2 + (atkBonus>0?1:0),{})} damage`); break;

    case 'damage2': notes.push(`dealt ${damageTarget(target,2,{useAttackBonus:true})} damage`); break;
    case 'damage3': notes.push(`dealt ${damageTarget(target,3,{useAttackBonus:true})} damage`); break;
    case 'pierce2': notes.push(`pierced for ${applyDamage(target.owner,target,2+atkBonus,{ignoreResist:true})} damage`); break;
    case 'necrosisSpiral': notes.push(`dealt ${damageTarget(target, target.poison>0?3:2,{useAttackBonus:true})} damage`); break;
    case 'split1': {
      const dealt=damageTarget(target,1,{useAttackBonus:true});
      const adj=adjacentOrgans(target.owner,target.slot)[0];
      const splash=adj?damageTarget(adj,1,{}):0;
      notes.push(`hit ${dealt} and splashed ${splash}`); break;
    }
    case 'execute4': {
      const dmg = target.hp<=2 ? applyDamage(target.owner,target,4+atkBonus,{ignoreResist:true}) : damageTarget(target,1,{useAttackBonus:true});
      notes.push(`dealt ${dmg} damage`); break;
    }
    case 'damage2draw1': notes.push(`dealt ${damageTarget(target,2,{useAttackBonus:true})} damage and drew 1`); drawCard(side); break;
    case 'damage3nodraw': notes.push(`dealt ${damageTarget(target,3,{useAttackBonus:true})} damage`); actor.boost.skipDraw=true; break;
    case 'damage2boosted': notes.push(`dealt ${damageTarget(target,2 + (atkBonus>0?1:0),{})} damage`); break;
    case 'ruinWeakest': {
      const weak=getWeakestAlive(foeSide); if(weak) notes.push(`ruined ${weak.name} for ${damageTarget(weak,3,{useAttackBonus:true})} damage`); break;
    }
    case 'echoStrike': target.poison += 1; notes.push(`dealt ${damageTarget(target,1,{useAttackBonus:true})} now and left a 1 poison echo`); break;

    case 'spread1': {
      const dealt=damageTarget(target,1,{useAttackBonus:true});
      const adj=adjacentOrgans(target.owner,target.slot)[0];
      const splash=adj?damageTarget(adj,1,{}):0;
      notes.push(`dealt ${dealt} + spread ${splash}`); break;
    }
    case 'spreadPoison': {
      target.poison += 1;
      adjacentOrgans(target.owner,target.slot).forEach(o=>o.poison += 1);
      notes.push('spread poison to adjacent organ(s)'); break;
    }
    case 'blastSpread': {
      const dealt=damageTarget(target,2,{useAttackBonus:true});
      adjacentOrgans(target.owner,target.slot).forEach(o=>damageTarget(o,1,{}));
      notes.push(`blasted for ${dealt} and splashed neighbors`); break;
    }
    case 'crawl': {
      const adj=adjacentOrgans(target.owner,target.slot)[0];
      if(target.poison>0 && adj){ damageTarget(adj,2,{useAttackBonus:true}); notes.push(`crawled 2 damage to ${adj.name}`); }
      else notes.push(`dealt ${damageTarget(target,1,{useAttackBonus:true})} damage`);
      break;
    }
    case 'poison2': target.poison += 2; notes.push('applied Poison 2'); break;
    case 'rain': {
      const alive=shuffle(state[foeSide].organs.filter(o=>o.alive)).slice(0,3);
      alive.forEach(o=>damageTarget(o,1,{useAttackBonus:true}));
      notes.push(`rained on ${alive.length} organs`); break;
    }
    case 'weave': {
      target.poison += 1;
      const adj=adjacentOrgans(target.owner,target.slot).find(o=>o.poison>0);
      if(adj) target.poison += adj.poison;
      notes.push(`wove poison to ${target.poison}`); break;
    }
    case 'poisonSweep': {
      let hits=0; state[foeSide].organs.filter(o=>o.alive&&o.poison>0).forEach(o=>{ damageTarget(o,1,{useAttackBonus:true}); hits++; });
      notes.push(`swept ${hits} poisoned organs`); break;
    }

    case 'mayhemCrash': {
      const dealt=damageTarget(target,3,{useAttackBonus:true});
      const self=randomAlive(side); if(self) applyDamage(side,self,1,{ignoreResist:true});
      notes.push(`dealt ${dealt} damage with backlash`); break;
    }
    case 'twoTargets2': {
      const list=state[foeSide].organs.filter(o=>o.alive).slice(0,2);
      list.forEach(o=>damageTarget(o,2,{useAttackBonus:true}));
      notes.push(`hit ${list.map(o=>o.name).join(' + ')}`); break;
    }
    case 'roulette4': {
      const r=randomAlive(foeSide); if(r){ damageTarget(r,4,{useAttackBonus:true}); notes.push(`rouletted ${r.name}`); } break;
    }
    case 'burst5': damageTarget(target,5,{useAttackBonus:true}); actor.boost.skipDraw=true; notes.push('burst for 5 damage'); break;
    case 'clearResistEnemy': state[foeSide].organs.forEach(o=>o.resist=0); notes.push('stripped all enemy Resist'); break;
    case 'quake1': state[foeSide].organs.filter(o=>o.alive).forEach(o=>damageTarget(o,1,{useAttackBonus:true})); notes.push('shook all enemy organs for 1'); break;

    case 'draw2': drawCard(side); drawCard(side); notes.push('drew 2 cards'); break;
    case 'scanDraw': { const strong=getStrongestAlive(foeSide); drawCard(side); notes.push(`scanned ${strong?strong.name:'the board'} and drew 1`); break; }
    case 'cleanseDraw': target.poison=0; drawCard(side); notes.push('cleansed poison and drew 1'); break;
    case 'resistTwo': {
      const alive=state[side].organs.filter(o=>o.alive).slice(0,2); alive.forEach(o=>o.resist += 1 + supBonus); notes.push(`granted Resist to ${alive.length} organs`); break;
    }
    case 'tempoDraw': drawCard(side); notes.push('cycled and drew 1'); break;
    case 'healAll1': state[side].organs.filter(o=>o.alive).forEach(o=>healTarget(o,1)); notes.push('healed all friendly organs'); break;

    case 'resist2': target.resist += 2 + supBonus; notes.push(`granted Resist ${2+supBonus}`); break;
    case 'resistAdjacent': {
      [target,...adjacentOrgans(side,target.slot)].forEach(o=>o.resist += 1 + supBonus); notes.push('shielded adjacent friendly organs'); break;
    }
    case 'brace3': target.resist += (target.hp<=2?3:1) + supBonus; notes.push('braced a vulnerable organ'); break;
    case 'resistCleanse': target.resist += 1 + supBonus; target.poison=0; notes.push('granted Resist and cleansed poison'); break;
    case 'resist2draw': target.resist += 2 + supBonus; drawCard(side); notes.push('granted Resist and drew 1'); break;
    case 'resistAll1': state[side].organs.filter(o=>o.alive).forEach(o=>o.resist += 1 + supBonus); notes.push('all friendly organs gained Resist'); break;

    case 'heal2': notes.push(`healed ${healTarget(target,2)} HP`); break;
    case 'heal1cleanse': target.poison=0; notes.push(`healed ${healTarget(target,1)} HP and cleansed poison`); break;
    case 'heal3': notes.push(`healed ${healTarget(target,3)} HP`); break;
    case 'healThree1': state[side].organs.filter(o=>o.alive).slice(0,3).forEach(o=>healTarget(o,1)); notes.push('healed 3 friendly organs'); break;
    case 'cleanseAll': state[side].organs.forEach(o=>o.poison=0); notes.push('cleansed all friendly poison'); break;
    case 'heal2resist1': notes.push(`healed ${healTarget(target,2)} HP`); target.resist += 1 + supBonus; notes.push('added Resist 1'); break;

    case 'poison1': target.poison += 1; notes.push('applied Poison 1'); break;
    case 'needle': damageTarget(target,1,{useAttackBonus:true}); target.poison += 1; notes.push('dealt 1 and poisoned target'); break;
    case 'poisonAll1': state[foeSide].organs.filter(o=>o.alive).forEach(o=>o.poison += 1); notes.push('poisoned all enemy organs'); break;
    case 'poisonLeach': target.poison += 1; const healSelf=getWeakestAlive(side); if(healSelf) healOrgan(healSelf,1); notes.push('applied poison and leeched 1 heal'); break;
    case 'poison3full': target.poison += (target.hp===target.maxHp?3:1); notes.push(`applied Poison ${target.hp===target.maxHp?3:1}`); break;

    case 'boost1': actor.boost.attack += 1; notes.push('primed +1 offensive boost'); break;
    case 'boost2': actor.boost.attack += 2; notes.push('primed +2 offensive boost'); break;
    case 'boostGuard': actor.boost.support += 1; notes.push('primed +1 support boost'); break;
    case 'boost1draw1': actor.boost.attack += 1; drawCard(side); notes.push('boosted offense and drew 1'); break;
    case 'boostMirror': actor.boost.mirror = true; notes.push('next card will mirror to an adjacent organ'); break;
    case 'boost3': actor.boost.attack += 3; notes.push('primed +3 offensive boost'); break;
  }

  const mirrorTarget = mirrorIfNeeded(side, card, target.owner, target.slot);
  if(mirrorTarget && ['Necrosis','Metastasis','Mayhem','Poison','Wild'].includes(card.type)){
    const mirrorDmg = applyDamage(mirrorTarget.owner, mirrorTarget, 1, {ignoreResist:false});
    notes.push(`mirror splash hit ${mirrorTarget.name} for ${mirrorDmg}`);
  }

  cleanupDestroyed();
  return notes.join(' ¬∑ ');
}

function autoPlayerChoosePlay(){
  const player = state.player;
  const weakEnemy=getWeakestAlive('ai');
  const hurtSelf=state.player.organs.filter(o=>o.alive && (o.hp<o.maxHp || o.poison>0)).sort((a,b)=>(a.hp+a.poison)-(b.hp+b.poison))[0];
  const endangered=getWeakestAlive('player');
  const offensiveTypes=['Necrosis','Metastasis','Mayhem','Poison'];
  const supportTypes=['Resist','Cure','Boost','Instant'];
  if(hurtSelf){ const cure = player.hand.find(c=>c.type==='Cure'); if(cure) return {card:cure,target:hurtSelf}; }
  if(endangered && endangered.hp<=2){ const resist = player.hand.find(c=>c.type==='Resist'); if(resist) return {card:resist,target:endangered}; }
  const boost = player.hand.find(c=>c.type==='Boost');
  const heavy = player.hand.find(c=>['Necrosis','Mayhem','Metastasis'].includes(c.type));
  if(boost && heavy){ const target = state.player.organs.find(o=>o.alive) || endangered; return {card:boost,target}; }
  const offense = player.hand.find(c=>offensiveTypes.includes(c.type));
  if(offense && weakEnemy) return {card:offense,target:weakEnemy};
  const instant = player.hand.find(c=>c.type==='Instant');
  if(instant){ const target = state.player.organs.find(o=>o.alive); return {card:instant,target}; }
  const support = player.hand.find(c=>supportTypes.includes(c.type));
  if(support){ const target = state.player.organs.find(o=>o.alive); return {card:support,target}; }
  return null;
}

function autoPlayerTurn(){
  if(state.gameOver) return;
  processTurnStart('player');
  if(checkWin()) return;
  const choice=autoPlayerChoosePlay();
  if(!choice){
    log('üü¢ <strong>Player AI passes.</strong> No valid play available.');
    setSpotlight('player','Pass Turn','Player-side AI found no valid move and passed.', ['PASS']);
    state.lastAction = 'Player AI passed';
    state.turn='ai';
    render();
    scheduleAutoplay();
    return;
  }
  removeCardFromHand('player', choice.card.uid);
  const note=executeCard('player', choice.card, choice.target.id);
  log(`üü¢ <strong>Player AI played ${choice.card.name}</strong> on <strong>${choice.target.name}</strong> ¬∑ ${note}`);
  setSpotlight('player', `${choice.card.name} ‚Üí ${choice.target.name}`, note || 'Resolved action.', [choice.card.type, `Target: ${choice.target.name}`]);
  state.lastAction = `${choice.card.name} on ${choice.target.name}`;
  if(!state.player.boost.skipDraw) drawCard('player'); else state.player.boost.skipDraw=false;
  state.selectedCardId=null; state.selectedTargetId=null;
  if(checkWin()) return;
  state.turn='ai';
  render();
  scheduleAutoplay();
}

function aiChoosePlay(){
  const ai=state.ai;
  const weakEnemy=getWeakestAlive('player');
  const hurtSelf=state.ai.organs.filter(o=>o.alive && (o.hp<o.maxHp || o.poison>0)).sort((a,b)=>(a.hp+a.poison)-(b.hp+b.poison))[0];
  const endangered=getWeakestAlive('ai');

  const offensiveTypes=['Necrosis','Metastasis','Mayhem','Poison'];
  const supportTypes=['Resist','Cure','Boost','Instant'];

  if(hurtSelf){
    const cure = ai.hand.find(c=>c.type==='Cure');
    if(cure) return {card:cure,target:hurtSelf};
  }
  if(endangered && endangered.hp<=2){
    const resist = ai.hand.find(c=>c.type==='Resist');
    if(resist) return {card:resist,target:endangered};
  }
  const boost = ai.hand.find(c=>c.type==='Boost');
  const heavy = ai.hand.find(c=>['Necrosis','Mayhem','Metastasis'].includes(c.type));
  if(boost && heavy){
    const target = state.ai.organs.find(o=>o.alive) || endangered;
    return {card:boost,target};
  }
  const offense = ai.hand.find(c=>offensiveTypes.includes(c.type));function playPlayerCard(){
  if(state.playerMode!=='manual' || state.turn!=='player' || state.gameOver) return;
  const card = getCard('player', state.selectedCardId);
  const target = [...state.player.organs,...state.ai.organs].find(o=>o.id===state.selectedTargetId);
  if(!card || !target || !isTargetCompatible(card, target.id)){
    log('‚ö†Ô∏è <strong>Incomplete move.</strong> Choose a valid card and target before playing.');
    render();
    return;
  }
  removeCardFromHand('player', card.uid);
  const note = executeCard('player', card, target.id);
  log(`üü¢ <strong>You played ${card.name}</strong> on <strong>${target.name}</strong> ¬∑ ${note}`);
  setSpotlight('player', `${card.name} ‚Üí ${target.name}`, note || 'Resolved action.', [card.type, `Target: ${target.name}`]);
  state.lastAction = `You played ${card.name} on ${target.name}`;
  if(!state.player.boost.skipDraw) drawCard('player'); else state.player.boost.skipDraw=false;
  if(checkWin()) return;
  setTurn('ai');
}

function autoPlayerTurn(){) return {card:offense,target:weakEnemy};
  const instant = ai.hand.find(c=>c.type==='Instant');
  if(instant){
    const target = state.ai.organs.find(o=>o.alive);
    return {card:instant,target};
  }
  const support = ai.hand.find(c=>supportTypes.includes(c.type));
  if(support){
    const target = state.ai.organs.find(o=>o.alive);
    return {card:support,target};
  }
  return null;
}

function aiTurn(){
  if(state.gameOver) return;
  processTurnStart('ai');
  if(checkWin()) return;
  const choice=aiChoosePlay();
  if(!choice){
    log('ü§ñ <strong>AI passes.</strong> No valid play available.');
    setSpotlight('ai','Pass Turn','AI found no valid move and passed.', ['PASS']);
    state.lastAction = 'AI passed';
    state.turn='player';
    render();
    scheduleAutoplay();
    return;
  }
  removeCardFuid);
  const note=executeCard('ai', choice.card, choice.target.id);
  log(`üî¥ <strong>AI played ${choice.card.name}</strong> on <strong>${choice.target.name}</strong> ¬∑ ${note}`);
  setSpotlight('ai', `${choice.card.name} ‚Üí ${choice.target.name}`, note || 'Resolved action.', [choice.card.type, `Target: ${choice.target.name}`]);
  state.lastAction = `${choice.card.name} on ${choice.target.name}`;
  if(!state.ai.boost.skipDraw) drawCard('ai'); else state.ai.boost.skipDraw=false;
  if(checkWin()) return;
  state.turn='player';
  render();
  scheduleAutoplay();
}

function checkWin(){
  const playerAlive=state.player.organs.some(o=>o.alive);
  const aiAlive=state.ai.organs.some(o=>o.alive);
  if(playerAlive && aiAlive){ render(); return false; }
  state.gameOver=true;
  if(aiAlive && !playerAlive){
    els.endTitle.textContent='AI VICTORY';
    els.endText.textContent='The AI removed all of your organs first.';
    log('üíÄ <strong>Defeat.</strong> Your last organ has fallen.');
  } else {
    els.endTitle.textContent='PLAYER VICTORY';
    els.endText.textContent='You removed all AI organs.';
    log('üèÜ <strong>Victory.</strong> All AI organs have been removed.');
  }
  els.endOverlay.classList.add('active');
  render();
  return true;
}

els.autoplayToggleBtn.addEventListener('click', ()=>{
  state.autoplay = !state.autoplay;
  render();
  if(state.autoplay) scheduleAutoplay();
  else clearTimeout(state.autoplayTimer);
});
els.stepBtn.addEventListener('click', ()=>{
  if(state.gameOver) return;
  clearTimeout(state.autoplayTimer);
  if(state.turn === 'player') autoPlayerTurn();
  else aiTurn();
});
els.restartBtn.addEventListener('click', newGame);
els.overlayRestartBtn.addEventListener('click', newGame);

initLegend();
newGame();
</script>
</body>
</html>
