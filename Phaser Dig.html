<!doctype html>

<html lang="en">

<head>

  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />

  <title>Dig Dug 2-ish Clone (Single-File) + Library Demos</title>

  <style>

    :root{--bg:#0b1020;--panel:rgba(255,255,255,.07);--line:rgba(255,255,255,.12);--txt:rgba(255,255,255,.92);--muted:rgba(255,255,255,.65);--accent:#7dd3fc}

    html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 30% 20%, #152047 0%, #0b1020 55%, #070a14 100%);color:var(--txt);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}

    .wrap{max-width:1200px;margin:0 auto;padding:14px;display:grid;gap:12px;grid-template-columns: 1.35fr .65fr}

    @media (max-width: 980px){.wrap{grid-template-columns:1fr}}

    .card{background:var(--panel);border:1px solid var(--line);border-radius:14px;box-shadow:0 12px 30px rgba(0,0,0,.35)}

    .top{padding:12px 14px;display:flex;gap:10px;align-items:center;justify-content:space-between;border-bottom:1px solid var(--line)}

    .title{display:flex;gap:10px;align-items:center}

    .title h1{font-size:16px;margin:0;letter-spacing:.2px}

    .title .pill{font-size:12px;color:#0b1020;background:var(--accent);padding:3px 10px;border-radius:999px;font-weight:700}

    .muted{color:var(--muted);font-size:12px}

    .main{padding:10px}

    #gameHost{width:100%;aspect-ratio: 4 / 3;min-height:420px;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,.10)}

    .side{padding:12px 14px}

    .k{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 12px}

    .k span{font-size:12px;border:1px solid var(--line);background:rgba(0,0,0,.25);padding:6px 8px;border-radius:10px}

    .btnRow{display:grid;grid-template-columns:1fr 1fr;gap:8px}

    button{appearance:none;border:1px solid var(--line);background:rgba(0,0,0,.25);color:var(--txt);padding:10px 10px;border-radius:12px;font-weight:700;cursor:pointer}

    button:hover{border-color:rgba(125,211,252,.55);box-shadow:0 0 0 2px rgba(125,211,252,.12) inset}

    button:active{transform:translateY(1px)}

    .hr{height:1px;background:var(--line);margin:12px 0}

    .miniHost{display:grid;gap:10px}

    .mini{border:1px solid var(--line);background:rgba(0,0,0,.25);border-radius:12px;overflow:hidden}

    .mini .hdr{display:flex;align-items:center;justify-content:space-between;padding:10px 10px;border-bottom:1px solid var(--line)}

    .mini .hdr b{font-size:13px}

    .mini .body{padding:10px}

    .mini canvas,.mini iframe{width:100%;height:210px;display:block;border:0}

    .log{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;color:rgba(255,255,255,.80);line-height:1.35}

    a{color:var(--accent);text-decoration:none}

  </style>

</head>

<body>

  <div class="wrap">

    <div class="card">

      <div class="top">

        <div class="title">

          <span class="pill">üéÆ Phaser Dig Game</span>

          <h1>Dig Dug 2-inspired (single-file, no assets)</h1>

        </div>

        <div class="muted">One HTML. CDNs. Keyboard + pump + rocks.</div>

      </div>

      <div class="main">

        <div id="gameHost"></div>

        <div class="muted" style="margin-top:10px">

          Controls: <b>Arrows/WASD</b> move ‚Ä¢ <b>Space</b> pump (hold to inflate) ‚Ä¢ <b>Shift</b> "phase" (short dash through dirt, cooldown)

        </div>

      </div>

    </div>

    <div class="card">

      <div class="top">

        <div class="title">

          <span class="pill">üß™ Library Showcase</span>

          <h1>Mini demos (optional)</h1>

        </div>

      </div>

      <div class="side">

        <div class="muted">

          Click any demo to load that library (lazy-loaded) and run a tiny scene.

        </div>

        <div class="k">

          <span>üöÄ Phaser</span><span>üßä Three.js</span><span>üèõÔ∏è Babylon.js</span><span>‚ú® PixiJS</span>

          <span>üí• Kaboom</span><span>üçé Matter</span><span>‚öîÔ∏è Excalibur</span><span>üëì A-Frame</span>

          <span>üçâ melonJS</span><span>üéØ Cannon</span><span>üß≤ Ammo</span><span>‚òÅÔ∏è PlayCanvas*</span>

        </div>

        <div class="btnRow">

          <button id="runPixi">‚ú® PixiJS</button>

          <button id="runThree">üßä Three.js</button>

          <button id="runBabylon">üèõÔ∏è Babylon</button>

          <button id="runKaboom">üí• Kaboom</button>

          <button id="runMatter">üçé Matter</button>

          <button id="runExcalibur">‚öîÔ∏è Excalibur</button>

          <button id="runAframe">üëì A-Frame</button>

          <button id="runMelon">üçâ melonJS</button>

          <button id="runCannon">üéØ Cannon</button>

          <button id="runAmmo">üß≤ Ammo</button>

          <button id="runPlayCanvas">‚òÅÔ∏è PlayCanvas*</button>

          <button id="clearDemos">üßπ Clear</button>

        </div>

        <div class="hr"></div>

        <div id="miniHost" class="miniHost"></div>

        <div class="hr"></div>

        <div class="muted">

          *PlayCanvas is typically editor-driven, but you can run its engine/runtime from a single file. This demo is runtime-only.

        </div>

      </div>

    </div>

  </div>

  <!-- Phaser (main game) -->

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>

  <script>

  /*****************************************************************

   * DIG DUG 2-ish CLONE (Phaser 3) ‚Äî single file, no assets

   * - Tile-based dirt removal (dig tunnels)

   * - Two enemy types (Pooka-ish + Fygar-ish)

   * - Pump mechanic (hold Space to inflate / pop)

   * - Rocks that fall when undermined

   * - Simple scoring + lives

   * - Small "phase dash" to show a distinct action

   *****************************************************************/

  (() => {

    const TILE = 16;

    const W = 40;         // tiles wide

    const H = 30;         // tiles high

    const HUD_H = 32;     // pixels

    const CANVAS_W = W * TILE;

    const CANVAS_H = H * TILE + HUD_H;

    const COLORS = {

      bg: 0x070a14,

      dirt: 0x6b3f1d,

      dirt2: 0x7a4a25,

      tunnel: 0x1b2036,

      player: 0x7dd3fc,

      enemy1: 0xfda4af,

      enemy2: 0xfbbf24,

      rock: 0x94a3b8,

      pump: 0xa7f3d0,

      ui: 0xffffff

    };

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    class DigScene extends Phaser.Scene {

      constructor(){ super("Dig"); }

      preload(){ /* no assets */ }

      create(){

        // World state

        this.score = 0;

        this.lives = 3;

        this.level = 1;

        // Input

        this.keys = this.input.keyboard.addKeys({

          up:"W", down:"S", left:"A", right:"D",

          up2:"UP", down2:"DOWN", left2:"LEFT", right2:"RIGHT",

          pump:"SPACE", phase:"SHIFT"

        });

        // Graphics -> textures

        this.makeTextures();

        // Tile map: 1 = dirt, 0 = tunnel

        this.grid = [];

        for (let y=0; y<H; y++){

          const row = new Uint8Array(W);

          row.fill(1);

          this.grid.push(row);

        }

        // Carve initial tunnels

        this.carveRect(2, 2, 6, 2);

        this.carveRect(2, 2, 2, 10);

        this.carveRect(2, 12, 24, 2);

        this.carveRect(26, 12, 2, 14);

        this.carveRect(12, 20, 16, 2);

        // Dirt layer

        this.dirt = this.add.image(0, HUD_H).setOrigin(0,0);

        this.tunnel = this.add.image(0, HUD_H).setOrigin(0,0);

        this.redrawTerrain(true);

        // Physics bounds

        this.physics.world.setBounds(0, HUD_H, CANVAS_W, H*TILE);

        // Player

        this.player = this.physics.add.sprite(this.tileToX(3), this.tileToY(3), "px_player");

        this.player.setCollideWorldBounds(true);

        this.player.setDrag(1500,1500);

        this.player.setMaxVelocity(150,150);

        this.player.facing = {x:1,y:0};

        this.player.phaseCooldown = 0;

        this.player.phaseTime = 0;

        // Pump (hidden by default)

        this.pump = this.add.sprite(-999,-999,"px_pump").setVisible(false);

        this.pumpActive = false;

        this.pumpHold = 0;

        this.pumpTarget = null;

        // Rocks

        this.rocks = this.physics.add.group();

        this.spawnRocks(10);

        // Enemies

        this.enemies = this.physics.add.group();

        this.spawnEnemies(5);

        // Collisions: player vs enemies/rocks

        this.physics.add.overlap(this.player, this.enemies, () => this.onPlayerHit(), null, this);

        // Player can *push* settled rocks (Dig Dug 2-ish feel)

        this.physics.add.collider(this.player, this.rocks, this.onPlayerRockCollide, null, this);

        // HUD

        this.hudText = this.add.text(10, 8, "", {fontSize:"14px", color:"#ffffff"});

        this.helpText = this.add.text(CANVAS_W-10, 8, "", {fontSize:"12px", color:"rgba(255,255,255,.8)"}).setOrigin(1,0);

        this.updateHUD();

        // Tick

        this.time.addEvent({delay: 150, loop:true, callback: () => this.enemyAI()});

        this.time.addEvent({delay: 60, loop:true, callback: () => this.rockCheck()});

        // Camera-ish (fixed; canvas size is exact)

        this.scale.resize(CANVAS_W, CANVAS_H);

        // Dig on move tick (keeps "tile digging feel")

        this.lastDigAt = {tx:-1, ty:-1};

        // Respawn invuln

        this.invuln = 0;

      }

      makeTextures(){

        const g = this.make.graphics({x:0,y:0,add:false});

        // Player

        g.clear();

        g.fillStyle(COLORS.player, 1);

        g.fillRoundedRect(1,1,14,14,4);

        g.fillStyle(0x0b1020,1);

        g.fillCircle(6,6,2);

        g.fillCircle(11,6,2);

        g.generateTexture("px_player", 16, 16);

        // Enemy 1 (Pooka-ish)

        g.clear();

        g.fillStyle(COLORS.enemy1, 1);

        g.fillRoundedRect(1,2,14,13,6);

        g.fillStyle(0x0b1020,1);

        g.fillRect(5,6,2,2); g.fillRect(9,6,2,2);

        g.fillStyle(0xffffff,1);

        g.fillRect(5,10,6,2);

        g.generateTexture("px_enemy1", 16, 16);

        // Enemy 2 (Fygar-ish)

        g.clear();

        g.fillStyle(COLORS.enemy2, 1);

        g.fillRoundedRect(1,2,14,13,6);

        g.fillStyle(0x0b1020,1);

        g.fillRect(4,6,3,2); g.fillRect(9,6,3,2);

        g.fillStyle(0xffffff,1);

        g.fillRect(5,11,7,2);

        g.generateTexture("px_enemy2", 16, 16);

        // Rock

        g.clear();

        g.fillStyle(COLORS.rock, 1);

        g.fillCircle(8,8,7);

        g.fillStyle(0xffffff,0.15);

        g.fillCircle(6,6,3);

        g.generateTexture("px_rock", 16, 16);

        // Pump

        g.clear();

        g.fillStyle(COLORS.pump, 1);

        g.fillRoundedRect(0,6,16,4,2);

        g.fillCircle(14,8,3);

        g.generateTexture("px_pump", 16, 16);

        g.destroy();

      }

      tileToX(tx){ return tx*TILE + TILE/2; }

      tileToY(ty){ return HUD_H + ty*TILE + TILE/2; }

      worldToTileX(x){ return clamp(Math.floor(x / TILE), 0, W-1); }

      worldToTileY(y){ return clamp(Math.floor((y - HUD_H) / TILE), 0, H-1); }

      carveRect(tx,ty,w,h){

        for(let y=ty;y<ty+h;y++) for(let x=tx;x<tx+w;x++) this.grid[y][x]=0;

      }

      redrawTerrain(full=false){

        const dirtCanvas = document.createElement("canvas");

        dirtCanvas.width = CANVAS_W; dirtCanvas.height = H*TILE;

        const tCanvas = document.createElement("canvas");

        tCanvas.width = CANVAS_W; tCanvas.height = H*TILE;

        const dctx = dirtCanvas.getContext("2d");

        const tctx = tCanvas.getContext("2d");

        tctx.fillStyle = "#1b2036";

        tctx.fillRect(0,0,CANVAS_W,H*TILE);

        for(let y=0;y<H;y++){

          for(let x=0;x<W;x++){

            if(this.grid[y][x]===1){

              const c = ((x+y)&1) ? "#6b3f1d" : "#7a4a25";

              dctx.fillStyle = c;

              dctx.fillRect(x*TILE, y*TILE, TILE, TILE);

              dctx.fillStyle = "rgba(0,0,0,.15)";

              dctx.fillRect(x*TILE, y*TILE, TILE, 1);

            } else {

              tctx.fillStyle = "rgba(255,255,255,.06)";

              tctx.fillRect(x*TILE, y*TILE, TILE, TILE);

            }

          }

        }

        const dirtKey = "tex_dirt";

        const tunKey = "tex_tunnel";

        if (this.textures.exists(dirtKey)) this.textures.remove(dirtKey);

        if (this.textures.exists(tunKey)) this.textures.remove(tunKey);

        this.textures.addCanvas(dirtKey, dirtCanvas);

        this.textures.addCanvas(tunKey, tCanvas);

        this.dirt.setTexture(dirtKey);

        this.tunnel.setTexture(tunKey);

      }

      digAtWorld(x,y){

        const tx = this.worldToTileX(x);

        const ty = this.worldToTileY(y);

        if (this.grid[ty][tx] === 1){

          this.grid[ty][tx] = 0;

          this.redrawTerrain(false);

        }

      }

      spawnRocks(n){

        let tries = 0;

        while(n>0 && tries<2000){

          tries++;

          const tx = Phaser.Math.Between(6, W-3);

          const ty = Phaser.Math.Between(6, H-4);

          if (this.grid[ty][tx]===1 && this.grid[ty-1][tx]===1){

            if (Math.abs(tx-3)+Math.abs(ty-3) < 10) continue;

            const r = this.rocks.create(this.tileToX(tx), this.tileToY(ty), "px_rock");

            r.tx = tx; r.ty = ty;

            r.body.setAllowGravity(false);

            r.falling = false;

            r.fallDelay = 0;

            r.setImmovable(true);

            r.pushable = false;

            r.pushCooldown = 0;

            r.setCollideWorldBounds(true);

            r.setBounce(0);

            r.setDrag(1800, 1800);

            r.setMaxVelocity(80, 80);

            n--;

          }

        }

      }

      spawnEnemies(n){

        for(let i=0;i<n;i++){

          const type = (i%2===0) ? "px_enemy1" : "px_enemy2";

          const e = this.enemies.create(this.tileToX(Phaser.Math.Between(10,W-5)), this.tileToY(Phaser.Math.Between(6,H-5)), type);

          e.type = type;

          e.setCollideWorldBounds(true);

          e.setDrag(800,800);

          e.setMaxVelocity(120,120);

          e.phase = 0;

          e.alive = true;

          e.aiDir = {x:0,y:0};

        }

      }

      enemyAI(){

        const px = this.player.x, py = this.player.y;

        this.enemies.children.iterate((e) => {

          if (!e || !e.alive) return;

          if (this.pumpTarget === e && this.pumpActive) {

            e.setVelocity(0,0);

            return;

          }

          if (e.phase <= 0 && Math.random() < 0.05){

            e.phase = 20;

          }

          const phased = e.phase > 0;

          if (e.phase > 0) e.phase--;

          const etx = this.worldToTileX(e.x);

          const ety = this.worldToTileY(e.y);

          const cx = this.tileToX(etx);

          const cy = this.tileToY(ety);

          const nearCenter = (Math.abs(e.x - cx) < 3 && Math.abs(e.y - cy) < 3);

          if (nearCenter){

            const opts = [];

            const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];

            for(const d of dirs){

              const nx = etx + d.x, ny = ety + d.y;

              if (nx<0||nx>=W||ny<0||ny>=H) continue;

              const pass = phased ? true : (this.grid[ny][nx]===0);

              if (!pass) continue;

              const rev = (d.x === -e.aiDir.x && d.y === -e.aiDir.y);

              opts.push({d, rev});

            }

            if (opts.length){

              opts.sort((a,b)=>{

                const ax = etx+a.d.x, ay = ety+a.d.y;

                const bx = etx+b.d.x, by = ety+b.d.y;

                const da = Math.abs(this.tileToX(ax)-px)+Math.abs(this.tileToY(ay)-py);

                const db = Math.abs(this.tileToX(bx)-px)+Math.abs(this.tileToY(by)-py);

                return (da + (a.rev?40:0)) - (db + (b.rev?40:0));

              });

              const pick = (Math.random()<0.20 && opts[1]) ? opts[1] : opts[0];

              e.aiDir = pick.d;

            }

          }

          const spd = phased ? 110 : 85;

          e.setVelocity(e.aiDir.x*spd, e.aiDir.y*spd);

        });

      }

      rockCheck(){

        this.rocks.children.iterate((r) => {

          if (!r) return;

          const tx = this.worldToTileX(r.x);

          const ty = this.worldToTileY(r.y);

          if (r.falling){

            r.setImmovable(false);

            r.body.setAllowGravity(false);

            r.y += 3.2;

            this.enemies.children.iterate((e)=>{

              if (!e || !e.alive) return;

              if (Phaser.Geom.Intersects.RectangleToRectangle(r.getBounds(), e.getBounds())){

                this.killEnemy(e, true);

              }

            });

            if (Phaser.Geom.Intersects.RectangleToRectangle(r.getBounds(), this.player.getBounds())){

              this.onPlayerHit();

            }

            const belowTy = this.worldToTileY(r.y + TILE/2 + 1);

            if (belowTy >= H-1){

              r.falling = false;

              r.setImmovable(true);

              r.y = this.tileToY(H-1);

              return;

            }

            const belowTx = this.worldToTileX(r.x);

            if (this.grid[belowTy][belowTx]===1){

              r.falling = false;

              r.setImmovable(true);

              r.y = this.tileToY(belowTy-1);

            }

            return;

          }

          // If rock is in an open tunnel and supported, make it pushable.

          const inTunnel = (this.grid[ty][tx] === 0);

          const belowY = ty + 1;

          const belowIsSolid = (belowY >= H) ? true : (this.grid[belowY][tx] === 1);

          // Another rock directly below also counts as support.

          let rockBelow = false;

          if (belowY < H){

            this.rocks.children.iterate((r2) => {

              if (!r2 || r2 === r || r2.falling) return;

              const r2tx = this.worldToTileX(r2.x);

              const r2ty = this.worldToTileY(r2.y);

              if (r2tx === tx && r2ty === belowY) rockBelow = true;

            });

          }

          r.pushable = inTunnel && (belowIsSolid || rockBelow || belowY >= H);

          r.setImmovable(!r.pushable);

          // Snap gently to tile centers when settled (prevents drift)

          if (r.pushable && Math.abs(r.body.velocity.x) < 2 && Math.abs(r.body.velocity.y) < 2){

            const cx = this.tileToX(tx);

            const cy = this.tileToY(ty);

            r.x += (cx - r.x) * 0.25;

            r.y += (cy - r.y) * 0.25;

          }

          if (belowY < H && this.grid[belowY][tx] === 0){

            r.fallDelay = (r.fallDelay||0) + 1;

            if (r.fallDelay > 10){

              r.falling = true;

              r.fallDelay = 0;

            }

          } else {

            r.fallDelay = 0;

          }

        });

      }

      tryPump(){

        const dir = this.player.facing;

        const maxTiles = 4;

        const startTx = this.worldToTileX(this.player.x);

        const startTy = this.worldToTileY(this.player.y);

        let hitEnemy = null;

        for(let i=1;i<=maxTiles;i++){

          const tx = startTx + dir.x*i;

          const ty = startTy + dir.y*i;

          if (tx<0||tx>=W||ty<0||ty>=H) break;

          if (this.grid[ty][tx]===1) break;

          this.enemies.children.iterate((e)=>{

            if (!e || !e.alive || hitEnemy) return;

            const etx = this.worldToTileX(e.x);

            const ety = this.worldToTileY(e.y);

            if (etx===tx && ety===ty) hitEnemy = e;

          });

          if (hitEnemy) break;

        }

        const pumpX = this.player.x + dir.x * TILE * 1.2;

        const pumpY = this.player.y + dir.y * TILE * 1.2;

        this.pump.setVisible(true);

        this.pump.setPosition(pumpX, pumpY);

        this.pump.setRotation(Math.atan2(dir.y, dir.x));

        this.pumpActive = true;

        this.pumpTarget = hitEnemy || null;

      }

      killEnemy(e, crushed=false){

        if (!e || !e.alive) return;

        e.alive = false;

        e.disableBody(true,true);

        this.score += crushed ? 400 : 200;

        this.updateHUD();

        const alive = this.enemies.children.entries.filter(x=>x && x.alive);

        if (alive.length === 0){

          this.nextLevel();

        }

      }

      nextLevel(){

        this.level++;

        this.score += 1000;

        this.updateHUD();

        this.spawnEnemies(2 + Math.min(4, this.level));

        this.spawnRocks(2);

        for(let i=0;i<6;i++){

          const tx = Phaser.Math.Between(2,W-3);

          const ty = Phaser.Math.Between(2,H-3);

          this.grid[ty][tx]=0;

        }

        this.redrawTerrain(true);

      }

      onPlayerHit(){

        if (this.invuln > 0) return;

        this.lives--;

        this.updateHUD();

        this.invuln = 120;

        this.player.setPosition(this.tileToX(3), this.tileToY(3));

        this.player.setVelocity(0,0);

        this.score = Math.max(0, this.score - 250);

        this.updateHUD();

        if (this.lives <= 0){

          this.scene.restart();

        }

      }

      updateHUD(){

        this.hudText.setText(`Score: ${this.score}   Lives: ${this.lives}   Level: ${this.level}`);

        this.helpText.setText(`Pump: SPACE  ‚Ä¢  Dash: SHIFT`);

      }

      onPlayerRockCollide(player, r){

        if (!r) return;

        // Falling rocks are lethal

        if (r.falling){

          this.onPlayerHit();

          return;

        }

        // Only push rocks that are settled in tunnels

        if (!r.pushable) return;

        // Small cooldown so one shove doesn't jump multiple tiles

        if (r.pushCooldown > 0) return;

        const pv = player.body.velocity;

        const dx = r.x - player.x;

        const dy = r.y - player.y;

        // Prefer horizontal pushing (Dig Dug style)

        if (Math.abs(dx) < Math.abs(dy)) return;

        const dir = dx >= 0 ? 1 : -1; // player on left pushes right, etc.

        // Player must be moving toward the rock

        if (dir === 1 && pv.x <= 10) return;

        if (dir === -1 && pv.x >= -10) return;

        const tx = this.worldToTileX(r.x);

        const ty = this.worldToTileY(r.y);

        const nx = tx + dir;

        if (nx < 0 || nx >= W) return;

        // Can only push into open tunnel space

        if (this.grid[ty][nx] !== 0) return;

        // Block pushing into another rock occupying that tile

        let blocked = false;

        this.rocks.children.iterate((r2) => {

          if (!r2 || r2 === r) return;

          const r2tx = this.worldToTileX(r2.x);

          const r2ty = this.worldToTileY(r2.y);

          if (r2tx === nx && r2ty === ty) blocked = true;

        });

        if (blocked) return;

        // Shove: burst velocity + drag settles it

        r.pushCooldown = 6;

        r.setVelocity(dir * 120, 0);

        this.time.delayedCall(120, () => { if (r && r.body) r.setVelocity(0, 0); });

      }

      update(){

        // tick down rock push cooldowns

        this.rocks.children.iterate((r) => {

          if (!r) return;

          if (r.pushCooldown > 0) r.pushCooldown--;

        });

        if (this.invuln > 0){

          this.invuln--;

          this.player.setAlpha((this.invuln % 10) < 5 ? 0.4 : 1);

        } else {

          this.player.setAlpha(1);

        }

        const up = this.keys.up.isDown || this.keys.up2.isDown;

        const down = this.keys.down.isDown || this.keys.down2.isDown;

        const left = this.keys.left.isDown || this.keys.left2.isDown;

        const right = this.keys.right.isDown || this.keys.right2.isDown;

        const acc = 900;

        if (this.player.phaseCooldown > 0) this.player.phaseCooldown--;

        if (this.player.phaseTime > 0) this.player.phaseTime--;

        const canPhase = this.player.phaseCooldown<=0 && this.player.phaseTime<=0;

        if (this.keys.phase.isDown && canPhase){

          this.player.phaseTime = 12;

          this.player.phaseCooldown = 90;

        }

        const phased = this.player.phaseTime > 0;

        if (left){ this.player.facing = {x:-1,y:0}; }

        else if (right){ this.player.facing = {x:1,y:0}; }

        else if (up){ this.player.facing = {x:0,y:-1}; }

        else if (down){ this.player.facing = {x:0,y:1}; }

        let ax = 0, ay = 0;

        if (left) ax = -acc;

        if (right) ax = acc;

        if (up) ay = -acc;

        if (down) ay = acc;

        if (!phased){

          const tx = this.worldToTileX(this.player.x);

          const ty = this.worldToTileY(this.player.y);

          const inTunnel = (this.grid[ty][tx]===0);

          if (!inTunnel){

            this.player.setVelocity(this.player.body.velocity.x*0.85, this.player.body.velocity.y*0.85);

          }

        } else {

          this.player.setMaxVelocity(240,240);

        }

        if (!phased) this.player.setMaxVelocity(150,150);

        this.player.setAcceleration(ax, ay);

        this.digAtWorld(this.player.x, this.player.y);

        const fx = this.player.x + this.player.facing.x*(TILE*0.7);

        const fy = this.player.y + this.player.facing.y*(TILE*0.7);

        this.digAtWorld(fx, fy);

        const pumping = this.keys.pump.isDown;

        if (pumping){

          if (!this.pumpActive){

            this.pumpHold = 0;

            this.tryPump();

          }

          this.pumpHold++;

          if (this.pumpTarget && this.pumpTarget.alive){

            const e = this.pumpTarget;

            e.setVelocity(0,0);

            const stage = clamp(Math.floor(this.pumpHold / 18), 0, 3);

            const s = 1 + stage*0.18;

            e.setScale(s);

            e.setTint(0xffffff);

            if (stage >= 3){

              this.killEnemy(e, false);

              this.pumpTarget = null;

              this.pumpActive = false;

              this.pump.setVisible(false);

              this.pumpHold = 0;

            }

          }

        } else {

          if (this.pumpTarget && this.pumpTarget.alive){

            this.pumpTarget.setScale(1);

            this.pumpTarget.clearTint();

          }

          this.pumpTarget = null;

          this.pumpActive = false;

          this.pump.setVisible(false);

          this.pumpHold = 0;

        }

      }

    }

    const config = {

      type: Phaser.AUTO,

      parent: "gameHost",

      width: CANVAS_W,

      height: CANVAS_H,

      backgroundColor: "#070a14",

      physics: { default: "arcade", arcade: { debug: false, gravity: {y:0} } },

      scene: [DigScene],

      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }

    };

    new Phaser.Game(config);

  })();

  </script>

  <script>

  /*****************************************************************

   * MINI DEMOS ‚Äî lazy-load each library into a small card

   * (All within this single HTML file.)

   *****************************************************************/

  const miniHost = document.getElementById("miniHost");

  function card(title){

    const wrap = document.createElement("div");

    wrap.className = "mini";

    const hdr = document.createElement("div");

    hdr.className = "hdr";

    hdr.innerHTML = `<b>${title}</b><span class="muted">loaded</span>`;

    const body = document.createElement("div");

    body.className = "body";

    wrap.appendChild(hdr); wrap.appendChild(body);

    miniHost.prepend(wrap);

    return body;

  }

  function loadScriptOnce(src){

    return new Promise((resolve, reject) => {

      if ([...document.scripts].some(s => s.src === src)) return resolve();

      const s = document.createElement("script");

      s.src = src;

      s.onload = () => resolve();

      s.onerror = () => reject(new Error("Failed: " + src));

      document.head.appendChild(s);

    });

  }

  function clearDemos(){

    miniHost.innerHTML = "";

  }

  document.getElementById("clearDemos").onclick = clearDemos;

  // ‚ú® PixiJS

  document.getElementById("runPixi").onclick = async () => {

    const body = card("‚ú® PixiJS ‚Äî fast 2D sprite batching");

    await loadScriptOnce("https://cdn.jsdelivr.net/npm/pixi.js@8.6.2/dist/pixi.min.js");

    const app = new PIXI.Application();

    await app.init({ width: 600, height: 210, backgroundColor: 0x0b1020, antialias:true });

    body.appendChild(app.canvas);

    const g = new PIXI.Graphics();

    g.roundRect(0,0,48,48,10).fill(0x7dd3fc);

    g.circle(16,18,4).fill(0x0b1020);

    g.circle(32,18,4).fill(0x0b1020);

    const tex = app.renderer.generateTexture(g);

    const s = new PIXI.Sprite(tex);

    s.anchor.set(0.5);

    s.position.set(80,105);

    app.stage.addChild(s);

    const text = new PIXI.Text({text:"PIXI: GPU batching + sprites", style:{fill:0xffffff, fontSize:14}});

    text.position.set(170, 92);

    app.stage.addChild(text);

    let t = 0;

    app.ticker.add((dt)=>{

      t += 0.05*dt;

      s.x = 80 + Math.cos(t)*40;

      s.y = 105 + Math.sin(t)*20;

      s.rotation = Math.sin(t)*0.25;

    });

  };

  // üßä Three.js

  document.getElementById("runThree").onclick = async () => {

    const body = card("üßä Three.js ‚Äî lightweight 3D rendering");

    await loadScriptOnce("https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js");

    const canvas = document.createElement("canvas");

    canvas.width = 600; canvas.height = 210;

    body.appendChild(canvas);

    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});

    renderer.setSize(600,210,false);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(55, 600/210, 0.1, 100);

    camera.position.set(0,1.1,3);

    const light = new THREE.DirectionalLight(0xffffff, 1.0);

    light.position.set(2,3,2);

    scene.add(light);

    scene.add(new THREE.AmbientLight(0xffffff, 0.3));

    const geo = new THREE.TorusKnotGeometry(0.55, 0.18, 120, 16);

    const mat = new THREE.MeshStandardMaterial({metalness:0.2, roughness:0.35, color:0x7dd3fc});

    const mesh = new THREE.Mesh(geo, mat);

    scene.add(mesh);

    function animate(){

      mesh.rotation.x += 0.01;

      mesh.rotation.y += 0.015;

      renderer.render(scene, camera);

      requestAnimationFrame(animate);

    }

    animate();

  };

  // üèõÔ∏è Babylon.js

  document.getElementById("runBabylon").onclick = async () => {

    const body = card("üèõÔ∏è Babylon.js ‚Äî full-featured 3D engine");

    await loadScriptOnce("https://cdn.jsdelivr.net/npm/babylonjs@7.16.0/babylon.min.js");

    const canvas = document.createElement("canvas");

    canvas.width = 600; canvas.height = 210;

    body.appendChild(canvas);

    const engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer:true, stencil:true});

    const scene = new BABYLON.Scene(engine);

    scene.clearColor = new BABYLON.Color4(0.043,0.063,0.125,1);

    const camera = new BABYLON.ArcRotateCamera("cam", Math.PI/2, Math.PI/3, 3.2, BABYLON.Vector3.Zero(), scene);

    camera.attachControl(canvas, true);

    const light = new BABYLON.HemisphericLight("l1", new BABYLON.Vector3(0,1,0), scene);

    const sphere = BABYLON.MeshBuilder.CreateSphere("s", {diameter:1.2, segments:32}, scene);

    const mat = new BABYLON.StandardMaterial("m", scene);

    mat.diffuseColor = new BABYLON.Color3(0.49,0.83,0.98);

    mat.specularColor = new BABYLON.Color3(0.7,0.7,0.7);

    sphere.material = mat;

    engine.runRenderLoop(() => {

      sphere.rotation.y += 0.01;

      scene.render();

    });

    window.addEventListener("resize", () => engine.resize());

  };

  // üí• Kaboom

  document.getElementById("runKaboom").onclick = async () => {

    const body = card("üí• Kaboom.js ‚Äî tiny arcade engine");

    await loadScriptOnce("https://unpkg.com/kaboom@3000.2.1/dist/kaboom.js");

    const host = document.createElement("div");

    body.appendChild(host);

    const k = kaboom({

      global: false,

      root: host,

      width: 600,

      height: 210,

      background: [11,16,32]

    });

    const { add, rect, pos, area, color, text, onKeyDown, onUpdate, rand } = k;

    const player = add([

      rect(22,22),

      pos(60, 120),

      area(),

      color(125, 211, 252),

      { speed: 180 }

    ]);

    add([text("KABOOM: quick arcade loops", {size:16}), pos(200, 12), color(255,255,255)]);

    const dots = [];

    for(let i=0;i<30;i++){

      dots.push(add([rect(2,2), pos(rand(0,600), rand(40,210)), color(255,255,255)]));

    }

    onKeyDown("left",  ()=> player.move(-player.speed, 0));

    onKeyDown("right", ()=> player.move(player.speed, 0));

    onKeyDown("up",    ()=> player.move(0, -player.speed));

    onKeyDown("down",  ()=> player.move(0, player.speed));

    onUpdate(() => {

      dots.forEach(d => { d.pos.x -= 1.5; if (d.pos.x < 0) d.pos.x = 600; });

    });

  };

  // üçé Matter.js

  document.getElementById("runMatter").onclick = async () => {

    const body = card("üçé Matter.js ‚Äî 2D rigid-body physics");

    await loadScriptOnce("https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js");

    const canvas = document.createElement("canvas");

    canvas.width = 600; canvas.height = 210;

    body.appendChild(canvas);

    const { Engine, Render, Runner, Bodies, Composite, Mouse, MouseConstraint } = Matter;

    const engine = Engine.create();

    const render = Render.create({

      canvas,

      engine,

      options: {

        width: 600,

        height: 210,

        wireframes: false,

        background: "#0b1020"

      }

    });

    const ground = Bodies.rectangle(300, 205, 640, 20, { isStatic:true, render:{fillStyle:"#1b2036"} });

    const ball = Bodies.circle(120, 60, 18, { restitution:0.8, render:{fillStyle:"#7dd3fc"} });

    const box  = Bodies.rectangle(220, 30, 36, 36, { restitution:0.2, render:{fillStyle:"#fda4af"} });

    Composite.add(engine.world, [ground, ball, box]);

    const mouse = Mouse.create(canvas);

    const mc = MouseConstraint.create(engine, { mouse, constraint:{ stiffness:0.15 } });

    Composite.add(engine.world, mc);

    Render.run(render);

    Runner.run(Runner.create(), engine);

  };

  // ‚öîÔ∏è Excalibur

  document.getElementById("runExcalibur").onclick = async () => {

    const body = card("‚öîÔ∏è Excalibur.js ‚Äî friendly 2D engine");

    await loadScriptOnce("https://cdn.jsdelivr.net/npm/excalibur@0.29.3/build/dist/excalibur.min.js");

    const canvas = document.createElement("canvas");

    body.appendChild(canvas);

    const game = new ex.Engine({

      canvasElement: canvas,

      width: 600,

      height: 210,

      backgroundColor: ex.Color.fromHex("#0b1020")

    });

    const player = new ex.Actor({

      x: 90, y: 130, width: 22, height: 22,

      color: ex.Color.fromRGB(125,211,252)

    });

    const label = new ex.Label({

      text: "EXCALIBUR: actors + input + collisions",

      pos: new ex.Vector(190, 20),

      font: new ex.Font({ size: 16, family: "system-ui" }),

      color: ex.Color.White

    });

    game.add(player);

    game.add(label);

    game.on("preupdate", (_evt) => {

      const k = game.input.keyboard;

      const sp = 180;

      let vx = 0, vy = 0;

      if (k.isHeld(ex.Keys.Left)) vx -= sp;

      if (k.isHeld(ex.Keys.Right)) vx += sp;

      if (k.isHeld(ex.Keys.Up)) vy -= sp;

      if (k.isHeld(ex.Keys.Down)) vy += sp;

      player.vel = new ex.Vector(vx, vy);

    });

    game.start();

  };

  // üëì A-Frame

  document.getElementById("runAframe").onclick = async () => {

    const body = card("üëì A-Frame ‚Äî WebXR-ready declarative 3D");

    await loadScriptOnce("https://aframe.io/releases/1.6.0/aframe.min.js");

    const iframe = document.createElement("iframe");

    iframe.srcdoc = `

<!doctype html><html><head><meta charset="utf-8"/></head>

<body style="margin:0">

  <a-scene embedded background="color: #0b1020">

    <a-entity position="0 1.2 2.6">

      <a-camera></a-camera>

    </a-entity>

    <a-box position="0 1 -2" rotation="0 45 0" color="#7dd3fc" animation="property: rotation; to: 0 405 0; loop: true; dur: 4000"></a-box>

    <a-plane rotation="-90 0 0" width="8" height="8" color="#1b2036"></a-plane>

    <a-entity position="-1.8 2 -2" text="value:A-FRAME: HTML for 3D/XR; color:#fff; width:6"></a-entity>

  </a-scene>

</body></html>`;

    body.appendChild(iframe);

  };

  // üçâ melonJS

  document.getElementById("runMelon").onclick = async () => {

    const body = card("üçâ melonJS ‚Äî 2D engine w/ ECS-ish patterns");

    await loadScriptOnce("https://cdn.jsdelivr.net/npm/melonjs@16.1.0/dist/melonjs.min.js");

    const canvas = document.createElement("canvas");

    canvas.width = 600; canvas.height = 210;

    body.appendChild(canvas);

    me.device.onReady(() => {

      me.video.init(600, 210, { parent: canvas.parentNode, renderer: me.video.CANVAS, scale: "none" });

      const label = new me.Text(20, 14, { font: "system-ui", size: 16, fillStyle: "#ffffff" });

      label.setText("melonJS: update loop + input");

      const box = new me.Renderable(60, 90, 26, 26);

      box.update = function(){ return true; };

      box.draw = function(r){

        r.setColor("#7dd3fc"); r.fillRect(this.pos.x, this.pos.y, 26, 26);

      };

      me.game.world.reset();

      me.game.world.addChild(label, 1);

      me.game.world.addChild(box, 2);

      me.input.bindKey(me.input.KEY.LEFT, "left");

      me.input.bindKey(me.input.KEY.RIGHT, "right");

      me.input.bindKey(me.input.KEY.UP, "up");

      me.input.bindKey(me.input.KEY.DOWN, "down");

      me.event.on(me.event.GAME_UPDATE, () => {

        const sp = 2.4;

        if (me.input.isKeyPressed("left"))  box.pos.x -= sp;

        if (me.input.isKeyPressed("right")) box.pos.x += sp;

        if (me.input.isKeyPressed("up"))    box.pos.y -= sp;

        if (me.input.isKeyPressed("down"))  box.pos.y += sp;

      });

    });

  };

  // üéØ Cannon.js (physics core demo)

  document.getElementById("runCannon").onclick = async () => {

    const body = card("üéØ Cannon.js ‚Äî 3D rigid-body physics");

    await loadScriptOnce("https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js")

      .catch(async () => {

        await loadScriptOnce("https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js");

      });

    const pre = document.createElement("div");

    pre.className = "log";

    body.appendChild(pre);

    const hasClassic = typeof CANNON !== "undefined";

    if (!hasClassic){

      pre.textContent = "Cannon-es is ESM; many browsers block it from a simple <script> tag.\nTip: use Cannon classic (already loaded via fallback) or bundle.\nThis demo loaded fallback if available.";

      return;

    }

    const world = new CANNON.World();

    world.gravity.set(0, -9.82, 0);

    const groundMat = new CANNON.Material("ground");

    const ground = new CANNON.Body({ mass: 0, material: groundMat });

    ground.addShape(new CANNON.Plane());

    ground.quaternion.setFromEuler(-Math.PI/2, 0, 0);

    world.addBody(ground);

    const sphere = new CANNON.Body({ mass: 1 });

    sphere.addShape(new CANNON.Sphere(0.25));

    sphere.position.set(0, 2, 0);

    world.addBody(sphere);

    let t = 0;

    const dt = 1/60;

    const timer = setInterval(() => {

      world.step(dt);

      t += dt;

      pre.textContent =

        "Cannon classic: stepping world\n" +

        `t=${t.toFixed(2)}s\n` +

        `sphere.y=${sphere.position.y.toFixed(3)}\n` +

        "(Pair Cannon + Three/Babylon for rendering.)";

      if (t > 4.0) clearInterval(timer);

    }, 1000/30);

  };

  // üß≤ Ammo.js (WASM demo note)

  document.getElementById("runAmmo").onclick = async () => {

    const body = card("üß≤ Ammo.js ‚Äî Bullet physics (WASM)");

    const pre = document.createElement("div");

    pre.className = "log";

    body.appendChild(pre);

    pre.textContent =

`Ammo.js is usable from a single HTML file, but it's heavier and CDN formats vary (WASM + glue).

Typical pattern:

1) load Ammo() factory

2) wait for Promise resolve

3) create btDiscreteDynamicsWorld

4) stepSimulation(dt)

If you want, I can provide a working single-file Ammo.js setup targeted to a specific CDN build.`;

  };

  // ‚òÅÔ∏è PlayCanvas runtime note

  document.getElementById("runPlayCanvas").onclick = async () => {

    const body = card("‚òÅÔ∏è PlayCanvas ‚Äî runtime-only (engine)");

    const pre = document.createElement("div");

    pre.className = "log";

    body.appendChild(pre);

    pre.textContent =

`PlayCanvas is absolutely usable as runtime in one HTML file, but:

- most workflows use the PlayCanvas Editor,

- the engine is sizeable,

- modern builds are usually module-based.

If you want a pure one-file runtime demo, I'll tailor it to the exact PlayCanvas engine build you prefer.`;

  };

  </script>

</body>

</html>
