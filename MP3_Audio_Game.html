<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üéõÔ∏è Chopped MP3 Pad Looper (Toggle Loop + Timeline)</title>
  <style>
    :root{
      --bg:#070913; --panel:rgba(255,255,255,.07); --line:rgba(255,255,255,.12);
      --txt:rgba(255,255,255,.92); --muted:rgba(255,255,255,.70);
      --accent:rgba(125,211,252,.85); --good:rgba(52,211,153,.35); --warn:rgba(251,191,36,.50);
      --danger:rgba(248,113,113,.40);
    }
    body{ margin:0; background:var(--bg); color:var(--txt); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap{ max-width:1100px; margin:22px auto; padding:0 14px 26px; }
    .card{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 14px 14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
    }
    h1{ font-size: 18px; margin: 0 0 10px; letter-spacing:.2px; }
    .sub{ font-size: 13px; color: var(--muted); line-height:1.35; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0; }
    .btn{
      cursor:pointer; user-select:none;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--txt);
      padding: 10px 12px;
      font-weight: 900;
      font-size: 13px;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn.primary{ background: rgba(125,211,252,.16); border-color: rgba(125,211,252,.32); }
    .btn.good{ background: rgba(52,211,153,.14); border-color: rgba(52,211,153,.28); }
    .btn.danger{ background: rgba(248,113,113,.12); border-color: rgba(248,113,113,.25); }

    .kv{ display:flex; gap:8px; align-items:center; }
    input[type="number"]{
      width: 92px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--txt);
      font-weight: 900;
    }

    .msg{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.20);
      font-size: 13px;
      min-height: 18px;
      color: var(--muted);
      white-space: pre-wrap;
    }

    /* Pads */
    .grid{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }
    .pad{
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      padding: 12px 12px;
      cursor: pointer;
      user-select:none;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      min-height: 86px;
    }
    .pad:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
    .pad.on{
      background: rgba(52,211,153,.14);
      border-color: rgba(52,211,153,.35);
      box-shadow: 0 0 0 2px rgba(52,211,153,.18) inset;
    }
    .pad.sel{ outline: 2px solid rgba(125,211,252,.90); outline-offset: 2px; }
    .pad .top{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .pad .name{ font-weight: 1000; font-size: 13px; }
    .pad .time{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; opacity: .9; }
    .pad .meta{ margin-top: 6px; font-size: 12px; color: var(--muted); line-height:1.3; }

    /* Timeline */
    .timeline{
      margin-top: 12px;
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      padding: 10px;
    }
    .tbar{
      position: relative;
      border-radius: 12px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.08);
      overflow: hidden;
      height: 280px;
    }
    .gridline{
      position:absolute; top:0; bottom:0;
      width:1px;
      background: rgba(255,255,255,.10);
      pointer-events:none;
    }
    .laneLabel{
      position:absolute; left:8px;
      font-size: 11px;
      color: rgba(255,255,255,.55);
      font-weight: 900;
      pointer-events:none;
    }
    .lane{
      position:absolute; left:0; right:0;
      height: 14px;
      border-top: 1px solid rgba(255,255,255,.07);
      pointer-events:none;
    }
    .block{
      position:absolute;
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(52,211,153,.22);
      pointer-events:none;
    }
    .block.sel{
      background: rgba(125,211,252,.22);
      border-color: rgba(125,211,252,.35);
    }
    .playhead{
      position:absolute; top:0; bottom:0;
      width: 2px;
      background: rgba(251,191,36,.95);
      pointer-events:none;
    }

    .small{ font-size: 12px; color: var(--muted); }
    code{ color: rgba(125,211,252,.95); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>üéõÔ∏è Chopped MP3 Pad Looper</h1>
      <div class="sub">
        Same-name rule: <b>game.html</b> loads <b>game.mp3</b>. Click <b>Enable Audio</b> to decode.
        Then click pads to toggle loop ON/OFF. Timeline shows 18 lanes (pads + 2 extras).
      </div>

      <div class="row">
        <button class="btn primary" id="enable">üîä Enable Audio + Decode</button>
        <button class="btn" id="stopAll">‚èπ Stop All</button>
        <button class="btn danger" id="reset">üßπ Reset 16 equal slices</button>
        <div class="kv"><span class="small">BPM</span><input type="number" id="bpm" value="120" min="40" max="240" /></div>
        <button class="btn good" id="transport">‚ñ∂ Transport</button>
      </div>

      <div class="timeline">
        <div class="small">
          Timeline is snapped to the full song duration and split into <b>16 segments</b>.
          Active blocks show pads currently looping.
        </div>
        <div class="tbar" id="tbar">
          <div class="playhead" id="playhead" style="left:0px;"></div>
        </div>
        <div class="small" style="margin-top:8px;">
          Tip: Click pad toggles loop. Selected pad is highlighted.
        </div>
      </div>

      <div class="msg" id="msg">Ready. Click ‚ÄúEnable Audio + Decode‚Äù.</div>

      <div class="grid" id="grid"></div>

      <div class="small" style="margin-top:10px">
        Keys: <code>1‚Äì9</code> toggles pads 1‚Äì9. <code>0</code> toggles pad 10. <code>Space</code> toggles Transport. <code>Esc</code> stop all.
      </div>
    </div>
  </div>

<script>
/* =========================================================
   Same-name MP3 resolution (do not change)
========================================================= */
function mp3UrlFromHtml() {
  const url = new URL(window.location.href);
  const path = url.pathname;
  const base = path.replace(/\.html?$/i, "");
  return url.origin + base + ".mp3";
}
const $ = (id) => document.getElementById(id);
const msg = (t) => $("msg").textContent = t;
function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
function fmt(x){ return (Math.round(x*100)/100).toFixed(2); }

/* =========================================================
   Audio decode + slices
========================================================= */
let audioCtx = null;
let buffer = null;
let durationSec = 0;

const PAD_COUNT = 16;
const LANE_COUNT = 18; // requested
const STORAGE_KEY = "mp3_chop_slices_v2";

let slices = []; // length 16: {id,start,end,name,note}
let selectedPad = 0;

// toggle-loop state: each pad has a looping player instance or not
const padLoop = Array.from({length: PAD_COUNT}, () => ({
  on: false,
  src: null,
  gain: null,
  startAt: 0, // audioCtx.currentTime when started
}));

function defaultSlicesEqual(dur) {
  const step = dur / PAD_COUNT;
  return Array.from({length: PAD_COUNT}, (_, i) => ({
    id: i,
    name: `Pad ${i+1}`,
    note: "click = toggle loop",
    start: i * step,
    end: (i+1) * step
  }));
}

function loadSlices() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    const s = JSON.parse(raw);
    if (!Array.isArray(s) || s.length !== PAD_COUNT) return null;
    return s;
  } catch { return null; }
}
function saveSlices() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(slices));
}

/* =========================================================
   WebAudio: play slice as looping toggle
   Implementation: schedule repeating one-shot sources end-to-start
========================================================= */
function stopPad(i) {
  const p = padLoop[i];
  p.on = false;

  if (p.src) {
    try { p.src.stop(); } catch {}
    p.src = null;
  }
  if (p.gain) {
    try { p.gain.disconnect(); } catch {}
    p.gain = null;
  }
}

function stopAllPads() {
  for (let i=0;i<PAD_COUNT;i++) stopPad(i);
  renderPads();
  renderTimeline();
  msg("Stopped all pads.");
}

// Create and start one iteration; when it ends, re-create if still on
function startOneIteration(i) {
  const p = padLoop[i];
  if (!p.on || !audioCtx || !buffer) return;

  const s = slices[i];
  const offset = clamp(s.start, 0, durationSec);
  const dur = clamp(s.end - s.start, 0.02, durationSec);

  // create gain if needed
  if (!p.gain) {
    p.gain = audioCtx.createGain();
    p.gain.gain.value = 0.95;
    p.gain.connect(audioCtx.destination);
  }

  const src = audioCtx.createBufferSource();
  src.buffer = buffer;
  src.connect(p.gain);

  p.src = src;
  if (!p.startAt) p.startAt = audioCtx.currentTime;

  // start now with offset+duration
  try {
    src.start(0, offset, dur);
  } catch (e) {
    console.error(e);
    msg("Playback error (see console).");
    p.on = false;
    return;
  }

  // on end, schedule next loop iteration immediately (tight)
  src.onended = () => {
    if (p.on) startOneIteration(i);
  };
}

function togglePad(i) {
  if (!audioCtx || !buffer) { msg("Enable Audio + Decode first."); return; }

  // select always
  selectedPad = i;

  const p = padLoop[i];
  p.on = !p.on;

  if (p.on) {
    // start looping
    p.startAt = audioCtx.currentTime;
    startOneIteration(i);
    msg(`Pad ${i+1} ON (looping)  slice=${fmt(slices[i].start)}‚Äì${fmt(slices[i].end)}s`);
  } else {
    stopPad(i);
    msg(`Pad ${i+1} OFF`);
  }

  renderPads();
  renderTimeline();
}

/* =========================================================
   Pads UI
========================================================= */
function renderPads() {
  const grid = $("grid");
  grid.innerHTML = "";
  for (let i=0;i<PAD_COUNT;i++){
    const s = slices[i] || {start:0,end:0,name:`Pad ${i+1}`,note:""};
    const el = document.createElement("div");
    el.className = "pad" + (padLoop[i].on ? " on" : "") + (selectedPad===i ? " sel" : "");
    el.id = `pad-${i}`;
    el.innerHTML = `
      <div class="top">
        <div class="name">${s.name}</div>
        <div class="time">${fmt(s.start)} ‚Üí ${fmt(s.end)}s</div>
      </div>
      <div class="meta">${padLoop[i].on ? "üü¢ looping (click to stop)" : (s.note || "click to loop")}</div>
    `;
    el.addEventListener("click", () => togglePad(i));
    grid.appendChild(el);
  }
}

/* =========================================================
   Timeline: 18 lanes, snapped to 16 segments across full duration
   Shows active pads as blocks positioned by slice start/end.
========================================================= */
const tbar = $("tbar");
const playheadEl = $("playhead");

let rafId = null;
let transportOn = false;
let transportStartPerf = 0; // performance.now()
let transportStartSec = 0;  // seconds within the song timeline
let transportRate = 1;      // playhead speed (visual only; musical loops are per-pad)

function pxFromSec(sec) {
  const w = tbar.clientWidth;
  const dur = Math.max(0.001, durationSec || 1);
  return clamp((sec / dur) * w, 0, w);
}
function laneY(laneIdx) {
  // lanes stacked inside tbar
  const topPad = 8;
  const laneH = 14;
  return topPad + laneIdx * laneH;
}

function clearTimeline() {
  [...tbar.querySelectorAll(".gridline,.laneLabel,.lane,.block")].forEach(n => n.remove());
}

function renderTimeline() {
  clearTimeline();
  if (!durationSec) return;

  const w = tbar.clientWidth;

  // vertical grid: 16 segments across song duration
  for (let k=0;k<=16;k++){
    const x = (k/16) * w;
    const gl = document.createElement("div");
    gl.className = "gridline";
    gl.style.left = x + "px";
    tbar.appendChild(gl);
  }

  // lanes (18)
  for (let i=0;i<LANE_COUNT;i++){
    const ln = document.createElement("div");
    ln.className = "lane";
    ln.style.top = laneY(i) + "px";
    tbar.appendChild(ln);

    const label = document.createElement("div");
    label.className = "laneLabel";
    label.style.top = (laneY(i) - 2) + "px";
    label.textContent = (i < 16) ? `Pad ${i+1}` : (i===16 ? "FX" : "FILL");
    tbar.appendChild(label);
  }

  // blocks for active pads (first 16 lanes)
  for (let i=0;i<16;i++){
    if (!padLoop[i].on) continue;
    const s = slices[i];
    const left = pxFromSec(s.start);
    const right = pxFromSec(s.end);
    const block = document.createElement("div");
    block.className = "block" + (selectedPad===i ? " sel" : "");
    block.style.left = left + "px";
    block.style.width = Math.max(4, right-left) + "px";
    block.style.top = (laneY(i) + 1) + "px";
    tbar.appendChild(block);
  }

  // playhead (position handled by RAF)
  playheadEl.style.left = pxFromSec(getTransportSec()) + "px";
}

function getTransportSec() {
  if (!transportOn) return transportStartSec;
  const elapsed = (performance.now() - transportStartPerf) / 1000;
  // wrap around song duration
  return (transportStartSec + elapsed * transportRate) % Math.max(0.001, durationSec);
}

function animate() {
  // update playhead and blocks selection state
  if (durationSec) {
    playheadEl.style.left = pxFromSec(getTransportSec()) + "px";
  }
  rafId = requestAnimationFrame(animate);
}

/* =========================================================
   Decode flow
========================================================= */
async function enableAndDecode() {
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state !== "running") await audioCtx.resume();

    const url = mp3UrlFromHtml();
    msg(`Fetching MP3‚Ä¶\n${url}`);

    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} fetching MP3`);
    const arr = await res.arrayBuffer();

    msg("Decoding MP3‚Ä¶");
    buffer = await audioCtx.decodeAudioData(arr);
    durationSec = buffer.duration;

    const loaded = loadSlices();
    slices = loaded ? loaded : defaultSlicesEqual(durationSec);

    // clamp safety
    for (const s of slices) {
      s.start = clamp(s.start, 0, durationSec);
      s.end = clamp(s.end, 0, durationSec);
      if (s.end <= s.start) s.end = clamp(s.start + (durationSec/16), 0, durationSec);
    }
    saveSlices();

    // reset transport to start
    transportOn = false;
    transportStartPerf = performance.now();
    transportStartSec = 0;

    msg(`Decoded ‚úÖ duration=${durationSec.toFixed(2)}s\nClick pads to toggle looping.`);
    renderPads();
    renderTimeline();

    if (!rafId) rafId = requestAnimationFrame(animate);
  } catch (err) {
    console.error(err);
    msg("Decode failed ‚ùå\nOpen DevTools Console for details.\nCommon causes: MP3 missing / wrong name / not served by Pages.");
  }
}

/* =========================================================
   Transport: visual playhead (and future quantize anchor)
========================================================= */
function toggleTransport() {
  if (!durationSec) { msg("Decode first."); return; }
  transportOn = !transportOn;
  if (transportOn) {
    // start running from current playhead position
    transportStartSec = transportStartSec || 0;
    transportStartPerf = performance.now();
    $("transport").textContent = "‚è∏ Transport";
    msg("Transport ON (visual playhead).");
  } else {
    // freeze position
    transportStartSec = getTransportSec();
    $("transport").textContent = "‚ñ∂ Transport";
    msg("Transport paused.");
  }
}

/* =========================================================
   Reset
========================================================= */
function resetEqualSlices() {
  if (!durationSec) { msg("Decode first."); return; }
  // stop pads first
  stopAllPads();
  slices = defaultSlicesEqual(durationSec);
  saveSlices();
  renderPads();
  renderTimeline();
  msg("Reset to equal 16 slices ‚úÖ");
}

/* =========================================================
   Events
========================================================= */
$("enable").addEventListener("click", enableAndDecode);
$("stopAll").addEventListener("click", stopAllPads);
$("reset").addEventListener("click", resetEqualSlices);
$("transport").addEventListener("click", toggleTransport);

window.addEventListener("resize", () => renderTimeline());

window.addEventListener("keydown", (e) => {
  if (e.code === "Space") { e.preventDefault(); toggleTransport(); }
  if (e.key === "Escape") stopAllPads();
  const n = Number(e.key);
  if (n >= 1 && n <= 9) togglePad(n-1);
  if (e.key === "0") togglePad(9);
});

/* Initial placeholders */
slices = Array.from({length: PAD_COUNT}, (_, i) => ({
  id:i, name:`Pad ${i+1}`, note:"Enable Audio to decode",
  start:0, end:0
}));
renderPads();
msg("Ready. Click ‚ÄúEnable Audio + Decode‚Äù.");
</script>
</body>
</html>
