<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Neural Conquest ‚Äî Platonic Representation Warfare</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;font-family:'Courier New',monospace;background:#000;color:#0ff}
canvas{display:block}

/* HUD */
#hud{position:absolute;top:14px;left:14px;background:linear-gradient(135deg,rgba(0,18,36,0.92),rgba(0,30,50,0.92));border:2px solid #00d4ff;padding:14px 16px;border-radius:10px;min-width:280px;pointer-events:none;z-index:100;box-shadow:0 0 24px rgba(0,212,255,0.25)}
.hud-title{color:#00d4ff;font-size:17px;margin-bottom:6px;text-shadow:0 0 12px #00d4ff;font-weight:bold;letter-spacing:1.5px}
.hud-sub{color:#6ab8d8;font-size:10px;margin-bottom:10px;font-style:italic;opacity:.8}
.hud-row{color:#88ccff;font-size:12px;margin:5px 0;display:flex;justify-content:space-between;border-bottom:1px solid rgba(0,212,255,0.12);padding-bottom:4px}
.hud-val{color:#00ff88;font-weight:bold}
.hud-val.red{color:#ff4466}
.hud-val.gold{color:#ffd600}

/* State Info Panel */
#state-panel{position:absolute;top:14px;right:14px;background:linear-gradient(135deg,rgba(20,8,40,0.94),rgba(40,14,60,0.94));border:2px solid #c050ff;padding:14px 16px;border-radius:10px;max-width:260px;pointer-events:none;z-index:100;box-shadow:0 0 20px rgba(180,80,255,0.2)}
#state-panel .title{color:#c050ff;font-size:15px;margin-bottom:8px;text-shadow:0 0 10px #c050ff;font-weight:bold}
#state-list{font-size:11px;color:#d0b8ff;max-height:180px;overflow-y:auto}
.state-tag{display:inline-block;background:rgba(180,80,255,0.2);border:1px solid rgba(180,80,255,0.5);border-radius:4px;padding:2px 6px;margin:2px;font-size:10px;color:#e0c0ff}

/* Neural Net Panel */
#nn-panel{position:absolute;bottom:14px;right:14px;background:linear-gradient(135deg,rgba(40,30,0,0.94),rgba(50,20,0,0.94));border:2px solid #ff8800;padding:14px 16px;border-radius:10px;width:220px;pointer-events:none;z-index:100;box-shadow:0 0 20px rgba(255,136,0,0.2)}
#nn-panel .title{color:#ff8800;font-size:13px;margin-bottom:8px;text-shadow:0 0 10px #ff8800;font-weight:bold}
.nn-row{font-size:10px;color:#ffcc88;margin:3px 0;display:flex;justify-content:space-between}
.nn-bar{height:6px;background:rgba(0,0,0,0.5);border-radius:3px;overflow:hidden;margin:2px 0}
.nn-fill{height:100%;background:linear-gradient(90deg,#ff8800,#ffcc00);transition:width .3s;border-radius:3px}

/* Controls */
#ctrl{position:absolute;bottom:14px;left:14px;background:linear-gradient(135deg,rgba(0,20,10,0.94),rgba(0,40,20,0.94));border:2px solid #00ff88;padding:12px 14px;border-radius:10px;pointer-events:all;z-index:100;box-shadow:0 0 20px rgba(0,255,136,0.2)}
#ctrl .title{color:#00ff88;font-size:13px;margin-bottom:8px;text-shadow:0 0 10px #00ff88;font-weight:bold}
.cbtn{background:linear-gradient(135deg,#001a10,#003322);border:1.5px solid #00ff88;color:#00ff88;padding:7px 12px;margin:3px;cursor:pointer;border-radius:6px;font-family:'Courier New',monospace;font-size:11px;font-weight:bold;transition:all .2s;display:inline-block}
.cbtn:hover{background:linear-gradient(135deg,#00ff88,#00cc66);color:#000;box-shadow:0 0 16px #00ff88;transform:translateY(-1px)}
.cbtn.active{background:linear-gradient(135deg,#ff00ff,#ff0088);border-color:#ff00ff;color:#fff;box-shadow:0 0 16px #ff00ff}
.cbtn.on{background:linear-gradient(135deg,#00aa55,#008844);color:#fff}

/* Center message */
#msg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#00ffff;font-size:28px;text-shadow:0 0 30px #00ffff,0 0 60px rgba(0,255,255,0.3);pointer-events:none;z-index:200;opacity:0;transition:opacity .5s;font-weight:bold;text-align:center;letter-spacing:2px}
#msg.show{opacity:1}

/* Crosshair */
#crosshair{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:32px;height:32px;pointer-events:none;z-index:150;opacity:.6}
#crosshair::before,#crosshair::after{content:'';position:absolute;background:#00ffff;box-shadow:0 0 6px #00ffff}
#crosshair::before{width:2px;height:100%;left:50%;transform:translateX(-50%)}
#crosshair::after{width:100%;height:2px;top:50%;transform:translateY(-50%)}

/* Legend */
#legend{position:absolute;top:50%;right:14px;transform:translateY(30%);background:rgba(0,10,20,0.88);border:1px solid rgba(0,212,255,0.3);padding:10px 12px;border-radius:8px;pointer-events:none;z-index:90;font-size:10px}
.leg-item{display:flex;align-items:center;margin:4px 0;color:rgba(255,255,255,0.85)}
.leg-dot{width:12px;height:12px;border-radius:3px;margin-right:8px;border:1px solid rgba(255,255,255,0.2)}

/* Minimap */
#minimap{position:absolute;bottom:80px;left:50%;transform:translateX(-50%);pointer-events:none;z-index:90;border:1px solid rgba(0,212,255,0.4);border-radius:6px;overflow:hidden;opacity:.7}
</style>
</head>
<body>
<div id="hud">
  <div class="hud-title">‚ö° NEURAL CONQUEST</div>
  <div class="hud-sub">Platonic Representation Warfare ‚Ä¢ Claim States ‚Ä¢ Destroy Swarms</div>
  <div class="hud-row">Health <span class="hud-val" id="hp">100</span></div>
  <div class="hud-row">Shield <span class="hud-val" id="shield">50</span></div>
  <div class="hud-row">Credits <span class="hud-val gold" id="gold">500</span></div>
  <div class="hud-row">Score <span class="hud-val" id="score">0</span></div>
  <div class="hud-row">Wave <span class="hud-val" id="wave">0</span></div>
  <div class="hud-row">Enemies <span class="hud-val red" id="enemies">0</span></div>
  <div class="hud-row">States Claimed <span class="hud-val" id="claimed">0</span></div>
  <div class="hud-row">Kills <span class="hud-val" id="kills">0</span></div>
</div>

<div id="state-panel">
  <div class="title">üó∫Ô∏è TERRITORY</div>
  <div style="font-size:10px;color:#a080cc;margin-bottom:6px">Click states to claim/release</div>
  <div id="state-list"></div>
</div>

<div id="nn-panel">
  <div class="title">üß† SELF-PLAY NEURAL NET</div>
  <div style="font-size:9px;color:#cc8844;margin-bottom:6px">8-Dir Movement Weights</div>
  <div id="nn-weights"></div>
  <div class="nn-row" style="margin-top:6px;border-top:1px solid rgba(255,136,0,0.3);padding-top:4px">Mode <span id="nn-mode" style="color:#ffaa00">LEARNING</span></div>
</div>

<div id="ctrl">
  <div class="title">üéÆ CONTROLS</div>
  <div style="font-size:9px;color:#66cc88;margin-bottom:6px">WASD=Move ‚Ä¢ Mouse=Aim ‚Ä¢ Click=Fire</div>
  <button class="cbtn" id="btn-wave">üåä Spawn Wave</button>
  <button class="cbtn" id="btn-self">ü§ñ Self-Play: OFF</button>
  <br>
  <button class="cbtn" id="btn-turrets">üóº Auto-Turrets: OFF</button>
  <button class="cbtn" id="btn-reset">‚Ü∫ Reset</button>
</div>

<div id="legend">
  <div class="leg-item"><div class="leg-dot" style="background:#ff1744"></div>CNN Swarm</div>
  <div class="leg-item"><div class="leg-dot" style="background:#00e676"></div>Transformer Mesh</div>
  <div class="leg-item"><div class="leg-dot" style="background:#ffd600"></div>RNN Loop</div>
  <div class="leg-item"><div class="leg-dot" style="background:#00b0ff"></div>Bio Dendrite</div>
  <div class="leg-item"><div class="leg-dot" style="background:#ffffff"></div>Platonic Ideal (Boss)</div>
  <div class="leg-item"><div class="leg-dot" style="background:#c050ff"></div>Claimed State</div>
  <div class="leg-item"><div class="leg-dot" style="background:#00ffff"></div>Player Ship</div>
</div>

<div id="crosshair"></div>
<div id="msg"></div>
<canvas id="minimap" width="160" height="100"></canvas>

<script type="importmap">
{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js","d3-geo":"https://cdn.jsdelivr.net/npm/d3-geo@3/+esm","topojson-client":"https://cdn.jsdelivr.net/npm/topojson-client@3/+esm"}}
</script>
<script type="module">
import*as THREE from'three';
import*as d3geo from'd3-geo';
import*as topojson from'topojson-client';

// ============================================================
// GLOBALS
// ============================================================
let scene,camera,renderer,clock;
let playerShip,playerGroup;
let mapGroup,statesData=[];
let enemies=[],projectiles=[],turrets=[],particles=[];
let centralIdeal,idealGlow;

const MAP={lonMin:-125,lonMax:-66,latMin:24,latMax:50,width:22,depth:12};
const mapFloorY=-4;
let _projection,_projCx,_projCy,_projS;

// Game state
const G={
  hp:100,maxHp:100,shield:50,maxShield:50,
  gold:500,score:0,wave:0,kills:0,
  selectedStates:new Set(),
  selfPlay:false,autoTurrets:false,
  paused:false,gameOver:false
};

// Input
const keys={};
const mouse={x:0,y:0,worldX:0,worldZ:0,down:false};
const raycaster=new THREE.Raycaster();
const mouseNDC=new THREE.Vector2();

// 8-Direction Neural Net for self-play
const NN={
  // 8 directions: N,NE,E,SE,S,SW,W,NW + fire weight
  weights:[0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5],
  fireWeight:0.5,
  lr:0.08,
  dirs:[
    {x:0,z:-1},{x:1,z:-1},{x:1,z:0},{x:1,z:1},
    {x:0,z:1},{x:-1,z:1},{x:-1,z:0},{x:-1,z:-1}
  ],
  labels:['N','NE','E','SE','S','SW','W','NW'],
  history:[],maxHist:200,
  // Record player action + outcome
  record(dirIdx,fired,reward){
    this.history.push({dir:dirIdx,fired,reward,t:Date.now()});
    if(this.history.length>this.maxHist)this.history.shift();
    // Update weights based on reward
    if(dirIdx>=0&&dirIdx<8){
      this.weights[dirIdx]+=this.lr*reward;
      this.weights[dirIdx]=Math.max(0.05,Math.min(1.5,this.weights[dirIdx]));
    }
    if(fired){
      this.fireWeight+=this.lr*reward*0.5;
      this.fireWeight=Math.max(0.1,Math.min(1.2,this.fireWeight));
    }
  },
  // Choose action via softmax-ish sampling
  chooseDir(threatDir,nearestDist){
    // Bias towards threat direction for evasion or attack
    const scores=[];
    let sum=0;
    for(let i=0;i<8;i++){
      let s=this.weights[i];
      // Bonus for directions away from nearest threat if close
      if(nearestDist<15&&threatDir!==null){
        const oppIdx=(threatDir+4)%8;
        if(i===oppIdx)s*=1.8;// flee bonus
        if(Math.abs(i-oppIdx)<=1||(i===0&&oppIdx===7)||(i===7&&oppIdx===0))s*=1.3;
      }
      // Bonus for attacking direction if far enough
      if(nearestDist>8&&nearestDist<30&&threatDir!==null){
        if(i===threatDir)s*=1.4;// attack bonus
      }
      scores.push(s);
      sum+=s;
    }
    // Weighted random
    let r=Math.random()*sum,acc=0;
    for(let i=0;i<8;i++){acc+=scores[i];if(r<=acc)return i;}
    return 0;
  },
  shouldFire(nearestDist){
    if(nearestDist>50)return false;
    return Math.random()<this.fireWeight*(nearestDist<25?1.5:0.8);
  }
};

// ============================================================
// NOISE
// ============================================================
function hash2(x,y){const s=Math.sin(x*127.1+y*311.7)*43758.5453123;return s-Math.floor(s)}
function valueNoise(x,y){const ix=Math.floor(x),iy=Math.floor(y),fx=x-ix,fy=y-iy;const a=hash2(ix,iy),b=hash2(ix+1,iy),c=hash2(ix,iy+1),d=hash2(ix+1,iy+1);const ux=fx*fx*(3-2*fx),uy=fy*fy*(3-2*fy);const lerp=(p,q,t)=>p+(q-p)*t;return lerp(lerp(a,b,ux),lerp(c,d,ux),uy)}
function fbm(x,y){let f=0,amp=0.5,freq=1;for(let i=0;i<4;i++){f+=amp*valueNoise(x*freq,y*freq);freq*=2;amp*=0.5}return f}

// ============================================================
// PROJECTION
// ============================================================
function projLonLatToXZ(lon,lat){
  const p=_projection([lon,lat]);
  if(!p)return null;
  return{x:-(p[0]-_projCx)*_projS,z:(p[1]-_projCy)*_projS};
}

function lonLatToXZ(lon,lat){
  const nx=(lon-MAP.lonMin)/(MAP.lonMax-MAP.lonMin);
  const nz=(lat-MAP.latMin)/(MAP.latMax-MAP.latMin);
  return new THREE.Vector3(-(nx-0.5)*MAP.width,0,(nz-0.5)*MAP.depth);
}

// ============================================================
// LABEL SPRITE
// ============================================================
function makeLabel(text,opts={}){
  const{fontSize=36,fg='rgba(220,255,255,0.95)',glow='rgba(0,255,255,0.35)'}=opts;
  const c=document.createElement('canvas');const ctx=c.getContext('2d');
  ctx.font=`bold ${fontSize}px Courier New`;
  const m=ctx.measureText(text);const w=Math.ceil(m.width+24);const h=Math.ceil(fontSize+20);
  c.width=w;c.height=h;
  ctx.shadowColor=glow;ctx.shadowBlur=14;
  ctx.font=`bold ${fontSize}px Courier New`;ctx.textAlign='center';ctx.textBaseline='middle';
  ctx.lineWidth=5;ctx.strokeStyle='rgba(0,0,0,0.8)';ctx.strokeText(text,w/2,h/2);
  ctx.fillStyle=fg;ctx.fillText(text,w/2,h/2);
  const tex=new THREE.CanvasTexture(c);tex.minFilter=THREE.LinearFilter;
  const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false});
  const sprite=new THREE.Sprite(mat);
  sprite.scale.set(w*0.005,h*0.005,1);
  return sprite;
}

// ============================================================
// SHOW MESSAGE
// ============================================================
function showMsg(text,duration=2000){
  const el=document.getElementById('msg');
  el.textContent=text;el.classList.add('show');
  setTimeout(()=>el.classList.remove('show'),duration);
}

// ============================================================
// INIT SCENE
// ============================================================
function initScene(){
  scene=new THREE.Scene();
  scene.fog=new THREE.FogExp2(0x050818,0.008);
  clock=new THREE.Clock();

  camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,500);
  camera.position.set(0,18,14);

  renderer=new THREE.WebGLRenderer({antialias:true,powerPreference:'high-performance'});
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio,2));
  renderer.setClearColor(0x040810);
  renderer.shadowMap.enabled=true;
  renderer.shadowMap.type=THREE.PCFSoftShadowMap;
  renderer.toneMapping=THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure=1.1;
  document.body.appendChild(renderer.domElement);

  // Lights
  scene.add(new THREE.HemisphereLight(0x4488bb,0x0a0818,0.4));
  const sun=new THREE.DirectionalLight(0xffffff,1.8);
  sun.position.set(10,20,8);sun.castShadow=true;
  sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.near=1;sun.shadow.camera.far=60;
  sun.shadow.camera.left=-24;sun.shadow.camera.right=24;
  sun.shadow.camera.top=16;sun.shadow.camera.bottom=-16;
  scene.add(sun);
  scene.add(new THREE.PointLight(0x00ffff,0.8,80).translateTo?new THREE.PointLight(0x00ffff,0.8,80):(() =>{const l=new THREE.PointLight(0x00ffff,0.8,80);l.position.set(-8,6,-6);return l})());
  const rimLight=new THREE.PointLight(0xff00ff,0.4,60);rimLight.position.set(8,4,8);scene.add(rimLight);

  // Starfield
  const starGeo=new THREE.BufferGeometry();
  const starPos=new Float32Array(2000*3);
  for(let i=0;i<2000;i++){starPos[i*3]=(Math.random()-0.5)*200;starPos[i*3+1]=Math.random()*80+10;starPos[i*3+2]=(Math.random()-0.5)*200;}
  starGeo.setAttribute('position',new THREE.BufferAttribute(starPos,3));
  scene.add(new THREE.Points(starGeo,new THREE.PointsMaterial({color:0x88bbff,size:0.08,transparent:true,opacity:0.5})));
}

// ============================================================
// BUILD PLAYER
// ============================================================
function buildPlayer(){
  playerGroup=new THREE.Group();

  // Hull - sleek cyberpunk ship
  const hull=new THREE.Mesh(
    new THREE.ConeGeometry(0.6,2.4,6),
    new THREE.MeshStandardMaterial({color:0x00ddff,emissive:0x004466,emissiveIntensity:0.6,metalness:0.8,roughness:0.2})
  );
  hull.rotation.x=-Math.PI/2;
  hull.castShadow=true;
  playerGroup.add(hull);

  // Wings
  const wingGeo=new THREE.BoxGeometry(2.8,0.08,0.7);
  const wingMat=new THREE.MeshStandardMaterial({color:0x0088aa,emissive:0x003344,emissiveIntensity:0.4,metalness:0.7,roughness:0.3});
  const wing=new THREE.Mesh(wingGeo,wingMat);
  wing.position.z=0.3;wing.castShadow=true;
  playerGroup.add(wing);

  // Engine glow
  const eng=new THREE.Mesh(
    new THREE.SphereGeometry(0.25,12,12),
    new THREE.MeshBasicMaterial({color:0x00ffff,transparent:true,opacity:0.7})
  );
  eng.position.z=1.2;eng.name='engine';
  playerGroup.add(eng);

  // Shield sphere (invisible until hit)
  const shieldMesh=new THREE.Mesh(
    new THREE.SphereGeometry(1.5,16,16),
    new THREE.MeshBasicMaterial({color:0x00aaff,transparent:true,opacity:0,wireframe:true})
  );
  shieldMesh.name='shieldMesh';
  playerGroup.add(shieldMesh);

  playerGroup.position.set(0,mapFloorY+1.5,0);
  scene.add(playerGroup);

  playerShip={
    group:playerGroup,
    pos:playerGroup.position,
    vel:new THREE.Vector3(),
    speed:0.18,
    rotY:0,
    hp:G.hp,
    fireCooldown:0,
    fireRate:120,
    lastDir:-1,
    lastFired:false
  };
}

// ============================================================
// BUILD MAP
// ============================================================
async function buildMap(){
  mapGroup=new THREE.Group();
  mapGroup.position.y=mapFloorY;

  // Ocean
  const oceanGeo=new THREE.PlaneGeometry(MAP.width*1.5,MAP.depth*1.6,80,80);
  oceanGeo.rotateX(-Math.PI/2);
  const oPos=oceanGeo.attributes.position;
  for(let i=0;i<oPos.count;i++){
    const x=oPos.getX(i),z=oPos.getZ(i);
    oPos.setY(i,(fbm((x+50)*0.1,(z+50)*0.1)-0.5)*0.15);
  }
  oPos.needsUpdate=true;oceanGeo.computeVertexNormals();
  const ocean=new THREE.Mesh(oceanGeo,new THREE.MeshPhysicalMaterial({
    color:0x071830,metalness:0,roughness:0.2,transmission:0.2,thickness:0.6,
    transparent:true,opacity:0.92,clearcoat:1,clearcoatRoughness:0.2,
    emissive:0x001420,emissiveIntensity:0.5
  }));
  ocean.receiveShadow=true;ocean.name='ocean';
  mapGroup.add(ocean);

  // Base slab
  const base=new THREE.Mesh(
    new THREE.BoxGeometry(MAP.width*1.1,0.12,MAP.depth*1.1),
    new THREE.MeshStandardMaterial({color:0x0a1428,metalness:0.5,roughness:0.4,emissive:0x000a18,emissiveIntensity:0.4})
  );
  base.position.y=-0.08;base.receiveShadow=true;
  mapGroup.add(base);

  // Grid
  const grid=new THREE.GridHelper(MAP.width*1.05,24,0x00ffff,0x1a3050);
  grid.position.y=0.01;grid.material.opacity=0.12;grid.material.transparent=true;
  mapGroup.add(grid);

  // Load TopoJSON
  let topo;
  try{
    const res=await fetch('https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json',{cache:'force-cache'});
    topo=await res.json();
  }catch(e){console.error('Map load failed',e);scene.add(mapGroup);return;}

  const statesFc=topojson.feature(topo,topo.objects.states);
  const innerBorders=topojson.mesh(topo,topo.objects.states,(a,b)=>a!==b);
  const outerBorder=topojson.mesh(topo,topo.objects.states,(a,b)=>a===b);

  _projection=d3geo.geoAlbersUsa().scale(1000).translate([0,0]);

  let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
  for(const f of statesFc.features){
    const walk=(coords)=>{
      if(!coords)return;
      if(typeof coords[0]==='number'){const p=_projection(coords);if(p){minX=Math.min(minX,p[0]);maxX=Math.max(maxX,p[0]);minY=Math.min(minY,p[1]);maxY=Math.max(maxY,p[1]);}return;}
      for(const c of coords)walk(c);
    };
    walk(f.geometry.coordinates);
  }
  _projS=Math.min(MAP.width/(maxX-minX),MAP.depth/(maxY-minY))*0.98;
  _projCx=(minX+maxX)*0.5;_projCy=(minY+maxY)*0.5;

  // State names by FIPS
  const FIPS_NAMES={1:'AL',2:'AK',4:'AZ',5:'AR',6:'CA',8:'CO',9:'CT',10:'DE',11:'DC',12:'FL',13:'GA',15:'HI',16:'ID',17:'IL',18:'IN',19:'IA',20:'KS',21:'KY',22:'LA',23:'ME',24:'MD',25:'MA',26:'MI',27:'MN',28:'MS',29:'MO',30:'MT',31:'NE',32:'NV',33:'NH',34:'NJ',35:'NM',36:'NY',37:'NC',38:'ND',39:'OH',40:'OK',41:'OR',42:'PA',44:'RI',45:'SC',46:'SD',47:'TN',48:'TX',49:'UT',50:'VT',51:'VA',53:'WA',54:'WV',55:'WI',56:'WY',72:'PR'};

  // Build each state
  for(const f of statesFc.features){
    const id=Number(f.id);
    const abbr=FIPS_NAMES[id]||'??';
    const shapes=shapesFromGeometry(f.geometry);
    if(!shapes.length)continue;

    // Default: flat unselected
    const stateHeight=0.3;
    const geo=new THREE.ExtrudeGeometry(shapes,{
      depth:stateHeight,bevelEnabled:true,bevelThickness:0.015,bevelSize:0.01,bevelSegments:1,curveSegments:6
    });
    geo.rotateX(-Math.PI/2);

    // Procedural bump on top
    const pos=geo.attributes.position;
    for(let i=0;i<pos.count;i++){
      const y=pos.getY(i);
      if(y>stateHeight*0.3){
        const x=pos.getX(i),z=pos.getZ(i);
        pos.setY(i,y+fbm((x+30)*3,(z+30)*3)*0.04);
      }
    }
    pos.needsUpdate=true;geo.computeVertexNormals();

    const mat=new THREE.MeshStandardMaterial({
      color:0x1a2a44,metalness:0.3,roughness:0.55,
      emissive:0x0a1828,emissiveIntensity:0.2,
      transparent:true,opacity:0.85,side:THREE.DoubleSide
    });

    const mesh=new THREE.Mesh(geo,mat);
    mesh.receiveShadow=true;mesh.castShadow=true;
    mesh.position.y=0.02;
    mesh.userData={type:'state',fips:id,abbr,selected:false,shapes};
    mapGroup.add(mesh);

    // Compute centroid for label
    let cx=0,cz=0,cnt=0;
    for(const shape of shapes){
      const pts=shape.getPoints(8);
      for(const p of pts){cx+=p.x;cz+=p.y;cnt++;}
    }
    if(cnt>0){cx/=cnt;cz/=cnt;}

    statesData.push({mesh,fips:id,abbr,cx,cz,selected:false,income:Math.floor(Math.random()*3)+1});
  }

  // Borders
  addBorderLines(innerBorders,0x2a5070,0.25,0.05);
  addBorderLines(outerBorder,0x00aacc,0.45,0.06);

  scene.add(mapGroup);

  // Build Central Platonic Ideal
  buildPlatonicIdeal();
}

function shapesFromGeometry(geom){
  const shapes=[];
  const polys=geom.type==='Polygon'?[geom.coordinates]:geom.type==='MultiPolygon'?geom.coordinates:[];
  for(const poly of polys){
    const outerPts=[];
    for(const ll of poly[0]){const p=projLonLatToXZ(ll[0],ll[1]);if(p)outerPts.push(new THREE.Vector2(p.x,p.z));}
    if(outerPts.length<3)continue;
    const shape=new THREE.Shape(outerPts);
    for(let h=1;h<poly.length;h++){
      const holePts=[];
      for(const ll of poly[h]){const p=projLonLatToXZ(ll[0],ll[1]);if(p)holePts.push(new THREE.Vector2(p.x,p.z));}
      if(holePts.length>=3)shape.holes.push(new THREE.Path(holePts));
    }
    shapes.push(shape);
  }
  return shapes;
}

function addBorderLines(topoMesh,color,opacity,yOff){
  const coords=topoMesh.type==='MultiLineString'?topoMesh.coordinates:[topoMesh.coordinates];
  for(const ring of coords){
    const pts=[];
    for(const ll of ring){const p=projLonLatToXZ(ll[0],ll[1]);if(p)pts.push(new THREE.Vector3(p.x,yOff,-p.z));}
    if(pts.length<2)continue;
    const bg=new THREE.BufferGeometry().setFromPoints(pts);
    mapGroup.add(new THREE.Line(bg,new THREE.LineBasicMaterial({color,transparent:true,opacity})));
  }
}

// ============================================================
// STATE SELECTION
// ============================================================
function toggleState(stateObj){
  stateObj.selected=!stateObj.selected;
  const mesh=stateObj.mesh;

  if(stateObj.selected){
    G.selectedStates.add(stateObj.abbr);
    // Raise and recolor
    mesh.material.color.setHex(0xc050ff);
    mesh.material.emissive.setHex(0x6020a0);
    mesh.material.emissiveIntensity=0.5;
    mesh.material.metalness=0.5;
    mesh.material.roughness=0.3;
    mesh.material.opacity=0.95;
    mesh.position.y=0.15;// raise up

    // Re-extrude taller
    const newGeo=new THREE.ExtrudeGeometry(mesh.userData.shapes,{
      depth:0.7,bevelEnabled:true,bevelThickness:0.025,bevelSize:0.02,bevelSegments:2,curveSegments:6
    });
    newGeo.rotateX(-Math.PI/2);
    const pos=newGeo.attributes.position;
    for(let i=0;i<pos.count;i++){
      const y=pos.getY(i);
      if(y>0.3){
        const x=pos.getX(i),z=pos.getZ(i);
        pos.setY(i,y+fbm((x+20)*4,(z+20)*4)*0.08);
      }
    }
    pos.needsUpdate=true;newGeo.computeVertexNormals();
    mesh.geometry.dispose();mesh.geometry=newGeo;

    showMsg(`‚ö° ${stateObj.abbr} CLAIMED +${stateObj.income}cr/wave`,1500);
  }else{
    G.selectedStates.delete(stateObj.abbr);
    mesh.material.color.setHex(0x1a2a44);
    mesh.material.emissive.setHex(0x0a1828);
    mesh.material.emissiveIntensity=0.2;
    mesh.material.metalness=0.3;
    mesh.material.roughness=0.55;
    mesh.material.opacity=0.85;
    mesh.position.y=0.02;

    const newGeo=new THREE.ExtrudeGeometry(mesh.userData.shapes,{
      depth:0.3,bevelEnabled:true,bevelThickness:0.015,bevelSize:0.01,bevelSegments:1,curveSegments:6
    });
    newGeo.rotateX(-Math.PI/2);
    const pos=newGeo.attributes.position;
    for(let i=0;i<pos.count;i++){
      const y=pos.getY(i);
      if(y>0.15){const x=pos.getX(i),z=pos.getZ(i);pos.setY(i,y+fbm((x+30)*3,(z+30)*3)*0.04);}
    }
    pos.needsUpdate=true;newGeo.computeVertexNormals();
    mesh.geometry.dispose();mesh.geometry=newGeo;
  }
  updateStateList();
}

function updateStateList(){
  const el=document.getElementById('state-list');
  el.innerHTML='';
  if(G.selectedStates.size===0){el.innerHTML='<div style="color:#806090;font-style:italic">No states claimed yet</div>';return;}
  for(const abbr of G.selectedStates){
    el.innerHTML+=`<span class="state-tag">${abbr}</span>`;
  }
}

// ============================================================
// PLATONIC IDEAL (BOSS ENTITY)
// ============================================================
function buildPlatonicIdeal(){
  const geo=new THREE.IcosahedronGeometry(1.2,2);
  const mat=new THREE.MeshStandardMaterial({
    color:0xffffff,emissive:0xffffff,emissiveIntensity:0.5,
    metalness:0.3,roughness:0.2,transparent:true,opacity:0.85
  });
  centralIdeal=new THREE.Mesh(geo,mat);
  centralIdeal.position.set(0,mapFloorY+4,0);
  centralIdeal.castShadow=true;
  scene.add(centralIdeal);

  // Wireframe shell
  const wf=new THREE.Mesh(new THREE.IcosahedronGeometry(1.35,2),
    new THREE.MeshBasicMaterial({color:0x00ffff,wireframe:true,transparent:true,opacity:0.18}));
  centralIdeal.add(wf);

  // Glow
  idealGlow=new THREE.Mesh(
    new THREE.SphereGeometry(2.2,24,24),
    new THREE.ShaderMaterial({
      uniforms:{time:{value:0}},
      vertexShader:`varying vec3 vN;void main(){vN=normalize(normalMatrix*normal);gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}`,
      fragmentShader:`uniform float time;varying vec3 vN;void main(){float i=pow(0.75-dot(vN,vec3(0,0,1)),2.2);float p=sin(time*2.)*0.15+0.85;vec3 g=vec3(0.4,1,1)*i*p;gl_FragColor=vec4(g,i*0.5);}`,
      side:THREE.BackSide,blending:THREE.AdditiveBlending,transparent:true,depthWrite:false
    })
  );
  idealGlow.position.copy(centralIdeal.position);
  scene.add(idealGlow);
}

// ============================================================
// ENEMIES ‚Äî Neural Network Swarm Entities
// ============================================================
const ENEMY_TYPES=[
  {name:'CNN',color:0xff1744,emissive:0x880000,speed:0.06,hp:30,damage:5,score:50,gold:15},
  {name:'Transformer',color:0x00e676,emissive:0x006630,speed:0.08,hp:20,damage:3,score:30,gold:10},
  {name:'RNN',color:0xffd600,emissive:0x886600,speed:0.1,hp:15,damage:4,score:25,gold:8},
  {name:'Biological',color:0x00b0ff,emissive:0x004488,speed:0.05,hp:40,damage:6,score:60,gold:20}
];

function spawnEnemy(type,x,z){
  const t=ENEMY_TYPES[type];
  const group=new THREE.Group();

  // Body varies by type
  let bodyGeo;
  switch(type){
    case 0:// CNN - cube cluster
      bodyGeo=new THREE.BoxGeometry(0.8,0.8,0.8);break;
    case 1:// Transformer - octahedron
      bodyGeo=new THREE.OctahedronGeometry(0.5,1);break;
    case 2:// RNN - torus
      bodyGeo=new THREE.TorusGeometry(0.4,0.15,8,12);break;
    case 3:// Bio - sphere with bumps
      bodyGeo=new THREE.SphereGeometry(0.5,8,8);
      const p=bodyGeo.attributes.position;
      for(let i=0;i<p.count;i++){
        const nx=p.getX(i),ny=p.getY(i),nz=p.getZ(i);
        const bump=1+fbm(nx*5+x,nz*5+z)*0.3;
        p.setXYZ(i,nx*bump,ny*bump,nz*bump);
      }
      p.needsUpdate=true;bodyGeo.computeVertexNormals();
      break;
  }

  const waveScale=1+G.wave*0.05;
  const body=new THREE.Mesh(bodyGeo,new THREE.MeshStandardMaterial({
    color:t.color,emissive:t.emissive,emissiveIntensity:0.5,metalness:0.4,roughness:0.35
  }));
  body.castShadow=true;
  group.add(body);

  // Inner glow
  const glowMesh=new THREE.Mesh(
    new THREE.SphereGeometry(0.7,8,8),
    new THREE.MeshBasicMaterial({color:t.color,transparent:true,opacity:0.15,blending:THREE.AdditiveBlending})
  );
  group.add(glowMesh);

  group.position.set(x,mapFloorY+1.2,z);
  group.scale.setScalar(waveScale);
  scene.add(group);

  const enemy={
    group,type,
    pos:group.position,
    vel:new THREE.Vector3(),
    hp:t.hp*(1+G.wave*0.1),
    maxHp:t.hp*(1+G.wave*0.1),
    speed:t.speed*(1+G.wave*0.01),
    damage:t.damage*(1+G.wave*0.05),
    score:t.score,gold:t.gold,
    fireCooldown:0,fireRate:800+Math.random()*400,
    projSpeed:0.5+G.wave*0.02,
    range:18+G.wave*0.5
  };
  enemies.push(enemy);
  return enemy;
}

function spawnWave(){
  G.wave++;
  const count=3+G.wave*2;
  const radius=20+Math.random()*8;

  for(let i=0;i<count;i++){
    const ang=(Math.PI*2*i)/count+(Math.random()-0.5)*0.3;
    const r=radius+Math.random()*5;
    const type=Math.floor(Math.random()*4);
    const x=playerShip.pos.x+Math.cos(ang)*r;
    const z=playerShip.pos.z+Math.sin(ang)*r;
    spawnEnemy(type,x,z);
  }

  // Income from claimed states
  let income=0;
  for(const sd of statesData){
    if(sd.selected)income+=sd.income;
  }
  G.gold+=income;

  showMsg(`üåä WAVE ${G.wave} ‚Äî ${count} Hostiles${income>0?' +$'+income:''}`,2500);
}

// ============================================================
// PROJECTILES
// ============================================================
function firePlayerProjectile(){
  if(playerShip.fireCooldown>0)return;
  playerShip.fireCooldown=playerShip.fireRate;
  playerShip.lastFired=true;

  const dir=new THREE.Vector3(
    Math.sin(playerShip.rotY),0,-Math.cos(playerShip.rotY)
  );

  const proj={
    pos:playerShip.pos.clone().add(dir.clone().multiplyScalar(1.5)),
    vel:dir.multiplyScalar(0.6),
    damage:12+G.wave*0.5,
    owner:'player',ttl:80,
    mesh:new THREE.Mesh(
      new THREE.SphereGeometry(0.12,6,6),
      new THREE.MeshBasicMaterial({color:0x00ffff})
    )
  };
  proj.mesh.position.copy(proj.pos);
  scene.add(proj.mesh);
  projectiles.push(proj);

  // Muzzle flash particle
  spawnParticle(proj.pos.clone(),0x00ffff,0.3,15);
}

function fireEnemyProjectile(enemy){
  if(enemy.fireCooldown>0)return;
  enemy.fireCooldown=enemy.fireRate;

  const dir=new THREE.Vector3().subVectors(playerShip.pos,enemy.pos).setY(0).normalize();
  const t=ENEMY_TYPES[enemy.type];

  const proj={
    pos:enemy.pos.clone(),
    vel:dir.multiplyScalar(enemy.projSpeed),
    damage:enemy.damage,
    owner:'enemy',ttl:100,
    mesh:new THREE.Mesh(
      new THREE.SphereGeometry(0.1,6,6),
      new THREE.MeshBasicMaterial({color:t.color})
    )
  };
  proj.mesh.position.copy(proj.pos);
  scene.add(proj.mesh);
  projectiles.push(proj);
}

// ============================================================
// TURRETS (on claimed states)
// ============================================================
function spawnTurretsOnStates(){
  // Remove old turrets
  for(const t of turrets){scene.remove(t.mesh);}
  turrets.length=0;

  for(const sd of statesData){
    if(!sd.selected)continue;
    const group=new THREE.Group();
    const base=new THREE.Mesh(
      new THREE.CylinderGeometry(0.3,0.4,0.5,8),
      new THREE.MeshStandardMaterial({color:0x00ff88,emissive:0x004422,emissiveIntensity:0.4,metalness:0.6,roughness:0.3})
    );
    group.add(base);
    const barrel=new THREE.Mesh(
      new THREE.CylinderGeometry(0.06,0.08,0.8,6),
      new THREE.MeshStandardMaterial({color:0x88ffcc,metalness:0.7,roughness:0.2})
    );
    barrel.rotation.z=Math.PI/2;barrel.position.y=0.4;
    group.add(barrel);

    group.position.set(sd.cx,mapFloorY+0.5,-sd.cz);
    scene.add(group);

    turrets.push({
      mesh:group,pos:group.position,
      range:12,damage:8+G.wave*0.3,fireRate:500,fireCooldown:0,projSpeed:0.5
    });
  }
}

function updateTurrets(dt){
  for(const t of turrets){
    t.fireCooldown=Math.max(0,t.fireCooldown-dt*1000);
    if(t.fireCooldown>0)continue;

    // Find nearest enemy
    let nearest=null,bestD=Infinity;
    for(const e of enemies){
      const d=t.pos.distanceTo(e.pos);
      if(d<t.range&&d<bestD){bestD=d;nearest=e;}
    }
    if(!nearest)continue;

    t.fireCooldown=t.fireRate;
    const dir=new THREE.Vector3().subVectors(nearest.pos,t.pos).setY(0).normalize();
    const proj={
      pos:t.pos.clone(),
      vel:dir.multiplyScalar(t.projSpeed),
      damage:t.damage,owner:'turret',ttl:60,
      mesh:new THREE.Mesh(new THREE.SphereGeometry(0.08,4,4),new THREE.MeshBasicMaterial({color:0x00ff88}))
    };
    proj.mesh.position.copy(proj.pos);
    scene.add(proj.mesh);
    projectiles.push(proj);
  }
}

// ============================================================
// PARTICLES
// ============================================================
function spawnParticle(pos,color,size,life){
  const mesh=new THREE.Mesh(
    new THREE.SphereGeometry(size,4,4),
    new THREE.MeshBasicMaterial({color,transparent:true,opacity:0.8,blending:THREE.AdditiveBlending})
  );
  mesh.position.copy(pos);
  scene.add(mesh);
  particles.push({mesh,life,maxLife:life,vel:new THREE.Vector3((Math.random()-0.5)*0.1,Math.random()*0.05,(Math.random()-0.5)*0.1)});
}

function spawnExplosion(pos,color,count=8){
  for(let i=0;i<count;i++){
    const m=new THREE.Mesh(
      new THREE.SphereGeometry(0.1+Math.random()*0.15,4,4),
      new THREE.MeshBasicMaterial({color,transparent:true,opacity:0.9,blending:THREE.AdditiveBlending})
    );
    m.position.copy(pos);
    scene.add(m);
    particles.push({
      mesh:m,life:20+Math.random()*15,maxLife:35,
      vel:new THREE.Vector3((Math.random()-0.5)*0.15,Math.random()*0.1,(Math.random()-0.5)*0.15)
    });
  }
}

function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.life--;
    p.mesh.position.add(p.vel);
    p.mesh.material.opacity=(p.life/p.maxLife)*0.8;
    p.mesh.scale.multiplyScalar(0.97);
    if(p.life<=0){
      scene.remove(p.mesh);
      p.mesh.geometry.dispose();p.mesh.material.dispose();
      particles.splice(i,1);
    }
  }
}

// ============================================================
// PLAYER INPUT + MOVEMENT
// ============================================================
function updatePlayer(dt){
  const spd=playerShip.speed;
  let moveX=0,moveZ=0;
  let dirIdx=-1;

  if(!G.selfPlay){
    if(keys['KeyW']||keys['ArrowUp'])moveZ-=1;
    if(keys['KeyS']||keys['ArrowDown'])moveZ+=1;
    if(keys['KeyA']||keys['ArrowLeft'])moveX-=1;
    if(keys['KeyD']||keys['ArrowRight'])moveX+=1;

    // Determine 8-dir index for NN recording
    if(moveX!==0||moveZ!==0){
      const ang=Math.atan2(moveX,-moveZ);// angle from North
      dirIdx=Math.round(((ang+Math.PI)/(Math.PI*2))*8)%8;
    }

    // Aim toward mouse world position
    const dx=mouse.worldX-playerShip.pos.x;
    const dz=mouse.worldZ-playerShip.pos.z;
    if(dx*dx+dz*dz>0.1){
      playerShip.rotY=Math.atan2(dx,-dz);
    }

    // Fire on click or space
    if(mouse.down||keys['Space']){
      firePlayerProjectile();
      playerShip.lastFired=true;
    }else{
      playerShip.lastFired=false;
    }
  }else{
    // SELF-PLAY: use Neural Net
    let nearestDist=999,threatDir=null;
    for(const e of enemies){
      const d=playerShip.pos.distanceTo(e.pos);
      if(d<nearestDist){
        nearestDist=d;
        const dx=e.pos.x-playerShip.pos.x;
        const dz=e.pos.z-playerShip.pos.z;
        const ang=Math.atan2(dx,-dz);
        threatDir=Math.round(((ang+Math.PI)/(Math.PI*2))*8)%8;
      }
    }

    dirIdx=NN.chooseDir(threatDir,nearestDist);
    const d=NN.dirs[dirIdx];
    moveX=d.x;moveZ=d.z;

    // Auto-aim at nearest
    if(nearestDist<50&&enemies.length>0){
      let nearest=enemies[0];
      for(const e of enemies){if(playerShip.pos.distanceTo(e.pos)<playerShip.pos.distanceTo(nearest.pos))nearest=e;}
      const dx=nearest.pos.x-playerShip.pos.x;
      const dz=nearest.pos.z-playerShip.pos.z;
      playerShip.rotY=Math.atan2(dx,-dz);
    }

    if(NN.shouldFire(nearestDist)){
      firePlayerProjectile();
      playerShip.lastFired=true;
    }else{
      playerShip.lastFired=false;
    }
  }

  // Normalize diagonal
  const len=Math.sqrt(moveX*moveX+moveZ*moveZ);
  if(len>0){moveX/=len;moveZ/=len;}

  playerShip.vel.x=moveX*spd;
  playerShip.vel.z=moveZ*spd;
  playerShip.pos.add(playerShip.vel);

  // Bounds
  playerShip.pos.x=Math.max(-MAP.width*0.7,Math.min(MAP.width*0.7,playerShip.pos.x));
  playerShip.pos.z=Math.max(-MAP.depth*0.7,Math.min(MAP.depth*0.7,playerShip.pos.z));

  playerGroup.rotation.y=playerShip.rotY;

  // Engine pulse
  const eng=playerGroup.getObjectByName('engine');
  if(eng)eng.scale.setScalar(0.8+Math.sin(Date.now()*0.01)*0.3+(len>0?0.4:0));

  playerShip.fireCooldown=Math.max(0,playerShip.fireCooldown-dt*1000);
  playerShip.lastDir=dirIdx;

  // Record for NN (reward = survived this frame)
  if(dirIdx>=0){
    // Base reward: small positive for moving
    let reward=0.01;
    // Bonus if enemies nearby and we're evading (not getting hit)
    if(enemies.length>0){
      let minD=999;
      for(const e of enemies)minD=Math.min(minD,playerShip.pos.distanceTo(e.pos));
      if(minD<10)reward+=0.02;// survived close call
      if(minD>15&&minD<30)reward+=0.01;// good positioning
    }
    NN.record(dirIdx,playerShip.lastFired,reward);
  }
}

// ============================================================
// ENEMY AI
// ============================================================
function updateEnemies(dt){
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];

    // Move toward player with slight avoidance of each other
    const toPlayer=new THREE.Vector3().subVectors(playerShip.pos,e.pos).setY(0);
    const dist=toPlayer.length();
    if(dist>0.1)toPlayer.normalize();

    // Separation from other enemies
    const sep=new THREE.Vector3();
    for(const other of enemies){
      if(other===e)continue;
      const d=e.pos.distanceTo(other.pos);
      if(d<3&&d>0){
        sep.add(new THREE.Vector3().subVectors(e.pos,other.pos).normalize().multiplyScalar(1/d));
      }
    }

    // Orbit behavior when close
    let steer=toPlayer.clone();
    if(dist<8){
      // Strafe sideways
      const perp=new THREE.Vector3(-toPlayer.z,0,toPlayer.x);
      steer.add(perp.multiplyScalar(0.7));
    }
    steer.add(sep.multiplyScalar(0.3));
    steer.normalize().multiplyScalar(e.speed);

    e.vel.lerp(steer,0.1);
    e.pos.add(e.vel);

    // Animate rotation
    e.group.rotation.y+=0.02;
    e.group.rotation.x+=0.01;

    // Fire at player
    e.fireCooldown=Math.max(0,e.fireCooldown-dt*1000);
    if(dist<e.range&&e.fireCooldown<=0){
      fireEnemyProjectile(e);
    }
  }
}

// ============================================================
// PROJECTILE + COLLISION
// ============================================================
function updateProjectiles(dt){
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    p.pos.add(p.vel);
    p.mesh.position.copy(p.pos);
    p.ttl--;

    if(p.ttl<=0){
      scene.remove(p.mesh);p.mesh.geometry.dispose();p.mesh.material.dispose();
      projectiles.splice(i,1);continue;
    }

    if(p.owner==='player'||p.owner==='turret'){
      // Check hit on enemies
      for(let j=enemies.length-1;j>=0;j--){
        const e=enemies[j];
        if(p.pos.distanceTo(e.pos)<1.2){
          e.hp-=p.damage;
          spawnParticle(p.pos.clone(),ENEMY_TYPES[e.type].color,0.2,12);

          if(e.hp<=0){
            // Killed!
            G.score+=e.score;
            G.gold+=e.gold;
            G.kills++;
            spawnExplosion(e.pos.clone(),ENEMY_TYPES[e.type].color,12);

            // NN reward: big positive for kills
            if(playerShip.lastDir>=0){
              NN.record(playerShip.lastDir,true,0.3);
            }

            scene.remove(e.group);
            enemies.splice(j,1);
          }

          scene.remove(p.mesh);p.mesh.geometry.dispose();p.mesh.material.dispose();
          projectiles.splice(i,1);
          break;
        }
      }
    }else if(p.owner==='enemy'){
      // Check hit on player
      if(p.pos.distanceTo(playerShip.pos)<1.5){
        // Shield first
        if(G.shield>0){
          G.shield=Math.max(0,G.shield-p.damage);
          const sm=playerGroup.getObjectByName('shieldMesh');
          if(sm){sm.material.opacity=0.4;setTimeout(()=>{sm.material.opacity=0;},200);}
        }else{
          G.hp=Math.max(0,G.hp-p.damage);
        }
        spawnParticle(p.pos.clone(),0xff4444,0.2,10);

        // NN negative reward for getting hit
        if(playerShip.lastDir>=0){
          NN.record(playerShip.lastDir,false,-0.15);
        }

        scene.remove(p.mesh);p.mesh.geometry.dispose();p.mesh.material.dispose();
        projectiles.splice(i,1);

        if(G.hp<=0&&!G.gameOver){
          G.gameOver=true;
          showMsg('üíÄ GAME OVER ‚Äî Score: '+G.score,5000);
        }
      }
    }
  }
}

// ============================================================
// CAMERA
// ============================================================
function updateCamera(){
  const target=new THREE.Vector3(playerShip.pos.x,playerShip.pos.y+14,playerShip.pos.z+10);
  camera.position.lerp(target,0.06);
  camera.lookAt(playerShip.pos.x,mapFloorY,playerShip.pos.z);
}

// ============================================================
// MOUSE -> WORLD POSITION
// ============================================================
const groundPlane=new THREE.Plane(new THREE.Vector3(0,1,0),-(mapFloorY+1.2));
function updateMouseWorld(){
  mouseNDC.set(mouse.x,mouse.y);
  raycaster.setFromCamera(mouseNDC,camera);
  const intersection=new THREE.Vector3();
  raycaster.ray.intersectPlane(groundPlane,intersection);
  if(intersection){
    mouse.worldX=intersection.x;
    mouse.worldZ=intersection.z;
  }
}

// ============================================================
// MINIMAP
// ============================================================
const minimapCanvas=document.getElementById('minimap');
const mctx=minimapCanvas.getContext('2d');

function drawMinimap(){
  const w=minimapCanvas.width,h=minimapCanvas.height;
  mctx.fillStyle='rgba(0,10,20,0.85)';
  mctx.fillRect(0,0,w,h);

  const scale=3;
  const cx=w/2,cy=h/2;
  const px=playerShip.pos.x,pz=playerShip.pos.z;

  // States
  for(const sd of statesData){
    const sx=(sd.cx-px*0.08)*scale+cx;
    const sy=(-sd.cz-pz*0.08)*scale+cy;
    mctx.fillStyle=sd.selected?'rgba(192,80,255,0.5)':'rgba(40,60,80,0.3)';
    mctx.fillRect(sx-1,sy-1,2,2);
  }

  // Enemies
  mctx.fillStyle='#ff4444';
  for(const e of enemies){
    const ex=(e.pos.x-px)*scale+cx;
    const ez=(e.pos.z-pz)*scale+cy;
    mctx.fillRect(ex-1,ez-1,3,3);
  }

  // Player
  mctx.fillStyle='#00ffff';
  mctx.beginPath();
  mctx.arc(cx,cy,3,0,Math.PI*2);
  mctx.fill();

  // Platonic Ideal
  mctx.fillStyle='#ffffff';
  const ix=(centralIdeal.position.x-px)*scale+cx;
  const iz=(centralIdeal.position.z-pz)*scale+cy;
  mctx.beginPath();mctx.arc(ix,iz,2,0,Math.PI*2);mctx.fill();
}

// ============================================================
// UI UPDATES
// ============================================================
function updateUI(){
  document.getElementById('hp').textContent=Math.ceil(G.hp);
  document.getElementById('hp').className='hud-val'+(G.hp<30?' red':'');
  document.getElementById('shield').textContent=Math.ceil(G.shield);
  document.getElementById('gold').textContent=G.gold;
  document.getElementById('score').textContent=G.score;
  document.getElementById('wave').textContent=G.wave;
  document.getElementById('enemies').textContent=enemies.length;
  document.getElementById('claimed').textContent=G.selectedStates.size;
  document.getElementById('kills').textContent=G.kills;

  // NN weights display
  const nnEl=document.getElementById('nn-weights');
  let html='';
  for(let i=0;i<8;i++){
    const pct=Math.min(100,Math.max(0,(NN.weights[i]/1.5)*100));
    html+=`<div class="nn-row">${NN.labels[i]}<span style="color:#ffcc00">${NN.weights[i].toFixed(2)}</span></div>`;
    html+=`<div class="nn-bar"><div class="nn-fill" style="width:${pct}%"></div></div>`;
  }
  html+=`<div class="nn-row" style="margin-top:4px">FIRE<span style="color:#ff6600">${NN.fireWeight.toFixed(2)}</span></div>`;
  const fpct=Math.min(100,Math.max(0,(NN.fireWeight/1.2)*100));
  html+=`<div class="nn-bar"><div class="nn-fill" style="width:${fpct}%;background:linear-gradient(90deg,#ff4400,#ff8800)"></div></div>`;
  nnEl.innerHTML=html;

  document.getElementById('nn-mode').textContent=G.selfPlay?'SELF-PLAY':'LEARNING';
  document.getElementById('nn-mode').style.color=G.selfPlay?'#ff00ff':'#ffaa00';
}

// ============================================================
// SELF-PLAY WAVE MANAGEMENT
// ============================================================
let selfPlayTimer=0;
function selfPlayLogic(dt){
  if(!G.selfPlay)return;
  selfPlayTimer+=dt;
  if(selfPlayTimer>8&&enemies.length<3){
    selfPlayTimer=0;
    spawnWave();
    if(G.autoTurrets)spawnTurretsOnStates();
  }
  // Auto-claim nearest unclaimed state occasionally
  if(Math.random()<0.002&&G.gold>50){
    let nearest=null,bestD=Infinity;
    for(const sd of statesData){
      if(sd.selected)continue;
      const dx=sd.cx-playerShip.pos.x;
      const dz=-sd.cz-playerShip.pos.z;
      const d=Math.sqrt(dx*dx+dz*dz);
      if(d<bestD){bestD=d;nearest=sd;}
    }
    if(nearest&&bestD<8){
      toggleState(nearest);
      G.gold-=20;
    }
  }
  // Shield regen
  if(G.shield<G.maxShield&&Math.random()<0.05){
    G.shield=Math.min(G.maxShield,G.shield+1);
  }
}

// ============================================================
// IDLE DETECTION -> AUTO SELF-PLAY
// ============================================================
let idleTimer=0;
const IDLE_THRESHOLD=15;// seconds of no input
function checkIdle(dt){
  if(Object.values(keys).some(v=>v)||mouse.down){
    idleTimer=0;
    if(G.selfPlay&&!manualSelfPlay){
      G.selfPlay=false;
      document.getElementById('btn-self').textContent='ü§ñ Self-Play: OFF';
      document.getElementById('btn-self').classList.remove('on');
      showMsg('üéÆ PLAYER CONTROL RESUMED',1500);
    }
    return;
  }
  idleTimer+=dt;
  if(idleTimer>IDLE_THRESHOLD&&!G.selfPlay&&!G.gameOver){
    G.selfPlay=true;
    document.getElementById('btn-self').textContent='ü§ñ Self-Play: ON';
    document.getElementById('btn-self').classList.add('on');
    showMsg('ü§ñ IDLE DETECTED ‚Äî Self-Play Activated',2000);
    if(enemies.length===0)spawnWave();
  }
}

let manualSelfPlay=false;

// ============================================================
// STATE CLICK DETECTION
// ============================================================
function onClickState(event){
  mouseNDC.set(
    (event.clientX/innerWidth)*2-1,
    -(event.clientY/innerHeight)*2+1
  );
  raycaster.setFromCamera(mouseNDC,camera);

  const meshes=statesData.map(s=>s.mesh);
  const hits=raycaster.intersectObjects(meshes);
  if(hits.length>0){
    const hitMesh=hits[0].object;
    const sd=statesData.find(s=>s.mesh===hitMesh);
    if(sd){
      toggleState(sd);
      if(G.autoTurrets)spawnTurretsOnStates();
      return true;
    }
  }
  return false;
}

// ============================================================
// ANIMATE PLATONIC IDEAL
// ============================================================
function animateIdeal(t){
  if(!centralIdeal)return;
  centralIdeal.rotation.y+=0.003;
  centralIdeal.rotation.x+=0.002;
  centralIdeal.position.y=mapFloorY+4+Math.sin(t*0.8)*0.3;
  if(idealGlow&&idealGlow.material.uniforms)idealGlow.material.uniforms.time.value=t;
  idealGlow.position.y=centralIdeal.position.y;
}

// ============================================================
// EVENT LISTENERS
// ============================================================
document.addEventListener('keydown',e=>{keys[e.code]=true;});
document.addEventListener('keyup',e=>{keys[e.code]=false;});
document.addEventListener('mousemove',e=>{
  mouse.x=(e.clientX/innerWidth)*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
});
document.addEventListener('mousedown',e=>{
  if(e.button===0){
    // Try state click first, then fire
    if(!onClickState(e)){
      mouse.down=true;
    }
  }
});
document.addEventListener('mouseup',e=>{if(e.button===0)mouse.down=false;});
document.addEventListener('contextmenu',e=>e.preventDefault());

document.getElementById('btn-wave').addEventListener('click',()=>{
  spawnWave();
  if(G.autoTurrets)spawnTurretsOnStates();
});

document.getElementById('btn-self').addEventListener('click',()=>{
  manualSelfPlay=!manualSelfPlay;
  G.selfPlay=manualSelfPlay;
  const btn=document.getElementById('btn-self');
  btn.textContent=G.selfPlay?'ü§ñ Self-Play: ON':'ü§ñ Self-Play: OFF';
  btn.classList.toggle('on',G.selfPlay);
  if(G.selfPlay&&enemies.length===0)spawnWave();
  showMsg(G.selfPlay?'ü§ñ SELF-PLAY ACTIVATED':'üéÆ MANUAL CONTROL',1500);
});

document.getElementById('btn-turrets').addEventListener('click',()=>{
  G.autoTurrets=!G.autoTurrets;
  const btn=document.getElementById('btn-turrets');
  btn.textContent=G.autoTurrets?'üóº Auto-Turrets: ON':'üóº Auto-Turrets: OFF';
  btn.classList.toggle('on',G.autoTurrets);
  if(G.autoTurrets)spawnTurretsOnStates();
  else{for(const t of turrets)scene.remove(t.mesh);turrets.length=0;}
});

document.getElementById('btn-reset').addEventListener('click',()=>{
  // Clear enemies
  for(const e of enemies)scene.remove(e.group);
  enemies.length=0;
  // Clear projectiles
  for(const p of projectiles){scene.remove(p.mesh);p.mesh.geometry.dispose();p.mesh.material.dispose();}
  projectiles.length=0;
  // Clear particles
  for(const p of particles){scene.remove(p.mesh);p.mesh.geometry.dispose();p.mesh.material.dispose();}
  particles.length=0;
  // Reset state
  G.hp=G.maxHp;G.shield=G.maxShield;G.gold=500;G.score=0;G.wave=0;G.kills=0;G.gameOver=false;
  playerShip.pos.set(0,mapFloorY+1.5,0);
  playerShip.vel.set(0,0,0);
  // Deselect states
  for(const sd of statesData){if(sd.selected)toggleState(sd);}
  // Reset turrets
  for(const t of turrets)scene.remove(t.mesh);turrets.length=0;
  // Reset NN
  NN.weights.fill(0.5);NN.fireWeight=0.5;NN.history.length=0;
  showMsg('‚Ü∫ RESET COMPLETE',1500);
});

window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

// ============================================================
// MAIN LOOP
// ============================================================
async function main(){
  initScene();
  buildPlayer();
  await buildMap();
  updateStateList();

  showMsg('‚ö° NEURAL CONQUEST\nWASD to move ‚Ä¢ Click to fire ‚Ä¢ Click states to claim',3500);

  let lastTime=performance.now();

  function animate(){
    requestAnimationFrame(animate);
    const now=performance.now();
    const dt=Math.min(0.05,(now-lastTime)/1000);
    lastTime=now;
    const t=clock.getElapsedTime();

    if(!G.gameOver){
      updateMouseWorld();
      checkIdle(dt);
      selfPlayLogic(dt);
      updatePlayer(dt);
      updateEnemies(dt);
      updateProjectiles(dt);
      if(G.autoTurrets)updateTurrets(dt);

      // Passive shield regen
      if(G.shield<G.maxShield&&Math.random()<0.01)G.shield=Math.min(G.maxShield,G.shield+0.5);
    }

    animateIdeal(t);
    updateParticles();
    updateCamera();
    updateUI();
    drawMinimap();

    // Animate ocean
    const ocean=scene.getObjectByName('ocean');
    if(ocean){
      const oPos=ocean.geometry.attributes.position;
      for(let i=0;i<oPos.count;i++){
        const x=oPos.getX(i),z=oPos.getZ(i);
        oPos.setY(i,(fbm((x+50+t*0.3)*0.1,(z+50)*0.1)-0.5)*0.15+Math.sin(x*0.5+t)*0.02);
      }
      oPos.needsUpdate=true;
    }

    // Animate selected states (pulse)
    for(const sd of statesData){
      if(sd.selected){
        const pulse=0.4+Math.sin(t*2+sd.fips)*0.1;
        sd.mesh.material.emissiveIntensity=pulse;
      }
    }

    renderer.render(scene,camera);
  }

  animate();
}

main();
</script>
</body>
</html>
