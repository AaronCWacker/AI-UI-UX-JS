<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Platonic Representation Hypothesis</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 100%);
    }
    canvas { display: block; }

    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      max-width: 350px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    h1 {
      margin: 0 0 10px 0;
      font-size: 20px;
      color: #00ffff;
    }
    p {
      margin: 8px 0;
      font-size: 14px;
      line-height: 1.5;
    }

    .legend {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 8px 0;
      font-size: 13px;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      margin-right: 10px;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    button {
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid #00ffff;
      color: #00ffff;
      padding: 8px 16px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.3s;
      user-select: none;
    }
    button:hover {
      background: rgba(0, 255, 255, 0.4);
      transform: translateY(-2px);
    }

    #network-info {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      max-width: 320px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-height: 80vh;
      overflow-y: auto;
    }
    #network-info h2 {
      margin: 0 0 15px 0;
      font-size: 18px;
      color: #00ffff;
    }
    .network-detail {
      display: flex;
      margin: 15px 0;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 5px;
    }
    .network-detail .legend-color {
      margin-right: 12px;
      flex-shrink: 0;
    }
    .network-detail strong {
      display: block;
      margin-bottom: 5px;
      color: #00ffff;
      font-size: 13px;
    }
    .network-detail p {
      margin: 0;
      font-size: 12px;
      line-height: 1.4;
      color: rgba(255, 255, 255, 0.9);
    }

    #hint {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 20px;
      color: rgba(255, 255, 255, 0.85);
      background: rgba(0, 0, 0, 0.35);
      padding: 10px 14px;
      border-radius: 999px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 12px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="info">
    <h1>ðŸ”® Platonic Representation Hypothesis</h1>
    <p><strong>The Theory:</strong> Different neural networks converge toward similar internal representations when learning the same task, regardless of architecture.</p>
    <p>Watch as diverse network topologies (shown as cell clusters) navigate toward a shared "ideal" representation space (the glowing center).</p>
    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background:#ff1744;"></div>
        <span><strong>CNN:</strong> Hierarchical layers, local connectivity</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#00e676;"></div>
        <span><strong>Transformer:</strong> Attention mesh, all-to-all connections</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#ffd600;"></div>
        <span><strong>RNN:</strong> Recurrent loops, temporal processing</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#00b0ff;"></div>
        <span><strong>Biological:</strong> Organic branching, dendrites</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:rgba(255,255,255,0.9);"></div>
        <span><strong>Platonic Ideal:</strong> Convergent representation</span>
      </div>
    </div>
  </div>

  <div id="network-info">
    <h2>Network Architectures</h2>
    <div class="network-detail">
      <div class="legend-color" style="background:#ff1744;"></div>
      <div>
        <strong>Convolutional Neural Networks (CNN)</strong>
        <p>Hierarchical layers with local receptive fields. Excels at spatial pattern recognition through convolution operations. Used in image processing, computer vision.</p>
      </div>
    </div>
    <div class="network-detail">
      <div class="legend-color" style="background:#00e676;"></div>
      <div>
        <strong>Transformers</strong>
        <p>Attention-based architecture with parallel processing. All nodes can attend to all others. Revolutionized NLP, powers modern large language models.</p>
      </div>
    </div>
    <div class="network-detail">
      <div class="legend-color" style="background:#ffd600;"></div>
      <div>
        <strong>Recurrent Neural Networks (RNN)</strong>
        <p>Contains feedback loops for temporal processing. Maintains hidden state across sequences. Used for time-series, language modeling.</p>
      </div>
    </div>
    <div class="network-detail">
      <div class="legend-color" style="background:#00b0ff;"></div>
      <div>
        <strong>Biological Neural Networks</strong>
        <p>Organic, dendritic structures with chemical synapses. Massively parallel, self-organizing. The original inspiration for artificial networks.</p>
      </div>
    </div>
  </div>

  <div id="controls">
    <button id="btn-reset">Reset</button>
    <button id="btn-paths">Toggle Connections</button>
    <button id="btn-trails">Toggle Trails</button>
    <button id="btn-rotate">Toggle Auto-Rotate</button>
    <button id="btn-camera">Toggle Mouse Camera</button>
  </div>

  <div id="hint">Drag to orbit â€¢ Wheel to zoom â€¢ Shift+Drag to pan (when Mouse Camera is ON)</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ===== Scene setup =====
    let scene, camera, renderer;
    let networkClusters = [];
    let centralIdeal;
    let particleSystem;
    let showConnections = true;
    let showTrails = true;
    let autoRotate = true;
    let mouseCamera = true;
    let time = 0;

    // Lightweight orbit controls (no extra imports)
    const controls = {
      isDown: false,
      button: 0,
      lastX: 0,
      lastY: 0,
      azimuth: 0.62,
      polar: 0.9,
      radius: 13,
      target: new THREE.Vector3(0, 0, 0),
      pan: new THREE.Vector3(0, 0, 0),
      damping: 0.12,
      velAz: 0,
      velPol: 0,
      velPanX: 0,
      velPanY: 0,
      update() {
        // damp velocities
        this.velAz *= (1 - this.damping);
        this.velPol *= (1 - this.damping);
        this.velPanX *= (1 - this.damping);
        this.velPanY *= (1 - this.damping);

        this.azimuth += this.velAz;
        this.polar = Math.max(0.12, Math.min(Math.PI - 0.12, this.polar + this.velPol));

        // pan in camera plane
        const panSpeed = 0.015 * this.radius;
        const right = new THREE.Vector3(1, 0, 0);
        const up = new THREE.Vector3(0, 1, 0);

        // build camera basis from spherical angles
        const dir = new THREE.Vector3(
          Math.sin(this.polar) * Math.cos(this.azimuth),
          Math.cos(this.polar),
          Math.sin(this.polar) * Math.sin(this.azimuth)
        ).normalize();
        right.crossVectors(dir, up).normalize();
        const camUp = new THREE.Vector3().crossVectors(right, dir).normalize();

        this.pan.addScaledVector(right, this.velPanX * panSpeed);
        this.pan.addScaledVector(camUp, this.velPanY * panSpeed);

        const pos = dir.multiplyScalar(this.radius).add(this.target).add(this.pan);
        camera.position.copy(pos);
        camera.lookAt(this.target.clone().add(this.pan));
      }
    };

    class NetworkCluster {
      constructor(type, color, position) {
        this.type = type;
        this.color = color;
        this.nodes = [];
        this.connections = [];
        this.group = new THREE.Group();
        this.velocity = new THREE.Vector3();
        this.originalPos = position.clone();
        this.convergenceSpeed = 0.01 + Math.random() * 0.01;
        this.orbitSpeed = 0.2 + Math.random() * 0.2;

        this.trail = null;
        this.trailPoints = [];
        this.trailMax = 90;

        this.createNetwork(type, color);
        this.group.position.copy(position);
        this.createTrail(color);
      }

      createNetwork(type, color) {
        switch (type) {
          case "CNN":
            this.createCNN(color);
            break;
          case "Transformer":
            this.createTransformer(color);
            break;
          case "RNN":
            this.createRNN(color);
            break;
          case "Biological":
            this.createBiological(color);
            break;
        }
      }

      createCNN(color) {
        const layers = [
          { count: 6, radius: 1.5 },
          { count: 4, radius: 1.0 },
          { count: 3, radius: 0.6 }
        ];

        layers.forEach((layer, layerIndex) => {
          const y = (layerIndex - 1) * 0.8;
          for (let i = 0; i < layer.count; i++) {
            const angle = (i / layer.count) * Math.PI * 2;
            const x = Math.cos(angle) * layer.radius;
            const z = Math.sin(angle) * layer.radius;
            const node = this.createNode(color, new THREE.Vector3(x, y, z));
            this.nodes.push({ mesh: node, layer: layerIndex, index: i });
          }
        });

        this.nodes.forEach((node, i) => {
          for (let j = i + 1; j < this.nodes.length; j++) {
            const other = this.nodes[j];
            if (
              other.layer === node.layer + 1 ||
              (other.layer === node.layer && Math.abs(other.index - node.index) <= 1)
            ) {
              this.createConnection(node.mesh.position, other.mesh.position, color);
            }
          }
        });
      }

      createTransformer(color) {
        const gridSize = 4;
        const spacing = 0.7;

        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const x = (i - gridSize / 2 + 0.5) * spacing;
            const y = (j - gridSize / 2 + 0.5) * spacing;
            const z = Math.sin(i * 0.5) * 0.3 + Math.cos(j * 0.5) * 0.3;
            const node = this.createNode(color, new THREE.Vector3(x, y, z));
            this.nodes.push({ mesh: node, x: i, y: j });
          }
        }

        this.nodes.forEach((node, i) => {
          const numConnections = 3 + Math.floor(Math.random() * 3);
          for (let c = 0; c < numConnections; c++) {
            const targetIndex = Math.floor(Math.random() * this.nodes.length);
            if (targetIndex !== i) {
              this.createConnection(node.mesh.position, this.nodes[targetIndex].mesh.position, color, 0.15);
            }
          }
        });
      }

      createRNN(color) {
        const nodeCount = 8;
        const radius = 1.2;

        for (let i = 0; i < nodeCount; i++) {
          const angle = (i / nodeCount) * Math.PI * 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius * 0.5;
          const z = Math.sin(angle) * radius;
          const node = this.createNode(color, new THREE.Vector3(x, y, z));
          this.nodes.push({ mesh: node, index: i });
        }

        this.nodes.forEach((node, i) => {
          const nextIndex = (i + 1) % this.nodes.length;
          this.createConnection(node.mesh.position, this.nodes[nextIndex].mesh.position, color);

          if (i % 2 === 0) {
            const loopPoint = node.mesh.position.clone();
            loopPoint.y += 0.5;
            this.createConnection(node.mesh.position, loopPoint, color, 0.2);
          }
        });
      }

      createBiological(color) {
        const center = new THREE.Vector3(0, 0, 0);
        const centerNode = this.createNode(color, center);
        this.nodes.push({ mesh: centerNode, generation: 0 });

        const createBranch = (parentPos, generation, maxGen) => {
          if (generation >= maxGen) return;
          const branches = generation === 0 ? 4 : 2 + Math.floor(Math.random() * 2);

          for (let i = 0; i < branches; i++) {
            const angle = Math.random() * Math.PI * 2;
            const elevation = (Math.random() - 0.5) * Math.PI * 0.6;
            const distance = 0.5 + Math.random() * 0.5;

            const newPos = new THREE.Vector3(
              parentPos.x + Math.cos(angle) * Math.cos(elevation) * distance,
              parentPos.y + Math.sin(elevation) * distance,
              parentPos.z + Math.sin(angle) * Math.cos(elevation) * distance
            );

            const node = this.createNode(color, newPos, 0.08 / (generation + 1));
            this.nodes.push({ mesh: node, generation: generation + 1 });
            this.createConnection(parentPos, newPos, color, 0.15);

            if (Math.random() > 0.3) createBranch(newPos, generation + 1, maxGen);
          }
        };

        createBranch(center, 0, 3);
      }

      createNode(color, position, size = 0.12) {
        const geometry = new THREE.SphereGeometry(size, 10, 10);
        const material = new THREE.MeshPhongMaterial({
          color,
          emissive: color,
          emissiveIntensity: 0.5,
          transparent: true,
          opacity: 0.92
        });
        const node = new THREE.Mesh(geometry, material);
        node.position.copy(position);
        node.userData.baseScale = 1;
        node.userData.pulseOffset = Math.random() * Math.PI * 2;
        this.group.add(node);
        return node;
      }

      createConnection(pos1, pos2, color, opacity = 0.3) {
        const points = [pos1.clone(), pos2.clone()];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({
          color,
          transparent: true,
          opacity
        });
        const line = new THREE.Line(geometry, material);
        line.visible = showConnections;
        this.group.add(line);
        this.connections.push(line);
      }

      createTrail(color) {
        const geo = new THREE.BufferGeometry();
        const max = this.trailMax;
        const positions = new Float32Array(max * 3);
        geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        geo.setDrawRange(0, 0);
        const mat = new THREE.LineBasicMaterial({
          color,
          transparent: true,
          opacity: 0.18
        });
        this.trail = new THREE.Line(geo, mat);
        this.trail.visible = showTrails;
        scene.add(this.trail);
      }

      pushTrailPoint(worldPos) {
        this.trailPoints.push(worldPos.clone());
        if (this.trailPoints.length > this.trailMax) this.trailPoints.shift();

        const attr = this.trail.geometry.getAttribute("position");
        for (let i = 0; i < this.trailPoints.length; i++) {
          const p = this.trailPoints[i];
          attr.setXYZ(i, p.x, p.y, p.z);
        }
        attr.needsUpdate = true;
        this.trail.geometry.setDrawRange(0, this.trailPoints.length);
      }

      setConnectionsVisible(v) {
        this.connections.forEach(l => (l.visible = v));
      }

      setTrailVisible(v) {
        if (this.trail) this.trail.visible = v;
      }

      reset() {
        this.group.position.copy(this.originalPos);
        this.velocity.set(0, 0, 0);
        this.trailPoints = [];
        if (this.trail) this.trail.geometry.setDrawRange(0, 0);
      }

      update(deltaTime, idx) {
        // pulse nodes
        for (const node of this.nodes) {
          const pulse = Math.sin(time * 2 + node.mesh.userData.pulseOffset) * 0.2 + 1;
          node.mesh.scale.setScalar(node.mesh.userData.baseScale * pulse);
        }

        // subtle internal rotation
        this.group.rotation.y += 0.005;
        this.group.rotation.x += 0.002;

        // converge + orbit
        const toCenter = new THREE.Vector3(0, 0, 0).sub(this.group.position);
        const distance = toCenter.length();

        if (distance > 3) {
          toCenter.normalize().multiplyScalar(this.convergenceSpeed);
          this.velocity.add(toCenter);
        }

        const ang = time * this.orbitSpeed;
        this.velocity.x += Math.cos(ang + idx) * 0.008;
        this.velocity.z += Math.sin(ang + idx) * 0.008;

        this.velocity.multiplyScalar(0.96);
        this.group.position.add(this.velocity);

        // trail (world pos)
        if (showTrails) this.pushTrailPoint(this.group.position);
      }
    }

    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0a0a1a, 10, 55);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x0a0a1a, 1);
      document.body.appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));

      const key = new THREE.PointLight(0xffffff, 1.5, 120);
      key.position.set(0, 0, 0);
      scene.add(key);

      const rim = new THREE.PointLight(0x00ffff, 0.55, 70);
      rim.position.set(6, 6, 6);
      scene.add(rim);

      // Central ideal
      const idealGeometry = new THREE.IcosahedronGeometry(0.8, 1);
      const idealMaterial = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 0.55,
        transparent: true,
        opacity: 0.92
      });
      centralIdeal = new THREE.Mesh(idealGeometry, idealMaterial);
      scene.add(centralIdeal);

      const wireframeGeo = new THREE.IcosahedronGeometry(0.86, 1);
      const wireframeMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        wireframe: true,
        transparent: true,
        opacity: 0.28
      });
      const wireframe = new THREE.Mesh(wireframeGeo, wireframeMat);
      centralIdeal.add(wireframe);

      // Glow aura (shader)
      const glowGeometry = new THREE.SphereGeometry(1.35, 32, 32);
      const glowMaterial = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec3 vNormal;
          void main() {
            float intensity = pow(0.75 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.2);
            vec3 glow = vec3(0.5, 1.0, 1.0) * intensity;
            float pulse = sin(time * 2.0) * 0.18 + 0.82;
            gl_FragColor = vec4(glow * pulse, intensity * 0.65);
          }
        `,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        transparent: true
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.name = "idealGlow";
      scene.add(glow);

      // Particles
      createParticles();

      // Networks
      const networkTypes = [
        { name: "CNN", color: 0xff1744, count: 3 },
        { name: "Transformer", color: 0x00e676, count: 3 },
        { name: "RNN", color: 0xffd600, count: 3 },
        { name: "Biological", color: 0x00b0ff, count: 3 }
      ];

      networkTypes.forEach((type, typeIndex) => {
        for (let i = 0; i < type.count; i++) {
          const ang = typeIndex * (Math.PI / 2) + i * (Math.PI / 6);
          const radius = 7 + Math.random() * 2;
          const pos = new THREE.Vector3(
            Math.cos(ang) * radius,
            (Math.random() - 0.5) * 3,
            Math.sin(ang) * radius
          );
          const cluster = new NetworkCluster(type.name, type.color, pos);
          scene.add(cluster.group);
          networkClusters.push(cluster);
        }
      });

      // UI
      wireUI();

      // initial camera
      controls.update();

      window.addEventListener("resize", onWindowResize, false);
      bindPointerControls();
    }

    function createParticles() {
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 900;
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 60;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 60;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
      }

      particleGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const particleMaterial = new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 0.05,
        transparent: true,
        opacity: 0.35
      });

      particleSystem = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particleSystem);
    }

    function animate() {
      requestAnimationFrame(animate);
      const deltaTime = 0.016;
      time += deltaTime;

      // update glow shader
      const glow = scene.getObjectByName("idealGlow");
      if (glow && glow.material && glow.material.uniforms && glow.material.uniforms.time) {
        glow.material.uniforms.time.value = time;
      }

      // update networks
      for (let i = 0; i < networkClusters.length; i++) {
        networkClusters[i].update(deltaTime, i);
      }

      // central ideal rotation
      centralIdeal.rotation.y += 0.007;
      centralIdeal.rotation.x += 0.004;

      // particle drift
      particleSystem.rotation.y += 0.00028;

      // camera
      if (autoRotate && !controls.isDown) {
        controls.velAz += 0.0012; // gentle auto orbit
      }
      if (mouseCamera) controls.update();
      else {
        // fallback static cinematic camera
        camera.position.x = Math.cos(time * 0.08) * 13;
        camera.position.z = Math.sin(time * 0.08) * 13;
        camera.position.y = 6 + Math.sin(time * 0.05) * 2;
        camera.lookAt(0, 0, 0);
      }

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ===== UI actions =====
    function wireUI() {
      document.getElementById("btn-reset").addEventListener("click", resetSimulation);
      document.getElementById("btn-paths").addEventListener("click", toggleConnections);
      document.getElementById("btn-trails").addEventListener("click", toggleTrails);
      document.getElementById("btn-rotate").addEventListener("click", toggleRotation);
      document.getElementById("btn-camera").addEventListener("click", toggleMouseCamera);
    }

    function resetSimulation() {
      networkClusters.forEach(c => c.reset());
    }

    function toggleConnections() {
      showConnections = !showConnections;
      networkClusters.forEach(c => c.setConnectionsVisible(showConnections));
    }

    function toggleTrails() {
      showTrails = !showTrails;
      networkClusters.forEach(c => c.setTrailVisible(showTrails));
      if (!showTrails) {
        networkClusters.forEach(c => {
          c.trailPoints = [];
          if (c.trail) c.trail.geometry.setDrawRange(0, 0);
        });
      }
    }

    function toggleRotation() {
      autoRotate = !autoRotate;
    }

    function toggleMouseCamera() {
      mouseCamera = !mouseCamera;
      document.getElementById("hint").style.display = mouseCamera ? "block" : "none";
    }

    // ===== Pointer controls =====
    function bindPointerControls() {
      const el = renderer.domElement;

      el.addEventListener("pointerdown", (e) => {
        if (!mouseCamera) return;
        controls.isDown = true;
        controls.button = e.button;
        controls.lastX = e.clientX;
        controls.lastY = e.clientY;
        el.setPointerCapture(e.pointerId);
      });

      el.addEventListener("pointermove", (e) => {
        if (!mouseCamera || !controls.isDown) return;
        const dx = e.clientX - controls.lastX;
        const dy = e.clientY - controls.lastY;
        controls.lastX = e.clientX;
        controls.lastY = e.clientY;

        const isPan = e.shiftKey || controls.button === 1 || controls.button === 2;
        if (isPan) {
          controls.velPanX += -dx * 0.0022;
          controls.velPanY += dy * 0.0022;
        } else {
          controls.velAz += -dx * 0.003;
          controls.velPol += -dy * 0.003;
        }
      });

      el.addEventListener("pointerup", (e) => {
        if (!mouseCamera) return;
        controls.isDown = false;
        try { el.releasePointerCapture(e.pointerId); } catch (_) {}
      });

      el.addEventListener("wheel", (e) => {
        if (!mouseCamera) return;
        e.preventDefault();
        const delta = Math.sign(e.deltaY);
        controls.radius = Math.max(4, Math.min(40, controls.radius + delta * 0.9));
      }, { passive: false });

      // prevent context menu
      el.addEventListener("contextmenu", (e) => e.preventDefault());
    }

    // ===== Boot =====
    init();
    animate();
  </script>
</body>
</html>
