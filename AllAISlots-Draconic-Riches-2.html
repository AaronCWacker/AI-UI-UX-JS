<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Draconic Riches: Fissure of Fire - MEGA EDITION</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Arial Black', sans-serif;
            background: radial-gradient(ellipse at center, #330000 0%, #000000 100%);
            overflow: hidden;
            touch-action: pan-x pan-y;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #game-container {
            position: fixed;
            width: 100vw;
            height: 100vh;
            display: grid;
            grid-template-rows: auto auto 1fr;
            gap: 0;
            padding: 0;
        }
        #canvas-3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            pointer-events: none;
        }
        #particles-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2;
            pointer-events: none;
        }
        #leprechaun {
            position: fixed;
            bottom: 5%; 
            left: 5%;
            width: 150px;
            height: 150px;
            z-index: 50;
            pointer-events: none;
            font-size: 100px;
            animation: leprechaunBounce 2s ease-in-out infinite, fireGlow 1.5s infinite alternate; 
            filter: drop-shadow(0 0 15px rgba(255,69,0,1));
        }
        @keyframes leprechaunBounce {
            0%, 100% { transform: translateY(0) rotate(-5deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }
        @keyframes fireGlow {
            from { box-shadow: 0 0 20px rgba(255, 69, 0, 0.8), 0 0 40px rgba(255, 140, 0, 0.5); }
            to { box-shadow: 0 0 10px rgba(255, 69, 0, 1), 0 0 30px rgba(255, 140, 0, 0.8); }
        }
        .header {
            background: linear-gradient(180deg, #333333 0%, #1a1a1a 100%);
            border-bottom: 6px solid #b22222;
            padding: 8px 10px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.8), inset 0 -3px 10px rgba(178,34,34,0.3);
            position: relative;
            z-index: 20;
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .header h1 {
            color: #ffffff;
            font-size: clamp(14px, 3vw, 24px);
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px rgba(255,69,0,0.8);
            margin: 0;
            letter-spacing: 1px;
            animation: titleGlow 2s ease-in-out infinite;
            flex: 1 1 auto;
            min-width: 200px;
            text-align: center;
        }
        @keyframes titleGlow {
            0%, 100% { text-shadow: 3px 3px 6px rgba(0,0,0,0.5), 0 0 20px rgba(255,69,0,0.8); }
            50% { text-shadow: 3px 3px 6px rgba(0,0,0,0.5), 0 0 40px rgba(255,69,0,1); }
        }
        .header-left, .header-right {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
        }
        .balance-item {
            background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(51,51,51,0.5));
            padding: 4px 10px;
            border-radius: 10px;
            color: #ff8c00;
            font-size: clamp(10px, 2vw, 13px);
            border: 2px solid rgba(255,69,0,0.5);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
            white-space: nowrap;
        }
        .balance-item span {
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #ff8c00;
        }
        .balance-item.free-spins {
            background: linear-gradient(135deg, rgba(255,69,0,0.3), rgba(255,140,0,0.2));
            border: 2px solid #ff8c00;
            animation: freeSpinPulse 1.5s infinite;
        }
        @keyframes freeSpinPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255,140,0,0.5); }
            50% { box-shadow: 0 0 20px rgba(255,140,0,1); }
        }
        .accumulation-piles {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .pile {
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(51,51,51,0.7));
            border: 2px solid #b22222;
            border-radius: 10px;
            padding: 4px 8px;
            text-align: center;
            box-shadow: 
                0 3px 10px rgba(0,0,0,0.7),
                inset 0 2px 5px rgba(255,69,0,0.2);
            transition: transform 0.3s ease;
            min-width: 70px;
        }
        .pile:hover {
            transform: scale(1.05);
        }
        .pile.pulse {
            animation: pilePulse 0.6s ease;
        }
        @keyframes pilePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); box-shadow: 0 0 30px rgba(255,69,0,0.8); }
        }
        .pile-label {
            color: #ff8c00;
            font-size: clamp(8px, 1.6vw, 10px);
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        .pile-amount {
            color: white;
            font-size: clamp(11px, 2.2vw, 14px);
            font-weight: bold;
            text-shadow: 0 0 10px #ff8c00;
        }
        .pile-icon {
            font-size: clamp(16px, 3.5vw, 22px);
            filter: drop-shadow(0 3px 6px rgba(0,0,0,0.5));
        }
        .controls-section {
            background: linear-gradient(180deg, #1a1a1a 0%, #000000 100%);
            border-bottom: 4px solid #b22222;
            padding: 8px 10px;
            position: relative;
            z-index: 20;
            box-shadow: 0 5px 15px rgba(0,0,0,0.6);
        }
        .controls {
            display: flex;
            justify-content: center;
            align-items: stretch;
            gap: 8px;
            flex-wrap: nowrap;
            max-width: 900px;
            margin: 0 auto;
        }
        .btn {
            padding: clamp(8px, 1.8vh, 14px) clamp(12px, 2.5vw, 20px);
            font-size: clamp(11px, 2.5vw, 15px);
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 
                0 4px 12px rgba(0,0,0,0.5),
                inset 0 2px 5px rgba(255,255,255,0.3);
            transition: all 0.2s ease;
            touch-action: manipulation;
            user-select: none;
            flex: 1;
            min-width: 80px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        }
        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #btn-spin {
            background: linear-gradient(135deg, #ff4500, #ff8c00);
            color: white;
            flex: 2;
        }
        #btn-spin:hover:not(:disabled) {
            background: linear-gradient(135deg, #ff6a00, #ffa500);
        }
        #btn-bet {
            background: linear-gradient(135deg, #228b22, #32cd32);
            color: white;
        }
        #btn-bet:hover {
            background: linear-gradient(135deg, #2eb82e, #3ae03a);
        }
        #btn-autoplay {
            background: linear-gradient(135deg, #4169e1, #1e90ff);
            color: white;
        }
        #btn-autoplay:hover {
            background: linear-gradient(135deg, #5179f1, #2ea0ff);
        }
        #btn-autoplay.active {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            animation: autoPulse 1s infinite;
        }
        @keyframes autoPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255,20,147,0.5); }
            50% { box-shadow: 0 0 20px rgba(255,105,180,1); }
        }
        .game-area {
            position: relative;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            overflow-y: auto;
        }
        .slot-machine {
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(51,51,51,0.6));
            border: 6px solid #b22222;
            border-radius: 20px;
            padding: 15px;
            box-shadow: 
                0 10px 40px rgba(0,0,0,0.8),
                inset 0 0 40px rgba(255,69,0,0.2);
            max-width: 90vw;
            max-height: 70vh;
        }
        #reels-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            justify-content: center;
        }
        .reel {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 60px;
        }
        .symbol {
            background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(40,40,40,0.8));
            border: 3px solid rgba(255,140,0,0.4);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(28px, 6vw, 48px);
            aspect-ratio: 1;
            min-height: 50px;
            box-shadow: 
                inset 0 2px 8px rgba(0,0,0,0.5),
                0 3px 10px rgba(0,0,0,0.6);
            transition: all 0.3s ease;
            position: relative;
        }
        .symbol.spinning {
            animation: spin 0.1s linear infinite;
        }
        @keyframes spin {
            0% { transform: translateY(0); }
            100% { transform: translateY(-100%); }
        }
        .symbol.winning {
            animation: winPulse 0.6s ease-in-out 3;
            border-color: #ffd700;
            box-shadow: 
                0 0 20px rgba(255,215,0,0.8),
                inset 0 0 20px rgba(255,215,0,0.3);
        }
        @keyframes winPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        .symbol.locked {
            border: 3px solid #ffd700;
            background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,140,0,0.2));
            box-shadow: 
                0 0 20px rgba(255,215,0,0.8),
                inset 0 0 15px rgba(255,215,0,0.4);
            animation: lockPulse 2s infinite;
        }
        @keyframes lockPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255,215,0,0.6); }
            50% { box-shadow: 0 0 30px rgba(255,215,0,1); }
        }
        .symbol.locked::after {
            content: '🔒';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 0.4em;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8));
        }
        .message-overlay {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translate(-50%, -100%) scale(0);
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(51,51,51,0.9));
            color: white;
            padding: 20px 40px;
            border-radius: 20px;
            font-size: clamp(20px, 4vw, 36px);
            font-weight: bold;
            z-index: 100;
            text-align: center;
            border: 4px solid;
            box-shadow: 0 10px 50px rgba(0,0,0,0.9);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
            max-width: 90vw;
            word-wrap: break-word;
        }
        .message-overlay.show {
            transform: translate(-50%, 0) scale(1);
            opacity: 1;
        }
        #bonus-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, rgba(255,69,0,0.95), rgba(255,140,0,0.9));
            color: white;
            padding: 40px 60px;
            border-radius: 30px;
            font-size: clamp(20px, 4vw, 36px);
            font-weight: bold;
            z-index: 100;
            text-align: center;
            border: 6px solid #ffd700;
            box-shadow: 0 15px 60px rgba(255,69,0,0.9);
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
        }
        #bonus-indicator.active {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            animation: bonusPulse 0.5s ease-in-out 3;
        }
        @keyframes bonusPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
        #bonus-reels {
            display: none;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 700px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(255,69,0,0.15), rgba(255,140,0,0.1));
            border: 4px solid rgba(255,140,0,0.5);
            border-radius: 20px;
            box-shadow: 
                0 0 30px rgba(255,140,0,0.4),
                inset 0 0 20px rgba(255,69,0,0.2);
        }
        #bonus-reels.active {
            display: flex;
        }
        .bonus-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            width: 100%;
        }
        .bonus-cell {
            background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(40,40,40,0.6));
            border: 3px solid rgba(255,140,0,0.3);
            border-radius: 15px;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(32px, 6vw, 56px);
            transition: all 0.3s ease;
            min-height: 80px;
            cursor: pointer;
        }
        .bonus-cell:hover:not(.filled) {
            background: linear-gradient(135deg, rgba(255,140,0,0.2), rgba(255,69,0,0.1));
            border-color: rgba(255,140,0,0.6);
            transform: scale(1.05);
        }
        .bonus-cell.filled {
            border-color: #ffd700;
            background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,140,0,0.2));
            animation: cellFill 0.5s ease;
        }
        @keyframes cellFill {
            0% { transform: scale(0) rotate(0deg); }
            50% { transform: scale(1.2) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }
        .bonus-cell.combo {
            animation: comboFlash 0.4s ease-in-out 6;
        }
        @keyframes comboFlash {
            0%, 100% { background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,140,0,0.2)); }
            50% { background: linear-gradient(135deg, rgba(255,69,0,0.8), rgba(255,140,0,0.6)); }
        }
        @media (max-width: 600px) {
            .header h1 {
                font-size: clamp(12px, 4vw, 18px);
            }
            .btn {
                font-size: clamp(10px, 3vw, 13px);
                padding: 6px 10px;
            }
            .symbol {
                font-size: clamp(24px, 8vw, 40px);
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas-3d"></canvas>
    <canvas id="particles-canvas"></canvas>
    <div id="leprechaun">🐉</div>
    
    <div id="game-container">
        <div class="header">
            <div class="header-content">
                <div class="header-left">
                    <div class="balance-item">
                        Balance: <span id="balance">1000</span> 💰
                    </div>
                    <div class="balance-item">
                        Bet: <span id="bet-display">10</span> 🎰
                    </div>
                </div>
                <h1>🐉 DRACONIC RICHES: MEGA FIRE 🔥</h1>
                <div class="header-right">
                    <div class="balance-item free-spins" id="free-spins-display" style="display: none;">
                        Free Spins: <span id="free-spins-count">0</span> ✨
                    </div>
                    <div class="accumulation-piles">
                        <div class="pile" id="pile-gold">
                            <div class="pile-icon">💰</div>
                            <div class="pile-label">GOLD</div>
                            <div class="pile-amount" id="pile-gold-amount">0</div>
                        </div>
                        <div class="pile" id="pile-gems">
                            <div class="pile-icon">💎</div>
                            <div class="pile-label">GEMS</div>
                            <div class="pile-amount" id="pile-gems-amount">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls-section">
            <div class="controls">
                <button id="btn-spin" class="btn">🎰 SPIN</button>
                <button id="btn-bet" class="btn">💵 BET</button>
                <button id="btn-autoplay" class="btn">⚡ AUTO</button>
            </div>
        </div>
        
        <div class="game-area">
            <div class="slot-machine">
                <div id="reels-container"></div>
                <div id="bonus-reels"></div>
            </div>
        </div>
    </div>
    
    <div id="message-overlay" class="message-overlay"></div>
    <div id="bonus-indicator">
        <h2>🐉 DRAGON'S DOMAIN BONUS! ⚔️</h2>
        <p style="font-size: clamp(14px, 3vw, 20px); margin-top: 10px;">Match 3+ adjacent symbols!</p>
        <p>Spins Remaining: <span id="bonus-spins-count">0</span></p>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Enhanced Game State
        const gameState = {
            balance: 1000,
            bet: 10,
            betOptions: [5, 10, 20, 50, 100],
            currentBetIndex: 1,
            isSpinning: false,
            autoPlay: false,
            autoPlayCount: 0,
            piles: { gold: 0, gems: 0 },
            bonusMode: false,
            bonusSpins: 0,
            bonusFilledCells: 0,
            bonusGrid: [],
            freeSpinsMode: false,
            freeSpinsCount: 0,
            lockedSymbols: []
        };
        
        // EXPANDED EMOJI SET - More variety!
        const symbols = [
            '🥚', '🗡️', '🛡️', '💰', '💎', '👑', '🔥', '🐉',
            '⚔️', '🏆', '💍', '🌟', '⭐', '🎯', '🎰', '💵',
            '🔱', '⚡', '🌋', '🦎', '🐲'
        ];
        
        const wildSymbol = '⭐';
        const megaWildSymbol = '🌟';
        
        // Payouts
        const payouts = {
            '🥚': { 3: 5, 4: 15, 5: 50 },
            '🗡️': { 3: 8, 4: 25, 5: 80 },
            '🛡️': { 3: 10, 4: 30, 5: 100 },
            '💰': { 3: 15, 4: 50, 5: 150 },
            '💎': { 3: 20, 4: 75, 5: 250 },
            '👑': { 3: 30, 4: 100, 5: 400 },
            '🔥': { 3: 50, 4: 150, 5: 600 },
            '🐉': { 3: 100, 4: 300, 5: 1000 },
            '⚔️': { 3: 12, 4: 35, 5: 110 },
            '🏆': { 3: 25, 4: 85, 5: 300 },
            '💍': { 3: 18, 4: 60, 5: 200 },
            '🎯': { 3: 10, 4: 28, 5: 90 },
            '🎰': { 3: 8, 4: 22, 5: 75 },
            '💵': { 3: 14, 4: 45, 5: 140 },
            '🔱': { 3: 40, 4: 120, 5: 500 },
            '⚡': { 3: 35, 4: 110, 5: 450 },
            '🌋': { 3: 45, 4: 140, 5: 550 },
            '🦎': { 3: 22, 4: 70, 5: 220 },
            '🐲': { 3: 80, 4: 250, 5: 900 },
            '⭐': 'wild',
            '🌟': 'megawild'
        };
        
        // Sound effects
        const sounds = {
            spin: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACA'),
            win: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACA'),
            bigwin: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACA'),
            bonus: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACA'),
            click: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACA'),
            lock: new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACA')
        };
        
        function playSound(type) {
            if (sounds[type]) {
                sounds[type].currentTime = 0;
                sounds[type].play().catch(() => {});
            }
        }
        
        // Three.js setup for 3D effects
        let scene, camera, renderer, particles = [];
        
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas-3d'),
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            for (let i = 0; i < 100; i++) {
                const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xff4500 : 0xffd700,
                    transparent: true,
                    opacity: 0.6
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02
                );
                scene.add(particle);
                particles.push(particle);
            }
            
            animate3D();
        }
        
        function animate3D() {
            requestAnimationFrame(animate3D);
            
            particles.forEach(particle => {
                particle.position.add(particle.velocity);
                particle.rotation.x += 0.01;
                particle.rotation.y += 0.01;
                
                if (Math.abs(particle.position.x) > 5) particle.velocity.x *= -1;
                if (Math.abs(particle.position.y) > 5) particle.velocity.y *= -1;
                if (Math.abs(particle.position.z) > 5) particle.velocity.z *= -1;
            });
            
            renderer.render(scene, camera);
        }
        
        // 2D Particle system
        const particlesCanvas = document.getElementById('particles-canvas');
        const ctx2D = particlesCanvas.getContext('2d');
        particlesCanvas.width = window.innerWidth;
        particlesCanvas.height = window.innerHeight;
        
        const particles2D = [];
        
        function createParticle2D(x, y, color, size) {
            particles2D.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5 - 2,
                color: color,
                size: size,
                life: 60
            });
        }
        
        function animateParticles2D() {
            ctx2D.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
            
            for (let i = particles2D.length - 1; i >= 0; i--) {
                const p = particles2D[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life--;
                
                ctx2D.globalAlpha = p.life / 60;
                ctx2D.fillStyle = p.color;
                ctx2D.beginPath();
                ctx2D.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx2D.fill();
                
                if (p.life <= 0) {
                    particles2D.splice(i, 1);
                }
            }
            
            requestAnimationFrame(animateParticles2D);
        }
        animateParticles2D();
        
        // Create 5-row reels
        function createReels() {
            const container = document.getElementById('reels-container');
            container.innerHTML = '';
            
            for (let col = 0; col < 5; col++) {
                const reel = document.createElement('div');
                reel.className = 'reel';
                reel.dataset.reel = col;
                
                for (let row = 0; row < 5; row++) {
                    const symbol = document.createElement('div');
                    symbol.className = 'symbol';
                    symbol.dataset.row = row;
                    symbol.dataset.col = col;
                    
                    // Get random symbol
                    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    symbol.textContent = randomSymbol;
                    
                    // Check if locked
                    const locked = gameState.lockedSymbols.find(
                        l => l.row === row && l.col === col
                    );
                    if (locked) {
                        symbol.textContent = locked.symbol;
                        symbol.classList.add('locked');
                    }
                    
                    reel.appendChild(symbol);
                }
                
                container.appendChild(reel);
            }
        }
        
        function updateUI() {
            document.getElementById('balance').textContent = Math.floor(gameState.balance);
            document.getElementById('bet-display').textContent = gameState.bet;
            document.getElementById('pile-gold-amount').textContent = gameState.piles.gold;
            document.getElementById('pile-gems-amount').textContent = gameState.piles.gems;
            
            if (gameState.freeSpinsMode && gameState.freeSpinsCount > 0) {
                document.getElementById('free-spins-display').style.display = 'block';
                document.getElementById('free-spins-count').textContent = gameState.freeSpinsCount;
            } else {
                document.getElementById('free-spins-display').style.display = 'none';
            }
        }
        
        function showMessage(text, color = '#FFD700') {
            const overlay = document.getElementById('message-overlay');
            overlay.textContent = text;
            overlay.style.borderColor = color;
            overlay.style.textShadow = `0 0 20px ${color}`;
            overlay.classList.add('show');
            
            setTimeout(() => {
                overlay.classList.remove('show');
            }, 1500);
        }
        
        async function spin() {
            // Handle bonus mode - just fill a cell
            if (gameState.bonusMode) {
                if (!gameState.isSpinning) {
                    fillRandomBonusCell();
                }
                return;
            }
            
            if (gameState.isSpinning) return;
            
            if (!gameState.freeSpinsMode) {
                if (gameState.balance < gameState.bet) {
                    showMessage('INSUFFICIENT GOLD!', '#FF4500');
                    gameState.autoPlay = false;
                    gameState.autoPlayCount = 0;
                    document.getElementById('btn-autoplay').classList.remove('active');
                    return;
                }
                gameState.balance -= gameState.bet;
            }
            
            gameState.isSpinning = true;
            document.getElementById('btn-spin').disabled = true;
            document.getElementById('btn-bet').disabled = true;
            
            playSound('spin');
            
            const reels = document.querySelectorAll('.reel');
            const finalSymbols = [];
            
            // Start spinning
            reels.forEach(reel => {
                const symbols = reel.querySelectorAll('.symbol');
                symbols.forEach(symbol => {
                    if (!symbol.classList.contains('locked')) {
                        symbol.classList.add('spinning');
                    }
                });
            });
            
            // Stop spinning
            for (let col = 0; col < 5; col++) {
                await new Promise(resolve => setTimeout(resolve, 200 + col * 100));
                
                const reel = reels[col];
                const symbolElements = reel.querySelectorAll('.symbol');
                const colSymbols = [];
                
                symbolElements.forEach((symbolEl, row) => {
                    symbolEl.classList.remove('spinning');
                    
                    if (!symbolEl.classList.contains('locked')) {
                        const rand = Math.random();
                        let newSymbol;
                        
                        if (rand < 0.03) {
                            newSymbol = megaWildSymbol;
                        } else if (rand < 0.08) {
                            newSymbol = wildSymbol;
                        } else {
                            newSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                        }
                        
                        symbolEl.textContent = newSymbol;
                    }
                    
                    colSymbols.push(symbolEl.textContent);
                });
                
                finalSymbols.push(colSymbols);
            }
            
            // Check wins
            const winResults = await checkWins(finalSymbols);
            
            // Update piles
            updatePiles(finalSymbols);
            
            // Handle free spins
            if (gameState.freeSpinsMode) {
                gameState.freeSpinsCount--;
                
                // If got a match during free spins, REFRESH to 3 spins (don't add)
                if (winResults.hasMatch) {
                    gameState.freeSpinsCount = 3;
                    showMessage('MATCH! FREE SPINS REFRESHED TO 3! 🔄', '#FFD700');
                    playSound('bonus');
                }
                
                if (gameState.freeSpinsCount <= 0) {
                    endFreeSpins();
                }
            }
            
            gameState.isSpinning = false;
            document.getElementById('btn-spin').disabled = false;
            document.getElementById('btn-bet').disabled = false;
            
            updateUI();
            
            if (gameState.autoPlay && gameState.autoPlayCount > 0) {
                gameState.autoPlayCount--;
                if (gameState.autoPlayCount > 0 && !gameState.bonusMode) {
                    setTimeout(() => spin(), 800);
                } else {
                    gameState.autoPlay = false;
                    document.getElementById('btn-autoplay').classList.remove('active');
                }
            }
        }
        
        async function checkWins(grid) {
            let totalWin = 0;
            const winningPositions = new Set();
            let hasFourInRow = false;
            let hasMatch = false;
            
            function isMatch(symbol1, symbol2) {
                if (symbol1 === wildSymbol || symbol1 === megaWildSymbol) return true;
                if (symbol2 === wildSymbol || symbol2 === megaWildSymbol) return true;
                return symbol1 === symbol2;
            }
            
            // Find contiguous groups of matching symbols using flood fill
            function findContiguousGroup(startCol, startRow, symbol, visited) {
                const group = [];
                const stack = [[startCol, startRow]];
                
                while (stack.length > 0) {
                    const [col, row] = stack.pop();
                    const key = `${col}-${row}`;
                    
                    if (visited.has(key)) continue;
                    if (col < 0 || col >= 5 || row < 0 || row >= 5) continue;
                    
                    const currentSymbol = grid[col][row];
                    
                    // Check if this cell matches (considering wilds)
                    if (!isMatch(symbol, currentSymbol) && !isMatch(currentSymbol, symbol)) continue;
                    
                    visited.add(key);
                    group.push([col, row]);
                    
                    // Check all 4 adjacent cells (up, down, left, right)
                    stack.push([col, row - 1]); // up
                    stack.push([col, row + 1]); // down
                    stack.push([col - 1, row]); // left
                    stack.push([col + 1, row]); // right
                }
                
                return group;
            }
            
            // Check for contiguous groups of 3 or more matching symbols
            const visited = new Set();
            
            for (let col = 0; col < 5; col++) {
                for (let row = 0; row < 5; row++) {
                    const key = `${col}-${row}`;
                    
                    if (visited.has(key)) continue;
                    
                    const symbol = grid[col][row];
                    
                    // Skip wilds as starting points - they'll be included in other groups
                    if (symbol === wildSymbol || symbol === megaWildSymbol) continue;
                    
                    const group = findContiguousGroup(col, row, symbol, visited);
                    
                    // If group has 3 or more contiguous matching symbols, it's a win!
                    if (group.length >= 3) {
                        hasMatch = true;
                        if (group.length >= 4) hasFourInRow = true;
                        
                        // Get the base symbol (non-wild)
                        let baseSymbol = symbol;
                        for (const [c, r] of group) {
                            const s = grid[c][r];
                            if (s !== wildSymbol && s !== megaWildSymbol && payouts[s]) {
                                baseSymbol = s;
                                break;
                            }
                        }
                        
                        // Calculate payout based on group size
                        const payout = payouts[baseSymbol] ? (payouts[baseSymbol][Math.min(group.length, 5)] || payouts[baseSymbol][5]) : 0;
                        totalWin += payout * gameState.bet;
                        
                        group.forEach(([c, r]) => {
                            winningPositions.add(`${c}-${r}`);
                        });
                    }
                }
            }
            
            // Count mega wilds for multiplier
            let megaWildCount = 0;
            for (let col = 0; col < 5; col++) {
                for (let row = 0; row < 5; row++) {
                    if (grid[col][row] === megaWildSymbol) {
                        megaWildCount++;
                    }
                }
            }
            
            if (megaWildCount > 0 && totalWin > 0) {
                totalWin *= (1 + megaWildCount * 0.5);
                showMessage(`MEGA WILD x${(1 + megaWildCount * 0.5).toFixed(1)}! 🌟`, '#FFD700');
                await new Promise(resolve => setTimeout(resolve, 800));
            }
            
            if (totalWin > 0) {
                // Highlight winning symbols
                winningPositions.forEach(pos => {
                    const [col, row] = pos.split('-').map(Number);
                    const symbol = document.querySelector(`[data-col="${col}"][data-row="${row}"]`);
                    if (symbol) {
                        symbol.classList.add('winning');
                        
                        const rect = symbol.getBoundingClientRect();
                        for (let i = 0; i < 15; i++) {
                            createParticle2D(
                                rect.left + rect.width / 2,
                                rect.top + rect.height / 2,
                                '#FFD700',
                                Math.random() * 3 + 2
                            );
                        }
                    }
                });
                
                if (totalWin >= gameState.bet * 20) {
                    playSound('bigwin');
                    showMessage(`🔥 MEGA WIN! +${Math.floor(totalWin)} 💰`, '#FF4500');
                } else {
                    playSound('win');
                    showMessage(`${winningPositions.size} MATCH! +${Math.floor(totalWin)} 💰`, '#FFD700');
                }
                
                gameState.balance += totalWin;
                
                await new Promise(resolve => setTimeout(resolve, 1800));
                
                document.querySelectorAll('.symbol.winning').forEach(s => {
                    s.classList.remove('winning');
                });
                
                // Lock symbols during free spins
                if (gameState.freeSpinsMode) {
                    lockWinningSymbols(winningPositions, grid);
                }
                
                // ONLY trigger bonus if 4-in-a-row and NOT in free spins mode
                if (hasFourInRow && !gameState.freeSpinsMode && !gameState.bonusMode) {
                    startFreeSpins();
                }
            }
            
            return { totalWin, hasMatch };
        }
        
        function lockWinningSymbols(positions, grid) {
            positions.forEach(pos => {
                const [col, row] = pos.split('-').map(Number);
                const symbol = grid[col][row];
                
                if (!gameState.lockedSymbols.find(l => l.row === row && l.col === col)) {
                    gameState.lockedSymbols.push({ row, col, symbol });
                    
                    const symbolElement = document.querySelector(`[data-col="${col}"][data-row="${row}"]`);
                    if (symbolElement) {
                        symbolElement.classList.add('locked');
                        playSound('lock');
                    }
                }
            });
            
            if (positions.size > 0) {
                showMessage(`${positions.size} SYMBOLS LOCKED! 🔒`, '#FFD700');
            }
        }
        
        function startFreeSpins() {
            gameState.freeSpinsMode = true;
            gameState.freeSpinsCount = 3; // Start with 3 spins
            gameState.lockedSymbols = [];
            
            playSound('bonus');
            showMessage('🎊 4-IN-A-ROW! FREE SPINS! 🎊', '#FF4500');
            
            updateUI();
        }
        
        function endFreeSpins() {
            gameState.freeSpinsMode = false;
            gameState.lockedSymbols = [];
            
            document.querySelectorAll('.symbol.locked').forEach(s => {
                s.classList.remove('locked');
            });
            
            showMessage('FREE SPINS COMPLETE! 🎉', '#FFD700');
            playSound('bigwin');
            
            updateUI();
            createReels();
        }
        
        function updatePiles(grid) {
            let goldFound = 0;
            let gemsFound = 0;
            
            for (let col = 0; col < 5; col++) {
                for (let row = 0; row < 5; row++) {
                    if (grid[col][row] === '💰') goldFound++;
                    if (grid[col][row] === '💎') gemsFound++;
                }
            }
            
            if (goldFound > 0) {
                gameState.piles.gold += goldFound;
                document.getElementById('pile-gold').classList.add('pulse');
                setTimeout(() => {
                    document.getElementById('pile-gold').classList.remove('pulse');
                }, 600);
            }
            
            if (gemsFound > 0) {
                gameState.piles.gems += gemsFound;
                document.getElementById('pile-gems').classList.add('pulse');
                setTimeout(() => {
                    document.getElementById('pile-gems').classList.remove('pulse');
                }, 600);
            }
            
            if (gameState.piles.gold >= 10) {
                triggerPileBonus('gold');
            }
            if (gameState.piles.gems >= 8) {
                triggerPileBonus('gems');
            }
        }
        
        function triggerPileBonus(type) {
            const amount = type === 'gold' ? gameState.piles.gold : gameState.piles.gems;
            const bonus = amount * gameState.bet * 5;
            
            gameState.balance += bonus;
            
            if (type === 'gold') {
                gameState.piles.gold = 0;
                showMessage(`💰 GOLD HOARD! +${bonus} 💰`, '#FFD700');
            } else {
                gameState.piles.gems = 0;
                showMessage(`💎 GEM CACHE! +${bonus} 💎`, '#00CED1');
            }
            
            playSound('bigwin');
            triggerBonus();
        }
        
        function triggerBonus() {
            gameState.bonusMode = true;
            gameState.bonusSpins = 5;
            gameState.bonusFilledCells = 0;
            
            // Stop autoplay if active
            if (gameState.autoPlay) {
                gameState.autoPlay = false;
                gameState.autoPlayCount = 0;
                document.getElementById('btn-autoplay').classList.remove('active');
            }
            
            playSound('bonus');
            
            document.getElementById('bonus-indicator').querySelector('h2').textContent = '🐉 DRAGON\'S DOMAIN BONUS! ⚔️';
            document.getElementById('bonus-indicator').classList.add('active');
            document.getElementById('bonus-spins-count').textContent = gameState.bonusSpins;
            
            // Disable buttons during transition
            document.getElementById('btn-spin').disabled = true;
            document.getElementById('btn-bet').disabled = true;
            document.getElementById('btn-autoplay').disabled = true;
            
            createBonusGrid();
            
            setTimeout(() => {
                document.getElementById('bonus-indicator').classList.remove('active');
                document.getElementById('reels-container').style.display = 'none';
                document.getElementById('bonus-reels').classList.add('active');
                
                // Re-enable spin button for bonus mode
                document.getElementById('btn-spin').disabled = false;
                
                // Show instruction message
                setTimeout(() => {
                    showMessage('CLICK SPIN TO FILL CELLS! 🎯', '#FF8C00');
                }, 500);
            }, 2500);
        }
        
        function createBonusGrid() {
            const bonusReels = document.getElementById('bonus-reels');
            bonusReels.innerHTML = '';
            gameState.bonusGrid = [];
            
            // Add title
            const title = document.createElement('div');
            title.style.cssText = `
                text-align: center;
                color: #FFD700;
                font-size: clamp(18px, 4vw, 28px);
                font-weight: bold;
                text-shadow: 0 0 10px rgba(255,215,0,0.8);
                margin-bottom: 10px;
                padding: 10px;
                background: linear-gradient(135deg, rgba(0,0,0,0.6), rgba(51,51,51,0.4));
                border-radius: 10px;
                border: 2px solid rgba(255,215,0,0.5);
            `;
            title.textContent = `🐉 DRAGON'S GRID - ${gameState.bonusSpins} SPINS LEFT 🐉`;
            title.id = 'bonus-title';
            bonusReels.appendChild(title);
            
            for (let row = 0; row < 3; row++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'bonus-row';
                const rowData = [];
                
                for (let col = 0; col < 5; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'bonus-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    rowDiv.appendChild(cell);
                    rowData.push({ filled: false, symbol: '' });
                }
                
                bonusReels.appendChild(rowDiv);
                gameState.bonusGrid.push(rowData);
            }
        }
        
        function fillRandomBonusCell() {
            const emptyCells = [];
            document.querySelectorAll('.bonus-cell:not(.filled)').forEach(cell => {
                emptyCells.push(cell);
            });
            
            if (emptyCells.length > 0 && gameState.bonusSpins > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const bonusSymbols = ['🥚', '🗡️', '🛡️', '💰', '💎', '👑', '🔥', '🐉'];
                const symbol = bonusSymbols[Math.floor(Math.random() * bonusSymbols.length)];
                
                randomCell.textContent = symbol;
                randomCell.classList.add('filled');
                gameState.bonusFilledCells++;
                
                const row = parseInt(randomCell.dataset.row);
                const col = parseInt(randomCell.dataset.col);
                gameState.bonusGrid[row][col] = { filled: true, symbol: symbol };
                
                playSound('click');
                
                const rect = randomCell.getBoundingClientRect();
                for (let i = 0; i < 15; i++) {
                    createParticle2D(
                        rect.left + rect.width / 2,
                        rect.top + rect.height / 2,
                        ['#FFD700', '#FF4500'][Math.floor(Math.random() * 2)],
                        Math.random() * 4 + 2
                    );
                }
                
                checkBonusPatterns();
                
                gameState.bonusSpins--;
                document.getElementById('bonus-spins-count').textContent = gameState.bonusSpins;
                
                // Update title
                const bonusTitle = document.getElementById('bonus-title');
                if (bonusTitle) {
                    bonusTitle.textContent = `🐉 DRAGON'S GRID - ${gameState.bonusSpins} SPINS LEFT 🐉`;
                }
                
                if (gameState.bonusSpins <= 0 || emptyCells.length === 1) {
                    setTimeout(() => endBonus(), 1500);
                }
            }
        }
        
        function checkBonusPatterns() {
            let extraSpins = 0;
            const comboCells = new Set();
            let bonusWin = 0;
            
            // Helper function to check if two cells are adjacent
            function areAdjacent(r1, c1, r2, c2) {
                const rowDiff = Math.abs(r1 - r2);
                const colDiff = Math.abs(c1 - c2);
                return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
            }
            
            // Find all contiguous groups of matching symbols
            function findContiguousGroup(startRow, startCol, symbol, visited) {
                const group = [];
                const stack = [[startRow, startCol]];
                
                while (stack.length > 0) {
                    const [row, col] = stack.pop();
                    const key = `${row}-${col}`;
                    
                    if (visited.has(key)) continue;
                    if (row < 0 || row >= 3 || col < 0 || col >= 5) continue;
                    if (!gameState.bonusGrid[row][col].filled) continue;
                    if (gameState.bonusGrid[row][col].symbol !== symbol) continue;
                    
                    visited.add(key);
                    group.push([row, col]);
                    
                    // Check all 4 adjacent cells
                    stack.push([row - 1, col]); // up
                    stack.push([row + 1, col]); // down
                    stack.push([row, col - 1]); // left
                    stack.push([row, col + 1]); // right
                }
                
                return group;
            }
            
            // Check for contiguous groups of 3 or more matching symbols
            const visited = new Set();
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 5; col++) {
                    const key = `${row}-${col}`;
                    
                    if (visited.has(key)) continue;
                    if (!gameState.bonusGrid[row][col].filled) continue;
                    
                    const symbol = gameState.bonusGrid[row][col].symbol;
                    const group = findContiguousGroup(row, col, symbol, visited);
                    
                    // If group has 3 or more contiguous matching symbols, it's a win!
                    if (group.length >= 3) {
                        extraSpins += Math.floor(group.length / 2); // More tiles = more spins
                        bonusWin += gameState.bet * group.length * 15; // Better payout for larger groups
                        
                        group.forEach(([r, c]) => {
                            comboCells.add(`${r}-${c}`);
                        });
                    }
                }
            }
            
            if (extraSpins > 0) {
                gameState.bonusSpins += extraSpins;
                gameState.balance += bonusWin;
                
                comboCells.forEach(coord => {
                    const [row, col] = coord.split('-');
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (cell) {
                        cell.classList.add('combo');
                        setTimeout(() => cell.classList.remove('combo'), 2400);
                    }
                });
                
                // Update title with new spin count
                const bonusTitle = document.getElementById('bonus-title');
                if (bonusTitle) {
                    bonusTitle.textContent = `🐉 DRAGON'S GRID - ${gameState.bonusSpins} SPINS LEFT 🐉`;
                }
                
                playSound('bigwin');
                showMessage(`🔥 ${comboCells.size} CONTIGUOUS MATCH! +${extraSpins} SPINS! +${bonusWin} 💰`, '#FF8C00');
                updateUI();
            }
        }
        
        function endBonus() {
            showMessage('BONUS COMPLETE! 🎉', '#FF4500');
            
            setTimeout(() => {
                document.getElementById('bonus-reels').classList.remove('active');
                document.getElementById('reels-container').style.display = 'grid';
                gameState.bonusMode = false;
                gameState.bonusSpins = 0;
                gameState.bonusFilledCells = 0;
                
                // Re-enable all buttons
                document.getElementById('btn-spin').disabled = false;
                document.getElementById('btn-bet').disabled = false;
                document.getElementById('btn-autoplay').disabled = false;
                
                // Ensure main reels are visible
                document.getElementById('reels-container').style.opacity = '1';
            }, 2000);
        }
        
        // Event Listeners
        document.getElementById('btn-spin').addEventListener('click', spin);
        
        document.getElementById('btn-bet').addEventListener('click', () => {
            if (gameState.freeSpinsMode) {
                showMessage('Cannot change bet during free spins!', '#FF4500');
                return;
            }
            
            playSound('click');
            gameState.currentBetIndex = (gameState.currentBetIndex + 1) % gameState.betOptions.length;
            gameState.bet = gameState.betOptions[gameState.currentBetIndex];
            updateUI();
        });
        
        document.getElementById('btn-autoplay').addEventListener('click', () => {
            playSound('click');
            
            if (gameState.autoPlay) {
                gameState.autoPlay = false;
                gameState.autoPlayCount = 0;
                document.getElementById('btn-autoplay').classList.remove('active');
            } else {
                gameState.autoPlay = true;
                gameState.autoPlayCount = 10;
                document.getElementById('btn-autoplay').classList.add('active');
                if (!gameState.isSpinning && !gameState.bonusMode) {
                    spin();
                }
            }
        });
        
        window.addEventListener('resize', () => {
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            particlesCanvas.width = window.innerWidth;
            particlesCanvas.height = window.innerHeight;
        });
        
        // Initialize
        initThreeJS();
        createReels();
        updateUI();
        
        setTimeout(() => {
            showMessage('🐉 MEGA FIRE! 🔥', '#FF4500');
        }, 500);
        
        console.log('🐉 DRACONIC RICHES: MEGA FIRE EDITION 🐉');
        console.log('✓ 5x5 GRID with CONTIGUOUS matching!');
        console.log('✓ Symbols must be ADJACENT to match (up/down/left/right)');
        console.log('✓ FREE SPINS on 4+ contiguous match (3 spins, refresh on match)');
        console.log('✓ Locked symbols during free spins');
        console.log('✓ Wildcards (⭐🌟) join any adjacent group!');
        console.log('✓ 21 different emoji symbols!');
        console.log('✓ BONUS GAME: 3+ adjacent matching tiles = rewards!');
    </script>
</body>
</html>
