<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Architecture Modeler</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .shape {
            cursor: move;
            user-select: none;
        }
        .shape-text, .shape-subtext, .shape-domain-text, .shape-mfa-text {
            pointer-events: none;
            user-select: none;
            font-size: 10px;
            font-weight: 500;
        }
         .shape-title {
            pointer-events: none;
            user-select: none;
            font-size: 12px;
            font-weight: 700;
        }
        .network-zone-title {
            pointer-events: none;
            font-size: 14px;
            font-weight: 600;
        }
        #canvas-svg {
            touch-action: none;
        }
        .connector-line, .connector-hitbox {
            stroke-width: 10;
            stroke-linecap: round;
            stroke: transparent;
            cursor: pointer;
        }
        .connector-line-visible {
             stroke-width: 2.5;
             stroke: #9ca3af; /* gray-400 */
             pointer-events: none;
        }
        .selected-connector .connector-line-visible {
            stroke: #3b82f6; /* blue-500 */
            stroke-width: 3.5;
        }
        .connector-label {
            font-size: 10px;
            font-weight: 600;
            fill: #374151; /* gray-700 */
            paint-order: stroke;
            stroke: #ffffff;
            stroke-width: 3px;
            stroke-linecap: butt;
            stroke-linejoin: miter;
        }
        .resize-handle, .connector-handle {
            fill: #3b82f6; /* blue-500 */
            stroke: white;
            stroke-width: 2px;
        }
        .resize-handle.tl, .resize-handle.br { cursor: nwse-resize; }
        .resize-handle.tr, .resize-handle.bl { cursor: nesw-resize; }
        .connector-handle { cursor: grab; }
        .connector-handle:active { cursor: grabbing; }

        #sidebar-editor input, #sidebar-editor textarea, #sidebar-editor select {
            @apply w-full bg-gray-100 border border-gray-300 rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500;
        }
         #sidebar-editor label {
            @apply text-xs font-medium text-gray-600;
        }
        .property-grid {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 0.5rem;
        }
        #selection-box {
            fill: rgba(59, 130, 246, 0.2);
            stroke: rgba(59, 130, 246, 0.8);
            stroke-width: 1;
            stroke-dasharray: 4 2;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen antialiased">

    <header class="bg-white shadow-md p-4 z-20">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-xl font-bold text-gray-800 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-indigo-600"><path d="M12 2L2 7l10 5 10-5-10-5z"></path><path d="M2 17l10 5 10-5"></path><path d="M2 12l10 5 10-5"></path></svg>
                AI Architecture Modeler
            </h1>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <aside class="w-72 bg-white p-4 shadow-lg overflow-y-auto z-10 flex flex-col">
            <h2 class="text-lg font-semibold text-gray-700 border-b pb-2">Components</h2>
            <div id="component-buttons-container" class="grid grid-cols-2 gap-2 mt-4"></div>

            <div class="mt-auto space-y-2 pt-4 border-t">
                 <button id="connect-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">Connect</button>
                 <button id="download-png-btn" class="w-full bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">Download Image</button>
                 <button id="save-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">Save Diagram</button>
                 <button id="load-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">Load Diagram</button>
                 <button id="clear-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">Clear Canvas</button>
            </div>
        </aside>

        <main class="flex-1 bg-gray-200 p-4">
            <div id="canvas-container" class="w-full h-full bg-white rounded-lg shadow-inner overflow-hidden relative">
                <svg id="canvas-svg" class="w-full h-full"></svg>
                <div id="temp-line-container" style="position: absolute; top: 0; left: 0; pointer-events: none; width: 100%; height: 100%; overflow: hidden;">
                    <svg id="temp-line-svg" width="100%" height="100%"></svg>
                </div>
            </div>
        </main>

        <aside id="sidebar-editor" class="w-96 bg-white p-4 shadow-lg overflow-y-auto z-10 border-l">
             <h2 class="text-lg font-semibold text-gray-700 border-b pb-2 mb-4">Properties</h2>
             <div id="editor-content" class="space-y-3">
                <p class="text-sm text-gray-500 text-center italic">Select an item to edit its properties.</p>
             </div>
        </aside>
    </div>
    
    <input type="file" id="file-input" class="hidden" accept=".json">

    <script>
        // --- DOM Element References ---
        const canvasContainer = document.getElementById('canvas-container');
        const svg = document.getElementById('canvas-svg');
        const componentButtonsContainer = document.getElementById('component-buttons-container');
        const connectBtn = document.getElementById('connect-btn');
        const clearBtn = document.getElementById('clear-btn');
        const saveBtn = document.getElementById('save-btn');
        const loadBtn = document.getElementById('load-btn');
        const downloadPngBtn = document.getElementById('download-png-btn');
        const fileInput = document.getElementById('file-input');
        const sidebarEditor = document.getElementById('sidebar-editor');
        const editorContent = document.getElementById('editor-content');
        const tempLineSvg = document.getElementById('temp-line-svg');

        // --- State Management ---
        let shapes = [];
        let connectors = [];
        let isDragging = false;
        let isConnecting = false;
        let isResizing = false;
        let isSelecting = false;
        let isDraggingConnectorHandle = false;
        let draggedShape = null;
        let connectionStartShape = null;
        let selectedItems = [];
        let draggedConnectorInfo = { handle: null, conn: null, end: null };
        let offset = { x: 0, y: 0 };
        let selectionBox = { x1: 0, y1: 0, x2: 0, y2: 0 };

        // --- Component Definitions ---
        const componentDefs = {
            'networkZone': {
                label: 'Network Zone', color: 'bg-gray-200', icon: 'ðŸŒ',
                properties: { name: 'domain.com', color: 'blue' },
                isZone: true,
                resizable: true,
                colors: { blue: 'fill-blue-100', green: 'fill-green-100', red: 'fill-red-100', yellow: 'fill-yellow-100', purple: 'fill-purple-100', pink: 'fill-pink-100', teal: 'fill-teal-100' }
            },
            'users': {
                label: 'Users', color: 'bg-pink-500', icon: 'ðŸ‘¤',
                properties: { role: 'User', group: 'Service' }
            },
            'webApp': {
                label: 'Web App', color: 'bg-blue-500', icon: 'ðŸ’»',
                properties: { name: 'My Web App', url: 'app.example.com' }
            },
            'firewall': {
                label: 'Firewall', color: 'bg-orange-600', icon: 'ðŸ¢ðŸ”’',
                properties: { policy: 'Default Deny', network: 'Perimeter' }
            },
            'script': {
                label: 'Script', color: 'bg-yellow-400', icon: 'ï¿½',
                properties: { name: 'deploy.ps1', targetZone: 'prod-net', mapsDrive: 'W:' }
            },
            'github': { 
                label: 'Github', color: 'bg-gray-800', icon: 'ðŸˆ', 
                properties: { url: 'github.com/repo', network: 'MS' } 
            },
            'serviceTool': { 
                label: 'Service Tool', color: 'bg-cyan-600', icon: 'ðŸ”§', 
                properties: { name: 'ServiceNow', domainLabel: 'Intranet', domain: 'tenant.com', id: '1', orgLabel: 'Client', url: 'service-now.com' } 
            },
            'vm': { 
                label: 'Virtual Machine', color: 'bg-orange-500', icon: 'ðŸ–¥ï¸', 
                properties: { type: 'VMWare', mfa: 'Azure MFA', authSet: 'RDP, Vault', hosts: 'wn, wp', networkId: 'MS 1' } 
            },
            'passwordVault': { 
                label: 'Password Vault', color: 'bg-yellow-500', icon: 'ðŸ”', 
                properties: { mfa: 'Azure MFA', url: 'vault.example.com', authDomain1: 'MS 1', authDomain2: 'MS 2' } 
            },
            'serverProd': { 
                label: 'Server (PROD)', color: 'bg-red-700', icon: 'ðŸ”©', 
                properties: { env: 'PROD', fqdn: 'prod.server.com', os: 'WINS2022', authId: 'MS 2 with Key', path: 'E:\\' } 
            },
            'serverNonProd': { 
                label: 'Server (Non-Prod)', color: 'bg-blue-700', icon: 'ðŸ”©', 
                properties: { env: 'Non-Prod', fqdn: 'dev.server.com', os: 'WINS2022', authId: 'MS 2 with Key', path: 'E:\\' } 
            },
            'driveMap': {
                label: 'Drive Map', color: 'bg-indigo-500', icon: 'ðŸš—',
                properties: { driveLetter: 'W:', server: 'Server1.domain.com', script: './Map_Drives.ps1' }
            },
            'aiApi': { 
                label: 'AI API', color: 'bg-sky-500', icon: 'ðŸ§ ðŸŒ', 
                properties: { name: 'My API', apiType: 'Azure OpenAI', model: 'GPT-4o', auth: 'URL, Key, App Reg on MS 1' },
                options: { apiType: ['Azure OpenAI', 'FastAPI', 'Custom'] }
            },
            'aiClient': { 
                label: 'AI Client', color: 'bg-sky-600', icon: 'ðŸ¤–ðŸ§ ', 
                properties: { name: 'App Client', clientType: 'Azure OpenAI Client', library: 'Azure.AI.OpenAI' },
                options: { clientType: ['Azure OpenAI Client', 'LangChain', 'Custom'] }
            },
            'aiAgent': {
                label: 'AI Agent', color: 'bg-teal-600', icon: 'ðŸ¤–',
                properties: { name: 'My Agent', agentType: 'Autonomous', task: 'Data Analysis' },
                options: { agentType: ['Autonomous', 'Tool-Using', 'Human-in-the-loop'] }
            },
            'pim': { 
                label: 'PIM', color: 'bg-purple-600', icon: 'ðŸ‘‘', 
                properties: { name: 'OC2', url: 'pim.example.com' } 
            },
            'fileShare': { 
                label: 'File Share', color: 'bg-green-600', icon: 'ðŸ“‚', 
                properties: { name: 'NFS File Dock', pathList: '/1, /2, /3, /3/Outbound', domain: 'domain.com 1' } 
            },
            'fileShareOutbound': { 
                label: 'File Share (Out)', color: 'bg-green-700', icon: 'ðŸ“¤', 
                properties: { name: 'NFS File Dock', path: '/3/Outbound', domain: 'domain.com 1' } 
            },
            'pngFile': { 
                label: 'PNG Image', color: 'bg-lime-500', icon: 'ðŸ–¼ï¸', 
                properties: { name: 'image.png', "Orientation": "Portrait", "Page Count": "2" } 
            },
            'pdfFile': { 
                label: 'PDF Document', color: 'bg-red-500', icon: 'ðŸ“„', 
                properties: { name: 'Summary Output.pdf', "Volume Per Month": "30,000", "Avg Pages Per Doc": "140", "Number of Documents in Set": "80" } 
            },
            'fullTextMdFile': { 
                label: 'FullText MD', color: 'bg-gray-500', icon: 'ðŸ“', 
                properties: { name: '_Fulltext.md', pages: 2500 } 
            },
            'summaryMdFile': { 
                label: 'Summary MD', color: 'bg-gray-600', icon: 'âœ¨', 
                properties: { name: 'summary.md', source: 'article.md' } 
            },
            'knowledgeTemplateFile': { 
                label: 'Knowledge File', color: 'bg-fuchsia-600', icon: 'ðŸ§ ', 
                properties: { name: 'Template.txt', Type: 'Summary Markdown Template' } 
            },
        };

        // --- Core Functions ---

        function getPropertyEmoji(key) {
            const lowerKey = key.toLowerCase();
            if (lowerKey.includes('url') || lowerKey.includes('fqdn')) return 'ðŸŒŽ';
            if (lowerKey.includes('mfa')) return 'ðŸ”’';
            if (lowerKey.includes('path') || lowerKey.includes('script')) return 'ðŸ“';
            if (lowerKey.includes('key') || lowerKey.includes('auth')) return 'ðŸ”‘';
            if (lowerKey.includes('os')) return 'ðŸ’»';
            if (lowerKey.includes('id')) return 'ðŸ†”';
            if (lowerKey.includes('name')) return 'ðŸ·ï¸';
            if (lowerKey.includes('role') || lowerKey.includes('group')) return 'ðŸ‘¥';
            if (lowerKey.includes('model') || lowerKey.includes('schema') || lowerKey.includes('type')) return 'ðŸ§ ';
            if (lowerKey.includes('size') || lowerKey.includes('pages') || lowerKey.includes('words') || lowerKey.includes('volume') || lowerKey.includes('count')) return 'ðŸ”¢';
            return 'â–ªï¸';
        }

        function calculateShapeHeight(shape) {
            const def = componentDefs[shape.type];
            if (def.isZone) return shape.height; 

            let visibleProperties = 0;
            for (const key in shape.properties) {
                if (!(shape.hideInShape && shape.hideInShape[key])) {
                    visibleProperties++;
                }
            }

            const baseHeight = 35; 
            const propertiesHeight = visibleProperties * 12;
            let bottomTextCount = 0;
            if (shape.properties.domain || shape.properties.networkId || shape.properties.network) bottomTextCount++;
            if (shape.properties.mfa) bottomTextCount++;
            const bottomTextHeight = bottomTextCount * 12;
            const padding = 15;

            return baseHeight + propertiesHeight + bottomTextHeight + padding;
        }

        function render() {
            svg.innerHTML = ''; 
            
            const zones = shapes.filter(s => componentDefs[s.type].isZone);
            const regularShapes = shapes.filter(s => !componentDefs[s.type].isZone);

            const zonesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            zones.forEach(shape => renderShape(shape, zonesGroup));
            svg.appendChild(zonesGroup);

            const connectorsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            connectors.forEach(conn => renderConnector(conn, connectorsGroup));
            svg.appendChild(connectorsGroup);

            const shapesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            regularShapes.forEach(shape => renderShape(shape, shapesGroup));
            svg.appendChild(shapesGroup);

            const selectionGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            if (selectedItems.length > 0) {
                selectedItems.forEach(item => {
                    if (item.type && componentDefs[item.type].resizable) {
                        renderResizeHandles(item, selectionGroup);
                    }
                });
            } else if (selectedItems.length === 1 && selectedItems[0].from) {
                renderConnectorHandles(selectedItems[0], selectionGroup);
            }

            if (isSelecting) {
                const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                box.setAttribute('id', 'selection-box');
                box.setAttribute('x', Math.min(selectionBox.x1, selectionBox.x2));
                box.setAttribute('y', Math.min(selectionBox.y1, selectionBox.y2));
                box.setAttribute('width', Math.abs(selectionBox.x1 - selectionBox.x2));
                box.setAttribute('height', Math.abs(selectionBox.y1 - selectionBox.y2));
                selectionGroup.appendChild(box);
            }
            svg.appendChild(selectionGroup);
        }

        function renderConnector(conn, parent) {
            const fromShape = shapes.find(s => s.id === conn.from);
            const toShape = shapes.find(s => s.id === conn.to);
            if (!fromShape || !toShape) return;

            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('data-id', conn.id);
            if(selectedItems.some(item => item.id === conn.id)) {
                group.classList.add('selected-connector');
            }

            const lineHitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            lineHitbox.setAttribute('x1', fromShape.x);
            lineHitbox.setAttribute('y1', fromShape.y);
            lineHitbox.setAttribute('x2', toShape.x);
            lineHitbox.setAttribute('y2', toShape.y);
            lineHitbox.setAttribute('class', 'connector-hitbox');
            group.appendChild(lineHitbox);

            const lineVisible = lineHitbox.cloneNode();
            lineVisible.setAttribute('class', 'connector-line-visible');
            group.appendChild(lineVisible);

            if (conn.label) {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('class', 'connector-label');
                text.setAttribute('x', (fromShape.x + toShape.x) / 2);
                text.setAttribute('y', (fromShape.y + toShape.y) / 2 - 5);
                text.setAttribute('text-anchor', 'middle');
                text.textContent = conn.label;
                group.appendChild(text);
            }
            parent.appendChild(group);
        }

        function renderShape(shape, parent) {
            shape.height = calculateShapeHeight(shape);

            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'shape');
            group.setAttribute('data-id', shape.id);
            group.setAttribute('transform', `translate(${shape.x}, ${shape.y})`);

            const def = componentDefs[shape.type];
            if (!def) return;
            
            const baseRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            baseRect.setAttribute('x', -shape.width / 2);
            baseRect.setAttribute('y', -shape.height / 2);
            baseRect.setAttribute('width', shape.width);
            baseRect.setAttribute('height', shape.height);
            baseRect.setAttribute('rx', 8);
            
            group.appendChild(baseRect);

            if (def.isZone) {
                const colorClass = def.colors[shape.properties.color] || 'fill-gray-100';
                baseRect.setAttribute('class', `${colorClass} stroke-gray-300 stroke-2`);
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('class', 'network-zone-title fill-gray-500');
                title.setAttribute('x', -shape.width / 2 + 10);
                title.setAttribute('y', -shape.height / 2 + 20);
                title.textContent = shape.properties.name;
                group.appendChild(title);
            } else {
                baseRect.setAttribute('class', `stroke-2 ${def.color.replace('bg-', 'stroke-')} fill-white`);
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('class', 'shape-title fill-gray-800');
                title.setAttribute('x', -shape.width / 2 + 10);
                title.setAttribute('y', -shape.height / 2 + 15);
                title.textContent = `${def.icon} ${def.label}`;
                group.appendChild(title);

                let yOffset = -shape.height / 2 + 35;
                for(const key in shape.properties) {
                    if (!(shape.hideInShape && shape.hideInShape[key])) {
                        const propText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        propText.setAttribute('class', 'shape-subtext fill-gray-900');
                        propText.setAttribute('x', -shape.width / 2 + 10);
                        propText.setAttribute('y', yOffset);
                        const propValue = String(shape.properties[key] || '').length > 25 ? String(shape.properties[key]).substring(0, 22) + '...' : shape.properties[key];
                        const emoji = getPropertyEmoji(key);
                        propText.textContent = `${emoji} ${key}: ${propValue}`;
                        group.appendChild(propText);
                        yOffset += 12;
                    }
                }

                const domainTextContent = shape.properties.domain || shape.properties.networkId || shape.properties.network;
                const mfaTextContent = shape.properties.mfa;
                let bottomTextY = shape.height / 2 - 8;

                if (mfaTextContent) {
                    const mfaText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    mfaText.setAttribute('class', 'shape-mfa-text fill-purple-600 font-semibold');
                    mfaText.setAttribute('x', 0);
                    mfaText.setAttribute('y', bottomTextY);
                    mfaText.setAttribute('text-anchor', 'middle');
                    mfaText.textContent = `MFA: ${mfaTextContent}`;
                    group.appendChild(mfaText);
                    bottomTextY -= 12;
                }

                if(domainTextContent) {
                    const domainText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    domainText.setAttribute('class', 'shape-domain-text fill-indigo-600 font-semibold');
                    domainText.setAttribute('x', 0);
                    domainText.setAttribute('y', bottomTextY);
                    domainText.setAttribute('text-anchor', 'middle');
                    domainText.textContent = domainTextContent;
                    group.appendChild(domainText);
                }
            }

            if (selectedItems.some(item => item.id === shape.id)) {
                baseRect.classList.add('stroke-indigo-500', 'stroke-4');
            }
            if (connectionStartShape && connectionStartShape.id === shape.id) {
                baseRect.classList.add('stroke-amber-400', 'stroke-4');
            }
            parent.appendChild(group);
        }

        function renderResizeHandles(shape, parent) {
            const x = shape.x;
            const y = shape.y;
            const w = shape.width / 2;
            const h = shape.height / 2;
            const handleSize = 16;
            const handles = [
                { x: x - w - handleSize/2, y: y - h - handleSize/2, class: 'tl' },
                { x: x + w - handleSize/2, y: y - h - handleSize/2, class: 'tr' },
                { x: x - w - handleSize/2, y: y + h - handleSize/2, class: 'bl' },
                { x: x + w - handleSize/2, y: y + h - handleSize/2, class: 'br' }
            ];

            handles.forEach(pos => {
                const handle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                handle.setAttribute('x', pos.x);
                handle.setAttribute('y', pos.y);
                handle.setAttribute('width', handleSize);
                handle.setAttribute('height', handleSize);
                handle.setAttribute('class', `resize-handle ${pos.class}`);
                handle.setAttribute('data-shape-id', shape.id);
                handle.setAttribute('data-handle-type', pos.class);
                parent.appendChild(handle);
            });
        }

        function renderConnectorHandles(conn, parent) {
            const fromShape = shapes.find(s => s.id === conn.from);
            const toShape = shapes.find(s => s.id === conn.to);
            if (!fromShape || !toShape) return;

            const fromHandle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            fromHandle.setAttribute('cx', fromShape.x);
            fromHandle.setAttribute('cy', fromShape.y);
            fromHandle.setAttribute('r', 8);
            fromHandle.setAttribute('class', 'connector-handle');
            fromHandle.setAttribute('data-conn-id', conn.id);
            fromHandle.setAttribute('data-conn-end', 'from');
            parent.appendChild(fromHandle);
            
            const toHandle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            toHandle.setAttribute('cx', toShape.x);
            toHandle.setAttribute('cy', toShape.y);
            toHandle.setAttribute('r', 8);
            toHandle.setAttribute('class', 'connector-handle');
            toHandle.setAttribute('data-conn-id', conn.id);
            toHandle.setAttribute('data-conn-end', 'to');
            parent.appendChild(toHandle);
        }

        function addShape(type) {
            const canvasRect = canvasContainer.getBoundingClientRect();
            const def = componentDefs[type];
            if (!def) return;

            const properties = JSON.parse(JSON.stringify(def.properties));
            let width = 200;
            let height = 300; // Temp value, will be calculated by renderShape
            if(def.isZone) {
                width = 400;
                height = 300;
            }

            const newShape = {
                id: `${type}-${crypto.randomUUID().substring(0, 6)}`,
                type: type,
                x: canvasRect.width / 2 + (Math.random() - 0.5) * 200,
                y: canvasRect.height / 2 + (Math.random() - 0.5) * 200,
                width, height, properties,
                hideInShape: {}
            };
            shapes.push(newShape);
            setSelectedItem([newShape]);
            render();
        }

        function getMousePosition(evt) {
            const CTM = svg.getScreenCTM();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return {
                x: (clientX - CTM.e) / CTM.a,
                y: (clientY - CTM.f) / CTM.d
            };
        }

        function setSelectedItem(items) {
            selectedItems = Array.isArray(items) ? items : (items ? [items] : []);
            renderSidebar();
            render();
        }

        function renderSidebar() {
            if (selectedItems.length === 0) {
                editorContent.innerHTML = `<p class="text-sm text-gray-500 text-center italic">Select an item to edit its properties.</p>`;
                return;
            }
            if (selectedItems.length > 1) {
                editorContent.innerHTML = `<p class="text-sm text-gray-700 font-semibold text-center">${selectedItems.length} items selected.</p>`;
                return;
            }

            const item = selectedItems[0];
            if (item.type) { 
                const def = componentDefs[item.type];
                editorContent.innerHTML = `<h3 class="text-md font-bold text-gray-800">${def.icon} ${def.label}</h3>`;
                
                for(const key in item.properties) {
                    const propertyGroup = document.createElement('div');
                    const label = document.createElement('label');
                    label.textContent = key.charAt(0).toUpperCase() + key.slice(1);
                    label.htmlFor = `prop-${key}`;
                    
                    const editorContainer = document.createElement('div');
                    editorContainer.className = 'property-grid';

                    let inputElement;
                    const options = def.options && def.options[key];

                    if(key === 'color' && def.colors) {
                        inputElement = document.createElement('select');
                        for(const colorName in def.colors) {
                            const option = document.createElement('option');
                            option.value = colorName;
                            option.textContent = colorName.charAt(0).toUpperCase() + colorName.slice(1);
                            if(item.properties[key] === colorName) option.selected = true;
                            inputElement.appendChild(option);
                        }
                        inputElement.addEventListener('change', (e) => {
                            item.properties[e.target.dataset.key] = e.target.value;
                            render();
                        });
                    } else if (options) {
                        inputElement = document.createElement('select');
                        options.forEach(opt => {
                             const option = document.createElement('option');
                            option.value = opt;
                            option.textContent = opt;
                            if(item.properties[key] === opt) option.selected = true;
                            inputElement.appendChild(option);
                        });
                        inputElement.addEventListener('change', (e) => {
                            item.properties[e.target.dataset.key] = e.target.value;
                            render();
                        });
                    } else {
                        inputElement = document.createElement('input');
                        inputElement.type = 'text';
                        inputElement.value = item.properties[key];
                        inputElement.addEventListener('input', (e) => {
                            item.properties[e.target.dataset.key] = e.target.value;
                            render();
                        });
                    }
                    inputElement.id = `prop-${key}`;
                    inputElement.dataset.key = key;

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.title = 'Show this property on the shape';
                    checkbox.checked = !(item.hideInShape && item.hideInShape[key]);
                    checkbox.addEventListener('change', (e) => {
                        if (!item.hideInShape) item.hideInShape = {};
                        item.hideInShape[key] = !e.target.checked;
                        render();
                    });

                    propertyGroup.appendChild(label);
                    editorContainer.appendChild(inputElement);
                    if (!def.isZone) {
                        editorContainer.appendChild(checkbox);
                    }
                    propertyGroup.appendChild(editorContainer);
                    editorContent.appendChild(propertyGroup);
                }
            } else if (item.from) {
                editorContent.innerHTML = `<h3 class="text-md font-bold text-gray-800">ðŸ”— Connector</h3>`;
                const propertyGroup = document.createElement('div');
                const label = document.createElement('label');
                label.textContent = 'Label';
                label.htmlFor = `prop-label`;
                
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `prop-label`;
                input.value = item.label || '';
                input.addEventListener('input', (e) => {
                    item.label = e.target.value;
                    render();
                });
                propertyGroup.appendChild(label);
                propertyGroup.appendChild(input);
                editorContent.appendChild(propertyGroup);
            }
        }

        function saveDiagram() {
            const data = { shapes, connectors };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ai-architecture.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadDiagram() { fileInput.click(); }
        
        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.shapes && data.connectors) {
                        shapes = data.shapes;
                        connectors = data.connectors;
                        shapes.forEach(s => {
                            if (!s.hideInShape) s.hideInShape = {};
                            if (s.showInShape) delete s.showInShape;
                        });
                        setSelectedItem([]);
                        render();
                    } else { alert('Invalid diagram file format.'); }
                } catch (err) { alert('Error parsing diagram file.'); console.error(err); }
            };
            reader.readAsText(file);
        }

        function downloadAsPng() {
            setSelectedItem([]);
            setTimeout(() => {
                if (shapes.length === 0) {
                    alert("Canvas is empty. Add some shapes to download an image.");
                    return;
                }
                
                const style = document.createElement('style');
                style.textContent = `@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
                    .shape-text, .shape-subtext, .shape-domain-text, .shape-mfa-text { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 500; fill: #111827; }
                    .shape-title { font-family: 'Inter', sans-serif; font-size: 12px; font-weight: 700; fill: #1f2937; }
                    .network-zone-title { font-family: 'Inter', sans-serif; font-size: 14px; font-weight: 600; fill: #4b5563; }
                    .shape-domain-text { fill: #4f46e5; font-weight: 600; }
                    .shape-mfa-text { fill: #7c3aed; font-weight: 600; }
                    .connector-label { font-family: 'Inter', sans-serif; font-size: 10px; font-weight: 600; fill: #374151; paint-order: stroke; stroke: #ffffff; stroke-width: 3px; }
                `;

                const svgClone = svg.cloneNode(true);
                svgClone.insertBefore(style, svgClone.firstChild);

                svgClone.querySelectorAll('.shape rect').forEach(rect => {
                    const originalRect = document.querySelector(`g[data-id="${rect.closest('.shape').dataset.id}"] rect`);
                    if (originalRect) {
                        const style = window.getComputedStyle(originalRect);
                        rect.setAttribute('fill', style.fill);
                        rect.setAttribute('stroke', style.stroke);
                        rect.setAttribute('stroke-width', style.strokeWidth);
                    }
                });
                
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                shapes.forEach(s => {
                    minX = Math.min(minX, s.x - s.width / 2);
                    minY = Math.min(minY, s.y - s.height / 2);
                    maxX = Math.max(maxX, s.x + s.width / 2);
                    maxY = Math.max(maxY, s.y + s.height / 2);
                });

                const padding = 20;
                const bbox = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };

                svgClone.setAttribute("width", bbox.width + padding * 2);
                svgClone.setAttribute("height", bbox.height + padding * 2);
                
                svgClone.innerHTML = `<g transform="translate(${-bbox.x + padding}, ${-bbox.y + padding})">${svgClone.innerHTML}</g>`;

                const svgString = new XMLSerializer().serializeToString(svgClone);
                const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                const url = URL.createObjectURL(svgBlob);

                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = bbox.width + padding * 2;
                    canvas.height = bbox.height + padding * 2;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    URL.revokeObjectURL(url);

                    const pngUrl = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    a.href = pngUrl;
                    a.download = 'architecture-diagram.png';
                    a.click();
                };
                img.onerror = () => { 
                    alert("Failed to load SVG image for conversion.");
                    URL.revokeObjectURL(url); 
                };
                img.src = url;
            }, 100);
        }

        // --- Event Handlers ---
        function handlePointerDown(evt) {
            evt.preventDefault();
            const mousePos = getMousePosition(evt);
            
            const resizeHandleTarget = evt.target.closest('.resize-handle');
            if (resizeHandleTarget) {
                isResizing = true;
                draggedShape = selectedItems[0];
                offset.handle = resizeHandleTarget.dataset.handleType;
                return;
            }

            const connHandleTarget = evt.target.closest('.connector-handle');
            if (connHandleTarget) {
                isDraggingConnectorHandle = true;
                const connId = connHandleTarget.dataset.connId;
                const connEnd = connHandleTarget.dataset.connEnd;
                draggedConnectorInfo = {
                    handle: connHandleTarget,
                    conn: connectors.find(c => c.id === connId),
                    end: connEnd
                };
                return;
            }

            const connectorTarget = evt.target.closest('g[data-id^="conn-"]');
            if(connectorTarget) {
                const connId = connectorTarget.getAttribute('data-id');
                setSelectedItem(connectors.find(c => c.id === connId));
                return;
            }

            const shapeTarget = evt.target.closest('.shape');
            if (!shapeTarget) {
                isSelecting = true;
                selectionBox.x1 = mousePos.x;
                selectionBox.y1 = mousePos.y;
                selectionBox.x2 = mousePos.x;
                selectionBox.y2 = mousePos.y;
                setSelectedItem([]);
                return;
            }
            
            const shapeId = shapeTarget.getAttribute('data-id');
            const shape = shapes.find(s => s.id === shapeId);
            
            if (isConnecting) {
                if (!connectionStartShape) {
                    connectionStartShape = shape;
                } else {
                    if (connectionStartShape.id !== shape.id) {
                        const exists = connectors.some(c => (c.from === connectionStartShape.id && c.to === shape.id) || (c.from === shape.id && c.to === connectionStartShape.id));
                        if (!exists) {
                           connectors.push({ id: `conn-${crypto.randomUUID().substring(0, 6)}`, from: connectionStartShape.id, to: shape.id, label: '' });
                        }
                    }
                    connectionStartShape = null;
                    isConnecting = false;
                    connectBtn.classList.remove('bg-amber-500', 'text-black');
                    connectBtn.classList.add('bg-gray-600', 'text-white');
                }
            } else {
                isDragging = true;
                if (!selectedItems.some(item => item.id === shape.id)) {
                    setSelectedItem(shape);
                }
                offset.x = mousePos.x;
                offset.y = mousePos.y;
                selectedItems.forEach(item => {
                    item.dragStart = { x: item.x, y: item.y };
                });
            }
            render();
        }

        function handlePointerMove(evt) {
            if (!isDragging && !isResizing && !isDraggingConnectorHandle && !isSelecting) return;
            evt.preventDefault();
            const mousePos = getMousePosition(evt);

            if (isResizing && draggedShape) {
                const dx = mousePos.x - draggedShape.x;
                const dy = mousePos.y - draggedShape.y;
                const aspect = draggedShape.width / draggedShape.height;

                switch(offset.handle) {
                    case 'br':
                        draggedShape.width = Math.max(50, draggedShape.width + (mousePos.x - (draggedShape.x + draggedShape.width/2)));
                        draggedShape.height = Math.max(50, draggedShape.height + (mousePos.y - (draggedShape.y + draggedShape.height/2)));
                        break;
                    case 'bl':
                         draggedShape.width = Math.max(50, draggedShape.width - (mousePos.x - (draggedShape.x - draggedShape.width/2)));
                         draggedShape.height = Math.max(50, draggedShape.height + (mousePos.y - (draggedShape.y + draggedShape.height/2)));
                         break;
                    case 'tr':
                         draggedShape.width = Math.max(50, draggedShape.width + (mousePos.x - (draggedShape.x + draggedShape.width/2)));
                         draggedShape.height = Math.max(50, draggedShape.height - (mousePos.y - (draggedShape.y - draggedShape.height/2)));
                         break;
                    case 'tl':
                         draggedShape.width = Math.max(50, draggedShape.width - (mousePos.x - (draggedShape.x - draggedShape.width/2)));
                         draggedShape.height = Math.max(50, draggedShape.height - (mousePos.y - (draggedShape.y - draggedShape.height/2)));
                         break;
                }

            } else if (isDragging && selectedItems.length > 0) {
                const dx = mousePos.x - offset.x;
                const dy = mousePos.y - offset.y;
                selectedItems.forEach(item => {
                    if (item.dragStart) {
                        item.x = item.dragStart.x + dx;
                        item.y = item.dragStart.y + dy;
                    }
                });
            } else if (isDraggingConnectorHandle) {
                tempLineSvg.innerHTML = '';
                const { conn, end } = draggedConnectorInfo;
                const staticEnd = end === 'from' ? 'to' : 'from';
                const staticShape = shapes.find(s => s.id === conn[staticEnd]);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', staticShape.x);
                line.setAttribute('y1', staticShape.y);
                line.setAttribute('x2', mousePos.x);
                line.setAttribute('y2', mousePos.y);
                line.setAttribute('stroke', '#3b82f6');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('stroke-dasharray', '5 5');
                tempLineSvg.appendChild(line);
            } else if (isSelecting) {
                selectionBox.x2 = mousePos.x;
                selectionBox.y2 = mousePos.y;
            }
            render();
        }

        function handlePointerUp(evt) {
             if (isSelecting) {
                const x1 = Math.min(selectionBox.x1, selectionBox.x2);
                const y1 = Math.min(selectionBox.y1, selectionBox.y2);
                const x2 = Math.max(selectionBox.x1, selectionBox.x2);
                const y2 = Math.max(selectionBox.y1, selectionBox.y2);

                const selected = shapes.filter(s => {
                    const shapeX1 = s.x - s.width / 2;
                    const shapeY1 = s.y - s.height / 2;
                    const shapeX2 = s.x + s.width / 2;
                    const shapeY2 = s.y + s.height / 2;
                    return x1 < shapeX2 && x2 > shapeX1 && y1 < shapeY2 && y2 > shapeY1;
                });
                setSelectedItem(selected);
            }
            
            if (isDraggingConnectorHandle) {
                const mousePos = getMousePosition(evt);
                const { conn, end } = draggedConnectorInfo;
                
                const targetShape = shapes.find(s => {
                    if (componentDefs[s.type].isZone) return false;
                    const halfW = s.width / 2;
                    const halfH = s.height / 2;
                    return mousePos.x > s.x - halfW && mousePos.x < s.x + halfW &&
                           mousePos.y > s.y - halfH && mousePos.y < s.y + halfH;
                });

                if (targetShape) {
                    conn[end] = targetShape.id;
                }
            }

            isDragging = false;
            isResizing = false;
            isSelecting = false;
            isDraggingConnectorHandle = false;
            draggedShape = null;
            tempLineSvg.innerHTML = '';
            selectedItems.forEach(item => delete item.dragStart);
            render();
        }

        function handleKeyDown(e) {
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedItems.length > 0) {
                const idsToDelete = new Set(selectedItems.map(item => item.id));
                shapes = shapes.filter(s => !idsToDelete.has(s.id));
                connectors = connectors.filter(c => !idsToDelete.has(c.id) && !idsToDelete.has(c.from) && !idsToDelete.has(c.to));
                setSelectedItem([]);
                render();
            }
        }

        // --- Initialization ---
        function initialize() {
            // Sort components alphabetically for better organization
            const sortedTypes = Object.keys(componentDefs).sort((a, b) => componentDefs[a].label.localeCompare(componentDefs[b].label));

            sortedTypes.forEach(type => {
                const def = componentDefs[type];
                const button = document.createElement('button');
                button.id = `add-${type}`;
                button.className = `w-full ${def.isZone ? 'bg-gray-200 text-gray-700 border border-gray-400' : def.color + ' text-white'} hover:opacity-80 font-bold py-2 px-2 rounded-lg transition-colors duration-200 flex flex-col items-center justify-center space-y-1 text-xs`;
                button.innerHTML = `
                    <span class="text-xl">${def.icon}</span>
                    <span class="text-center leading-tight">${def.label}</span>
                `;
                button.addEventListener('click', () => addShape(type));
                componentButtonsContainer.appendChild(button);
            });

            connectBtn.addEventListener('click', () => {
                isConnecting = !isConnecting;
                if (isConnecting) {
                    connectionStartShape = null;
                    connectBtn.classList.remove('bg-gray-600', 'text-white');
                    connectBtn.classList.add('bg-amber-500', 'text-black');
                } else {
                    connectionStartShape = null;
                    connectBtn.classList.remove('bg-amber-500', 'text-black');
                    connectBtn.classList.add('bg-gray-600', 'text-white');
                }
                render();
            });

            clearBtn.addEventListener('click', () => {
                if (confirm('Are you sure you want to clear the entire canvas?')) {
                    shapes = [];
                    connectors = [];
                    setSelectedItem([]);
                    render();
                }
            });
            
            saveBtn.addEventListener('click', saveDiagram);
            loadBtn.addEventListener('click', loadDiagram);
            downloadPngBtn.addEventListener('click', downloadAsPng);
            fileInput.addEventListener('change', handleFileLoad);

            svg.addEventListener('mousedown', handlePointerDown);
            svg.addEventListener('mousemove', handlePointerMove);
            document.addEventListener('mouseup', handlePointerUp);
            svg.addEventListener('touchstart', handlePointerDown, { passive: false });
            document.addEventListener('touchmove', handlePointerMove, { passive: false });
            document.addEventListener('touchend', handlePointerUp);
            document.addEventListener('touchcancel', handlePointerUp);
            window.addEventListener('keydown', handleKeyDown);

            render();
            renderSidebar();
        }

        initialize();
    </script>
</body>
</html>
