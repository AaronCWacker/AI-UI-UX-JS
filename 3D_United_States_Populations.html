<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Platonic Representation Hypothesis + 3D US Map (MN ‚Ä¢ TX ‚Ä¢ FL ‚Ä¢ CA)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 100%);
    }
    canvas { display: block; }

    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 18px 18px 14px 18px;
      border-radius: 12px;
      max-width: 370px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
    h1 {
      margin: 0 0 8px 0;
      font-size: 18px;
      color: #00ffff;
      letter-spacing: 0.3px;
    }
    p {
      margin: 8px 0;
      font-size: 13px;
      line-height: 1.45;
      color: rgba(255,255,255,0.92);
    }
    .legend {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.18);
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 7px 0;
      font-size: 12px;
      color: rgba(255,255,255,0.9);
    }
    .legend-color {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      margin-right: 10px;
      border: 1px solid rgba(255, 255, 255, 0.25);
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.65);
      padding: 12px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.12);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      max-width: min(740px, calc(100vw - 40px));
    }
    button {
      background: rgba(0, 255, 255, 0.16);
      border: 1px solid rgba(0,255,255,0.9);
      color: #aefcff;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
      transition: transform 0.12s ease, background 0.2s ease, border-color 0.2s ease;
      user-select: none;
      letter-spacing: 0.2px;
    }
    button:hover {
      background: rgba(0, 255, 255, 0.28);
      transform: translateY(-1px);
      border-color: rgba(0,255,255,1);
    }

    #hint {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 20px;
      color: rgba(255, 255, 255, 0.86);
      background: rgba(0, 0, 0, 0.32);
      padding: 10px 14px;
      border-radius: 999px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 12px;
      pointer-events: none;
      text-align: center;
      max-width: calc(100vw - 40px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>
  <div id="info">
    <h1>üîÆ Platonic Representation Hypothesis + üó∫Ô∏è 3D US Map</h1>
    <p><strong>The Theory:</strong> Different neural nets converge toward similar internal representations when learning the same task.</p>
    <p><strong>New:</strong> Enhanced 3D map layer for <strong>CA ‚Ä¢ MN ‚Ä¢ TX ‚Ä¢ FL</strong> with coastal feel, procedural surface detail, correct NSEW, and <strong>3D ZIP2 cones</strong> for city population.</p>
    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background:#ff1744;"></div>
        <span><strong>CNN:</strong> hierarchical / local receptive fields</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#00e676;"></div>
        <span><strong>Transformer:</strong> attention mesh</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#ffd600;"></div>
        <span><strong>RNN:</strong> recurrent loops</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#00b0ff;"></div>
        <span><strong>Biological:</strong> organic dendrites</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:rgba(255,255,255,0.9);"></div>
        <span><strong>Platonic Ideal:</strong> convergent representation</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:rgba(140,255,240,0.35);"></div>
        <span><strong>ZIP2 Cone:</strong> mouth size = population</span>
      </div>
    </div>
  </div>

  <div id="controls">
    <button id="btn-reset">Reset</button>
    <button id="btn-paths">Toggle Connections</button>
    <button id="btn-trails">Toggle Trails</button>
    <button id="btn-rotate">Toggle Auto-Rotate</button>
    <button id="btn-camera">Toggle Mouse Camera</button>
    <button id="btn-map">Toggle Map Layer</button>
    <button id="btn-cones">Toggle ZIP2 Cones</button>
    <button id="btn-labels">Toggle Labels</button>
    <button id="btn-compass">Toggle Compass Rose</button>
    <button id="btn-topdown">Top-Down Map View</button>
  </div>

  <div id="hint">Drag to orbit ‚Ä¢ Wheel to zoom ‚Ä¢ Shift+Drag to pan (Mouse Camera ON) ‚Ä¢ Axes: +X=East, +Z=North, +Y=Up (CA left, ME right)</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "d3-geo": "https://cdn.jsdelivr.net/npm/d3-geo@3/+esm",
    "topojson-client": "https://cdn.jsdelivr.net/npm/topojson-client@3/+esm"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import * as d3geo from 'd3-geo';
import * as topojson from 'topojson-client';

// ============================================================
// ‚úÖ Coordinate truth:
//   +X = East, +Z = North, +Y = Up
//   California (negative lon) sits LEFT; Maine sits RIGHT
// ============================================================

// ===== Scene setup =====
let scene, camera, renderer;
let networkClusters = [];
let centralIdeal, particleSystem;
let showConnections = true;
let showTrails = true;
let autoRotate = true;
let mouseCamera = true;
let time = 0;

// Map layer toggles
let mapVisible = true;
let conesVisible = true;
let labelsVisible = true;
let compassVisible = true;
let isTopDown = false;
let topDownZoom = 16;
let topDownPan = { x: 0, z: 0 };

let mapGroup, conesGroup, labelsGroup, compassGroup;
const mapFloorY = -4.2;

// ===== Lightweight orbit controls =====
const controls = {
  isDown: false,
  button: 0,
  lastX: 0,
  lastY: 0,
  azimuth: 0.62,
  polar: 0.86,
  radius: 16,
  target: new THREE.Vector3(0, 0, 0),
  pan: new THREE.Vector3(0, 0, 0),
  damping: 0.18,
  velAz: 0,
  velPol: 0,
  velPanX: 0,
  velPanY: 0,
  update() {
    this.velAz *= (1 - this.damping);
    this.velPol *= (1 - this.damping);
    this.velPanX *= (1 - this.damping);
    this.velPanY *= (1 - this.damping);
    this.azimuth += this.velAz;
    this.polar = Math.max(0.12, Math.min(Math.PI - 0.12, this.polar + this.velPol));
    const panSpeed = 0.015 * this.radius;
    const up = new THREE.Vector3(0, 1, 0);
    const dir = new THREE.Vector3(
      Math.sin(this.polar) * Math.cos(this.azimuth),
      Math.cos(this.polar),
      Math.sin(this.polar) * Math.sin(this.azimuth)
    ).normalize();
    const right = new THREE.Vector3().crossVectors(dir, up).normalize();
    const camUp = new THREE.Vector3().crossVectors(right, dir).normalize();
    this.pan.addScaledVector(right, this.velPanX * panSpeed);
    this.pan.addScaledVector(camUp, this.velPanY * panSpeed);
    const pos = dir.multiplyScalar(this.radius).add(this.target).add(this.pan);
    camera.position.copy(pos);
    camera.lookAt(this.target.clone().add(this.pan));
  }
};

// ============================================================
// üåä Procedural noise
// ============================================================
function hash2(x, y) {
  const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453123;
  return s - Math.floor(s);
}
function valueNoise2(x, y) {
  const ix = Math.floor(x), iy = Math.floor(y);
  const fx = x - ix, fy = y - iy;
  const a = hash2(ix, iy), b = hash2(ix + 1, iy);
  const c = hash2(ix, iy + 1), d = hash2(ix + 1, iy + 1);
  const ux = fx * fx * (3 - 2 * fx);
  const uy = fy * fy * (3 - 2 * fy);
  const lerp = (p, q, t) => p + (q - p) * t;
  return lerp(lerp(a, b, ux), lerp(c, d, ux), uy);
}
function fbm2(x, y) {
  let f = 0, amp = 0.5, freq = 1.0;
  for (let i = 0; i < 5; i++) {
    f += amp * valueNoise2(x * freq, y * freq);
    freq *= 2.0; amp *= 0.5;
  }
  return f;
}

// ============================================================
// üó∫Ô∏è Map constants
// ============================================================
const MAP = { lonMin: -125, lonMax: -66, latMin: 24, latMax: 50, width: 18.5, depth: 10.0 };

function lonLatToXZ(lon, lat) {
  const nx = (lon - MAP.lonMin) / (MAP.lonMax - MAP.lonMin);
  const nz = (lat - MAP.latMin) / (MAP.latMax - MAP.latMin);
  return new THREE.Vector3(-(nx - 0.5) * MAP.width, 0, (nz - 0.5) * MAP.depth);
}

// ============================================================
// ‚ú® Label sprites
// ============================================================
function makeLabelSprite(text, opts = {}) {
  const {
    fontSize = 44, padding = 18,
    fg = "rgba(220,255,255,0.98)", stroke = "rgba(0,0,0,0.75)",
    bg = "rgba(0,0,0,0.0)", glow = "rgba(0,255,255,0.35)", maxWidth = 900
  } = opts;
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  ctx.font = `700 ${fontSize}px Segoe UI, Tahoma, sans-serif`;
  const metrics = ctx.measureText(text);
  const textW = Math.min(maxWidth, metrics.width);
  const w = Math.ceil(textW + padding * 2);
  const h = Math.ceil(fontSize + padding * 2);
  canvas.width = w; canvas.height = h;
  ctx.fillStyle = bg; ctx.fillRect(0, 0, w, h);
  ctx.shadowColor = glow; ctx.shadowBlur = 18;
  ctx.font = `700 ${fontSize}px Segoe UI, Tahoma, sans-serif`;
  ctx.textAlign = "center"; ctx.textBaseline = "middle";
  ctx.lineWidth = 8; ctx.strokeStyle = stroke;
  ctx.strokeText(text, w / 2, h / 2);
  ctx.fillStyle = fg; ctx.fillText(text, w / 2, h / 2);
  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
  const sprite = new THREE.Sprite(mat);
  const s = 0.012;
  sprite.scale.set(canvas.width * s * 0.45, canvas.height * s * 0.45, 1);
  return sprite;
}

// ============================================================
// üß≠ Compass Rose
// ============================================================
function buildCompassRose() {
  const g = new THREE.Group();
  const discGeo = new THREE.CylinderGeometry(1.05, 1.05, 0.08, 48);
  const discMat = new THREE.MeshStandardMaterial({ color: 0x0b1020, metalness: 0.35, roughness: 0.35, emissive: 0x001018, emissiveIntensity: 0.65 });
  g.add(new THREE.Mesh(discGeo, discMat));
  const rimGeo = new THREE.TorusGeometry(1.05, 0.06, 12, 64);
  const rimMat = new THREE.MeshStandardMaterial({ color: 0x00e5ff, metalness: 0.6, roughness: 0.25, emissive: 0x00c8ff, emissiveIntensity: 0.35 });
  const rim = new THREE.Mesh(rimGeo, rimMat); rim.rotation.x = Math.PI / 2; rim.position.y = 0.06; g.add(rim);

  const arrowGeo = new THREE.ConeGeometry(0.18, 0.85, 24);
  const arrowMatN = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.25, roughness: 0.35, emissive: 0x00ffff, emissiveIntensity: 0.45 });
  const arrowN = new THREE.Mesh(arrowGeo, arrowMatN); arrowN.position.set(0, 0.18, 0.65); arrowN.rotation.x = -Math.PI / 2; g.add(arrowN);
  const arrowMatS = new THREE.MeshStandardMaterial({ color: 0x23314a, metalness: 0.3, roughness: 0.5, emissive: 0x003040, emissiveIntensity: 0.35 });
  const arrowS = new THREE.Mesh(arrowGeo, arrowMatS); arrowS.position.set(0, 0.16, -0.65); arrowS.rotation.x = Math.PI / 2; g.add(arrowS);

  const tickGeo = new THREE.BoxGeometry(0.06, 0.05, 0.22);
  const tickMat = new THREE.MeshStandardMaterial({ color: 0x9befff, metalness: 0.2, roughness: 0.35, emissive: 0x006070, emissiveIntensity: 0.35 });
  for (let i = 0; i < 16; i++) {
    const t = new THREE.Mesh(tickGeo, tickMat);
    const a = (i / 16) * Math.PI * 2;
    t.position.set(Math.sin(a) * 0.88, 0.09, Math.cos(a) * 0.88); t.rotation.y = a; g.add(t);
  }
  const n = makeLabelSprite("N", { fontSize: 56, glow: "rgba(0,255,255,0.55)" });
  const e = makeLabelSprite("E", { fontSize: 44, glow: "rgba(0,255,255,0.45)" });
  const s = makeLabelSprite("S", { fontSize: 44, glow: "rgba(0,255,255,0.35)", fg: "rgba(190,215,255,0.95)" });
  const w = makeLabelSprite("W", { fontSize: 44, glow: "rgba(0,255,255,0.45)" });
  n.position.set(0, 0.52, 1.28); s.position.set(0, 0.5, -1.28);
  e.position.set(-1.28, 0.5, 0); w.position.set(1.28, 0.5, 0);
  g.add(n, e, s, w);
  g.rotation.x = -0.18;
  return g;
}

// ============================================================
// üåé 3D Map Layer ‚Äî REALISTIC US states from TopoJSON
// ============================================================
// Shared projection helpers (set after fetch)
let _projection, _projCx, _projCy, _projS;

function projLonLatToXZ(lon, lat) {
  const p = _projection([lon, lat]);
  if (!p) return null;
  // No z-negation here; shapes negate via rotateX(-PI/2) to land +Z=North
  return { x: -(p[0] - _projCx) * _projS, z: (p[1] - _projCy) * _projS };
}

function ringToPoints(ring) {
  const pts = [];
  for (const ll of ring) {
    const p = projLonLatToXZ(ll[0], ll[1]);
    if (p) pts.push(new THREE.Vector2(p.x, p.z));
  }
  return pts;
}

function shapesFromGeometry(geom) {
  const shapes = [];
  const polys = geom.type === 'Polygon' ? [geom.coordinates] : geom.type === 'MultiPolygon' ? geom.coordinates : [];
  for (const poly of polys) {
    const outerPts = ringToPoints(poly[0]);
    if (outerPts.length < 3) continue;
    const shape = new THREE.Shape(outerPts);
    for (let h = 1; h < poly.length; h++) {
      const holePts = ringToPoints(poly[h]);
      if (holePts.length >= 3) shape.holes.push(new THREE.Path(holePts));
    }
    shapes.push(shape);
  }
  return shapes;
}

function borderLineMesh(topoMesh, color, opacity, yOff) {
  const group = new THREE.Group();
  const geom = topoMesh;
  const coords = geom.type === 'MultiLineString' ? geom.coordinates : [geom.coordinates];
  for (const ring of coords) {
    const pts3 = [];
    for (const ll of ring) {
      const p = projLonLatToXZ(ll[0], ll[1]);
      // Negate z to match shapes (which negate via rotateX)
      if (p) pts3.push(new THREE.Vector3(p.x, yOff, -p.z));
    }
    if (pts3.length < 2) continue;
    const bg = new THREE.BufferGeometry().setFromPoints(pts3);
    const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
    group.add(new THREE.Line(bg, mat));
  }
  return group;
}

async function buildMapLayer() {
  mapGroup = new THREE.Group();
  mapGroup.position.y = mapFloorY;

  // --- Ocean surface (procedural waves)
  const oceanGeo = new THREE.PlaneGeometry(MAP.width * 1.45, MAP.depth * 1.55, 120, 120);
  oceanGeo.rotateX(-Math.PI / 2);
  const oPos = oceanGeo.attributes.position;
  for (let i = 0; i < oPos.count; i++) {
    const x = oPos.getX(i), z = oPos.getZ(i);
    const n = fbm2((x + 100) * 0.12, (z + 100) * 0.12);
    oPos.setY(i, (n - 0.5) * 0.14 + Math.sin(x * 0.9) * 0.03 + Math.cos(z * 0.85) * 0.03);
  }
  oPos.needsUpdate = true;
  oceanGeo.computeVertexNormals();
  const oceanMat = new THREE.MeshPhysicalMaterial({
    color: 0x07162c, metalness: 0.0, roughness: 0.18, transmission: 0.25,
    thickness: 0.8, transparent: true, opacity: 0.96, clearcoat: 1.0,
    clearcoatRoughness: 0.18, emissive: 0x001628, emissiveIntensity: 0.6
  });
  const ocean = new THREE.Mesh(oceanGeo, oceanMat);
  ocean.receiveShadow = true; ocean.name = "ocean";
  mapGroup.add(ocean);

  // --- Base slab
  const baseGeo = new THREE.BoxGeometry(MAP.width * 1.06, 0.12, MAP.depth * 1.06);
  const baseMat = new THREE.MeshStandardMaterial({ color: 0x071022, metalness: 0.5, roughness: 0.45, emissive: 0x001028, emissiveIntensity: 0.55 });
  const base = new THREE.Mesh(baseGeo, baseMat); base.position.y = -0.1; base.receiveShadow = true;
  mapGroup.add(base);

  // --- Grid
  const grid = new THREE.GridHelper(MAP.width * 1.04, 26, 0x00ffff, 0x2a4a6a);
  grid.position.y = 0.01; grid.material.opacity = 0.18; grid.material.transparent = true;
  mapGroup.add(grid);

  // ========== Fetch TopoJSON ==========
  const STATES_URL = 'https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json';
  let topo;
  try {
    const res = await fetch(STATES_URL, { cache: 'force-cache' });
    topo = await res.json();
  } catch (e) {
    console.error('Failed to load TopoJSON', e);
    scene.add(mapGroup);
    return;
  }

  const statesFc = topojson.feature(topo, topo.objects.states);
  const innerBorders = topojson.mesh(topo, topo.objects.states, (a, b) => a !== b);
  const outerBorder  = topojson.mesh(topo, topo.objects.states, (a, b) => a === b);

  // Set up Albers USA projection
  _projection = d3geo.geoAlbersUsa().scale(1000).translate([0, 0]);

  // Compute projected bounding box
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const f of statesFc.features) {
    const walk = (coords) => {
      if (!coords) return;
      if (typeof coords[0] === 'number') {
        const p = _projection(coords);
        if (p) { minX = Math.min(minX, p[0]); maxX = Math.max(maxX, p[0]); minY = Math.min(minY, p[1]); maxY = Math.max(maxY, p[1]); }
        return;
      }
      for (const c of coords) walk(c);
    };
    walk(f.geometry.coordinates);
  }
  const spanX = Math.max(1e-6, maxX - minX);
  const spanY = Math.max(1e-6, maxY - minY);
  _projS = Math.min(MAP.width / spanX, MAP.depth / spanY) * 0.98;
  _projCx = (minX + maxX) * 0.5;
  _projCy = (minY + maxY) * 0.5;

  // Highlight config by FIPS id
  const HIGHLIGHT = new Map([
    [6,  { key: 'CA', name: 'CALIFORNIA',  color: 0x18ffd0, emissive: 0x00c8a6, label: { lon: -119.6, lat: 36.8 } }],
    [27, { key: 'MN', name: 'MINNESOTA',   color: 0x00b0ff, emissive: 0x005a9e, label: { lon: -94.6,  lat: 46.3 } }],
    [48, { key: 'TX', name: 'TEXAS',        color: 0xffd600, emissive: 0x8a7600, label: { lon: -99.5,  lat: 31.2 } }],
    [12, { key: 'FL', name: 'FLORIDA',      color: 0xff1744, emissive: 0x8a0020, label: { lon: -82.5,  lat: 28.6 } }]
  ]);

  const stateHeight = 0.55;
  const bevel = 0.025;

  // ========== Build each state ==========
  for (const f of statesFc.features) {
    const id = Number(f.id);
    const shapes = shapesFromGeometry(f.geometry);
    if (!shapes.length) continue;

    const isHighlight = HIGHLIGHT.has(id);

    if (isHighlight) {
      // --- Extruded highlighted states ---
      const st = HIGHLIGHT.get(id);

      // ExtrudeGeometry extrudes along +Z in shape space.
      // Our shapes are in the XZ plane (Vector2 x‚ÜíworldX, y‚ÜíworldZ).
      // We extrude, then rotate so extrusion axis becomes +Y.
      const geo = new THREE.ExtrudeGeometry(shapes, {
        depth: stateHeight,
        bevelEnabled: true,
        bevelThickness: bevel,
        bevelSize: bevel * 0.8,
        bevelSegments: 2,
        curveSegments: 8
      });

      // Rotate from XY-extrude-along-Z to XZ-extrude-along-Y
      geo.rotateX(-Math.PI / 2);

      // Add subtle surface noise to the top vertices
      const pos = geo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const y = pos.getY(i);
        if (y > stateHeight * 0.4) {
          const x = pos.getX(i), z = pos.getZ(i);
          const bump = fbm2((x + 50) * 2.5, (z + 50) * 2.5) * 0.06;
          pos.setY(i, y + bump);
        }
      }
      pos.needsUpdate = true;
      geo.computeVertexNormals();

      const mat = new THREE.MeshStandardMaterial({
        color: st.color,
        metalness: 0.25,
        roughness: 0.38,
        emissive: st.emissive,
        emissiveIntensity: 0.34,
        side: THREE.DoubleSide
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.position.y = 0.02;
      mapGroup.add(mesh);

      // Glowing edge ring at base
      for (const shape of shapes) {
        const edgePts = shape.getPoints(24).map(p2 => new THREE.Vector3(p2.x, 0.03, -p2.y));
        if (edgePts.length > 2) {
          edgePts.push(edgePts[0].clone());
          const edgeGeo = new THREE.BufferGeometry().setFromPoints(edgePts);
          const edgeMat = new THREE.LineBasicMaterial({ color: st.color, transparent: true, opacity: 0.55 });
          mapGroup.add(new THREE.Line(edgeGeo, edgeMat));
        }
      }

      // State label
      const lp = projLonLatToXZ(st.label.lon, st.label.lat);
      if (lp) {
        const lbl = makeLabelSprite(st.name, { fontSize: 40, glow: "rgba(0,255,255,0.5)" });
        lbl.position.set(lp.x, stateHeight + 0.55, -lp.z);
        lbl.userData.isStateLabel = true;
        labelsGroup.add(lbl);
      }

    } else {
      // --- Flat non-highlighted states ---
      const geo = new THREE.ShapeGeometry(shapes, 6);
      geo.rotateX(-Math.PI / 2);
      const mat = new THREE.MeshStandardMaterial({
        color: 0x1a2a44,
        metalness: 0.3,
        roughness: 0.55,
        emissive: 0x0a1828,
        emissiveIntensity: 0.25,
        transparent: true,
        opacity: 0.82,
        side: THREE.DoubleSide
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.receiveShadow = true;
      mesh.position.y = 0.03;
      mapGroup.add(mesh);
    }
  }

  // ========== State border lines ==========
  const innerLines = borderLineMesh(innerBorders, 0x3a6a8a, 0.35, 0.06);
  mapGroup.add(innerLines);
  const outerLines = borderLineMesh(outerBorder, 0x00d4ff, 0.55, 0.07);
  mapGroup.add(outerLines);

  scene.add(mapGroup);
}

// ============================================================
// üèôÔ∏è ZIP2 Cones
// ============================================================
function buildZip2Cones() {
  conesGroup = new THREE.Group();
  conesGroup.position.y = mapFloorY;

  const cities = [
    { st: "CA", city: "Los Angeles",   lon: -118.2437, lat: 34.0522, pop: 3890000, zip2: "90-91" },
    { st: "CA", city: "San Diego",     lon: -117.1611, lat: 32.7157, pop: 1380000, zip2: "92" },
    { st: "CA", city: "San Jose",      lon: -121.8863, lat: 37.3382, pop: 1010000, zip2: "95" },
    { st: "CA", city: "San Francisco", lon: -122.4194, lat: 37.7749, pop: 808000,  zip2: "94" },
    { st: "MN", city: "Minneapolis",   lon: -93.2650,  lat: 44.9778, pop: 425000,  zip2: "55" },
    { st: "MN", city: "St. Paul",      lon: -93.0899,  lat: 44.9537, pop: 307000,  zip2: "55" },
    { st: "MN", city: "Duluth",        lon: -92.1005,  lat: 46.7867, pop: 86600,   zip2: "55" },
    { st: "TX", city: "Houston",       lon: -95.3698,  lat: 29.7604, pop: 2300000, zip2: "77" },
    { st: "TX", city: "Dallas",        lon: -96.7970,  lat: 32.7767, pop: 1300000, zip2: "75" },
    { st: "TX", city: "Austin",        lon: -97.7431,  lat: 30.2672, pop: 980000,  zip2: "78" },
    { st: "TX", city: "San Antonio",   lon: -98.4936,  lat: 29.4241, pop: 1470000, zip2: "78" },
    { st: "FL", city: "Miami",         lon: -80.1918,  lat: 25.7617, pop: 455000,  zip2: "33" },
    { st: "FL", city: "Tampa",         lon: -82.4572,  lat: 27.9506, pop: 403000,  zip2: "33-34" },
    { st: "FL", city: "Orlando",       lon: -81.3792,  lat: 28.5383, pop: 307000,  zip2: "32-33" },
    { st: "FL", city: "Jacksonville",  lon: -81.6557,  lat: 30.3322, pop: 971000,  zip2: "32" },
  ];

  const popMin = 80000, popMax = 3900000;
  const norm = (p) => Math.min(1, Math.max(0, (p - popMin) / (popMax - popMin)));

  function stColor(st) {
    switch (st) {
      case "CA": return 0x18ffd0;
      case "MN": return 0x00b0ff;
      case "TX": return 0xffd600;
      case "FL": return 0xff1744;
      default: return 0xffffff;
    }
  }

  for (const c of cities) {
    const p = lonLatToXZ(c.lon, c.lat);
    const t = norm(c.pop);
    const mouth = 0.10 + t * 0.58;
    const h = 0.35 + t * 1.75;

    const geo = new THREE.ConeGeometry(mouth, h, 28, 1, true);
    geo.translate(0, h * 0.5, 0);
    const vPos = geo.attributes.position;
    for (let i = 0; i < vPos.count; i++) {
      const x = vPos.getX(i), y = vPos.getY(i), z = vPos.getZ(i);
      const twist = (y / h) * 0.35;
      const cs = Math.cos(twist), sn = Math.sin(twist);
      const rx = x * cs - z * sn, rz = x * sn + z * cs;
      const wobble = (fbm2((rx + 10) * 1.6, (rz + 10) * 1.6) - 0.5) * 0.03;
      vPos.setXYZ(i, rx * (1 + wobble), y, rz * (1 + wobble));
    }
    vPos.needsUpdate = true;
    geo.computeVertexNormals();

    const mat = new THREE.MeshPhysicalMaterial({
      color: stColor(c.st), roughness: 0.22, metalness: 0.08, transmission: 0.55,
      thickness: 0.8, transparent: true, opacity: 0.36, clearcoat: 1.0,
      clearcoatRoughness: 0.18, emissive: stColor(c.st), emissiveIntensity: 0.22
    });
    const cone = new THREE.Mesh(geo, mat);
    cone.position.set(p.x, 0.12, p.z); cone.castShadow = true;
    conesGroup.add(cone);

    const stemGeo = new THREE.CylinderGeometry(0.018, 0.028, 0.22, 10);
    const stemMat = new THREE.MeshStandardMaterial({ color: 0xbefcff, transparent: true, opacity: 0.35, metalness: 0.2, roughness: 0.55, emissive: 0x004a5a, emissiveIntensity: 0.35 });
    const stem = new THREE.Mesh(stemGeo, stemMat);
    stem.position.set(p.x, 0.11, p.z); conesGroup.add(stem);

    const lbl = makeLabelSprite(`${c.city}  ‚Ä¢  ZIP2 ${c.zip2}`, { fontSize: 34, glow: "rgba(0,255,255,0.45)" });
    lbl.position.set(p.x, 0.35 + h, p.z);
    lbl.userData.isCityLabel = true;
    labelsGroup.add(lbl);

    const ringGeo = new THREE.RingGeometry(mouth * 0.75, mouth * 0.98, 44);
    ringGeo.rotateX(-Math.PI / 2);
    const ringMat = new THREE.MeshBasicMaterial({ color: stColor(c.st), transparent: true, opacity: 0.22, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.position.set(p.x, 0.07, p.z);
    conesGroup.add(ring);
  }
  scene.add(conesGroup);
}

// ============================================================
// üß† Network clusters
// ============================================================
class NetworkCluster {
  constructor(type, color, position) {
    this.type = type; this.color = color;
    this.nodes = []; this.connections = [];
    this.group = new THREE.Group();
    this.velocity = new THREE.Vector3();
    this.originalPos = position.clone();
    this.convergenceSpeed = 0.01 + Math.random() * 0.01;
    this.orbitSpeed = 0.2 + Math.random() * 0.2;
    this.trail = null; this.trailPoints = []; this.trailMax = 90;
    this.createNetwork(type, color);
    this.group.position.copy(position);
    this.createTrail(color);
  }
  createNetwork(type, color) {
    switch (type) {
      case "CNN": this.createCNN(color); break;
      case "Transformer": this.createTransformer(color); break;
      case "RNN": this.createRNN(color); break;
      case "Biological": this.createBiological(color); break;
    }
  }
  createCNN(color) {
    const layers = [{ count: 6, radius: 1.5 }, { count: 4, radius: 1.0 }, { count: 3, radius: 0.6 }];
    layers.forEach((layer, li) => {
      const y = (li - 1) * 0.8;
      for (let i = 0; i < layer.count; i++) {
        const a = (i / layer.count) * Math.PI * 2;
        const node = this.createNode(color, new THREE.Vector3(Math.cos(a) * layer.radius, y, Math.sin(a) * layer.radius));
        this.nodes.push({ mesh: node, layer: li, index: i });
      }
    });
    this.nodes.forEach((n, i) => {
      for (let j = i + 1; j < this.nodes.length; j++) {
        const o = this.nodes[j];
        if (o.layer === n.layer + 1 || (o.layer === n.layer && Math.abs(o.index - n.index) <= 1))
          this.createConnection(n.mesh.position, o.mesh.position, color);
      }
    });
  }
  createTransformer(color) {
    const gs = 4, sp = 0.7;
    for (let i = 0; i < gs; i++) for (let j = 0; j < gs; j++) {
      const x = (i - gs / 2 + 0.5) * sp, y = (j - gs / 2 + 0.5) * sp;
      const z = Math.sin(i * 0.5) * 0.3 + Math.cos(j * 0.5) * 0.3;
      this.nodes.push({ mesh: this.createNode(color, new THREE.Vector3(x, y, z)), x: i, y: j });
    }
    this.nodes.forEach((n, i) => {
      for (let c = 0; c < 3 + Math.floor(Math.random() * 3); c++) {
        const t = Math.floor(Math.random() * this.nodes.length);
        if (t !== i) this.createConnection(n.mesh.position, this.nodes[t].mesh.position, color, 0.15);
      }
    });
  }
  createRNN(color) {
    const nc = 8, r = 1.2;
    for (let i = 0; i < nc; i++) {
      const a = (i / nc) * Math.PI * 2;
      this.nodes.push({ mesh: this.createNode(color, new THREE.Vector3(Math.cos(a) * r, Math.sin(a) * r * 0.5, Math.sin(a) * r)), index: i });
    }
    this.nodes.forEach((n, i) => {
      this.createConnection(n.mesh.position, this.nodes[(i + 1) % nc].mesh.position, color);
      if (i % 2 === 0) { const lp = n.mesh.position.clone(); lp.y += 0.5; this.createConnection(n.mesh.position, lp, color, 0.2); }
    });
  }
  createBiological(color) {
    const center = new THREE.Vector3(0, 0, 0);
    this.nodes.push({ mesh: this.createNode(color, center), generation: 0 });
    const branch = (pp, gen, mx) => {
      if (gen >= mx) return;
      const br = gen === 0 ? 4 : 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < br; i++) {
        const a = Math.random() * Math.PI * 2, el = (Math.random() - 0.5) * Math.PI * 0.6;
        const d = 0.5 + Math.random() * 0.5;
        const np = new THREE.Vector3(pp.x + Math.cos(a) * Math.cos(el) * d, pp.y + Math.sin(el) * d, pp.z + Math.sin(a) * Math.cos(el) * d);
        this.nodes.push({ mesh: this.createNode(color, np, 0.08 / (gen + 1)), generation: gen + 1 });
        this.createConnection(pp, np, color, 0.15);
        if (Math.random() > 0.3) branch(np, gen + 1, mx);
      }
    };
    branch(center, 0, 3);
  }
  createNode(color, position, size = 0.12) {
    const geo = new THREE.SphereGeometry(size, 12, 12);
    const mat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.55, metalness: 0.25, roughness: 0.35, transparent: true, opacity: 0.93 });
    const node = new THREE.Mesh(geo, mat);
    node.position.copy(position);
    node.userData.baseScale = 1; node.userData.pulseOffset = Math.random() * Math.PI * 2;
    node.castShadow = true; this.group.add(node); return node;
  }
  createConnection(p1, p2, color, opacity = 0.3) {
    const geo = new THREE.BufferGeometry().setFromPoints([p1.clone(), p2.clone()]);
    const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
    const line = new THREE.Line(geo, mat); line.visible = showConnections;
    this.group.add(line); this.connections.push(line);
  }
  createTrail(color) {
    const geo = new THREE.BufferGeometry();
    geo.setAttribute("position", new THREE.BufferAttribute(new Float32Array(this.trailMax * 3), 3));
    geo.setDrawRange(0, 0);
    this.trail = new THREE.Line(geo, new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.16 }));
    this.trail.visible = showTrails; scene.add(this.trail);
  }
  pushTrailPoint(wp) {
    this.trailPoints.push(wp.clone());
    if (this.trailPoints.length > this.trailMax) this.trailPoints.shift();
    const attr = this.trail.geometry.getAttribute("position");
    for (let i = 0; i < this.trailPoints.length; i++) { const p = this.trailPoints[i]; attr.setXYZ(i, p.x, p.y, p.z); }
    attr.needsUpdate = true; this.trail.geometry.setDrawRange(0, this.trailPoints.length);
  }
  setConnectionsVisible(v) { this.connections.forEach(l => l.visible = v); }
  setTrailVisible(v) { if (this.trail) this.trail.visible = v; }
  reset() { this.group.position.copy(this.originalPos); this.velocity.set(0, 0, 0); this.trailPoints = []; if (this.trail) this.trail.geometry.setDrawRange(0, 0); }
  update(dt, idx) {
    for (const n of this.nodes) { const p = Math.sin(time * 2 + n.mesh.userData.pulseOffset) * 0.2 + 1; n.mesh.scale.setScalar(n.mesh.userData.baseScale * p); }
    this.group.rotation.y += 0.0015; this.group.rotation.x += 0.0007;
    const tc = new THREE.Vector3(0, 0, 0).sub(this.group.position);
    if (tc.length() > 3) { tc.normalize().multiplyScalar(this.convergenceSpeed); this.velocity.add(tc); }
    const ang = time * this.orbitSpeed;
    this.velocity.x += Math.cos(ang + idx) * 0.008;
    this.velocity.z += Math.sin(ang + idx) * 0.008;
    this.velocity.multiplyScalar(0.96);
    this.group.position.add(this.velocity);
    if (showTrails) this.pushTrailPoint(this.group.position);
  }
}

// ============================================================
// Init
// ============================================================
function init() {
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x060716, 14, 70);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1200);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x050612, 1);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.08;
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // Lights
  scene.add(new THREE.HemisphereLight(0x6bdcff, 0x0b1020, 0.45));
  const key = new THREE.DirectionalLight(0xffffff, 2.2);
  key.position.set(8, 16, 10); key.castShadow = true;
  key.shadow.mapSize.set(2048, 2048);
  key.shadow.camera.near = 1; key.shadow.camera.far = 70;
  key.shadow.camera.left = -22; key.shadow.camera.right = 22;
  key.shadow.camera.top = 22; key.shadow.camera.bottom = -22;
  scene.add(key);
  const rim = new THREE.PointLight(0x00ffff, 1.35, 120); rim.position.set(-8, 8, -10); scene.add(rim);
  const core = new THREE.PointLight(0xffffff, 1.0, 90); core.position.set(0, 0.5, 0); scene.add(core);

  // Central Platonic Ideal
  const idealGeo = new THREE.IcosahedronGeometry(0.85, 2);
  const idealMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.5, metalness: 0.25, roughness: 0.22, transparent: true, opacity: 0.92 });
  centralIdeal = new THREE.Mesh(idealGeo, idealMat);
  centralIdeal.position.y = 0.6; centralIdeal.castShadow = true; scene.add(centralIdeal);

  const wfGeo = new THREE.IcosahedronGeometry(0.93, 2);
  const wfMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.22 });
  centralIdeal.add(new THREE.Mesh(wfGeo, wfMat));

  const glowGeo = new THREE.SphereGeometry(1.6, 40, 40);
  const glowMat = new THREE.ShaderMaterial({
    uniforms: { time: { value: 0 } },
    vertexShader: `varying vec3 vNormal; void main(){ vNormal=normalize(normalMatrix*normal); gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
    fragmentShader: `uniform float time; varying vec3 vNormal; void main(){ float i=pow(0.78-dot(vNormal,vec3(0,0,1)),2.25); float p=sin(time*2.0)*0.15+0.85; vec3 g=vec3(0.45,1,1)*i*p; gl_FragColor=vec4(g,i*0.62); }`,
    side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
  });
  const glow = new THREE.Mesh(glowGeo, glowMat); glow.name = "idealGlow"; glow.position.copy(centralIdeal.position); scene.add(glow);

  // Particles
  const pGeo = new THREE.BufferGeometry();
  const pCount = 1100, pPos = new Float32Array(pCount * 3);
  for (let i = 0; i < pCount; i++) { pPos[i * 3] = (Math.random() - 0.5) * 70; pPos[i * 3 + 1] = (Math.random() - 0.5) * 70; pPos[i * 3 + 2] = (Math.random() - 0.5) * 70; }
  pGeo.setAttribute("position", new THREE.BufferAttribute(pPos, 3));
  particleSystem = new THREE.Points(pGeo, new THREE.PointsMaterial({ color: 0x7efcff, size: 0.055, transparent: true, opacity: 0.28 }));
  particleSystem.position.y = 1.0; scene.add(particleSystem);

  // Network clusters
  const types = [
    { name: "CNN", color: 0xff1744, count: 3 },
    { name: "Transformer", color: 0x00e676, count: 3 },
    { name: "RNN", color: 0xffd600, count: 3 },
    { name: "Biological", color: 0x00b0ff, count: 3 }
  ];
  types.forEach((t, ti) => {
    for (let i = 0; i < t.count; i++) {
      const a = ti * (Math.PI / 2) + i * (Math.PI / 6);
      const r = 7.2 + Math.random() * 2.2;
      const pos = new THREE.Vector3(Math.cos(a) * r, (Math.random() - 0.5) * 3.2 + 1.8, Math.sin(a) * r);
      const c = new NetworkCluster(t.name, t.color, pos);
      scene.add(c.group); networkClusters.push(c);
    }
  });

  // Labels group (needs to exist before map builds)
  labelsGroup = new THREE.Group();
  labelsGroup.position.y = mapFloorY;
  scene.add(labelsGroup);

  // Build map + cones (async)
  buildMapLayer();
  buildZip2Cones();

  // Compass
  compassGroup = new THREE.Group();
  const compass = buildCompassRose();
  compass.position.set(MAP.width * 0.62, mapFloorY + 0.45, -MAP.depth * 0.62);
  compass.scale.setScalar(1.18);
  compassGroup.add(compass);
  scene.add(compassGroup);

  wireUI();
  controls.target.set(0, 0.6, 0);
  controls.update();
  window.addEventListener("resize", onWindowResize);
  bindPointerControls();
}

function animate() {
  requestAnimationFrame(animate);
  time += 0.016;

  const glow = scene.getObjectByName("idealGlow");
  if (glow?.material?.uniforms?.time) glow.material.uniforms.time.value = time;

  for (let i = 0; i < networkClusters.length; i++) networkClusters[i].update(0.016, i);
  centralIdeal.rotation.y += 0.002; centralIdeal.rotation.x += 0.0012;
  particleSystem.rotation.y += 0.00008; particleSystem.rotation.x += 0.00003;

  const ocean = scene.getObjectByName("ocean");
  if (ocean) ocean.rotation.y = Math.sin(time * 0.08) * 0.02;

  if (conesGroup && conesVisible) {
    conesGroup.children.forEach((obj, i) => {
      if (obj.isMesh && obj.geometry?.type?.includes("Cone")) {
        const s = 1 + Math.sin(time * 1.6 + i) * 0.015;
        obj.scale.set(s, 1 + Math.sin(time * 1.1 + i) * 0.02, s);
      }
    });
  }
  if (compassGroup && compassVisible) compassGroup.rotation.y = Math.sin(time * 0.12) * 0.03;

  if (autoRotate && !controls.isDown && !isTopDown) controls.velAz += 0.00015;
  if (isTopDown) {
    camera.up.set(0, 0, 1);
    camera.position.set(topDownPan.x, topDownZoom, topDownPan.z - 0.01);
    camera.lookAt(topDownPan.x, mapFloorY, topDownPan.z);
  } else if (mouseCamera) {
    camera.up.set(0, 1, 0);
    controls.update();
  } else {
    camera.position.x = Math.cos(time * 0.02) * 16;
    camera.position.z = Math.sin(time * 0.02) * 16;
    camera.position.y = 8 + Math.sin(time * 0.015) * 1.2;
    camera.lookAt(0, 0.4, 0);
  }
  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function wireUI() {
  document.getElementById("btn-reset").addEventListener("click", () => {
    isTopDown = false;
    topDownPan = { x: 0, z: 0 };
    camera.up.set(0, 1, 0);
    networkClusters.forEach(c => c.reset());
    controls.azimuth = 0.66; controls.polar = 0.95; controls.radius = 18;
    controls.pan.set(0, 0, 0); controls.target.set(0, 0.35, 0);
  });
  document.getElementById("btn-paths").addEventListener("click", () => {
    showConnections = !showConnections;
    networkClusters.forEach(c => c.setConnectionsVisible(showConnections));
  });
  document.getElementById("btn-trails").addEventListener("click", () => {
    showTrails = !showTrails;
    networkClusters.forEach(c => c.setTrailVisible(showTrails));
    if (!showTrails) networkClusters.forEach(c => { c.trailPoints = []; if (c.trail) c.trail.geometry.setDrawRange(0, 0); });
  });
  document.getElementById("btn-rotate").addEventListener("click", () => { autoRotate = !autoRotate; if (autoRotate) { isTopDown = false; camera.up.set(0,1,0); } });
  document.getElementById("btn-camera").addEventListener("click", () => {
    mouseCamera = !mouseCamera;
    if (!mouseCamera) { isTopDown = false; camera.up.set(0,1,0); }
    document.getElementById("hint").style.display = mouseCamera ? "block" : "none";
  });
  document.getElementById("btn-map").addEventListener("click", () => { mapVisible = !mapVisible; if (mapGroup) mapGroup.visible = mapVisible; });
  document.getElementById("btn-cones").addEventListener("click", () => {
    conesVisible = !conesVisible;
    if (conesGroup) conesGroup.visible = conesVisible;
    labelsGroup.children.forEach(s => { if (s.userData.isCityLabel) s.visible = conesVisible && labelsVisible; });
  });
  document.getElementById("btn-labels").addEventListener("click", () => {
    labelsVisible = !labelsVisible;
    if (labelsGroup) labelsGroup.visible = labelsVisible;
    labelsGroup.children.forEach(s => {
      if (s.userData.isCityLabel) s.visible = conesVisible && labelsVisible;
      else s.visible = labelsVisible;
    });
  });
  document.getElementById("btn-compass").addEventListener("click", () => { compassVisible = !compassVisible; if (compassGroup) compassGroup.visible = compassVisible; });
  document.getElementById("btn-topdown").addEventListener("click", () => {
    isTopDown = true;
    mouseCamera = true;
    camera.up.set(0, 0, 1); // +Z = North = screen up
    camera.position.set(0, 16, -0.01);
    camera.lookAt(0, mapFloorY, 0);
    topDownZoom = 16;
  });
}

function bindPointerControls() {
  const el = renderer.domElement;
  el.addEventListener("pointerdown", (e) => {
    if (!mouseCamera) return;
    controls.isDown = true; controls.button = e.button;
    controls.lastX = e.clientX; controls.lastY = e.clientY;
    el.setPointerCapture(e.pointerId);
  });
  el.addEventListener("pointermove", (e) => {
    if (!mouseCamera || !controls.isDown) return;
    const dx = e.clientX - controls.lastX, dy = e.clientY - controls.lastY;
    controls.lastX = e.clientX; controls.lastY = e.clientY;
    if (isTopDown) {
      // In top-down, drag always pans (X=screen-right=East, Z=screen-up=North)
      const scale = topDownZoom * 0.0015;
      topDownPan.x -= dx * scale;
      topDownPan.z += dy * scale;
    } else if (e.shiftKey || controls.button === 1 || controls.button === 2) {
      controls.velPanX += -dx * 0.0022; controls.velPanY += dy * 0.0022;
    } else {
      controls.velAz += -dx * 0.003; controls.velPol += -dy * 0.003;
    }
  });
  el.addEventListener("pointerup", (e) => { if (!mouseCamera) return; controls.isDown = false; try { el.releasePointerCapture(e.pointerId); } catch (_) {} });
  el.addEventListener("wheel", (e) => {
    if (!mouseCamera) return; e.preventDefault();
    if (isTopDown) {
      topDownZoom = Math.max(4, Math.min(40, topDownZoom + Math.sign(e.deltaY) * 1.2));
    } else {
      controls.radius = Math.max(4, Math.min(60, controls.radius + Math.sign(e.deltaY) * 0.9));
    }
  }, { passive: false });
  el.addEventListener("contextmenu", (e) => e.preventDefault());
}

init();
animate();
</script>
</body>
</html>
