<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üó∫Ô∏è US Pop + State Borders Sim ‚öì (GLB Upload + Accel Movement)</title>
  <style>
    :root{
      --bg0:#050a14;
      --bg1:#071a2f;
      --hud:rgba(0, 20, 40, 0.85);
      --hud2:rgba(20, 0, 40, 0.75);
      --cyan:#00e5ff;
      --green:#00ff88;
      --mag:#ff00ff;
      --amber:#ffaa00;
      --muted:#88ccff;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; overflow:hidden; background:radial-gradient(1200px 700px at 20% 10%, #0b2a4a 0%, var(--bg0) 50%, #02030a 100%); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; color:#d7fbff; }
    #canvas{ position:fixed; inset:0; }

    /* HUD */
    #hud{
      position:fixed; left:16px; top:16px; z-index:10; width:360px;
      background:linear-gradient(135deg, var(--hud), rgba(0, 60, 90, 0.35));
      border:2px solid rgba(0,229,255,0.45);
      box-shadow:0 16px 60px rgba(0,229,255,0.10);
      border-radius:14px; padding:14px 14px 12px;
      backdrop-filter: blur(8px);
    }
    #hud h1{ margin:0 0 6px; font-size:14px; letter-spacing:1px; color:var(--cyan); text-shadow:0 0 14px rgba(0,229,255,.35); }
    #hud .sub{ font-size:11px; color:rgba(215,251,255,.75); margin-bottom:10px; }
    #hud .row{ display:flex; justify-content:space-between; gap:10px; font-size:12px; padding:6px 0; border-bottom:1px solid rgba(0,229,255,0.12); }
    #hud .k{ color:rgba(215,251,255,.75); }
    #hud .v{ color:var(--green); font-weight:800; }
    #hud .help{ margin-top:10px; font-size:11px; color:rgba(215,251,255,.7); line-height:1.35; }
    .chip{ display:inline-flex; gap:6px; align-items:center; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,0.14); background:rgba(0,0,0,0.25); }

    /* Overlay uploader */
    #upload-overlay{
      position:fixed; inset:0; z-index:50; display:flex; align-items:center; justify-content:center;
      background:radial-gradient(900px 600px at 50% 40%, rgba(0,255,136,0.12), rgba(0,0,0,0.92));
    }
    #upload-card{
      width:min(560px, calc(100vw - 24px));
      background:linear-gradient(135deg, rgba(0,25,40,0.92), rgba(10,0,20,0.88));
      border:2px solid rgba(0,255,136,0.55);
      box-shadow:0 20px 90px rgba(0,255,136,0.12);
      border-radius:18px;
      padding:22px 22px 18px;
      text-align:center;
    }
    #upload-card h2{ margin:0 0 8px; font-size:18px; color:var(--green); text-shadow:0 0 18px rgba(0,255,136,.25); }
    #upload-card p{ margin:0 0 14px; font-size:12px; color:rgba(215,251,255,.75); }
    #file-input{ display:none; }
    #upload-btn{
      border:none; cursor:pointer; font-weight:900; letter-spacing:.6px;
      padding:12px 20px; border-radius:12px;
      background:linear-gradient(135deg, rgba(0,255,136,1), rgba(0,200,110,1));
      color:#001012;
      box-shadow:0 10px 40px rgba(0,255,136,0.22);
      transition: transform .15s ease, filter .15s ease;
    }
    #upload-btn:hover{ transform: translateY(-1px); filter:saturate(1.1); }
    #upload-skip{
      margin-left:10px;
      background:transparent; color:rgba(215,251,255,.75);
      border:1px solid rgba(255,255,255,0.18);
      padding:12px 16px; border-radius:12px; cursor:pointer;
    }
    #loading{
      position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
      z-index:60; display:none; padding:12px 16px; border-radius:12px;
      border:1px solid rgba(0,255,136,0.35);
      background:rgba(0,0,0,0.6);
      color:var(--green);
      box-shadow:0 14px 50px rgba(0,255,136,0.12);
    }

    /* Mini controls hint bottom-right */
    #corner{
      position:fixed; right:16px; bottom:16px; z-index:10;
      background:linear-gradient(135deg, rgba(20,20,40,0.78), rgba(0,0,0,0.6));
      border:1px solid rgba(255,0,255,0.35);
      border-radius:14px; padding:10px 12px;
      width:320px;
      box-shadow:0 16px 60px rgba(255,0,255,0.08);
      backdrop-filter: blur(8px);
    }
    #corner .t{ color:var(--mag); font-weight:900; font-size:12px; margin-bottom:6px; }
    #corner .b{ font-size:11px; color:rgba(215,251,255,.75); line-height:1.35; }

    a{ color:inherit; }
  </style>
</head>
<body>
  <div id="canvas"></div>

  <div id="hud">
    <h1>üó∫Ô∏è US POP + STATE BORDERS ¬∑ SIM CORE</h1>
    <div class="sub">State mesh + population towers + player GLB (fixed uploader) ¬∑ WASD accel (A/D reversed)</div>
    <div class="row"><div class="k">üìç Mode</div><div class="v" id="mode">MAP</div></div>
    <div class="row"><div class="k">üèéÔ∏è Speed</div><div class="v" id="speed">0.00</div></div>
    <div class="row"><div class="k">üß≠ Heading</div><div class="v" id="heading">0¬∞</div></div>
    <div class="row"><div class="k">üß± State lines</div><div class="v" id="statesLoaded">loading‚Ä¶</div></div>
    <div class="row"><div class="k">üë§ Player model</div><div class="v" id="playerModel">default</div></div>
    <div class="help">
      <div class="chip">üéÆ <b>Move</b>: W/S forward/back ¬∑ <b>A/D reversed</b> (D=left, A=right)</div><br/>
      <div class="chip">üß® <b>Boost</b>: Shift ¬∑ <b>Brake</b>: Space</div><br/>
      <div class="chip">üñ±Ô∏è Drag: orbit cam ¬∑ Wheel: zoom</div>
    </div>
  </div>

  <div id="upload-overlay">
    <div id="upload-card">
      <h2>üöÄ Upload a GLB Player Model</h2>
      <p>Drop in a .glb/.gltf and we‚Äôll center + scale it and attach it to the player group.</p>
      <input type="file" id="file-input" accept=".glb,.gltf" />
      <button id="upload-btn">Choose GLB File</button>
      <button id="upload-skip" title="Skip and use default">Skip</button>
      <p style="margin-top:12px; opacity:.7;">Tip: If the model loads sideways, we can add per-file yaw/pitch presets next.</p>
    </div>
  </div>

  <div id="loading">Loading model‚Ä¶</div>

  <div id="corner">
    <div class="t">‚öôÔ∏è Sim toggles</div>
    <div class="b">
      <b>M</b> toggles Map/Freefly camera ¬∑ <b>R</b> resets player ¬∑ <b>U</b> re-open uploader<br/>
      Population bars are approximate (demo dataset) ‚Äî we can wire real census CSV later.
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/",
      "d3-geo": "https://cdn.jsdelivr.net/npm/d3-geo@3/+esm",
      "topojson-client": "https://cdn.jsdelivr.net/npm/topojson-client@3/+esm"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as d3geo from 'd3-geo';
    import * as topojson from 'topojson-client';

    // ============================================================
    // üß† Tiny utilities
    // ============================================================
    const clamp = (v, a, b) => (v < a ? a : (v > b ? b : v));
    const lerp = (a, b, t) => a + (b - a) * t;
    const V3A = new THREE.Vector3();
    const V3B = new THREE.Vector3();

    // ============================================================
    // üåé Three.js setup
    // ============================================================
    const mount = document.getElementById('canvas');
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x071a2f, 60, 420);
    scene.background = new THREE.Color(0x050a14);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 90, 150);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    mount.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 35;
    controls.maxDistance = 520;
    controls.target.set(0, 0, 0);

    // Lights
    const hemi = new THREE.HemisphereLight(0x88ccff, 0x001018, 0.75);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.15);
    sun.position.set(120, 180, 90);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.left = -260;
    sun.shadow.camera.right = 260;
    sun.shadow.camera.top = 260;
    sun.shadow.camera.bottom = -260;
    sun.shadow.camera.near = 10;
    sun.shadow.camera.far = 650;
    scene.add(sun);

    // Ground glow
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(1200, 1200, 1, 1),
      new THREE.MeshStandardMaterial({
        color: 0x061a2a,
        roughness: 0.85,
        metalness: 0.05,
        emissive: 0x001018,
        emissiveIntensity: 0.25
      })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Subtle grid lines
    const grid = new THREE.GridHelper(600, 60, 0x0aa6c4, 0x0aa6c4);
    grid.material.opacity = 0.12;
    grid.material.transparent = true;
    grid.position.y = 0.02;
    scene.add(grid);

    // ============================================================
    // üó∫Ô∏è US States mesh (TopoJSON ‚Üí d3-geo projection ‚Üí Three line segments)
    // ============================================================
    const usGroup = new THREE.Group();
    usGroup.position.set(0, 0.06, 0);
    scene.add(usGroup);

    const STATES_URL = 'https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json';

    // Project lon/lat to a compact sim space
    const projection = d3geo.geoAlbersUsa()
      .scale(1000)          // d3 pixels-ish
      .translate([0, 0]);   // center at origin

    // Map projected coords to Three world units
    const WORLD_SCALE = 0.12; // shrink to fit our ground

    function projectLonLatToWorld(lon, lat, out = new THREE.Vector3()) {
      const p = projection([lon, lat]);
      if (!p) return out.set(0, 0, 0);
      // d3 returns [x,y] where y grows down; flip y to z
      return out.set(p[0] * WORLD_SCALE, 0.08, -p[1] * WORLD_SCALE);
    }

    function lineFromMultiLineString(mls) {
      const positions = [];
      for (const line of mls.coordinates) {
        for (let i = 0; i < line.length; i++) {
          const [lon, lat] = line[i];
          const v = projectLonLatToWorld(lon, lat, V3A);
          positions.push(v.x, v.y, v.z);
        }
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const mat = new THREE.LineBasicMaterial({ color: 0x00e5ff, transparent: true, opacity: 0.55 });
      const line = new THREE.LineSegments(geo, mat);
      return line;
    }

    async function loadStates() {
      const el = document.getElementById('statesLoaded');
      try {
        const res = await fetch(STATES_URL, { cache: 'force-cache' });
        const topo = await res.json();
        const states = topojson.feature(topo, topo.objects.states);
        const borders = topojson.mesh(topo, topo.objects.states, (a, b) => a !== b);

        // Borders line mesh
        const borderLine = lineFromMultiLineString(borders);
        usGroup.add(borderLine);

        // Outer coastline-ish outline (states exterior)
        const outline = topojson.mesh(topo, topo.objects.states, (a, b) => a === b);
        const outlineLine = lineFromMultiLineString(outline);
        outlineLine.material = new THREE.LineBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.22 });
        outlineLine.position.y = 0.03;
        usGroup.add(outlineLine);

        // Fill-ish faint mesh via points sampling (cheap ‚Äúheat mist‚Äù)
        // (We keep it lightweight; proper polygon fill is heavier.)
        const mist = new THREE.Points(
          new THREE.BufferGeometry(),
          new THREE.PointsMaterial({ color: 0x88ccff, size: 0.5, transparent: true, opacity: 0.15 })
        );
        const pts = [];
        // Sample a few thousand random points across bounding box and keep those inside US polygon
        // Using d3geo for containment
        const feature = { type: 'FeatureCollection', features: states.features };
        const bounds = d3geo.geoBounds(feature);
        const [minLon, minLat] = bounds[0];
        const [maxLon, maxLat] = bounds[1];
        const tries = 3500;
        let kept = 0;
        for (let i = 0; i < tries; i++) {
          const lon = lerp(minLon, maxLon, Math.random());
          const lat = lerp(minLat, maxLat, Math.random());
          if (!projection([lon, lat])) continue;
          // approximate containment by using one big multipolygon (union not available here), so we accept projection presence
          const w = projectLonLatToWorld(lon, lat, V3A);
          pts.push(w.x, 0.09 + Math.random() * 0.2, w.z);
          kept++;
        }
        mist.geometry.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
        usGroup.add(mist);

        el.textContent = `loaded (${states.features.length} states)`;
      } catch (err) {
        console.error(err);
        el.textContent = 'failed (offline?)';
      }
    }

    // ============================================================
    // üìä Population bars (demo dataset ‚Äî easily replaceable)
    // ============================================================
    const popBars = new THREE.Group();
    popBars.position.y = 0.02;
    scene.add(popBars);

    // Approx. 2020-ish populations (millions). Demo subset to keep it light.
    // You can replace with full census CSV later.
    const POP = [
      { name: 'CA', lon: -119.4179, lat: 36.7783, m: 39.5 },
      { name: 'TX', lon: -99.9018, lat: 31.9686, m: 29.1 },
      { name: 'FL', lon: -81.5158, lat: 27.6648, m: 21.5 },
      { name: 'NY', lon: -75.0000, lat: 43.0000, m: 19.3 },
      { name: 'PA', lon: -77.1945, lat: 41.2033, m: 13.0 },
      { name: 'IL', lon: -89.3985, lat: 40.6331, m: 12.7 },
      { name: 'OH', lon: -82.9071, lat: 40.4173, m: 11.7 },
      { name: 'GA', lon: -82.9001, lat: 32.1656, m: 10.7 },
      { name: 'NC', lon: -79.0193, lat: 35.7596, m: 10.4 },
      { name: 'MI', lon: -85.6024, lat: 44.3148, m: 10.0 },
      { name: 'NJ', lon: -74.4057, lat: 40.0583, m: 9.3 },
      { name: 'VA', lon: -78.6569, lat: 37.4316, m: 8.6 },
      { name: 'WA', lon: -120.7401, lat: 47.7511, m: 7.7 },
      { name: 'AZ', lon: -111.0937, lat: 34.0489, m: 7.2 },
      { name: 'MA', lon: -71.3824, lat: 42.4072, m: 6.9 }
    ];

    function buildPopBars() {
      // Clear
      while (popBars.children.length) popBars.remove(popBars.children[0]);

      const base = new THREE.MeshStandardMaterial({
        color: 0x00ff88,
        emissive: 0x00ff88,
        emissiveIntensity: 0.18,
        roughness: 0.35,
        metalness: 0.25
      });
      const cap = new THREE.MeshStandardMaterial({
        color: 0xffaa00,
        emissive: 0xffaa00,
        emissiveIntensity: 0.15,
        roughness: 0.4,
        metalness: 0.2
      });

      for (const s of POP) {
        const pos = projectLonLatToWorld(s.lon, s.lat, V3A);
        const h = 1 + (s.m * 0.9); // scale height
        const geo = new THREE.CylinderGeometry(0.8, 1.1, h, 10, 1);
        const bar = new THREE.Mesh(geo, base);
        bar.position.set(pos.x, h / 2, pos.z);
        bar.castShadow = true;
        bar.receiveShadow = true;

        const capGeo = new THREE.SphereGeometry(1.0, 12, 10);
        const c = new THREE.Mesh(capGeo, cap);
        c.position.set(pos.x, h + 0.4, pos.z);
        c.castShadow = true;

        // label sprite-ish (simple CanvasTexture)
        const label = makeTextSprite(`${s.name} ¬∑ ${s.m.toFixed(1)}M`, {
          fontSize: 44,
          padding: 18,
          border: 'rgba(0,229,255,0.35)',
          fill: 'rgba(0,0,0,0.55)',
          text: 'rgba(215,251,255,0.92)'
        });
        label.position.set(pos.x, h + 6.0, pos.z);

        popBars.add(bar, c, label);
      }
    }

    function makeTextSprite(text, opt = {}) {
      const fontSize = opt.fontSize ?? 42;
      const padding = opt.padding ?? 16;
      const border = opt.border ?? 'rgba(255,255,255,0.2)';
      const fill = opt.fill ?? 'rgba(0,0,0,0.5)';
      const textColor = opt.text ?? 'rgba(255,255,255,0.9)';

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = `900 ${fontSize}px ui-monospace, monospace`;
      const metrics = ctx.measureText(text);
      const w = Math.ceil(metrics.width + padding * 2);
      const h = Math.ceil(fontSize + padding * 1.6);
      canvas.width = w;
      canvas.height = h;

      ctx.font = `900 ${fontSize}px ui-monospace, monospace`;
      ctx.fillStyle = fill;
      roundRect(ctx, 0, 0, w, h, 16);
      ctx.fill();
      ctx.strokeStyle = border;
      ctx.lineWidth = 6;
      ctx.stroke();

      ctx.fillStyle = textColor;
      ctx.textBaseline = 'middle';
      ctx.fillText(text, padding, h / 2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.anisotropy = 4;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
      const spr = new THREE.Sprite(mat);
      // world size
      spr.scale.set(w * 0.05, h * 0.05, 1);
      return spr;
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    // ============================================================
    // üë§ Player: acceleration-based movement + GLB uploader (working)
    // ============================================================
    const player = {
      group: new THREE.Group(),
      pos: new THREE.Vector3(0, 1.2, 0),
      vel: new THREE.Vector3(),
      acc: new THREE.Vector3(),
      yaw: 0,
      maxSpeed: 60,          // units/sec
      maxAccel: 110,         // units/sec^2
      friction: 6.0,         // damping
      boostMul: 1.65,
      brakeMul: 2.4
    };

    scene.add(player.group);

    // Default capsule-ish craft
    function createDefaultCraft() {
      player.group.clear();
      const hull = new THREE.Mesh(
        new THREE.CapsuleGeometry(1.2, 3.6, 6, 10),
        new THREE.MeshStandardMaterial({
          color: 0x00e5ff,
          emissive: 0x00e5ff,
          emissiveIntensity: 0.28,
          metalness: 0.75,
          roughness: 0.25
        })
      );
      hull.rotation.x = Math.PI / 2;
      hull.position.y = 1.25;
      hull.castShadow = true;
      player.group.add(hull);

      const fin = new THREE.Mesh(
        new THREE.BoxGeometry(0.3, 1.0, 2.0),
        new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0.2, metalness: 0.5, roughness: 0.35 })
      );
      fin.position.set(0, 1.9, -1.6);
      fin.castShadow = true;
      player.group.add(fin);

      const glow = new THREE.PointLight(0x00ff88, 1.3, 55);
      glow.position.set(0, 1.5, 2.8);
      player.group.add(glow);
    }
    createDefaultCraft();

    function resetPlayer() {
      player.pos.set(0, 1.2, 0);
      player.vel.set(0, 0, 0);
      player.acc.set(0, 0, 0);
      player.yaw = 0;
      player.group.position.copy(player.pos);
      player.group.rotation.set(0, 0, 0);
      controls.target.set(0, 0, 0);
    }

    // Keys
    const keys = Object.create(null);
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'KeyM') toggleMode();
      if (e.code === 'KeyR') resetPlayer();
      if (e.code === 'KeyU') openUploader();
    });
    window.addEventListener('keyup', (e) => { keys[e.code] = false; });

    // Mode (Map follow vs free-orbit)
    let mode = 'MAP';
    const modeEl = document.getElementById('mode');
    function toggleMode(){
      mode = (mode === 'MAP') ? 'FREE' : 'MAP';
      modeEl.textContent = mode;
    }

    function updatePlayer(dt) {
      // Acceleration-based, with A/D reversed (requested)
      const fwd = (keys['KeyW'] ? 1 : 0) + (keys['KeyS'] ? -1 : 0);
      const strafe = (keys['KeyA'] ? 1 : 0) + (keys['KeyD'] ? -1 : 0); // üîÅ reversed
      const boosting = !!(keys['ShiftLeft'] || keys['ShiftRight']);
      const braking = !!keys['Space'];

      // Build input vector in world XZ relative to camera heading
      const camDir = V3A.set(0, 0, -1).applyQuaternion(camera.quaternion);
      camDir.y = 0;
      camDir.normalize();
      const camRight = V3B.set(1, 0, 0).applyQuaternion(camera.quaternion);
      camRight.y = 0;
      camRight.normalize();

      const input = new THREE.Vector3();
      input.addScaledVector(camDir, fwd);
      input.addScaledVector(camRight, strafe);
      if (input.lengthSq() > 0.0001) input.normalize();

      const accelMag = player.maxAccel * (boosting ? player.boostMul : 1.0);
      player.acc.set(input.x * accelMag, 0, input.z * accelMag);

      // Integrate
      player.vel.addScaledVector(player.acc, dt);

      // Brake (strong damping)
      const damp = player.friction * (braking ? player.brakeMul : 1.0);
      player.vel.addScaledVector(player.vel, -damp * dt);

      // Clamp speed
      const maxV = player.maxSpeed * (boosting ? player.boostMul : 1.0);
      const sp = player.vel.length();
      if (sp > maxV) player.vel.multiplyScalar(maxV / sp);

      // Move
      player.pos.addScaledVector(player.vel, dt);
      player.pos.y = 1.2;

      // Face motion direction
      if (player.vel.lengthSq() > 0.05) {
        player.yaw = Math.atan2(player.vel.x, player.vel.z);
      }
      player.group.position.copy(player.pos);
      player.group.rotation.set(0, player.yaw, 0);

      // Keep within bounds
      player.pos.x = clamp(player.pos.x, -240, 240);
      player.pos.z = clamp(player.pos.z, -180, 180);
      player.group.position.copy(player.pos);

      // HUD
      document.getElementById('speed').textContent = sp.toFixed(2);
      document.getElementById('heading').textContent = `${Math.round(THREE.MathUtils.radToDeg(player.yaw))}¬∞`;

      // Camera follow in MAP mode
      if (mode === 'MAP') {
        const follow = V3A.copy(player.pos).add(new THREE.Vector3(
          Math.sin(player.yaw) * -55,
          70,
          Math.cos(player.yaw) * -55
        ));
        camera.position.lerp(follow, 1 - Math.pow(0.001, dt));
        controls.target.lerp(V3B.copy(player.pos).setY(0), 1 - Math.pow(0.001, dt));
      }
    }

    // ============================================================
    // üöÄ GLB uploader (the WORKING pattern you proved)
    // ============================================================
    const fileInput = document.getElementById('file-input');
    const uploadBtn = document.getElementById('upload-btn');
    const uploadSkip = document.getElementById('upload-skip');
    const uploadOverlay = document.getElementById('upload-overlay');
    const loading = document.getElementById('loading');

    function openUploader(){ uploadOverlay.style.display = 'flex'; }
    function closeUploader(){ uploadOverlay.style.display = 'none'; }

    uploadBtn.addEventListener('click', () => fileInput.click());
    uploadSkip.addEventListener('click', () => {
      closeUploader();
      document.getElementById('playerModel').textContent = 'default';
    });

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      closeUploader();
      loading.style.display = 'block';

      const reader = new FileReader();
      reader.onload = (ev) => {
        const loader = new GLTFLoader();
        loader.parse(ev.target.result, '', (gltf) => {
          // Keep any lights in player group? We'll rebuild craft cleanly.
          player.group.clear();

          const model = gltf.scene;

          // Center + scale
          const box = new THREE.Box3().setFromObject(model);
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z) || 1;
          const scale = 7.0 / maxDim;
          model.scale.setScalar(scale);

          box.setFromObject(model);
          const center = box.getCenter(new THREE.Vector3());
          model.position.sub(center);

          model.traverse((c) => {
            if (c.isMesh) {
              c.castShadow = true;
              c.receiveShadow = true;
              if (c.material) {
                c.material.side = THREE.DoubleSide;
                c.material.needsUpdate = true;
              }
            }
          });

          // Add a small glow so it still feels "alive"
          const glow = new THREE.PointLight(0x00ff88, 1.2, 55);
          glow.position.set(0, 2.0, 2.8);
          player.group.add(model);
          player.group.add(glow);

          player.group.position.copy(player.pos);
          player.group.rotation.set(0, player.yaw, 0);

          loading.style.display = 'none';
          document.getElementById('playerModel').textContent = file.name;
        }, (err) => {
          console.error('Error loading GLB:', err);
          loading.style.display = 'none';
          alert('Error loading GLB file.');
          // fallback
          createDefaultCraft();
          document.getElementById('playerModel').textContent = 'default';
        });
      };
      reader.readAsArrayBuffer(file);
    });

    // Let user click overlay background? keep it explicit.

    // ============================================================
    // üé¨ Boot
    // ============================================================
    resetPlayer();
    buildPopBars();
    loadStates();

    // ============================================================
    // üïí Main loop
    // ============================================================
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, clock.getDelta());

      updatePlayer(dt);

      // Make pop labels face camera
      for (const ch of popBars.children) {
        if (ch.isSprite) ch.quaternion.copy(camera.quaternion);
      }

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start with uploader shown; user can skip.
    // (If you want: auto-hide after first successful load.)
  </script>
</body>
</html>
