<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>‚öì Maritime AI Commander ‚Äî Evolved Playable Sim</title>
<meta name="description" content="Playable POV naval sandbox with touch controls, cognitive cone, interaction pings, safe collisions, optional GLB animations, plus a stable world grid."/>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;background:linear-gradient(to bottom,#001a33,#000);color:#0ff;overflow:hidden;touch-action:none;}
#canvas-container{width:100vw;height:100vh;position:relative;}

/* HUD */
#hud{position:absolute;top:14px;left:14px;background:linear-gradient(135deg,rgba(0,30,60,.92),rgba(0,50,80,.92));border:2px solid #00d4ff;padding:12px;border-radius:12px;min-width:300px;z-index:100;backdrop-filter:blur(6px);}
.hud-title{font-size:18px;font-weight:900;color:#00d4ff;text-shadow:0 0 10px #00d4ff;}
.hud-subtitle{font-size:10px;color:#88ccff;font-style:italic;margin-bottom:8px;}
.hud-stat{font-size:12px;color:#88ccff;border-bottom:1px solid rgba(0,212,255,.16);margin:4px 0;padding-bottom:3px;}
.hud-value{float:right;color:#00ff88;}

/* Panels */
.panel{position:absolute;background:rgba(10,10,25,.92);border-radius:12px;padding:12px;border:2px solid #ff00ff;z-index:101;backdrop-filter:blur(6px);}
#controls{bottom:14px;left:14px;width:300px;}
#shop{bottom:14px;right:14px;border-color:#ffaa00;width:300px;}
#memory{top:14px;right:14px;max-width:380px;max-height:440px;overflow:auto;}
#cameraPanel{top:240px;left:14px;width:310px;border-color:#00ff88;}

@media (max-width: 820px){
  #hud{min-width:260px}
  #memory{display:none;}
  #cameraPanel{top:210px}
  #shop{display:none;} /* phones: prioritize play space */
}

/* Buttons */
.btn{display:block;width:100%;margin:4px 0;padding:10px 12px;border-radius:10px;cursor:pointer;border:2px solid #00d4ff;background:linear-gradient(135deg,#001a33,#003366);color:#00d4ff;font-weight:900;letter-spacing:.2px;user-select:none;}
.btn:hover{background:#00d4ff;color:#000;}
.btn.active{background:#ff00ff;color:#fff;border-color:#ff00ff;}
.btn.warn{border-color:#ff6600;color:#ff6600;}
.btn.warn:hover{background:#ff6600;color:#000;}
.row{display:flex;gap:8px;}
.row .btn{flex:1;}
.small{font-size:10px;color:#aee;}

/* Memory */
.memory-entry{font-size:11px;margin:4px 0;padding:6px;background:rgba(80,0,80,.45);border-left:3px solid #f0f;}

/* Touch UI */
#touchUI{position:absolute;inset:0;pointer-events:none;z-index:120;}
.pad{position:absolute;width:150px;height:150px;border-radius:18px;border:2px solid rgba(0,212,255,.55);background:rgba(0,20,40,.20);pointer-events:auto;touch-action:none;}
#movePad{left:16px;bottom:16px;}
#lookPad{right:16px;bottom:16px;border-color:rgba(255,0,255,.55);}
.stick{position:absolute;left:50%;top:50%;width:56px;height:56px;border-radius:16px;transform:translate(-50%,-50%);background:rgba(0,212,255,.35);border:2px solid rgba(0,212,255,.8);}
#lookStick{background:rgba(255,0,255,.25);border-color:rgba(255,0,255,.75);}
.hint{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:11px;color:rgba(170,230,255,.75);text-align:center;pointer-events:none;}
#lookHint{color:rgba(255,180,255,.75);}
.badge{position:absolute;bottom:-18px;left:0;right:0;font-size:10px;text-align:center;color:rgba(180,220,255,.75);}

/* Mini toast */
#toast{position:absolute;left:50%;top:12px;transform:translateX(-50%);padding:8px 12px;border-radius:10px;border:1px solid rgba(0,212,255,.5);background:rgba(0,20,40,.55);color:#bff;font-size:12px;z-index:200;backdrop-filter:blur(6px);display:none;}
</style>
</head>
<body>
<div id="canvas-container"></div>
<div id="toast"></div>
<input id="glbFile" type="file" accept=".glb,.gltf,model/gltf-binary,model/gltf+json" style="display:none" />

<!-- GLB Upload Overlay (borrowed from US map demo) -->
<div id="upload-overlay" style="display:none; position:fixed; inset:0; z-index:500; align-items:center; justify-content:center; background:radial-gradient(900px 600px at 50% 40%, rgba(0,255,136,0.12), rgba(0,0,0,0.92));">
  <div id="upload-card" style="width:min(560px, calc(100vw - 24px)); background:linear-gradient(135deg, rgba(0,25,40,0.92), rgba(10,0,20,0.88)); border:2px solid rgba(0,255,136,0.55); box-shadow:0 20px 90px rgba(0,255,136,0.12); border-radius:18px; padding:22px 22px 18px; text-align:center;">
    <div style="margin:0 0 8px; font-size:18px; font-weight:900; color:#00ff88; text-shadow:0 0 18px rgba(0,255,136,.25);">üöÄ Upload a GLB Player Model</div>
    <div style="margin:0 0 14px; font-size:12px; color:rgba(215,251,255,.75);">Drop in a <b>.glb</b> or <b>.gltf</b>. We‚Äôll center + scale it and attach it to the player root.</div>
    <button id="upload-btn" style="border:none; cursor:pointer; font-weight:900; letter-spacing:.6px; padding:12px 20px; border-radius:12px; background:linear-gradient(135deg, rgba(0,255,136,1), rgba(0,200,110,1)); color:#001012; box-shadow:0 10px 40px rgba(0,255,136,0.22);">Choose GLB File</button>
    <button id="upload-skip" style="margin-left:10px; background:transparent; color:rgba(215,251,255,.75); border:1px solid rgba(255,255,255,0.18); padding:12px 16px; border-radius:12px; cursor:pointer;" title="Skip and keep current">Skip</button>
    <div style="margin-top:12px; font-size:11px; opacity:.72;">Tip: If a model loads sideways, we can add per-file yaw/pitch presets.</div>
  </div>
</div>
<div id="loading" style="position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:600; display:none; padding:12px 16px; border-radius:12px; border:1px solid rgba(0,255,136,0.35); background:rgba(0,0,0,0.6); color:#00ff88; box-shadow:0 14px 50px rgba(0,255,136,0.12);">Loading model‚Ä¶</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-title">‚öì MARITIME AI COMMANDER</div>
  <div class="hud-subtitle">POV + Touch + Cone + Pings + Safe Collisions + Grid + GLB Anim</div>
  <div class="hud-stat">Credits <span class="hud-value" id="gold">$1000</span></div>
  <div class="hud-stat">Allies <span class="hud-value" id="allies">0</span></div>
  <div class="hud-stat">Enemies <span class="hud-value" id="enemies">0</span></div>
  <div class="hud-stat">Score <span class="hud-value" id="score">0</span></div>
  <div class="hud-stat">Generation <span class="hud-value" id="gen">0</span></div>
  <div class="hud-stat">Camera <span class="hud-value" id="camLabel">ORBIT</span></div>
</div>

<!-- Controls -->
<div id="controls" class="panel">
  <div style="color:#ff00ff;font-weight:900;margin-bottom:6px;">üéÆ OPERATIONS</div>
  <button class="btn" id="wave">üåä‚ûï Wave (+1 Ally / +5 Enemies)</button>
  <div class="row">
    <button class="btn" id="battle">‚öîÔ∏è Combat: OFF</button>
    <button class="btn" id="autoplay">ü§ñ Autoplay: OFF</button>
  </div>

  <div style="margin-top:6px;font-size:11px;color:#88ccff;">ü§ñ Autoplay Profile</div>
  <div class="row">
    <button class="btn" data-profile="calm">üå±</button>
    <button class="btn" data-profile="balanced">‚öñÔ∏è</button>
    <button class="btn" data-profile="chaos">üî•</button>
  </div>

  <div class="row">
    <button class="btn" id="interactToggle">üìç Pings: ON</button>
    <button class="btn" id="resetCam">üß≠ Recenter</button>
  </div>

  <button class="btn warn" id="panic">üö® PANIC MODE</button>
  <div class="small" style="margin-top:6px;">PC/Mac: WASD + mouse drag. Mobile: pads. Tap POV buttons to inspect close interactions.</div>
</div>

<!-- Shop (hidden on phones by CSS) -->
<div id="shop" class="panel">
  <div style="color:#ffaa00;font-weight:900;">üè≠ DEFENSE SYSTEMS</div>
  <div style="font-size:10px;color:#cc8800;font-style:italic;">‚ÄúWe tried nothing and we‚Äôre all out of ideas.‚Äù</div>
  <button class="btn" data-tower="cannon" data-cost="100">üî• Cannon $100</button>
  <button class="btn" data-tower="harpoon" data-cost="150">üéØ Harpoon $150</button>
  <button class="btn" data-tower="net" data-cost="200">üï∏Ô∏è Net $200</button>
</div>

<!-- Camera Panel -->
<div id="cameraPanel" class="panel">
  <div style="color:#00ff88;font-weight:900;margin-bottom:6px;">üé• POV PANEL</div>
  <div class="row">
    <button class="btn" data-cam="orbit">üõ∞Ô∏è Orbit</button>
    <button class="btn" data-cam="chase">üèéÔ∏è Chase</button>
    <button class="btn" data-cam="shoulder">üßç Shoulder</button>
  </div>
  <div class="row">
    <button class="btn" data-cam="head">üëÅÔ∏è Head</button>
    <button class="btn" data-cam="cinematic">üé¨ Cine</button>
    <button class="btn" data-cam="free">ü™Ç Free</button>
  </div>
  <div class="row">
    <button class="btn" id="coneToggle">üß†üî¶ Cone: ON</button>
    <button class="btn" id="qualityToggle">‚ú® Quality: HIGH</button>
  </div>
  <div class="row">
    <button class="btn" id="gridToggle">üß≠ Grid: ON</button>
    <button class="btn" id="resetGrid">üß± Grid: Rebuild</button>
  </div>
  <div class="row">
    <button class="btn" id="uploadGLB">üì¶ Upload GLB</button>
    <button class="btn" id="resetGLB">üßπ Reset Model</button>
  </div>
  <div class="small">Grid floats above water (no z-fight). Cone = attention volume. Pings highlight nearby entities inside the cone.</div>
</div>

<!-- Memory -->
<div id="memory" class="panel">
  <div style="color:#f0f;font-weight:900;">üß† VETERAN DOCTRINE</div>
  <div style="font-size:10px;color:#aaa;">(Ships arguing loudly but learning anyway)</div>
  <div id="log"></div>
</div>

<!-- Touch UI -->
<div id="touchUI">
  <div id="movePad" class="pad">
    <div class="stick" id="moveStick"></div>
    <div class="hint">üïπÔ∏è MOVE</div>
    <div class="badge">left pad</div>
  </div>
  <div id="lookPad" class="pad">
    <div class="stick" id="lookStick"></div>
    <div class="hint" id="lookHint">üëÜ LOOK</div>
    <div class="badge">right pad</div>
  </div>
</div>

<!-- Importmap + ES Modules (fixes: THREE.GLTFLoader is not a constructor) -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/",
    "d3-geo": "https://cdn.jsdelivr.net/npm/d3-geo@3/+esm",
    "topojson-client": "https://cdn.jsdelivr.net/npm/topojson-client@3/+esm"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import * as d3geo from 'd3-geo';
import * as topojson from 'topojson-client';

/* ===================================================
   CONFIG ‚úÖ
=================================================== */
const PLAYER_GLB_URL = "";      // optional remote .glb URL
const PLAYER_GLB_SCALE = 1.0;   // tweak if your GLB is huge/tiny

/* ===================================================
   UTIL üß∞
=================================================== */
const clamp01 = v => Math.max(0, Math.min(1, v));
const lerp = (a,b,t)=>a+(b-a)*t;
const damp = (current, target, lambda, dt)=> lerp(current, target, 1 - Math.exp(-lambda*dt));
const toast = (msg)=>{
  const el = document.getElementById('toast');
  if(!el) return;
  el.textContent = msg;
  el.style.display = 'block';
  clearTimeout(toast._t);
  toast._t = setTimeout(()=> el.style.display='none', 1600);
};
const log = (msg)=>{
  const l = document.getElementById('log');
  if(!l) return;
  const e=document.createElement('div');
  e.className='memory-entry';
  e.textContent=`[${new Date().toLocaleTimeString()}] ${msg}`;
  l.prepend(e);
  while(l.children.length>26) l.removeChild(l.lastChild);
};

/* ===================================================
   GAME STATE üéÆ
=================================================== */
const game = {
  gold: 1000,
  score: 0,
  allies: [],
  enemies: [],
  battle: false,
  autoplay: false,
  profile: 'balanced',
  generation: 0,
};
const doctrine = { aggression:.5, focus:.5, kiting:.5 };

/* ===================================================
   THREE SETUP üåå
=================================================== */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x001a33, 70, 650);
scene.background = new THREE.Color(0x001226);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1800);
camera.position.set(0, 18, 42);

const renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.getElementById('canvas-container').appendChild(renderer.domElement);

// lights üí°
scene.add(new THREE.AmbientLight(0x405070, 0.52));
const hemi = new THREE.HemisphereLight(0x9ad6ff, 0x001018, 0.35);
scene.add(hemi);

const sun = new THREE.DirectionalLight(0xffffff, 1.02);
sun.position.set(140, 240, 90);
sun.castShadow = true;
sun.shadow.mapSize.set(1024,1024);
sun.shadow.camera.near = 10;
sun.shadow.camera.far = 800;
sun.shadow.camera.left = -260;
sun.shadow.camera.right = 260;
sun.shadow.camera.top = 260;
sun.shadow.camera.bottom = -260;
scene.add(sun);

const fill = new THREE.DirectionalLight(0x88ccff, 0.32);
fill.position.set(-140, 110, -70);
scene.add(fill);

/* ===================================================
   WORLD: water + US map geography üó∫Ô∏èüåä
=================================================== */
const WATER_Y = 0;
const waterMat = new THREE.MeshStandardMaterial({
  color:0x1E90FF,
  transparent:true,
  opacity:0.88,
  emissive:0x001018,
  emissiveIntensity:0.35,
  roughness:0.35,
  metalness:0.05
});
// Help overlays (grid + borders) avoid flicker
waterMat.polygonOffset = true;
waterMat.polygonOffsetFactor = 1;
waterMat.polygonOffsetUnits = 1;

const water = new THREE.Mesh(
  new THREE.PlaneGeometry(1200,1200,1,1),
  waterMat
);
water.rotation.x = -Math.PI/2;
water.receiveShadow = true;
scene.add(water);

// --- US borders (TopoJSON ‚Üí d3-geo projection ‚Üí Three line segments)
const usGroup = new THREE.Group();
usGroup.position.set(0, WATER_Y + 0.08, 0);
scene.add(usGroup);

const STATES_URL = 'https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json';

// Project lon/lat to compact sim space
const projection = d3geo.geoAlbersUsa()
  .scale(1000)
  .translate([0, 0]);

// Map projected coords to Three world units
const WORLD_SCALE = 0.12;
const V3A = new THREE.Vector3();

function projectLonLatToWorld(lon, lat, out = V3A) {
  const p = projection([lon, lat]);
  if (!p) return out.set(0, 0, 0);
  // d3 returns [x,y] where y grows down; flip y to z
  return out.set(p[0] * WORLD_SCALE, WATER_Y + 0.08, -p[1] * WORLD_SCALE);
}

function lineFromMultiLineString(mls, mat) {
  const positions = [];
  for (const line of mls.coordinates) {
    // build segments
    for (let i = 1; i < line.length; i++) {
      const [lon0, lat0] = line[i - 1];
      const [lon1, lat1] = line[i];
      const a = projectLonLatToWorld(lon0, lat0, new THREE.Vector3());
      const b = projectLonLatToWorld(lon1, lat1, new THREE.Vector3());
      positions.push(a.x, a.y, a.z, b.x, b.y, b.z);
    }
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  return new THREE.LineSegments(geo, mat);
}

async function loadStates() {
  const el = document.getElementById('gen'); // reuse HUD line as a quick ‚Äústatus‚Äù
  try {
    const res = await fetch(STATES_URL, { cache: 'force-cache' });
    const topo = await res.json();

    const states = topojson.feature(topo, topo.objects.states);
    const borders = topojson.mesh(topo, topo.objects.states, (a, b) => a !== b);
    const outline = topojson.mesh(topo, topo.objects.states, (a, b) => a === b);

    const borderMat = new THREE.LineBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.58 });
    const outlineMat = new THREE.LineBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.22 });

    const borderLine = lineFromMultiLineString(borders, borderMat);
    const outlineLine = lineFromMultiLineString(outline, outlineMat);
    outlineLine.position.y = WATER_Y + 0.04;

    usGroup.add(borderLine);
    usGroup.add(outlineLine);

    // light ‚Äúmist fill‚Äù points (cheap visual density)
    const mist = new THREE.Points(
      new THREE.BufferGeometry(),
      new THREE.PointsMaterial({ color: 0x88ccff, size: 0.5, transparent: true, opacity: 0.10 })
    );
    const pts = [];
    const feature = { type: 'FeatureCollection', features: states.features };
    const bounds = d3geo.geoBounds(feature);
    const [minLon, minLat] = bounds[0];
    const [maxLon, maxLat] = bounds[1];

    const lerpLocal = (a,b,t)=>a+(b-a)*t;
    for (let i = 0; i < 3000; i++) {
      const lon = lerpLocal(minLon, maxLon, Math.random());
      const lat = lerpLocal(minLat, maxLat, Math.random());
      if (!projection([lon, lat])) continue;
      const w = projectLonLatToWorld(lon, lat, new THREE.Vector3());
      pts.push(w.x, WATER_Y + 0.10 + Math.random() * 0.28, w.z);
    }
    mist.geometry.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
    usGroup.add(mist);

    log(`üó∫Ô∏è US state borders loaded (${states.features.length} states)`);
    toast('üó∫Ô∏è US borders loaded');
    // keep gen counter for waves; don‚Äôt overwrite UI; just log.
  } catch (err) {
    console.warn(err);
    log('‚ö†Ô∏è Failed to load US borders (offline?)');
  }
}

// Population ‚Äútowers‚Äù (demo subset)
const popBars = new THREE.Group();
popBars.position.y = 0.02;
scene.add(popBars);

const POP = [
  { name: 'CA', lon: -119.4179, lat: 36.7783, m: 39.5 },
  { name: 'TX', lon: -99.9018,  lat: 31.9686, m: 29.1 },
  { name: 'FL', lon: -81.5158,  lat: 27.6648, m: 21.5 },
  { name: 'NY', lon: -75.0000,  lat: 43.0000, m: 19.3 },
  { name: 'PA', lon: -77.1945,  lat: 41.2033, m: 13.0 },
  { name: 'IL', lon: -89.3985,  lat: 40.6331, m: 12.7 },
  { name: 'OH', lon: -82.9071,  lat: 40.4173, m: 11.7 },
  { name: 'GA', lon: -82.9001,  lat: 32.1656, m: 10.7 },
  { name: 'NC', lon: -79.0193,  lat: 35.7596, m: 10.4 },
  { name: 'MI', lon: -85.6024,  lat: 44.3148, m: 10.0 },
  { name: 'NJ', lon: -74.4057,  lat: 40.0583, m: 9.3 },
  { name: 'VA', lon: -78.6569,  lat: 37.4316, m: 8.6 },
  { name: 'WA', lon: -120.7401, lat: 47.7511, m: 7.7 },
  { name: 'AZ', lon: -111.0937, lat: 34.0489, m: 7.2 },
  { name: 'MA', lon: -71.3824,  lat: 42.4072, m: 6.9 }
];

function buildPopBars() {
  while (popBars.children.length) popBars.remove(popBars.children[0]);

  const base = new THREE.MeshStandardMaterial({
    color: 0x00ff88,
    emissive: 0x00ff88,
    emissiveIntensity: 0.18,
    roughness: 0.35,
    metalness: 0.25
  });
  const cap = new THREE.MeshStandardMaterial({
    color: 0xffaa00,
    emissive: 0xffaa00,
    emissiveIntensity: 0.15,
    roughness: 0.4,
    metalness: 0.2
  });

  for (const s of POP) {
    const pos = projectLonLatToWorld(s.lon, s.lat, new THREE.Vector3());
    if (pos.x === 0 && pos.z === 0) continue;
    const h = 1 + (s.m * 0.9);

    const geo = new THREE.CylinderGeometry(0.8, 1.1, h, 10, 1);
    const bar = new THREE.Mesh(geo, base);
    bar.position.set(pos.x, h / 2, pos.z);
    bar.castShadow = true;
    bar.receiveShadow = true;

    const capGeo = new THREE.SphereGeometry(1.0, 12, 10);
    const c = new THREE.Mesh(capGeo, cap);
    c.position.set(pos.x, h + 0.4, pos.z);
    c.castShadow = true;

    popBars.add(bar, c);
  }
  log('üìä Population towers placed (demo subset)');
}

// ‚Äúbuoys‚Äù become coastal neon beacons
for(let i=0;i<16;i++){
  const buoy = new THREE.Mesh(
    new THREE.CylinderGeometry(0.4,0.6,2.2,10),
    new THREE.MeshStandardMaterial({color:0xff33aa, emissive:0x220012, emissiveIntensity:0.35, roughness:0.5})
  );
  buoy.position.set((Math.random()*760-380), WATER_Y+1.1, (Math.random()*760-380));
  buoy.castShadow = true;
  scene.add(buoy);
}

/* ===================================================
   WORLD GRID üß≠ (stable visibility)
=================================================== */
let gridOn = true;
let grid = null;
function rebuildGrid(){
  if(grid){
    scene.remove(grid);
    grid.geometry?.dispose?.();
    // GridHelper uses LineSegments + material array sometimes; dispose carefully
    const m = grid.material;
    if(Array.isArray(m)) m.forEach(mm=>mm?.dispose?.());
    else m?.dispose?.();
    grid = null;
  }
  grid = new THREE.GridHelper(1000, 200, 0x00ffff, 0x004455);
  grid.position.y = WATER_Y + 0.06; // lift above water to avoid z-fighting
  grid.material.transparent = true;
  grid.material.opacity = 0.28;
  grid.renderOrder = 999;
  grid.frustumCulled = false;
  grid.visible = gridOn;
  scene.add(grid);
}
rebuildGrid();

// Build US map overlays
loadStates();
buildPopBars();

function setGrid(on){
  gridOn = on;
  if(grid) grid.visible = on;
  document.getElementById('gridToggle').textContent = `üß≠ Grid: ${on ? 'ON' : 'OFF'}`;
  toast(on ? 'üß≠ Grid on' : 'üß≠ Grid off');
}

/* ===================================================
   PLAYER: GLB + fallback + animations üßç‚Äç‚ôÇÔ∏èüéûÔ∏è
=================================================== */
const player = {
  root: new THREE.Group(),
  body: null,
  pos: new THREE.Vector3(0, 2, 0),
  vel: new THREE.Vector3(),
  yaw: 0,
  pitch: 0,
  speed: 0,
  onLand: false,
  goal: new THREE.Vector3(50, WATER_Y, 30),
  mixer: null,
  clips: {},
  activeAction: null,
  actionName: 'idle',
  colliderR: 1.0,
};
scene.add(player.root);

function clearPlayerModel(){
  if(player.mixer){
    try{ player.mixer.stopAllAction(); }catch(_){ }
  }
  player.mixer = null;
  player.clips = {};
  player.activeAction = null;
  player.actionName = 'idle';

  for(let i=player.root.children.length-1;i>=0;i--){
    const ch = player.root.children[i];
    player.root.remove(ch);
    ch.traverse?.(o=>{
      if(o.isMesh){
        o.geometry?.dispose?.();
        const m = o.material;
        if(Array.isArray(m)) m.forEach(mm=>mm?.dispose?.());
        else m?.dispose?.();
      }
    });
  }
  player.body = null;
}

function makeFallbackCapsuleMesh(){
  // Use primitives (CapsuleGeometry availability varies)
  const g = new THREE.Group();
  const radius = 0.9;
  const bodyH = 1.2;
  const mat = new THREE.MeshStandardMaterial({
    color:0x00ff88,
    roughness:0.55,
    metalness:0.2,
    emissive:0x001c10,
    emissiveIntensity:0.25
  });

  const cylinder = new THREE.Mesh(
    new THREE.CylinderGeometry(radius, radius, bodyH, 16, 1),
    mat
  );
  cylinder.castShadow = true;
  cylinder.receiveShadow = true;
  g.add(cylinder);

  const top = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 12), mat);
  top.castShadow = true;
  top.receiveShadow = true;
  top.position.y = bodyH/2;
  g.add(top);

  const bot = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 12), mat);
  bot.castShadow = true;
  bot.receiveShadow = true;
  bot.position.y = -bodyH/2;
  g.add(bot);

  return { group:g, radius };
}

function makeFallbackPlayer(){
  clearPlayerModel();
  const { group, radius } = makeFallbackCapsuleMesh();
  group.position.y = 1.6; // lift off surface
  player.root.add(group);
  player.body = group;
  player.colliderR = radius;
  log('üßç Using fallback capsule (Upload GLB to swap).');
}

function chooseClipNameByHeuristic(names){
  const pick = (patterns)=>{
    for(const p of patterns){
      const n = names.find(x=>String(x).toLowerCase().includes(p));
      if(n) return n;
    }
    return null;
  };
  return {
    idle: pick(['idle','stand','breath','rest']),
    walk: pick(['walk','stroll','move']),
    run:  pick(['run','sprint','jog']),
  };
}

function setAction(name){
  if(!player.mixer || !player.clips[name]) return;
  if(player.actionName === name) return;
  const next = player.clips[name];
  if(player.activeAction){
    next.reset();
    next.crossFadeFrom(player.activeAction, 0.18, true);
    next.play();
  }else{
    next.reset();
    next.play();
  }
  player.activeAction = next;
  player.actionName = name;
}

function applyLoadedPlayerGLTF(gltf){
  clearPlayerModel();

  const model = gltf.scene;
  model.traverse(o=>{
    if(o.isMesh){
      o.castShadow = true;
      o.receiveShadow = true;
      const m = o.material;
      if(m && m.isMaterial){
        if(m.roughness !== undefined) m.roughness = Math.min(0.92, Math.max(0.12, m.roughness));
        if(m.metalness !== undefined) m.metalness = Math.min(0.9, m.metalness);
      }
    }
  });
  model.scale.setScalar(PLAYER_GLB_SCALE);
  model.position.y = 0;
  player.root.add(model);
  player.body = model;

  // capsule-ish collider radius (best-effort): derive from bbox
  try{
    const box = new THREE.Box3().setFromObject(model);
    const size = new THREE.Vector3();
    box.getSize(size);
    player.colliderR = Math.max(0.6, Math.min(2.5, Math.max(size.x, size.z) * 0.25));
  }catch(_){
    player.colliderR = 1.0;
  }

  if(gltf.animations && gltf.animations.length){
    player.mixer = new THREE.AnimationMixer(model);
    const names = gltf.animations.map(a=>a.name || 'clip');
    const guess = chooseClipNameByHeuristic(names);
    const mk = (anim)=> player.mixer.clipAction(anim);

    for(const a of gltf.animations){
      if(guess.idle && a.name === guess.idle) player.clips.idle = mk(a);
      if(guess.walk && a.name === guess.walk) player.clips.walk = mk(a);
      if(guess.run  && a.name === guess.run)  player.clips.run  = mk(a);
    }
    if(!player.clips.idle) player.clips.idle = mk(gltf.animations[0]);
    if(!player.clips.walk) player.clips.walk = player.clips.idle;
    if(!player.clips.run)  player.clips.run  = player.clips.walk;

    setAction('idle');
    log('‚úÖ Player model loaded + animations ready.');
  }else{
    log('‚úÖ Player model loaded (no animations detected).');
  }
}

async function loadPlayerGLB(url){
  return new Promise((resolve,reject)=>{
    const loader = new GLTFLoader();
    loader.load(url, gltf => resolve(gltf), undefined, err => reject(err));
  });
}

(async ()=>{
  if(!PLAYER_GLB_URL){ makeFallbackPlayer(); return; }
  try{
    const gltf = await loadPlayerGLB(PLAYER_GLB_URL);
    applyLoadedPlayerGLTF(gltf);
  }catch(e){
    console.warn(e);
    makeFallbackPlayer();
    log('‚ö†Ô∏è GLB failed; fallback capsule used.');
  }
})();

/* ===================================================
   COGNITIVE CONE üß†üî¶ + INTERACTION PINGS üìç
=================================================== */
const coneVis = new THREE.Group();
scene.add(coneVis);
let coneOn = true;
let pingsOn = true;

const coneGeo = new THREE.ConeGeometry(10, 26, 18, 1, true);
coneGeo.translate(0, -13, 0);
const coneMat = new THREE.MeshBasicMaterial({color:0x00ff88, transparent:true, opacity:0.10, side:THREE.DoubleSide, depthWrite:false});
const coneMesh = new THREE.Mesh(coneGeo, coneMat);
coneVis.add(coneMesh);

const ring = new THREE.Mesh(
  new THREE.RingGeometry(3.5, 4.2, 32),
  new THREE.MeshBasicMaterial({color:0x00ff88, transparent:true, opacity:0.25, side:THREE.DoubleSide, depthWrite:false})
);
ring.rotation.x = -Math.PI/2;
ring.position.set(0, 0.05, 0);
coneVis.add(ring);

function makePingTexture(label, color){
  const c = document.createElement('canvas');
  c.width = 256; c.height = 128;
  const g = c.getContext('2d');
  g.clearRect(0,0,c.width,c.height);

  // bubble
  g.fillStyle = 'rgba(0,20,40,0.70)';
  g.strokeStyle = color;
  g.lineWidth = 6;
  roundRect(g, 16, 16, 224, 80, 18);
  g.fill();
  g.stroke();

  // text
  g.fillStyle = '#dff';
  g.font = 'bold 42px ui-monospace, monospace';
  g.textAlign = 'center';
  g.textBaseline = 'middle';
  g.fillText(label, 128, 56);

  const tex = new THREE.CanvasTexture(c);
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.anisotropy = 2;
  return tex;

  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }
}

function makePingSprite(label, color){
  const mat = new THREE.SpriteMaterial({ map: makePingTexture(label, color), transparent:true, depthWrite:false });
  const s = new THREE.Sprite(mat);
  s.scale.set(7, 3.5, 1);
  s.visible = false;
  scene.add(s);
  return s;
}

/* ===================================================
   SHIPS üö¢
=================================================== */
class Ship{
  constructor(x,z,team){
    this.team = team;
    this.pos = new THREE.Vector3(x, 1, z);
    this.vel = new THREE.Vector3();
    this.hp = 100;
    this.mesh = new THREE.Mesh(
      new THREE.BoxGeometry(3,1,6),
      new THREE.MeshStandardMaterial({ color: team==='enemy'?0xff0000:0x00ff88, roughness:0.55, metalness:0.15 })
    );
    this.mesh.position.copy(this.pos);
    this.mesh.castShadow = true;
    this.mesh.receiveShadow = true;
    scene.add(this.mesh);

    const label = team==='enemy' ? '‚ò†Ô∏è' : 'üõü';
    const col = team==='enemy' ? 'rgba(255,60,60,0.95)' : 'rgba(0,255,160,0.95)';
    this.ping = makePingSprite(label, col);
  }
  update(){
    const target = (this.team==='enemy') ? game.allies[0] : game.enemies[0];
    if(target){
      const dir = target.pos.clone().sub(this.pos).normalize();
      const accel = (this.team==='enemy') ? 0.03 : 0.02;
      this.vel.addScaledVector(dir, accel);
    }
    this.vel.clampLength(0, 0.55);
    this.pos.add(this.vel);
    this.vel.multiplyScalar(0.95);
    this.mesh.position.copy(this.pos);
  }
}

/* ===================================================
   SPAWN üåä
=================================================== */
function spawnWave(){
  game.generation++;
  document.getElementById('gen').textContent = game.generation;

  const ally = new Ship(Math.random()*10-5, Math.random()*10-5, 'ally');
  game.allies.push(ally);

  for(let i=0;i<5;i++){
    const e = new Ship(Math.random()*140-70, Math.random()*140-70, 'enemy');
    game.enemies.push(e);
  }
  log(`üåä Wave ${game.generation}: +1 Ally / +5 Enemies`);
}

/* ===================================================
   DOCTRINE MUTATION üß¨
=================================================== */
function mutateDoctrine(){
  const chaos = ({calm:.002, balanced:.006, chaos:.015})[game.profile] ?? .006;
  doctrine.aggression = clamp01(doctrine.aggression + (Math.random()-.5)*chaos);
  doctrine.focus      = clamp01(doctrine.focus      + (Math.random()-.5)*chaos);
  doctrine.kiting     = clamp01(doctrine.kiting     + (Math.random()-.5)*chaos);
  log(`üß¨ Doctrine mutated (A:${Math.round(doctrine.aggression*100)}% F:${Math.round(doctrine.focus*100)}%)`);
}

/* ===================================================
   SURFACE HEIGHT + SAFE COLLISION üöß
   (US map mode: keep it flat + clamp to map bounds)
=================================================== */
function computeSurfaceY(x,z){
  // Flat ‚Äúmap table‚Äù surface
  return { y: WATER_Y + 1.2, onLand:false };
}

function pushOutFromIslands(){
  // No island colliders in US map mode (kept for API compatibility)
}
/* ===================================================
   INPUT üéõÔ∏è (Keyboard/Mouse + Touch pads)
=================================================== */
const input = {
  forward: 0,
  right: 0,
  lookX: 0,
  lookY: 0,
  mouseDown: false,
  freeCam: { yaw:0, pitch:0 },
};

window.addEventListener('keydown', (e)=>{
  if(e.key === 'w' || e.key === 'ArrowUp') input.forward = 1;
  if(e.key === 's' || e.key === 'ArrowDown') input.forward = -1;
  if(e.key === 'a' || e.key === 'ArrowLeft') input.right = -1;
  if(e.key === 'd' || e.key === 'ArrowRight') input.right = 1;
});
window.addEventListener('keyup', (e)=>{
  if(['w','s','ArrowUp','ArrowDown'].includes(e.key)) input.forward = 0;
  if(['a','d','ArrowLeft','ArrowRight'].includes(e.key)) input.right = 0;
});

renderer.domElement.addEventListener('pointerdown', ()=>{ input.mouseDown = true; });
window.addEventListener('pointerup', ()=>{ input.mouseDown = false; });
window.addEventListener('pointermove', (e)=>{
  if(!input.mouseDown) return;
  // if free cam, rotate the free cam basis; otherwise rotate the player
  if(CAM.mode === 'free'){
    input.freeCam.yaw   += e.movementX * 0.0022;
    input.freeCam.pitch += e.movementY * 0.0018;
    input.freeCam.pitch = THREE.MathUtils.clamp(input.freeCam.pitch, -1.2, 1.1);
  }else{
    input.lookX += e.movementX * 0.0022;
    input.lookY += e.movementY * 0.0018;
  }
});

function setupPad(padEl, stickEl, onMove){
  let activeId = null;
  let cx=0, cy=0;
  const max = 46;
  const reset = ()=>{ stickEl.style.transform = `translate(-50%,-50%)`; onMove(0,0); };

  padEl.addEventListener('pointerdown', (e)=>{
    activeId = e.pointerId;
    padEl.setPointerCapture(activeId);
    const r = padEl.getBoundingClientRect();
    cx = r.left + r.width/2;
    cy = r.top  + r.height/2;
  });

  padEl.addEventListener('pointermove', (e)=>{
    if(e.pointerId !== activeId) return;
    const dx = e.clientX - cx;
    const dy = e.clientY - cy;
    const len = Math.hypot(dx,dy) || 1;
    const k = Math.min(max, len)/len;
    const sx = dx*k;
    const sy = dy*k;
    stickEl.style.transform = `translate(${sx-28}px, ${sy-28}px)`;
    onMove(sx/max, sy/max);
  });

  const end = (e)=>{
    if(activeId === null) return;
    if(e && e.pointerId !== activeId) return;
    activeId = null;
    reset();
  };
  padEl.addEventListener('pointerup', end);
  padEl.addEventListener('pointercancel', end);
  padEl.addEventListener('lostpointercapture', end);
}

setupPad(document.getElementById('movePad'), document.getElementById('moveStick'), (x,y)=>{
  input.right = x;
  input.forward = -y;
});
setupPad(document.getElementById('lookPad'), document.getElementById('lookStick'), (x,y)=>{
  // touch look always rotates player (simple + stable)
  input.lookX += x * 0.06;
  input.lookY += y * 0.04;
});

/* ===================================================
   CAMERA MODES üé•
=================================================== */
const CAM = { mode:'orbit', dist:36, height:14, smooth:0.12 };
function setCameraMode(m){
  CAM.mode = m;
  document.getElementById('camLabel').textContent = m.toUpperCase();
  document.querySelectorAll('[data-cam]').forEach(b=>b.classList.toggle('active', b.dataset.cam===m));
  if(m==='free'){
    input.freeCam.yaw = player.yaw;
    input.freeCam.pitch = 0;
  }
  log(`üé• Camera: ${m.toUpperCase()}`);
}

document.querySelectorAll('[data-cam]').forEach(b=>b.addEventListener('click', ()=> setCameraMode(b.dataset.cam)));
setCameraMode('orbit');

/* ===================================================
   AUTOPLAY ü§ñ
=================================================== */
function pickNewGoal(){
  const choices = [
    new THREE.Vector3(40, WATER_Y, 20),
    new THREE.Vector3(-60, WATER_Y, -10),
    new THREE.Vector3(5, WATER_Y, -70),
    new THREE.Vector3(Math.random()*340-170, WATER_Y, Math.random()*340-170)
  ];
  player.goal.copy(choices[(Math.random()*choices.length)|0]);
}

function autoplaySteer(dt){
  const to = player.goal.clone().sub(player.pos);
  const dist = to.length();
  if(dist < 6) pickNewGoal();

  const desiredYaw = Math.atan2(to.x, to.z);
  let dy = desiredYaw - player.yaw;
  while(dy > Math.PI) dy -= Math.PI*2;
  while(dy < -Math.PI) dy += Math.PI*2;

  player.yaw += dy * dt * lerp(0.8, 2.2, doctrine.focus);
  const throttle = clamp01(dist / 40);
  input.forward = lerp(input.forward, 0.6 + 0.4*throttle, 0.08);
  input.right   = lerp(input.right,   0.0, 0.12);
}

/* ===================================================
   PLAYER UPDATE üßç‚Äç‚ôÇÔ∏è
=================================================== */
function updatePlayer(dt){
  player.yaw += input.lookX;
  player.pitch = THREE.MathUtils.clamp(player.pitch + input.lookY, -0.85, 0.65);
  input.lookX = 0;
  input.lookY = 0;

  const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.sin(player.yaw + Math.PI/2), 0, Math.cos(player.yaw + Math.PI/2));

  const move = new THREE.Vector3()
    .addScaledVector(forward, input.forward)
    .addScaledVector(right, input.right);

  if(move.lengthSq() > 0.0001) move.normalize();

  const baseSpeed = 18;
  const accel = 34;
  const damping = 9;

  player.vel.addScaledVector(move, accel*dt);

  const hv = new THREE.Vector3(player.vel.x, 0, player.vel.z);
  const max = baseSpeed * (player.onLand ? 1.0 : 0.92);
  hv.clampLength(0, max);
  player.vel.x = hv.x;
  player.vel.z = hv.z;

  player.vel.multiplyScalar(Math.max(0, 1 - damping*dt));

  player.pos.addScaledVector(player.vel, dt);

  pushOutFromIslands();

  const surf = computeSurfaceY(player.pos.x, player.pos.z);
  player.onLand = surf.onLand;
  player.pos.y = damp(player.pos.y, surf.y, 10, dt);

  player.root.position.copy(player.pos);
  player.root.rotation.y = player.yaw;

  player.speed = hv.length();

  if(player.mixer){
    const s = player.speed;
    if(s < 0.6) setAction('idle');
    else if(s < 9.0) setAction('walk');
    else setAction('run');
    player.mixer.update(dt);
  }

  if(coneOn){
    coneVis.visible = true;
    coneVis.position.set(player.pos.x, WATER_Y + 0.05, player.pos.z);
    coneVis.rotation.set(0, player.yaw, 0);
    coneMesh.rotation.set(Math.PI/2, 0, 0);
    coneMesh.position.set(0, 0.1, 12);
    ring.position.set(0, 0.05, 6);
  }else{
    coneVis.visible = false;
  }
}

/* ===================================================
   CAMERA UPDATE üé•
=================================================== */
const camTarget = new THREE.Vector3();
const camPos = new THREE.Vector3(0, 18, 42);
const tmp = new THREE.Vector3();

function recenterCamera(){
  camPos.copy(camera.position);
  input.freeCam.yaw = player.yaw;
  input.freeCam.pitch = 0;
  toast('üß≠ Recentered');
}

function updateCamera(dt){
  const p = player.pos;
  const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  const right   = new THREE.Vector3(Math.sin(player.yaw + Math.PI/2), 0, Math.cos(player.yaw + Math.PI/2));

  camTarget.copy(p).addScaledVector(forward, 6).add(new THREE.Vector3(0, 2.6, 0));

  if(CAM.mode === 'free'){
    const yaw = input.freeCam.yaw;
    const pitch = input.freeCam.pitch;
    const f = new THREE.Vector3(
      Math.sin(yaw) * Math.cos(pitch),
      Math.sin(pitch),
      Math.cos(yaw) * Math.cos(pitch)
    ).normalize();
    const r = new THREE.Vector3().crossVectors(f, new THREE.Vector3(0,1,0)).normalize();
    const sp = 22;
    camPos.addScaledVector(f, input.forward * sp * dt);
    camPos.addScaledVector(r, input.right   * sp * dt);
    camera.position.lerp(camPos, 0.18);
    camera.lookAt(camTarget);
    return;
  }

  if(CAM.mode === 'orbit'){
    tmp.copy(p).addScaledVector(forward, -CAM.dist).add(new THREE.Vector3(0, CAM.height, 0));
    camera.position.lerp(tmp, CAM.smooth);
    camera.lookAt(p.x, p.y + 2.2, p.z);
    return;
  }
  if(CAM.mode === 'chase'){
    tmp.copy(p).addScaledVector(forward, -18).add(new THREE.Vector3(0, 7.2, 0));
    camera.position.lerp(tmp, 0.18);
    camera.lookAt(camTarget);
    return;
  }
  if(CAM.mode === 'shoulder'){
    tmp.copy(p).addScaledVector(forward, -6.5).addScaledVector(right, 2.4).add(new THREE.Vector3(0, 3.4, 0));
    camera.position.lerp(tmp, 0.22);
    camera.lookAt(camTarget);
    return;
  }
  if(CAM.mode === 'head'){
    tmp.copy(p).addScaledVector(forward, 0.8).add(new THREE.Vector3(0, 3.0, 0));
    camera.position.lerp(tmp, 0.35);
    camera.lookAt(camTarget);
    return;
  }
  if(CAM.mode === 'cinematic'){
    const t = performance.now()*0.001;
    tmp.copy(p)
      .addScaledVector(forward, -26)
      .addScaledVector(right, Math.sin(t*0.6)*6)
      .add(new THREE.Vector3(0, 12 + Math.sin(t*0.9)*1.2, 0));
    camera.position.lerp(tmp, 0.07);
    camera.lookAt(p.x, p.y + 2.2, p.z);
    return;
  }
}

/* ===================================================
   INTERACTION PINGS üìç
=================================================== */
function isInCone(entityPos){
  const v = entityPos.clone().sub(player.pos);
  v.y = 0;
  const dist = v.length();
  if(dist > 32) return false;
  const f = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
  const dot = (dist>0) ? v.normalize().dot(f) : 1;
  return dot > 0.45;
}

function updatePings(){
  const all = game.allies.concat(game.enemies);
  for(const s of all){
    if(!s.ping) continue;
    if(!pingsOn || !coneOn){ s.ping.visible = false; continue; }

    const near = s.pos.distanceTo(player.pos) < 34;
    const inCone = isInCone(s.pos);
    s.ping.visible = near && inCone;

    if(s.ping.visible){
      s.ping.position.set(s.pos.x, s.pos.y + 5.5, s.pos.z);
      const d = s.pos.distanceTo(player.pos);
      const k = THREE.MathUtils.clamp(1.2 - d/45, 0.65, 1.2);
      s.ping.scale.set(7*k, 3.5*k, 1);
    }
  }
}

/* ===================================================
   QUALITY TOGGLE ‚ú®
=================================================== */
let qualityHigh = true;
function setQuality(high){
  qualityHigh = high;
  renderer.setPixelRatio(Math.min(devicePixelRatio || 1, high ? 2 : 1));
  renderer.shadowMap.enabled = high;
  document.getElementById('qualityToggle').textContent = high ? '‚ú® Quality: HIGH' : '‚ö° Quality: FAST';
  toast(high ? '‚ú® High quality' : '‚ö° Fast mode');
}
setQuality(true);

/* ===================================================
   GLB UPLOAD üì¶ (overlay + FileReader + loader.parse)
=================================================== */
const glbInput = document.getElementById('glbFile');
const uploadBtnPanel = document.getElementById('uploadGLB');
const resetBtn  = document.getElementById('resetGLB');

const uploadOverlay = document.getElementById('upload-overlay');
const uploadBtn = document.getElementById('upload-btn');
const uploadSkip = document.getElementById('upload-skip');
const loading = document.getElementById('loading');

function openUploader(){
  if(uploadOverlay) uploadOverlay.style.display = 'flex';
}
function closeUploader(){
  if(uploadOverlay) uploadOverlay.style.display = 'none';
}

uploadBtnPanel?.addEventListener('click', ()=> openUploader());

uploadBtn?.addEventListener('click', ()=>{
  try{ glbInput.value = ''; }catch(_){ }
  glbInput.click();
});

uploadSkip?.addEventListener('click', ()=>{
  closeUploader();
  toast('üß© Kept current model');
});

resetBtn?.addEventListener('click', ()=>{
  if(PLAYER_GLB_URL){
    toast('üßπ Reset to URL model');
    loadPlayerGLB(PLAYER_GLB_URL).then(applyLoadedPlayerGLTF).catch(()=>makeFallbackPlayer());
  }else{
    toast('üßπ Reset to fallback');
    makeFallbackPlayer();
  }
});

glbInput?.addEventListener('change', (e)=>{
  const file = e.target.files && e.target.files[0];
  if(!file) return;

  closeUploader();
  if(loading) loading.style.display = 'block';

  const name = (file.name||'').toLowerCase();
  if(name.endsWith('.gltf')){
    toast('‚ö†Ô∏è .gltf may miss textures ‚Äî .glb works best');
    log('‚ö†Ô∏è Loading .gltf ‚Äî if textures are missing, export as .glb (embedded).');
  }

  const reader = new FileReader();
  reader.onload = (ev)=>{
    const loader = new GLTFLoader();
    try{
      loader.parse(ev.target.result, '', (gltf)=>{
        applyLoadedPlayerGLTF(gltf);
        if(loading) loading.style.display = 'none';
        toast('‚úÖ Model loaded');
        log(`üì¶ Loaded local model: ${file.name}`);
      }, (err)=>{
        console.warn('parse error', err);
        if(loading) loading.style.display = 'none';
        toast('‚ùå Failed to load model');
        log('‚ùå Failed to parse local model');
      });
    }catch(err){
      console.warn(err);
      if(loading) loading.style.display = 'none';
      toast('‚ùå Failed to load model');
      log('‚ùå Loader exception while parsing');
    }
  };
  reader.onerror = ()=>{
    if(loading) loading.style.display = 'none';
    toast('‚ùå File read failed');
    log('‚ùå FileReader failed');
  };
  reader.readAsArrayBuffer(file);
});

// Hotkey: U opens uploader overlay (desktop convenience)
window.addEventListener('keydown', (e)=>{
  if((e.key||'').toLowerCase() === 'u') openUploader();
});
/* ===================================================
   UI WIRING üß©
=================================================== */
document.getElementById('wave').onclick = spawnWave;

document.getElementById('battle').onclick = ()=>{
  game.battle = !game.battle;
  document.getElementById('battle').textContent = game.battle ? '‚öîÔ∏è Combat: ON' : '‚öîÔ∏è Combat: OFF';
  log(game.battle ? '‚öîÔ∏è Combat engaged' : 'üïäÔ∏è Combat disengaged');
};

document.getElementById('autoplay').onclick = ()=>{
  game.autoplay = !game.autoplay;
  document.getElementById('autoplay').textContent = `ü§ñ Autoplay: ${game.autoplay ? 'ON' : 'OFF'}`;
  log(game.autoplay ? 'ü§ñ Autoplay engaged (goal seeking)' : 'üßç Autoplay stopped');
  if(game.autoplay) pickNewGoal();
};

document.querySelectorAll('[data-profile]').forEach(b=>b.onclick=()=>{
  game.profile = b.dataset.profile;
  log(`ü§ñ Profile set to ${game.profile.toUpperCase()}`);
});

document.getElementById('panic').onclick = ()=>{
  for(let i=0;i<3;i++) spawnWave();
  doctrine.aggression=.9; doctrine.focus=.9; doctrine.kiting=.9;
  log('üö® PANIC MODE ‚Äî doctrines redlined');
};

document.getElementById('coneToggle').onclick = ()=>{
  coneOn = !coneOn;
  document.getElementById('coneToggle').textContent = `üß†üî¶ Cone: ${coneOn ? 'ON' : 'OFF'}`;
};

document.getElementById('interactToggle').onclick = ()=>{
  pingsOn = !pingsOn;
  document.getElementById('interactToggle').textContent = `üìç Pings: ${pingsOn ? 'ON' : 'OFF'}`;
  toast(pingsOn ? 'üìç Pings on' : 'üìç Pings off');
};

document.getElementById('resetCam').onclick = recenterCamera;

document.getElementById('qualityToggle').onclick = ()=> setQuality(!qualityHigh);

document.getElementById('gridToggle').onclick = ()=> setGrid(!gridOn);
document.getElementById('resetGrid').onclick = ()=>{ rebuildGrid(); toast('üß± Grid rebuilt'); };

/* ===================================================
   LOOP üîÅ
=================================================== */
let lastT = performance.now();
let lastDoctrine = performance.now();

function animate(){
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min(0.033, (now - lastT)/1000);
  lastT = now;

  if(game.autoplay){
    autoplaySteer(dt);
  }

  if(game.autoplay && (now - lastDoctrine) > 4200){
    mutateDoctrine();
    if(game.enemies.length < 4) spawnWave();
    lastDoctrine = now;
  }

  updatePlayer(dt);
  updateCamera(dt);

  game.allies.forEach(s=>s.update());
  game.enemies.forEach(s=>s.update());
  updatePings();

  document.getElementById('gold').textContent = '$' + game.gold;
  document.getElementById('allies').textContent = game.allies.length;
  document.getElementById('enemies').textContent = game.enemies.length;
  document.getElementById('score').textContent = game.score;

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio || 1, qualityHigh ? 2 : 1));
});

/* ===================================================
   SELF-TESTS ‚úÖ
=================================================== */
(function tests(){
  console.assert(typeof THREE !== 'undefined', 'THREE should load');
  console.assert(typeof THREE.GridHelper === 'function', 'GridHelper should exist');
  console.assert(typeof GLTFLoader === 'function', 'GLTFLoader should be a constructor');
  console.assert(!!document.getElementById('gridToggle'), 'gridToggle should exist');
  console.assert(!!document.getElementById('qualityToggle'), 'qualityToggle should exist');
  console.assert(!!document.getElementById('uploadGLB'), 'uploadGLB should exist');
  console.assert(typeof makeFallbackPlayer === 'function', 'makeFallbackPlayer should exist');
  log('‚úÖ Self-tests passed');
})();

/* Boot */
log('üåä Maritime AI Commander Online');
log('üß≠ Grid helper stabilized (no water z-fight)');
log('üé• POV panel + üß† cone + üìç pings + üöß safe collisions');
log('üì¶ Upload GLB to swap the player model');
</script>
</body>
</html>
