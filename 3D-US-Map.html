```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Platonic Representation Hypothesis + 3D US Map (MN ‚Ä¢ TX ‚Ä¢ FL ‚Ä¢ CA)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 100%);
    }
    canvas { display: block; }

    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 18px 18px 14px 18px;
      border-radius: 12px;
      max-width: 370px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
    h1 {
      margin: 0 0 8px 0;
      font-size: 18px;
      color: #00ffff;
      letter-spacing: 0.3px;
    }
    p {
      margin: 8px 0;
      font-size: 13px;
      line-height: 1.45;
      color: rgba(255,255,255,0.92);
    }
    .legend {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.18);
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 7px 0;
      font-size: 12px;
      color: rgba(255,255,255,0.9);
    }
    .legend-color {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      margin-right: 10px;
      border: 1px solid rgba(255, 255, 255, 0.25);
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.65);
      padding: 12px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.12);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      max-width: min(740px, calc(100vw - 40px));
    }
    button {
      background: rgba(0, 255, 255, 0.16);
      border: 1px solid rgba(0,255,255,0.9);
      color: #aefcff;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 12px;
      transition: transform 0.12s ease, background 0.2s ease, border-color 0.2s ease;
      user-select: none;
      letter-spacing: 0.2px;
    }
    button:hover {
      background: rgba(0, 255, 255, 0.28);
      transform: translateY(-1px);
      border-color: rgba(0,255,255,1);
    }

    #hint {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 20px;
      color: rgba(255, 255, 255, 0.86);
      background: rgba(0, 0, 0, 0.32);
      padding: 10px 14px;
      border-radius: 999px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 12px;
      pointer-events: none;
      text-align: center;
      max-width: calc(100vw - 40px);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>
  <div id="info">
    <h1>üîÆ Platonic Representation Hypothesis + üó∫Ô∏è 3D US Map</h1>
    <p><strong>The Theory:</strong> Different neural nets converge toward similar internal representations when learning the same task.</p>
    <p><strong>New:</strong> Enhanced 3D map layer for <strong>CA ‚Ä¢ MN ‚Ä¢ TX ‚Ä¢ FL</strong> with coastal feel, procedural surface detail, correct NSEW, and <strong>3D ZIP2 cones</strong> for city population.</p>
    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background:#ff1744;"></div>
        <span><strong>CNN:</strong> hierarchical / local receptive fields</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#00e676;"></div>
        <span><strong>Transformer:</strong> attention mesh</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#ffd600;"></div>
        <span><strong>RNN:</strong> recurrent loops</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:#00b0ff;"></div>
        <span><strong>Biological:</strong> organic dendrites</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:rgba(255,255,255,0.9);"></div>
        <span><strong>Platonic Ideal:</strong> convergent representation</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background:rgba(140,255,240,0.35);"></div>
        <span><strong>ZIP2 Cone:</strong> mouth size = population</span>
      </div>
    </div>
  </div>

  <div id="controls">
    <button id="btn-reset">Reset</button>
    <button id="btn-paths">Toggle Connections</button>
    <button id="btn-trails">Toggle Trails</button>
    <button id="btn-rotate">Toggle Auto-Rotate</button>
    <button id="btn-camera">Toggle Mouse Camera</button>
    <button id="btn-map">Toggle Map Layer</button>
    <button id="btn-cones">Toggle ZIP2 Cones</button>
    <button id="btn-labels">Toggle Labels</button>
    <button id="btn-compass">Toggle Compass Rose</button>
    <button id="btn-topdown">Top-Down Map View</button>
  </div>

  <div id="hint">Drag to orbit ‚Ä¢ Wheel to zoom ‚Ä¢ Shift+Drag to pan (Mouse Camera ON) ‚Ä¢ Axes: +X=East, +Z=North, +Y=Up (CA left, ME right)</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ============================================================
    // ‚úÖ Coordinate truth (so NSEW is right):
    //   - World axes: +X = East, +Z = North, +Y = Up
    //   - Lon maps to X, Lat maps to Z (no mirroring)
    //   - Result: California (more negative lon) sits LEFT of Maine (less negative lon)
    // ============================================================

    // ===== Scene setup =====
    let scene, camera, renderer;
    let networkClusters = [];
    let centralIdeal, particleSystem;
    let showConnections = true;
    let showTrails = true;
    let autoRotate = true;
    let mouseCamera = true;
    let time = 0;

    // Map layer toggles
    let mapVisible = true;
    let conesVisible = true;
    let labelsVisible = true;
    let compassVisible = true;

    let mapGroup, conesGroup, labelsGroup, compassGroup;
    let mapFloorY = -4.2;

    // Post-ish: mild bloom look without postprocessing:
    // - Physically correct lights
    // - ACES tone mapping
    // - emissive accents
    // - fog + haze

    // ===== Lightweight orbit controls (no extra imports) =====
    const controls = {
      isDown: false,
      button: 0,
      lastX: 0,
      lastY: 0,
      azimuth: 0.62,
      polar: 0.86,
      radius: 16,
      target: new THREE.Vector3(0, 0, 0),
      pan: new THREE.Vector3(0, 0, 0),
      damping: 0.12,
      velAz: 0,
      velPol: 0,
      velPanX: 0,
      velPanY: 0,
      update() {
        this.velAz *= (1 - this.damping);
        this.velPol *= (1 - this.damping);
        this.velPanX *= (1 - this.damping);
        this.velPanY *= (1 - this.damping);

        this.azimuth += this.velAz;
        this.polar = Math.max(0.12, Math.min(Math.PI - 0.12, this.polar + this.velPol));

        const panSpeed = 0.015 * this.radius;
        const up = new THREE.Vector3(0, 1, 0);

        const dir = new THREE.Vector3(
          Math.sin(this.polar) * Math.cos(this.azimuth),
          Math.cos(this.polar),
          Math.sin(this.polar) * Math.sin(this.azimuth)
        ).normalize();

        const right = new THREE.Vector3().crossVectors(dir, up).normalize();
        const camUp = new THREE.Vector3().crossVectors(right, dir).normalize();

        this.pan.addScaledVector(right, this.velPanX * panSpeed);
        this.pan.addScaledVector(camUp, this.velPanY * panSpeed);

        const pos = dir.multiplyScalar(this.radius).add(this.target).add(this.pan);
        camera.position.copy(pos);
        camera.lookAt(this.target.clone().add(this.pan));
      }
    };

    // ============================================================
    // üåä Procedural utils (noise + palettes)
    // ============================================================
    function hash2(x, y) {
      // tiny deterministic hash
      const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453123;
      return s - Math.floor(s);
    }
    function valueNoise2(x, y) {
      const ix = Math.floor(x), iy = Math.floor(y);
      const fx = x - ix, fy = y - iy;
      const a = hash2(ix, iy);
      const b = hash2(ix + 1, iy);
      const c = hash2(ix, iy + 1);
      const d = hash2(ix + 1, iy + 1);
      const ux = fx * fx * (3 - 2 * fx);
      const uy = fy * fy * (3 - 2 * fy);
      const lerp = (p, q, t) => p + (q - p) * t;
      return lerp(lerp(a, b, ux), lerp(c, d, ux), uy);
    }
    function fbm2(x, y) {
      let f = 0, amp = 0.5, freq = 1.0;
      for (let i = 0; i < 5; i++) {
        f += amp * valueNoise2(x * freq, y * freq);
        freq *= 2.0;
        amp *= 0.5;
      }
      return f;
    }

    // ============================================================
    // üó∫Ô∏è Lat/Lon -> Map coords (X=East, Z=North)
    // ============================================================
    const MAP = {
      lonMin: -125,
      lonMax: -66,
      latMin: 24,
      latMax: 50,
      width: 18.5,
      depth: 10.0
    };

    function lonLatToXZ(lon, lat) {
      const nx = (lon - MAP.lonMin) / (MAP.lonMax - MAP.lonMin);  // 0..1 west->east
      const nz = (lat - MAP.latMin) / (MAP.latMax - MAP.latMin);  // 0..1 south->north
      const x = (nx - 0.5) * MAP.width;
      const z = (nz - 0.5) * MAP.depth;
      return new THREE.Vector3(x, 0, z);
    }

    // ============================================================
    // ‚ú® Label sprites (canvas -> texture)
    // ============================================================
    function makeLabelSprite(text, opts = {}) {
      const {
        fontSize = 44,
        padding = 18,
        fg = "rgba(220,255,255,0.98)",
        stroke = "rgba(0,0,0,0.75)",
        bg = "rgba(0,0,0,0.0)",
        glow = "rgba(0,255,255,0.35)",
        maxWidth = 900
      } = opts;

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");

      ctx.font = `700 ${fontSize}px Segoe UI, Tahoma, sans-serif`;
      const metrics = ctx.measureText(text);
      const textW = Math.min(maxWidth, metrics.width);
      const w = Math.ceil(textW + padding * 2);
      const h = Math.ceil(fontSize + padding * 2);

      canvas.width = w;
      canvas.height = h;

      // background
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, w, h);

      // glow
      ctx.shadowColor = glow;
      ctx.shadowBlur = 18;

      // stroke
      ctx.font = `700 ${fontSize}px Segoe UI, Tahoma, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.lineWidth = 8;
      ctx.strokeStyle = stroke;
      ctx.strokeText(text, w / 2, h / 2);

      // fill
      ctx.fillStyle = fg;
      ctx.fillText(text, w / 2, h / 2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.anisotropy = 4;

      const mat = new THREE.SpriteMaterial({
        map: tex,
        transparent: true,
        depthWrite: false
      });

      const sprite = new THREE.Sprite(mat);
      // scale in world units
      const s = 0.012;
      sprite.scale.set(canvas.width * s * 0.45, canvas.height * s * 0.45, 1);

      return sprite;
    }

    // ============================================================
    // üß≠ 3D Compass Rose (N/E/S/W, correct orientation)
    // ============================================================
    function buildCompassRose() {
      const g = new THREE.Group();

      // base disc
      const discGeo = new THREE.CylinderGeometry(1.05, 1.05, 0.08, 48, 1, false);
      const discMat = new THREE.MeshStandardMaterial({
        color: 0x0b1020,
        metalness: 0.35,
        roughness: 0.35,
        emissive: 0x001018,
        emissiveIntensity: 0.65
      });
      const disc = new THREE.Mesh(discGeo, discMat);
      disc.castShadow = true;
      disc.receiveShadow = true;
      g.add(disc);

      // rim
      const rimGeo = new THREE.TorusGeometry(1.05, 0.06, 12, 64);
      const rimMat = new THREE.MeshStandardMaterial({
        color: 0x00e5ff,
        metalness: 0.6,
        roughness: 0.25,
        emissive: 0x00c8ff,
        emissiveIntensity: 0.35
      });
      const rim = new THREE.Mesh(rimGeo, rimMat);
      rim.rotation.x = Math.PI / 2;
      rim.position.y = 0.06;
      rim.castShadow = true;
      g.add(rim);

      // arrow (north)
      const arrowGeo = new THREE.ConeGeometry(0.18, 0.85, 24);
      const arrowMatN = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.25,
        roughness: 0.35,
        emissive: 0x00ffff,
        emissiveIntensity: 0.45
      });
      const arrowN = new THREE.Mesh(arrowGeo, arrowMatN);
      arrowN.position.set(0, 0.18, 0.65);
      arrowN.rotation.x = -Math.PI / 2; // point along +Z (North)
      arrowN.castShadow = true;
      g.add(arrowN);

      // south arrow (subtle)
      const arrowMatS = new THREE.MeshStandardMaterial({
        color: 0x23314a,
        metalness: 0.3,
        roughness: 0.5,
        emissive: 0x003040,
        emissiveIntensity: 0.35
      });
      const arrowS = new THREE.Mesh(arrowGeo, arrowMatS);
      arrowS.position.set(0, 0.16, -0.65);
      arrowS.rotation.x = Math.PI / 2; // point along -Z (South)
      arrowS.castShadow = true;
      g.add(arrowS);

      // tick marks
      const tickGeo = new THREE.BoxGeometry(0.06, 0.05, 0.22);
      const tickMat = new THREE.MeshStandardMaterial({
        color: 0x9befff,
        metalness: 0.2,
        roughness: 0.35,
        emissive: 0x006070,
        emissiveIntensity: 0.35
      });

      for (let i = 0; i < 16; i++) {
        const t = new THREE.Mesh(tickGeo, tickMat);
        const a = (i / 16) * Math.PI * 2;
        t.position.set(Math.sin(a) * 0.88, 0.09, Math.cos(a) * 0.88);
        t.rotation.y = a;
        t.castShadow = true;
        g.add(t);
      }

      // letters
      const n = makeLabelSprite("N", { fontSize: 56, glow: "rgba(0,255,255,0.55)" });
      const e = makeLabelSprite("E", { fontSize: 44, glow: "rgba(0,255,255,0.45)" });
      const s = makeLabelSprite("S", { fontSize: 44, glow: "rgba(0,255,255,0.35)", fg: "rgba(190,215,255,0.95)" });
      const w = makeLabelSprite("W", { fontSize: 44, glow: "rgba(0,255,255,0.45)" });

      n.position.set(0, 0.52, 1.28);  // +Z
      s.position.set(0, 0.5, -1.28);  // -Z
      e.position.set(1.28, 0.5, 0);   // +X
      w.position.set(-1.28, 0.5, 0);  // -X

      g.add(n, e, s, w);

      // slight tilt toward camera for readability
      g.rotation.x = -0.18;
      return g;
    }

    // ============================================================
    // üåé 3D Map Layer (procedural ocean + land surface + state slabs)
    // ============================================================
    function buildMapLayer() {
      mapGroup = new THREE.Group();
      mapGroup.position.y = mapFloorY;

      // --- Ocean plane with shader-ish Fresnel feel
      const oceanGeo = new THREE.PlaneGeometry(MAP.width * 1.45, MAP.depth * 1.55, 120, 120);
      oceanGeo.rotateX(-Math.PI / 2);

      // Add subtle wave displacement directly to geometry (fast, no extra libs)
      const pos = oceanGeo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const z = pos.getZ(i);
        const n = fbm2((x + 100) * 0.12, (z + 100) * 0.12);
        const rip = Math.sin(x * 0.9) * 0.03 + Math.cos(z * 0.85) * 0.03;
        pos.setY(i, (n - 0.5) * 0.14 + rip);
      }
      pos.needsUpdate = true;
      oceanGeo.computeVertexNormals();

      const oceanMat = new THREE.MeshPhysicalMaterial({
        color: 0x07162c,
        metalness: 0.0,
        roughness: 0.18,
        transmission: 0.25,
        thickness: 0.8,
        transparent: true,
        opacity: 0.96,
        clearcoat: 1.0,
        clearcoatRoughness: 0.18,
        emissive: 0x001628,
        emissiveIntensity: 0.6
      });

      const ocean = new THREE.Mesh(oceanGeo, oceanMat);
      ocean.receiveShadow = true;
      ocean.name = "ocean";
      mapGroup.add(ocean);

      // --- Map base plate (dark tech plate under states)
      const baseGeo = new THREE.BoxGeometry(MAP.width * 1.06, 0.12, MAP.depth * 1.06);
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x071022,
        metalness: 0.5,
        roughness: 0.45,
        emissive: 0x001028,
        emissiveIntensity: 0.55
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = -0.1;
      base.castShadow = true;
      base.receiveShadow = true;
      mapGroup.add(base);

      // --- Subtle grid lines on base using LineSegments
      const grid = new THREE.GridHelper(MAP.width * 1.04, 26, 0x00ffff, 0x2a4a6a);
      grid.position.y = 0.01;
      grid.material.opacity = 0.18;
      grid.material.transparent = true;
      mapGroup.add(grid);

      // --- Coastline hint (procedural wavy outline around the map region)
      // Not true US coastline data (kept self-contained), but gives "coastal" feel.
      const coastPoints = [];
      const w = MAP.width * 0.53;
      const d = MAP.depth * 0.53;
      for (let i = 0; i <= 220; i++) {
        const t = i / 220;
        const a = t * Math.PI * 2;
        const jitter = (fbm2(Math.cos(a) * 2.1 + 10, Math.sin(a) * 2.1 + 10) - 0.5) * 0.35;
        coastPoints.push(new THREE.Vector3(
          Math.sin(a) * (w + jitter),
          0.06,
          Math.cos(a) * (d + jitter * 0.8)
        ));
      }
      const coastGeo = new THREE.BufferGeometry().setFromPoints(coastPoints);
      const coastMat = new THREE.LineBasicMaterial({ color: 0x6ffcff, transparent: true, opacity: 0.14 });
      const coast = new THREE.LineLoop(coastGeo, coastMat);
      mapGroup.add(coast);

      // --- State slabs (CA, MN, TX, FL) with procedural surface offsets
      // These are simplified "bounding polygons" (not official borders),
      // but oriented correctly and positioned by lat/lon so west/east is correct.
      const stateDefs = [
        {
          key: "CA",
          name: "CALIFORNIA",
          color: 0x18ffd0,
          emissive: 0x00c8a6,
          // simplified polygon (lon,lat) around CA-ish
          poly: [
            [-124.4, 42.0], [-123.0, 40.7], [-122.3, 39.2], [-122.4, 37.7],
            [-121.9, 36.5], [-121.4, 35.2], [-120.6, 34.7], [-119.7, 34.2],
            [-118.5, 34.0], [-117.2, 33.0], [-114.1, 32.6], [-114.6, 34.9],
            [-114.6, 36.1], [-114.1, 37.2], [-114.0, 41.0], [-120.0, 42.0]
          ],
          label: { lon: -119.6, lat: 36.8 }
        },
        {
          key: "MN",
          name: "MINNESOTA",
          color: 0x00b0ff,
          emissive: 0x005a9e,
          poly: [
            [-97.2, 49.0], [-95.3, 49.0], [-93.1, 48.6], [-92.0, 48.0],
            [-91.4, 47.2], [-91.2, 46.0], [-92.7, 46.0], [-92.8, 45.0],
            [-94.5, 43.5], [-96.5, 43.5], [-97.2, 46.0], [-97.2, 49.0]
          ],
          label: { lon: -94.6, lat: 46.3 }
        },
        {
          key: "TX",
          name: "TEXAS",
          color: 0xffd600,
          emissive: 0x8a7600,
          poly: [
            [-106.6, 31.8], [-104.9, 31.8], [-103.0, 31.8], [-100.0, 34.6],
            [-99.0, 36.5], [-97.5, 35.0], [-95.0, 33.8], [-94.0, 33.0],
            [-93.6, 31.0], [-96.0, 28.8], [-97.2, 26.0], [-99.2, 26.0],
            [-101.5, 29.0], [-103.0, 29.5], [-104.5, 29.8], [-106.6, 31.8]
          ],
          label: { lon: -99.5, lat: 31.2 }
        },
        {
          key: "FL",
          name: "FLORIDA",
          color: 0xff1744,
          emissive: 0x8a0020,
          poly: [
            [-87.6, 30.9], [-85.0, 30.9], [-83.0, 30.8], [-81.2, 30.8],
            [-80.1, 29.9], [-80.1, 28.0], [-80.8, 26.2], [-81.6, 25.2],
            [-82.6, 26.0], [-83.5, 27.3], [-84.7, 28.3], [-85.2, 29.3],
            [-86.1, 30.2], [-87.6, 30.9]
          ],
          label: { lon: -82.5, lat: 28.6 }
        }
      ];

      // --- Extrude state polygons into a custom geometry (top surface, side walls)
      function buildStateMesh(polyLonLat, mat, height = 0.55, bevel = 0.0) {
        // Convert to XZ points in local map space
        const pts = polyLonLat.map(([lon, lat]) => lonLatToXZ(lon, lat));
        // Build a shape in XY for ExtrudeGeometry (x -> x, y -> z)
        const shapePts = pts.map(v => new THREE.Vector2(v.x, v.z));
        const shape = new THREE.Shape(shapePts);

        const geo = new THREE.ExtrudeGeometry(shape, {
          depth: height,
          bevelEnabled: bevel > 0,
          bevelThickness: bevel,
          bevelSize: bevel * 0.8,
          bevelSegments: bevel > 0 ? 2 : 0,
          curveSegments: 12
        });

        // ExtrudeGeometry extrudes along +Z in its local space; we want +Y up.
        // So rotate: geometry's "depth axis" -> world Y
        geo.rotateX(-Math.PI / 2);

        // Center slightly above the base, then add surface wobble
        geo.translate(0, 0.06, 0);

        // Procedural surface offsets (top only): nudge vertices by noise using normals
        const p = geo.attributes.position;
        const n = geo.attributes.normal;

        for (let i = 0; i < p.count; i++) {
          const vx = p.getX(i);
          const vy = p.getY(i);
          const vz = p.getZ(i);

          // Only boost the top-ish surface (vy near height)
          const topMask = Math.max(0, Math.min(1, (vy - (height * 0.72)) / (height * 0.28)));
          if (topMask > 0.001) {
            const noise = fbm2((vx + 20) * 0.55, (vz + 20) * 0.55);
            const ridges = Math.sin(vx * 2.2) * 0.06 + Math.cos(vz * 2.0) * 0.06;
            const bump = (noise - 0.5) * 0.22 + ridges * 0.18;
            const nx = n.getX(i), ny = n.getY(i), nz = n.getZ(i);
            p.setXYZ(i, vx + nx * bump * topMask, vy + ny * bump * topMask, vz + nz * bump * topMask);
          }
        }
        p.needsUpdate = true;
        geo.computeVertexNormals();

        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        // Add a subtle outline
        const edges = new THREE.EdgesGeometry(geo, 20);
        const edgeMat = new THREE.LineBasicMaterial({ color: 0xbefcff, transparent: true, opacity: 0.22 });
        const outline = new THREE.LineSegments(edges, edgeMat);
        outline.position.copy(mesh.position);
        mesh.add(outline);

        return mesh;
      }

      // State materials: glossy tech-land with emissive rim
      function makeStateMaterial(baseColor, emissiveColor) {
        return new THREE.MeshStandardMaterial({
          color: baseColor,
          metalness: 0.25,
          roughness: 0.38,
          emissive: emissiveColor,
          emissiveIntensity: 0.34
        });
      }

      for (const st of stateDefs) {
        const mat = makeStateMaterial(st.color, st.emissive);
        const mesh = buildStateMesh(st.poly, mat, 0.62, 0.04);
        mesh.name = `state_${st.key}`;
        mesh.userData = { key: st.key, name: st.name };

        // Add a soft glow plane above state (fake bloom aura)
        const bbox = new THREE.Box3().setFromObject(mesh);
        const size = new THREE.Vector3();
        bbox.getSize(size);
        const glowGeo = new THREE.PlaneGeometry(size.x * 1.05, size.z * 1.05, 1, 1);
        glowGeo.rotateX(-Math.PI / 2);
        const glowMat = new THREE.MeshBasicMaterial({
          color: st.color,
          transparent: true,
          opacity: 0.08,
          blending: THREE.AdditiveBlending,
          depthWrite: false
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        glow.position.y = 0.78;
        glow.position.x = (bbox.min.x + bbox.max.x) * 0.5;
        glow.position.z = (bbox.min.z + bbox.max.z) * 0.5;
        mapGroup.add(glow);

        mapGroup.add(mesh);

        // state label (floating 3D sprite)
        const lp = lonLatToXZ(st.label.lon, st.label.lat);
        const label = makeLabelSprite(st.name, {
          fontSize: 44,
          glow: "rgba(0,255,255,0.55)",
          fg: "rgba(235,255,255,0.98)",
          stroke: "rgba(0,0,0,0.75)"
        });
        label.position.set(lp.x, 1.45, lp.z);
        label.userData.isLabel = true;
        labelsGroup.add(label);
      }

      // Add NSEW axis micro-legend in the map itself
      const axisN = makeLabelSprite("‚Üë N", { fontSize: 34, glow: "rgba(0,255,255,0.45)" });
      axisN.position.set(0, 0.9, MAP.depth * 0.55);
      labelsGroup.add(axisN);

      const axisE = makeLabelSprite("E ‚Üí", { fontSize: 34, glow: "rgba(0,255,255,0.45)" });
      axisE.position.set(MAP.width * 0.58, 0.9, 0);
      labelsGroup.add(axisE);

      scene.add(mapGroup);
    }

    // ============================================================
    // üèôÔ∏è ZIP2 Cones (city points; mouth size = population)
    // - Self-contained demo dataset (you can swap this for real zip2 aggregates later)
    // ============================================================
    function buildZip2Cones() {
      conesGroup = new THREE.Group();
      conesGroup.position.y = mapFloorY;

      const cities = [
        // CA
        { st: "CA", city: "Los Angeles",  lon: -118.2437, lat: 34.0522, pop: 3890000, zip2: "90-91" },
        { st: "CA", city: "San Diego",    lon: -117.1611, lat: 32.7157, pop: 1380000, zip2: "92" },
        { st: "CA", city: "San Jose",     lon: -121.8863, lat: 37.3382, pop: 1010000, zip2: "95" },
        { st: "CA", city: "San Francisco",lon: -122.4194, lat: 37.7749, pop: 808000,  zip2: "94" },

        // MN
        { st: "MN", city: "Minneapolis",  lon: -93.2650,  lat: 44.9778, pop: 425000,  zip2: "55" },
        { st: "MN", city: "St. Paul",     lon: -93.0899,  lat: 44.9537, pop: 307000,  zip2: "55" },
        { st: "MN", city: "Duluth",       lon: -92.1005,  lat: 46.7867, pop: 86600,   zip2: "55" },

        // TX
        { st: "TX", city: "Houston",      lon: -95.3698,  lat: 29.7604, pop: 2300000, zip2: "77" },
        { st: "TX", city: "Dallas",       lon: -96.7970,  lat: 32.7767, pop: 1300000, zip2: "75" },
        { st: "TX", city: "Austin",       lon: -97.7431,  lat: 30.2672, pop: 980000,  zip2: "78" },
        { st: "TX", city: "San Antonio",  lon: -98.4936,  lat: 29.4241, pop: 1470000, zip2: "78" },

        // FL
        { st: "FL", city: "Miami",        lon: -80.1918,  lat: 25.7617, pop: 455000,  zip2: "33" },
        { st: "FL", city: "Tampa",        lon: -82.4572,  lat: 27.9506, pop: 403000,  zip2: "33-34" },
        { st: "FL", city: "Orlando",      lon: -81.3792,  lat: 28.5383, pop: 307000,  zip2: "32-33" },
        { st: "FL", city: "Jacksonville", lon: -81.6557,  lat: 30.3322, pop: 971000,  zip2: "32" },
      ];

      // scaling for mouth radius and height
      const popMin = 80000, popMax = 3900000;
      const norm = (p) => Math.min(1, Math.max(0, (p - popMin) / (popMax - popMin)));

      function stColor(st) {
        switch (st) {
          case "CA": return 0x18ffd0;
          case "MN": return 0x00b0ff;
          case "TX": return 0xffd600;
          case "FL": return 0xff1744;
          default: return 0xffffff;
        }
      }

      for (const c of cities) {
        const p = lonLatToXZ(c.lon, c.lat);

        // cone parameters: mouth radius shows population; tip is narrow near ground
        const t = norm(c.pop);
        const mouth = 0.10 + t * 0.58;     // bottom radius
        const tip = Math.max(0.02, mouth * 0.12);
        const h = 0.35 + t * 1.75;

        // translucent cone
        const geo = new THREE.ConeGeometry(mouth, h, 28, 1, true);
        // ConeGeometry points up; we want tip at top? But your request is "radius of bottom of cone is size of pop"
        // We'll invert: base at bottom (ground), cone points upward.
        geo.translate(0, h * 0.5, 0);

        // Make it a little "techy" by stretching and adding subtle twist via vertex edits
        const pos = geo.attributes.position;
        for (let i = 0; i < pos.count; i++) {
          const x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
          const twist = (y / h) * 0.35;
          const cs = Math.cos(twist), sn = Math.sin(twist);
          const rx = x * cs - z * sn;
          const rz = x * sn + z * cs;
          const wobble = (fbm2((rx + 10) * 1.6, (rz + 10) * 1.6) - 0.5) * 0.03;
          pos.setXYZ(i, rx * (1 + wobble), y, rz * (1 + wobble));
        }
        pos.needsUpdate = true;
        geo.computeVertexNormals();

        const mat = new THREE.MeshPhysicalMaterial({
          color: stColor(c.st),
          roughness: 0.22,
          metalness: 0.08,
          transmission: 0.55,
          thickness: 0.8,
          transparent: true,
          opacity: 0.36,
          clearcoat: 1.0,
          clearcoatRoughness: 0.18,
          emissive: stColor(c.st),
          emissiveIntensity: 0.22
        });

        const cone = new THREE.Mesh(geo, mat);
        cone.position.set(p.x, 0.12, p.z);
        cone.castShadow = true;
        cone.receiveShadow = false;

        // pin stem (translucent)
        const stemGeo = new THREE.CylinderGeometry(0.018, 0.028, 0.22, 10);
        const stemMat = new THREE.MeshStandardMaterial({
          color: 0xbefcff,
          transparent: true,
          opacity: 0.35,
          metalness: 0.2,
          roughness: 0.55,
          emissive: 0x004a5a,
          emissiveIntensity: 0.35
        });
        const stem = new THREE.Mesh(stemGeo, stemMat);
        stem.position.set(p.x, 0.11, p.z);
        stem.castShadow = true;

        // city label (floating)
        const txt = `${c.city}  ‚Ä¢  ZIP2 ${c.zip2}`;
        const lbl = makeLabelSprite(txt, { fontSize: 34, glow: "rgba(0,255,255,0.45)" });
        lbl.position.set(p.x, 0.35 + h, p.z);
        lbl.userData.isCityLabel = true;

        conesGroup.add(cone);
        conesGroup.add(stem);
        labelsGroup.add(lbl);

        // base ring glow
        const ringGeo = new THREE.RingGeometry(mouth * 0.75, mouth * 0.98, 44);
        ringGeo.rotateX(-Math.PI / 2);
        const ringMat = new THREE.MeshBasicMaterial({
          color: stColor(c.st),
          transparent: true,
          opacity: 0.22,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide,
          depthWrite: false
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.set(p.x, 0.07, p.z);
        conesGroup.add(ring);
      }

      scene.add(conesGroup);
    }

    // ============================================================
    // üß† Network clusters (your original sim, kept)
    // ============================================================
    class NetworkCluster {
      constructor(type, color, position) {
        this.type = type;
        this.color = color;
        this.nodes = [];
        this.connections = [];
        this.group = new THREE.Group();
        this.velocity = new THREE.Vector3();
        this.originalPos = position.clone();
        this.convergenceSpeed = 0.01 + Math.random() * 0.01;
        this.orbitSpeed = 0.2 + Math.random() * 0.2;

        this.trail = null;
        this.trailPoints = [];
        this.trailMax = 90;

        this.createNetwork(type, color);
        this.group.position.copy(position);
        this.createTrail(color);
      }

      createNetwork(type, color) {
        switch (type) {
          case "CNN": this.createCNN(color); break;
          case "Transformer": this.createTransformer(color); break;
          case "RNN": this.createRNN(color); break;
          case "Biological": this.createBiological(color); break;
        }
      }

      createCNN(color) {
        const layers = [{ count: 6, radius: 1.5 }, { count: 4, radius: 1.0 }, { count: 3, radius: 0.6 }];
        layers.forEach((layer, layerIndex) => {
          const y = (layerIndex - 1) * 0.8;
          for (let i = 0; i < layer.count; i++) {
            const angle = (i / layer.count) * Math.PI * 2;
            const x = Math.cos(angle) * layer.radius;
            const z = Math.sin(angle) * layer.radius;
            const node = this.createNode(color, new THREE.Vector3(x, y, z));
            this.nodes.push({ mesh: node, layer: layerIndex, index: i });
          }
        });

        this.nodes.forEach((node, i) => {
          for (let j = i + 1; j < this.nodes.length; j++) {
            const other = this.nodes[j];
            if (other.layer === node.layer + 1 || (other.layer === node.layer && Math.abs(other.index - node.index) <= 1)) {
              this.createConnection(node.mesh.position, other.mesh.position, color);
            }
          }
        });
      }

      createTransformer(color) {
        const gridSize = 4, spacing = 0.7;
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const x = (i - gridSize / 2 + 0.5) * spacing;
            const y = (j - gridSize / 2 + 0.5) * spacing;
            const z = Math.sin(i * 0.5) * 0.3 + Math.cos(j * 0.5) * 0.3;
            const node = this.createNode(color, new THREE.Vector3(x, y, z));
            this.nodes.push({ mesh: node, x: i, y: j });
          }
        }
        this.nodes.forEach((node, i) => {
          const numConnections = 3 + Math.floor(Math.random() * 3);
          for (let c = 0; c < numConnections; c++) {
            const targetIndex = Math.floor(Math.random() * this.nodes.length);
            if (targetIndex !== i) this.createConnection(node.mesh.position, this.nodes[targetIndex].mesh.position, color, 0.15);
          }
        });
      }

      createRNN(color) {
        const nodeCount = 8, radius = 1.2;
        for (let i = 0; i < nodeCount; i++) {
          const angle = (i / nodeCount) * Math.PI * 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius * 0.5;
          const z = Math.sin(angle) * radius;
          const node = this.createNode(color, new THREE.Vector3(x, y, z));
          this.nodes.push({ mesh: node, index: i });
        }
        this.nodes.forEach((node, i) => {
          const nextIndex = (i + 1) % this.nodes.length;
          this.createConnection(node.mesh.position, this.nodes[nextIndex].mesh.position, color);
          if (i % 2 === 0) {
            const loopPoint = node.mesh.position.clone(); loopPoint.y += 0.5;
            this.createConnection(node.mesh.position, loopPoint, color, 0.2);
          }
        });
      }

      createBiological(color) {
        const center = new THREE.Vector3(0, 0, 0);
        const centerNode = this.createNode(color, center);
        this.nodes.push({ mesh: centerNode, generation: 0 });

        const createBranch = (parentPos, generation, maxGen) => {
          if (generation >= maxGen) return;
          const branches = generation === 0 ? 4 : 2 + Math.floor(Math.random() * 2);
          for (let i = 0; i < branches; i++) {
            const angle = Math.random() * Math.PI * 2;
            const elevation = (Math.random() - 0.5) * Math.PI * 0.6;
            const distance = 0.5 + Math.random() * 0.5;
            const newPos = new THREE.Vector3(
              parentPos.x + Math.cos(angle) * Math.cos(elevation) * distance,
              parentPos.y + Math.sin(elevation) * distance,
              parentPos.z + Math.sin(angle) * Math.cos(elevation) * distance
            );
            const node = this.createNode(color, newPos, 0.08 / (generation + 1));
            this.nodes.push({ mesh: node, generation: generation + 1 });
            this.createConnection(parentPos, newPos, color, 0.15);
            if (Math.random() > 0.3) createBranch(newPos, generation + 1, maxGen);
          }
        };
        createBranch(center, 0, 3);
      }

      createNode(color, position, size = 0.12) {
        const geometry = new THREE.SphereGeometry(size, 12, 12);
        const material = new THREE.MeshStandardMaterial({
          color,
          emissive: color,
          emissiveIntensity: 0.55,
          metalness: 0.25,
          roughness: 0.35,
          transparent: true,
          opacity: 0.93
        });
        const node = new THREE.Mesh(geometry, material);
        node.position.copy(position);
        node.userData.baseScale = 1;
        node.userData.pulseOffset = Math.random() * Math.PI * 2;
        node.castShadow = true;
        this.group.add(node);
        return node;
      }

      createConnection(pos1, pos2, color, opacity = 0.3) {
        const points = [pos1.clone(), pos2.clone()];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
        const line = new THREE.Line(geometry, material);
        line.visible = showConnections;
        this.group.add(line);
        this.connections.push(line);
      }

      createTrail(color) {
        const geo = new THREE.BufferGeometry();
        const max = this.trailMax;
        const positions = new Float32Array(max * 3);
        geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        geo.setDrawRange(0, 0);
        const mat = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.16 });
        this.trail = new THREE.Line(geo, mat);
        this.trail.visible = showTrails;
        scene.add(this.trail);
      }

      pushTrailPoint(worldPos) {
        this.trailPoints.push(worldPos.clone());
        if (this.trailPoints.length > this.trailMax) this.trailPoints.shift();
        const attr = this.trail.geometry.getAttribute("position");
        for (let i = 0; i < this.trailPoints.length; i++) {
          const p = this.trailPoints[i];
          attr.setXYZ(i, p.x, p.y, p.z);
        }
        attr.needsUpdate = true;
        this.trail.geometry.setDrawRange(0, this.trailPoints.length);
      }

      setConnectionsVisible(v) { this.connections.forEach(l => (l.visible = v)); }
      setTrailVisible(v) { if (this.trail) this.trail.visible = v; }

      reset() {
        this.group.position.copy(this.originalPos);
        this.velocity.set(0, 0, 0);
        this.trailPoints = [];
        if (this.trail) this.trail.geometry.setDrawRange(0, 0);
      }

      update(deltaTime, idx) {
        for (const node of this.nodes) {
          const pulse = Math.sin(time * 2 + node.mesh.userData.pulseOffset) * 0.2 + 1;
          node.mesh.scale.setScalar(node.mesh.userData.baseScale * pulse);
        }

        this.group.rotation.y += 0.0048;
        this.group.rotation.x += 0.0022;

        const toCenter = new THREE.Vector3(0, 0, 0).sub(this.group.position);
        const distance = toCenter.length();
        if (distance > 3) {
          toCenter.normalize().multiplyScalar(this.convergenceSpeed);
          this.velocity.add(toCenter);
        }
        const ang = time * this.orbitSpeed;
        this.velocity.x += Math.cos(ang + idx) * 0.008;
        this.velocity.z += Math.sin(ang + idx) * 0.008;

        this.velocity.multiplyScalar(0.96);
        this.group.position.add(this.velocity);

        if (showTrails) this.pushTrailPoint(this.group.position);
      }
    }

    // ============================================================
    // Init / Lighting / Particles / Ideal
    // ============================================================
    function init() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x060716, 14, 70);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1200);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x050612, 1);

      // Better rendering response (Three r128)
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.08;
      renderer.physicallyCorrectLights = true;

      // Shadows
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      document.body.appendChild(renderer.domElement);

      // Lights: cinematic key + rim + ambient haze
      const hemi = new THREE.HemisphereLight(0x6bdcff, 0x0b1020, 0.45);
      scene.add(hemi);

      const key = new THREE.DirectionalLight(0xffffff, 2.2);
      key.position.set(8, 16, 10);
      key.castShadow = true;
      key.shadow.mapSize.set(2048, 2048);
      key.shadow.camera.near = 1;
      key.shadow.camera.far = 70;
      key.shadow.camera.left = -22;
      key.shadow.camera.right = 22;
      key.shadow.camera.top = 22;
      key.shadow.camera.bottom = -22;
      scene.add(key);

      const rim = new THREE.PointLight(0x00ffff, 1.35, 120);
      rim.position.set(-8, 8, -10);
      scene.add(rim);

      const core = new THREE.PointLight(0xffffff, 1.0, 90);
      core.position.set(0, 0.5, 0);
      scene.add(core);

      // Central ideal
      const idealGeometry = new THREE.IcosahedronGeometry(0.85, 2);
      const idealMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 0.5,
        metalness: 0.25,
        roughness: 0.22,
        transparent: true,
        opacity: 0.92
      });
      centralIdeal = new THREE.Mesh(idealGeometry, idealMaterial);
      centralIdeal.position.y = 0.6;
      centralIdeal.castShadow = true;
      scene.add(centralIdeal);

      const wireframeGeo = new THREE.IcosahedronGeometry(0.93, 2);
      const wireframeMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        wireframe: true,
        transparent: true,
        opacity: 0.22
      });
      const wireframe = new THREE.Mesh(wireframeGeo, wireframeMat);
      centralIdeal.add(wireframe);

      // Glow aura (shader)
      const glowGeometry = new THREE.SphereGeometry(1.6, 40, 40);
      const glowMaterial = new THREE.ShaderMaterial({
        uniforms: { time: { value: 0 } },
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          varying vec3 vNormal;
          void main() {
            float intensity = pow(0.78 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.25);
            float pulse = sin(time * 2.0) * 0.15 + 0.85;
            vec3 glow = vec3(0.45, 1.0, 1.0) * intensity * pulse;
            gl_FragColor = vec4(glow, intensity * 0.62);
          }
        `,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glow.name = "idealGlow";
      glow.position.copy(centralIdeal.position);
      scene.add(glow);

      // Particles
      createParticles();

      // Networks
      const networkTypes = [
        { name: "CNN", color: 0xff1744, count: 3 },
        { name: "Transformer", color: 0x00e676, count: 3 },
        { name: "RNN", color: 0xffd600, count: 3 },
        { name: "Biological", color: 0x00b0ff, count: 3 }
      ];
      networkTypes.forEach((type, typeIndex) => {
        for (let i = 0; i < type.count; i++) {
          const ang = typeIndex * (Math.PI / 2) + i * (Math.PI / 6);
          const radius = 7.2 + Math.random() * 2.2;
          const pos = new THREE.Vector3(
            Math.cos(ang) * radius,
            (Math.random() - 0.5) * 3.2 + 1.8,
            Math.sin(ang) * radius
          );
          const cluster = new NetworkCluster(type.name, type.color, pos);
          scene.add(cluster.group);
          networkClusters.push(cluster);
        }
      });

      // Map groups
      labelsGroup = new THREE.Group();
      labelsGroup.position.y = mapFloorY;
      scene.add(labelsGroup);

      buildMapLayer();
      buildZip2Cones();

      // Compass rose pinned in world near map
      compassGroup = new THREE.Group();
      const compass = buildCompassRose();
      compass.position.set(MAP.width * 0.62, mapFloorY + 0.45, -MAP.depth * 0.62);
      compass.scale.setScalar(1.18);
      compassGroup.add(compass);
      scene.add(compassGroup);

      // UI + controls
      wireUI();
      controls.target.set(0, 0.6, 0);
      controls.update();

      window.addEventListener("resize", onWindowResize, false);
      bindPointerControls();
    }

    function createParticles() {
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 1100;
      const positions = new Float32Array(particleCount * 3);
      const speeds = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 70;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 70;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 70;
        speeds[i] = Math.random();
      }

      particleGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute("speed", new THREE.BufferAttribute(speeds, 1));

      const particleMaterial = new THREE.PointsMaterial({
        color: 0x7efcff,
        size: 0.055,
        transparent: true,
        opacity: 0.28
      });

      particleSystem = new THREE.Points(particleGeometry, particleMaterial);
      particleSystem.position.y = 1.0;
      scene.add(particleSystem);
    }

    // ============================================================
    // Animate
    // ============================================================
    function animate() {
      requestAnimationFrame(animate);
      const deltaTime = 0.016;
      time += deltaTime;

      // update glow shader
      const glow = scene.getObjectByName("idealGlow");
      if (glow?.material?.uniforms?.time) glow.material.uniforms.time.value = time;

      // networks
      for (let i = 0; i < networkClusters.length; i++) networkClusters[i].update(deltaTime, i);

      // central ideal rotation
      centralIdeal.rotation.y += 0.0068;
      centralIdeal.rotation.x += 0.004;

      // particle drift
      particleSystem.rotation.y += 0.00024;
      particleSystem.rotation.x += 0.00009;

      // ocean shimmer (tiny normal-ish movement by rotating very slightly)
      const ocean = scene.getObjectByName("ocean");
      if (ocean) {
        ocean.rotation.y = Math.sin(time * 0.08) * 0.02;
      }

      // cones subtle pulse
      if (conesGroup && conesVisible) {
        conesGroup.children.forEach((obj, i) => {
          if (obj.isMesh && obj.geometry?.type.includes("Cone")) {
            const s = 1 + Math.sin(time * 1.6 + i) * 0.015;
            obj.scale.set(s, 1 + Math.sin(time * 1.1 + i) * 0.02, s);
          }
        });
      }

      // compass gentle wobble for ‚Äú3D presence‚Äù
      if (compassGroup && compassVisible) {
        compassGroup.rotation.y = Math.sin(time * 0.22) * 0.08;
      }

      // camera
      if (autoRotate && !controls.isDown) controls.velAz += 0.0010;

      if (mouseCamera) controls.update();
      else {
        camera.position.x = Math.cos(time * 0.07) * 16;
        camera.position.z = Math.sin(time * 0.07) * 16;
        camera.position.y = 8 + Math.sin(time * 0.05) * 1.8;
        camera.lookAt(0, 0.4, 0);
      }

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ============================================================
    // UI actions
    // ============================================================
    function wireUI() {
      document.getElementById("btn-reset").addEventListener("click", resetSimulation);
      document.getElementById("btn-paths").addEventListener("click", toggleConnections);
      document.getElementById("btn-trails").addEventListener("click", toggleTrails);
      document.getElementById("btn-rotate").addEventListener("click", () => autoRotate = !autoRotate);
      document.getElementById("btn-camera").addEventListener("click", toggleMouseCamera);

      document.getElementById("btn-map").addEventListener("click", () => {
        mapVisible = !mapVisible;
        if (mapGroup) mapGroup.visible = mapVisible;
      });

      document.getElementById("btn-cones").addEventListener("click", () => {
        conesVisible = !conesVisible;
        if (conesGroup) conesGroup.visible = conesVisible;
        // city labels live in labelsGroup; keep them tied to cones toggle for sanity
        labelsGroup.children.forEach(s => { if (s.userData.isCityLabel) s.visible = conesVisible && labelsVisible; });
      });

      document.getElementById("btn-labels").addEventListener("click", () => {
        labelsVisible = !labelsVisible;
        if (labelsGroup) labelsGroup.visible = labelsVisible;
        // If labels turned off, hide all; if on, respect cones toggle for city labels
        if (labelsGroup) {
          labelsGroup.children.forEach(s => {
            if (s.userData.isCityLabel) s.visible = conesVisible && labelsVisible;
            else s.visible = labelsVisible;
          });
        }
      });

      document.getElementById("btn-compass").addEventListener("click", () => {
        compassVisible = !compassVisible;
        if (compassGroup) compassGroup.visible = compassVisible;
      });

      document.getElementById("btn-topdown").addEventListener("click", topDownMapView);
    }

    function resetSimulation() {
      networkClusters.forEach(c => c.reset());
      // snap camera to a friendly view that shows CA left, ME right (east-west correct)
      controls.azimuth = 0.66;
      controls.polar = 0.95;
      controls.radius = 18;
      controls.pan.set(0, 0, 0);
      controls.target.set(0, 0.35, 0);
    }

    function toggleConnections() {
      showConnections = !showConnections;
      networkClusters.forEach(c => c.setConnectionsVisible(showConnections));
    }

    function toggleTrails() {
      showTrails = !showTrails;
      networkClusters.forEach(c => c.setTrailVisible(showTrails));
      if (!showTrails) {
        networkClusters.forEach(c => {
          c.trailPoints = [];
          if (c.trail) c.trail.geometry.setDrawRange(0, 0);
        });
      }
    }

    function toggleMouseCamera() {
      mouseCamera = !mouseCamera;
      document.getElementById("hint").style.display = mouseCamera ? "block" : "none";
    }

    function topDownMapView() {
      // Aim camera down toward map layer, keep +Z north at top of view
      mouseCamera = true;
      controls.target.set(0, mapFloorY + 0.35, 0);
      controls.pan.set(0, 0, 0);
      controls.radius = 14.5;
      controls.polar = 0.28;      // near top-down
      controls.azimuth = 0.0;     // aligns view so +Z is up-screen-ish
    }

    // ============================================================
    // Pointer controls
    // ============================================================
    function bindPointerControls() {
      const el = renderer.domElement;

      el.addEventListener("pointerdown", (e) => {
        if (!mouseCamera) return;
        controls.isDown = true;
        controls.button = e.button;
        controls.lastX = e.clientX;
        controls.lastY = e.clientY;
        el.setPointerCapture(e.pointerId);
      });

      el.addEventListener("pointermove", (e) => {
        if (!mouseCamera || !controls.isDown) return;
        const dx = e.clientX - controls.lastX;
        const dy = e.clientY - controls.lastY;
        controls.lastX = e.clientX;
        controls.lastY = e.clientY;

        const isPan = e.shiftKey || controls.button === 1 || controls.button === 2;
        if (isPan) {
          controls.velPanX += -dx * 0.0022;
          controls.velPanY += dy * 0.0022;
        } else {
          controls.velAz += -dx * 0.003;
          controls.velPol += -dy * 0.003;
        }
      });

      el.addEventListener("pointerup", (e) => {
        if (!mouseCamera) return;
        controls.isDown = false;
        try { el.releasePointerCapture(e.pointerId); } catch (_) {}
      });

      el.addEventListener("wheel", (e) => {
        if (!mouseCamera) return;
        e.preventDefault();
        const delta = Math.sign(e.deltaY);
        controls.radius = Math.max(4, Math.min(60, controls.radius + delta * 0.9));
      }, { passive: false });

      el.addEventListener("contextmenu", (e) => e.preventDefault());
    }

    // ===== Boot =====
    init();
    animate();
  </script>
</body>
</html>
```
