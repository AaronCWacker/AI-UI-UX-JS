<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScifiKin Deities and Demigods</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px; }
        #cards { position: absolute; bottom: 10px; left: 10px; display: flex; gap: 10px; }
        .card { background: rgba(255, 255, 255, 0.2); padding: 5px; border-radius: 5px; font-size: 12px; cursor: pointer; }
        .card:hover { background: rgba(255, 255, 255, 0.4); }
        #log { position: absolute; top: 10px; right: 10px; width: 250px; height: 200px; overflow-y: auto; background: rgba(0, 0, 0, 0.7); padding: 10px; color: white; border-radius: 5px; }
        #turn-indicator { position: absolute; top: 70px; left: 10px; color: white; background: rgba(0, 0, 0, 0.7); padding: 5px; border-radius: 5px; }
        #control-panel { position: absolute; top: 100px; left: 10px; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px; }
        .control-btn { background: #444; color: white; border: none; padding: 5px; margin: 5px; cursor: pointer; }
        .control-btn:hover { background: #666; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="player-stats"></div>
        <div id="turn-phase">Phase: Kick Open Portal</div>
    </div>
    <div id="cards"></div>
    <div id="log">Game Log:<br></div>
    <div id="turn-indicator">Turn: Player 1</div>
    <div id="control-panel"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Realistic Skybox
        const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
        const skyboxMaterials = [
            new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.BackSide }), // Right
            new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.BackSide }), // Left
            new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.BackSide }), // Top
            new THREE.MeshBasicMaterial({ color: 0x111111, side: THREE.BackSide }), // Bottom
            new THREE.MeshBasicMaterial({ color: 0x1a1a3a, side: THREE.BackSide }), // Front
            new THREE.MeshBasicMaterial({ color: 0x2a2a5a, side: THREE.BackSide })  // Back
        ];
        const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
        scene.add(skybox);
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(1000 * 3);
        for (let i = 0; i < 1000; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 1000;
            starPositions[i * 3 + 1] = (Math.random() - 0.5) * 1000;
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 1000;
        }
        starGeometry.setAttribute("position", new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.5 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x606060, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Procedural World Generation
        const exploredAreas = new Set();
        function generateWorld() {
            const terrainGeometry = new THREE.PlaneGeometry(50, 50, 50, 50);
            for (let i = 0; i < terrainGeometry.attributes.position.array.length; i += 3) {
                terrainGeometry.attributes.position.array[i + 2] = Math.sin(i / 100) * 2 + Math.random() * 0.5;
            }
            const terrainMaterial = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.8,
                bumpMap: new THREE.Texture(generateBumpMap()),
                bumpScale: 0.5
            });
            const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            scene.add(terrain);

            for (let i = 0; i < 20; i++) {
                const type = Math.random() < 0.5 ? "tree" : Math.random() < 0.5 ? "altar" : "ruin";
                const objGeometry = type === "tree" ?
                    new THREE.CylinderGeometry(0.2, 0.5, 3, 16) :
                    type === "altar" ? new THREE.BoxGeometry(1, 0.5, 1) :
                    new THREE.BoxGeometry(1.5, 1.5, 1.5);
                const objMaterial = new THREE.MeshStandardMaterial({
                    color: type === "tree" ? 0x8B4513 : type === "altar" ? 0xB0C4DE : 0x808080,
                    roughness: 0.9
                });
                const obj = new THREE.Mesh(objGeometry, objMaterial);
                obj.position.set(
                    (Math.random() - 0.5) * 40,
                    type === "tree" ? 1.5 : 0.5,
                    (Math.random() - 0.5) * 40
                );
                scene.add(obj);
            }
        }

        function generateBumpMap() {
            const canvas = document.createElement("canvas");
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext("2d");
            for (let x = 0; x < 256; x++) {
                for (let y = 0; y < 256; y++) {
                    const value = Math.sin(x / 50) * Math.cos(y / 50) * 128 + 128;
                    ctx.fillStyle = `rgb(${value},${value},${value})`;
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            return new THREE.CanvasTexture(canvas);
        }

        function markExploredArea(position) {
            const x = Math.round(position.x);
            const z = Math.round(position.z);
            const key = `${x},${z}`;
            if (!exploredAreas.has(key)) {
                exploredAreas.add(key);
                const marker = new THREE.Mesh(
                    new THREE.CircleGeometry(1, 16),
                    new THREE.MeshBasicMaterial({ color: 0x00FF00, transparent: true, opacity: 0.3 })
                );
                marker.rotation.x = -Math.PI / 2;
                marker.position.set(x, 0.1, z);
                scene.add(marker);
                setTimeout(() => {
                    marker.material.opacity -= 0.01;
                    if (marker.material.opacity <= 0) scene.remove(marker);
                }, 5000);
            }
        }

        generateWorld();

        // Procedural 3D Models
        function createProceduralDeity(pantheon) {
            const group = new THREE.Group();
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.8, 32);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: pantheon === "Olympian" ? 0xFFD700 : pantheon === "Norse" ? 0x4682B4 : pantheon === "Egyptian" ? 0xDAA520 : 0x00FF00,
                emissive: pantheon ? 0x222222 : 0x000000
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            const headGeometry = new THREE.SphereGeometry(0.3, 32, 32);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 1.2;
            group.add(head);
            const weaponGeometry = pantheon === "Norse" ?
                new THREE.CylinderGeometry(0.05, 0.05, 1.2, 16) :
                new THREE.BoxGeometry(0.1, 0.1, 1.5);
            const weaponMaterial = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.8 });
            const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            weapon.position.set(0.5, 0.8, 0);
            weapon.rotation.z = Math.PI / 4;
            group.add(weapon);
            if (pantheon) {
                const auraGeometry = new THREE.TorusGeometry(0.6, 0.1, 16, 32);
                const auraMaterial = new THREE.MeshBasicMaterial({
                    color: pantheon === "Olympian" ? 0xFFFF00 : pantheon === "Norse" ? 0x00B7EB : 0xFFA500,
                    transparent: true,
                    opacity: 0.5
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                aura.rotation.x = Math.PI / 2;
                group.add(aura);
            }
            return group;
        }

        function createProceduralBeast(isDemigod) {
            const group = new THREE.Group();
            const bodyGeometry = isDemigod ?
                new THREE.DodecahedronGeometry(1.5, 1) :
                new THREE.IcosahedronGeometry(1.2 + Math.random() * 0.5, 1);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: isDemigod ? 0xFF4500 : Math.random() * 0xffffff,
                roughness: 0.7
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);
            for (let i = 0; i < (isDemigod ? 4 : 2); i++) {
                const detailGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                const detailMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
                const detail = new THREE.Mesh(detailGeometry, detailMaterial);
                detail.position.set(
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 1.5
                );
                group.add(detail);
            }
            group.position.set(5, 1, -5);
            return group;
        }

        function createEffectAnimation(type) {
            const group = new THREE.Group();
            if (type === "combat") {
                const particles = new THREE.BufferGeometry();
                const positions = new Float32Array(100 * 3);
                for (let i = 0; i < 100; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 3;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 3;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 3;
                }
                particles.setAttribute("position", new THREE.BufferAttribute(positions, 3));
                const particleMaterial = new THREE.PointsMaterial({ color: 0xFF0000, size: 0.1 });
                const points = new THREE.Points(particles, particleMaterial);
                group.add(points);
            } else if (type === "blessing") {
                const aura = new THREE.Mesh(
                    new THREE.SphereGeometry(0.8, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.5 })
                );
                group.add(aura);
            }
            return group;
        }

        // Pantheon Data
        const pantheons = [
            { name: "Olympian", ability: "Auto-succeed one flee roll per turn", bonus: { strength: 2, autoSucceedFlee: true }, color: 0xFFD700 },
            { name: "Norse", ability: "Gain +1 level on combat win", bonus: { extraLevel: 1 }, color: 0x4682B4 },
            { name: "Egyptian", ability: "+3 strength vs. demigods", bonus: { demigodStrength: 3 }, color: 0xDAA520 }
        ];

        // Card Decks
        const doorDeck = [
            { type: "beast", name: "Star Serpent", strength: 3, levelReward: 1, treasureReward: 1, badStuff: "Lose 1 level" },
            { type: "beast", name: "Void Titan", strength: 5, levelReward: 2, treasureReward: 2, badStuff: "Lose 2 cards" },
            { type: "beast", name: "Celestial Chimera", strength: 7, levelReward: 2, treasureReward: 2, badStuff: "Lose 1 divine rank" },
            { type: "demigod", name: "Lesser Deity", strength: 10, levelReward: 3, treasureReward: 3, badStuff: "Lose all items" },
            { type: "curse", name: "Divine Wrath", effect: "Lose 1 divine rank" },
            { type: "curse", name: "Cosmic Bane", effect: "Lose 1 level" }
        ];
        const treasureDeck = [
            { type: "relic", name: "Godblade", bonus: 2 },
            { type: "relic", name: "Aether Shield", bonus: 2 },
            { type: "blessing", name: "Divine Boon", bonus: 3, oneShot: true },
            { type: "blessing", name: "Heavenly Favor", bonus: 4, oneShot: true },
            { type: "pantheon", name: "Olympian", effect: pantheons[0] },
            { type: "pantheon", name: "Norse", effect: pantheons[1] },
            { type: "pantheon", name: "Egyptian", effect: pantheons[2] }
        ];

        // Game State
        let gameLog = [];
        let currentBeast = null;
        let phase = "kick";
        let currentPlayerIndex = 0;
        let humanPlayerId = null;

        const players = [
            { id: 1, level: 1, divineRank: 0, strength: 1, pantheon: null, hand: [], equipped: [], model: createProceduralDeity(null), boundingBox: new THREE.Box3(), history: [], alive: true, position: new THREE.Vector3(-5, 1, 5) },
            { id: 2, level: 1, divineRank: 0, strength: 1, pantheon: null, hand: [], equipped: [], model: createProceduralDeity(null), boundingBox: new THREE.Box3(), history: [], alive: true, position: new THREE.Vector3(5, 1, 5) },
            { id: 3, level: 1, divineRank: 0, strength: 1, pantheon: null, hand: [], equipped: [], model: createProceduralDeity(null), boundingBox: new THREE.Box3(), history: [], alive: true, position: new THREE.Vector3(-5, 1, -5) },
            { id: 4, level: 1, divineRank: 0, strength: 1, pantheon: null, hand: [], equipped: [], model: createProceduralDeity(null), boundingBox: new THREE.Box3(), history: [], alive: true, position: new THREE.Vector3(5, 1, -5) }
        ];

        // Initialize Players
        players.forEach(player => {
            scene.add(player.model);
            player.model.position.copy(player.position);
            player.boundingBox.setFromCenterAndSize(player.position, new THREE.Vector3(1, 2, 1));
            for (let i = 0; i < 4; i++) {
                player.hand.push(doorDeck[Math.floor(Math.random() * doorDeck.length)]);
                player.hand.push(treasureDeck[Math.floor(Math.random() * treasureDeck.length)]);
            }
        });

        // UI Elements
        const statsDiv = document.getElementById("player-stats");
        const phaseDiv = document.getElementById("turn-phase");
        const cardsDiv = document.getElementById("cards");
        const logDiv = document.getElementById("log");
        const turnIndicator = document.getElementById("turn-indicator");
        const controlPanel = document.getElementById("control-panel");

        function updateUI() {
            statsDiv.innerHTML = players.map(p =>
                `Player ${p.id}${p.id === humanPlayerId ? " (You)" : ""}: Level ${p.level} | Strength ${p.strength} | Divine Rank ${p.divineRank} | Pantheon: ${p.pantheon || "None"} | ${p.alive ? "Alive" : "Dead"}`
            ).join("<br>");
            phaseDiv.innerText = `Phase: ${phase === "kick" ? "Kick Open Portal" : phase === "seek" ? "Seek Divinity/Loot" : "Charity"}`;
            turnIndicator.innerText = `Turn: Player ${players[currentPlayerIndex].id}${players[currentPlayerIndex].id === humanPlayerId ? " (You)" : ""}`;
            cardsDiv.innerHTML = "";
            if (humanPlayerId === players[currentPlayerIndex].id && phase === "seek") {
                players[currentPlayerIndex].hand.forEach((card, index) => {
                    const cardDiv = document.createElement("div");
                    cardDiv.className = "card";
                    cardDiv.innerText = `${card.name} (${card.type})`;
                    cardDiv.onclick = () => playCard(index);
                    cardsDiv.appendChild(cardDiv);
                });
            }
            logDiv.innerHTML = "Game Log:<br>" + gameLog.slice(-5).join("<br>");
            controlPanel.innerHTML = players.map(p =>
                `<button class="control-btn" onclick="takeControl(${p.id})" ${!p.alive || p.id === humanPlayerId ? "disabled" : ""}>Control Player ${p.id}</button>`
            ).join("");
        }

        function log(message) {
            gameLog.push(`Player ${players[currentPlayerIndex].id}: ${message}`);
            players[currentPlayerIndex].history.push(message);
            updateUI();
        }

        function takeControl(playerId) {
            if (players.find(p => p.id === playerId).alive) {
                humanPlayerId = playerId;
                log(`You took control of Player ${playerId}`);
            }
            updateUI();
        }

        function playCard(index) {
            if (phase !== "seek" || humanPlayerId !== players[currentPlayerIndex].id) return;
            const player = players[currentPlayerIndex];
            const card = player.hand[index];
            if (card.type === "beast" || card.type === "demigod") {
                if (!currentBeast && (player.level < 10 || card.type === "demigod")) {
                    log(`Played: ${card.name}`);
                    currentBeast = card;
                    currentBeast.model = createProceduralBeast(card.type === "demigod");
                    currentBeast.boundingBox = new THREE.Box3().setFromCenterAndSize(
                        new THREE.Vector3(5, 1, -5), new THREE.Vector3(2, 2, 2)
                    );
                    scene.add(currentBeast.model);
                    player.hand.splice(index, 1);
                    moveTowardBeast(player);
                }
            } else if (card.type === "relic" || card.type === "blessing") {
                player.equipped.push(card);
                player.strength += card.bonus;
                log(`Equipped: ${card.name} (+${card.bonus} strength)`);
                const effect = createEffectAnimation("blessing");
                effect.position.copy(player.model.position);
                scene.add(effect);
                setTimeout(() => scene.remove(effect), 1000);
                player.hand.splice(index, 1);
                if (card.oneShot) player.equipped = player.equipped.filter(item => item !== card);
                updatePlayerModel(player);
            } else if (card.type === "pantheon" && !player.pantheon) {
                player.pantheon = card.effect.name;
                player.divineRank += 2;
                player.strength += card.effect.bonus.strength || 0;
                log(`Joined pantheon: ${card.effect.name}`);
                const effect = createEffectAnimation("blessing");
                effect.position.copy(player.model.position);
                scene.add(effect);
                setTimeout(() => scene.remove(effect), 1000);
                player.hand.splice(index, 1);
                updatePlayerModel(player);
            }
            updateUI();
        }

        function aiPlayCard(player) {
            if (!player.hand.length) return;
            const cardIndex = Math.floor(Math.random() * player.hand.length);
            const card = player.hand[cardIndex];
            if (card.type === "beast" || card.type === "demigod") {
                if (!currentBeast && (player.level < 10 || card.type === "demigod")) {
                    log(`Played: ${card.name}`);
                    currentBeast = card;
                    currentBeast.model = createProceduralBeast(card.type === "demigod");
                    currentBeast.boundingBox = new THREE.Box3().setFromCenterAndSize(
                        new THREE.Vector3(5, 1, -5), new THREE.Vector3(2, 2, 2)
                    );
                    scene.add(currentBeast.model);
                    player.hand.splice(cardIndex, 1);
                    moveTowardBeast(player);
                }
            } else if (card.type === "relic" || card.type === "blessing") {
                player.equipped.push(card);
                player.strength += card.bonus;
                log(`Equipped: ${card.name} (+${card.bonus} strength)`);
                const effect = createEffectAnimation("blessing");
                effect.position.copy(player.model.position);
                scene.add(effect);
                setTimeout(() => scene.remove(effect), 1000);
                player.hand.splice(cardIndex, 1);
                if (card.oneShot) player.equipped = player.equipped.filter(item => item !== card);
                updatePlayerModel(player);
            } else if (card.type === "pantheon" && !player.pantheon) {
                player.pantheon = card.effect.name;
                player.divineRank += 2;
                player.strength += card.effect.bonus.strength || 0;
                log(`Joined pantheon: ${card.effect.name}`);
                const effect = createEffectAnimation("blessing");
                effect.position.copy(player.model.position);
                scene.add(effect);
                setTimeout(() => scene.remove(effect), 1000);
                player.hand.splice(cardIndex, 1);
                updatePlayerModel(player);
            }
        }

        function updatePlayerModel(player) {
            scene.remove(player.model);
            player.model = createProceduralDeity(player.pantheon);
            player.model.position.copy(player.position);
            scene.add(player.model);
        }

        function moveTowardBeast(player) {
            const target = currentBeast ? currentBeast.model.position : new THREE.Vector3(0, 1, 0);
            const direction = target.clone().sub(player.position).normalize().multiplyScalar(0.1);
            player.position.add(direction);
            player.model.position.copy(player.position);
            player.boundingBox.setFromCenterAndSize(player.position, new THREE.Vector3(1, 2, 1));
            markExploredArea(player.position);
            player.model.children.forEach(child => {
                if (child.geometry.type === "BoxGeometry" || child.geometry.type === "CylinderGeometry") {
                    child.rotation.z = Math.sin(Date.now() * 0.005) * 0.5 + Math.PI / 4;
                }
            });
        }

        function kickOpenPortal(player) {
            if (!player.alive) return;
            const card = doorDeck[Math.floor(Math.random() * doorDeck.length)];
            log(`Kicked open portal: ${card.name}`);
            if (card.type === "beast" || (card.type === "demigod" && player.level >= 9)) {
                currentBeast = card;
                currentBeast.model = createProceduralBeast(card.type === "demigod");
                currentBeast.boundingBox = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(5, 1, -5), new THREE.Vector3(2, 2, 2)
                );
                scene.add(currentBeast.model);
                moveTowardBeast(player);
            } else if (card.type === "curse") {
                applyCurse(player, card);
                phase = "seek";
            }
            updateUI();
        }

        function combat(player, beast) {
            if (!player.alive) return false;
            let totalStrength = player.level + player.equipped.reduce((sum, item) => sum + (item.bonus || 0), 0);
            if (player.divineRank >= 3) totalStrength += 5;
            if (player.pantheon === "Egyptian" && beast.type === "demigod") totalStrength += 3;
            log(`Combat: Player ${player.id} (${totalStrength}) vs ${beast.name} (${beast.strength})`);
            const effect = createEffectAnimation("combat");
            effect.position.copy(player.model.position);
            scene.add(effect);
            setTimeout(() => scene.remove(effect), 1000);
            if (totalStrength > beast.strength) {
                const extraLevel = player.pantheon === "Norse" ? 1 : 0;
                log(`Victory! Gained ${beast.levelReward + extraLevel} level(s) and ${beast.treasureReward} treasure(s)`);
                player.level += beast.levelReward + extraLevel;
                player.divineRank += 1;
                for (let i = 0; i < beast.treasureReward; i++) {
                    player.hand.push(treasureDeck[Math.floor(Math.random() * treasureDeck.length)]);
                }
                scene.remove(beast.model);
                currentBeast = null;
                phase = "charity";
                if (player.level >= 10 && beast.type === "demigod") {
                    log(`Player ${player.id} ascended to Godhood!`);
                    return true;
                }
            } else {
                log(`Defeat! Flee or face: ${beast.badStuff}`);
                flee(player);
            }
            updateUI();
            return false;
        }

        function flee(player) {
            if (!player.alive) return;
            const roll = (player.pantheon === "Olympian" && player.divineRank >= 3) ? 6 : Math.floor(Math.random() * 6) + 1;
            log(`Flee roll: ${roll}`);
            if (roll >= 5) {
                log("Escaped!");
                scene.remove(currentBeast.model);
                currentBeast = null;
                phase = "charity";
                player.position.set(-5, 1, player.id * 2 - 5);
                player.model.position.copy(player.position);
            } else {
                log(`Failed to flee: ${currentBeast.badStuff}`);
                if (currentBeast.badStuff.includes("Lose 1 level")) player.level = Math.max(1, player.level - 1);
                if (currentBeast.badStuff.includes("Lose 2 cards")) player.hand.splice(0, Math.min(2, player.hand.length));
                if (currentBeast.badStuff.includes("Lose all items")) {
                    player.equipped = [];
                    player.strength = player.level;
                    updatePlayerModel(player);
                }
                if (currentBeast.badStuff.includes("Lose 1 divine rank")) player.divineRank = Math.max(0, player.divineRank - 1);
                if (currentBeast.badStuff === "Lose all items") {
                    player.alive = false;
                    scene.remove(player.model);
                    log(`Player ${player.id} died!`);
                    if (player.id === humanPlayerId) humanPlayerId = null;
                }
                scene.remove(currentBeast.model);
                currentBeast = null;
                phase = "charity";
                player.position.set(-5, 1, player.id * 2 - 5);
                player.model.position.copy(player.position);
            }
            updateUI();
        }

        function applyCurse(player, card) {
            if (!player.alive) return;
            if (card.effect.includes("Lose 1 divine rank")) {
                player.divineRank = Math.max(0, player.divineRank - 1);
                log(`Curse applied: ${card.effect}`);
            } else if (card.effect.includes("Lose 1 level")) {
                player.level = Math.max(1, player.level - 1);
                log(`Curse applied: ${card.effect}`);
            }
            updateUI();
        }

        function lootTheRealm(player) {
            if (!player.alive) return;
            if (phase === "seek" && !currentBeast) {
                const card = doorDeck[Math.floor(Math.random() * doorDeck.length)];
                player.hand.push(card);
                log(`Looted: ${card.name}`);
                const treasure = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.5, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0xFFD700 })
                );
                treasure.position.set((Math.random() - 0.5) * 20, 0.5, (Math.random() - 0.5) * 20);
                scene.add(treasure);
                setTimeout(() => scene.remove(treasure), 2000);
                phase = "charity";
                updateUI();
            }
        }

        function charity(player) {
            if (!player.alive) return;
            if (player.hand.length > 5) {
                const lowestOpponent = players.filter(p => p.alive).reduce((min, p) => p.level < min.level ? p : min, players.find(p => p.alive));
                const card = player.hand.shift();
                log(`Gave ${card.name} to Player ${lowestOpponent.id} (Level ${lowestOpponent.level})`);
                lowestOpponent.level += 1;
            }
            phase = "kick";
            updateUI();
        }

        function checkCollision(player) {
            if (!player.alive) return false;
            if (currentBeast && player.boundingBox.intersectsBox(currentBeast.boundingBox)) {
                if (combat(player, currentBeast)) {
                    return true;
                }
            }
            return false;
        }

        // Animation and Game Loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.05;
            players.forEach(player => {
                if (!player.alive) return;
                if (currentBeast && currentPlayerIndex === player.id - 1) {
                    moveTowardBeast(player);
                    player.model.rotation.y += 0.03;
                    player.model.position.y = 1 + Math.sin(time + player.id) * 0.1;
                }
                player.model.position.x = Math.max(-20, Math.min(20, player.model.position.x));
                player.model.position.z = Math.max(-20, Math.min(20, player.model.position.z));
                player.boundingBox.setFromCenterAndSize(player.model.position, new THREE.Vector3(1, 2, 1));
            });
            if (currentBeast) {
                currentBeast.model.rotation.y += 0.03;
                currentBeast.model.position.y = 1 + Math.sin(time) * 0.2;
            }
            renderer.render(scene, camera);
        }
        camera.position.set(0, 10, 20);
        camera.lookAt(0, 0, 0);
        animate();

        function gameLoop() {
            const player = players[currentPlayerIndex];
            if (!player.alive) {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                phase = "kick";
                updateUI();
                setTimeout(gameLoop, 1000);
                return;
            }
            if (player.level >= 10 && !currentBeast) {
                const demigodCard = doorDeck.find(card => card.type === "demigod");
                currentBeast = demigodCard;
                currentBeast.model = createProceduralBeast(true);
                currentBeast.boundingBox = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(5, 1, -5), new THREE.Vector3(2, 2, 2)
                );
                scene.add(currentBeast.model);
                log(`Final challenge: Lesser Deity!`);
                moveTowardBeast(player);
                updateUI();
            }
            if (checkCollision(player)) {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                phase = "kick";
                updateUI();
                setTimeout(gameLoop, 1000);
                return;
            }
            if (phase === "kick") {
                kickOpenPortal(player);
            } else if (phase === "seek") {
                if (player.id === humanPlayerId) {
                    lootTheRealm(player);
                } else {
                    aiPlayCard(player);
                    lootTheRealm(player);
                }
            } else if (phase === "charity") {
                charity(player);
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                phase = "kick";
            }
            updateUI();
            setTimeout(gameLoop, 2000);
        }

        // Start Game
        updateUI();
        gameLoop();

        // Handle window resize
        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
