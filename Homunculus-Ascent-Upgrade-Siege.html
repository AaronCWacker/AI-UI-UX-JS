<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>HOMUNCULUS ASCENT â€” Upgrade Siege</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800;900&family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#050814;--panel:rgba(10,16,32,.82);--panel2:rgba(16,24,48,.9);--line:rgba(255,255,255,.10);
  --text:#eef4ff;--muted:#9db0cf;--mint:#33ffbb;--cyan:#44ddff;--violet:#c79dff;--rose:#ff6f91;--gold:#ffd35e;--amber:#ffad63;
}
*{box-sizing:border-box} html,body{margin:0;height:100%;overflow:hidden;background:radial-gradient(circle at top,#17274f 0%,#08101f 38%,#04070f 100%);color:var(--text);font-family:Inter,system-ui,sans-serif}
body{display:grid;grid-template-rows:auto 1fr auto} button{font:inherit}
#topbar,#footer{padding:10px 14px;background:rgba(255,255,255,.03);border-bottom:1px solid var(--line)}
#footer{border-top:1px solid var(--line);border-bottom:0;display:flex;justify-content:space-between;gap:12px;color:var(--muted);font-size:.78rem}
#topbar{display:flex;justify-content:space-between;align-items:center;gap:12px}
.title{font-family:Orbitron,sans-serif;font-weight:900;letter-spacing:.12em;font-size:1rem;background:linear-gradient(135deg,var(--mint),var(--cyan),var(--violet));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.subtitle{font-size:.74rem;color:var(--muted);margin-top:2px}
#app{display:grid;grid-template-columns:330px 1fr 330px;gap:12px;padding:12px;height:100%}
.panel{background:var(--panel);border:1px solid var(--line);border-radius:18px;backdrop-filter:blur(12px);box-shadow:0 16px 40px rgba(0,0,0,.28)}
.left,.right{padding:12px;overflow:auto}.center{display:grid;grid-template-rows:auto 1fr auto auto;gap:10px;padding:12px;overflow:hidden}
.banner{display:flex;justify-content:space-between;gap:10px;padding:12px;border:1px solid var(--line);border-radius:16px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03))}
.bannerTitle{font-family:Orbitron,sans-serif;font-size:.82rem;letter-spacing:.12em;color:var(--gold)} .bannerText{font-size:.78rem;color:var(--muted);line-height:1.45;margin-top:4px}
.livePill{align-self:flex-start;padding:6px 10px;border-radius:999px;border:1px solid rgba(51,255,187,.35);background:rgba(51,255,187,.08);color:var(--mint);font-size:.72rem;font-family:JetBrains Mono,monospace}
#arenaWrap{position:relative;overflow:hidden;border:1px solid var(--line);border-radius:18px;background:radial-gradient(circle at 50% 20%,rgba(68,221,255,.08),rgba(0,0,0,0) 35%),linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02))}
canvas{display:block;width:100%;height:100%}
#hud{display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center;padding:10px 12px;border:1px solid var(--line);border-radius:16px;background:var(--panel2)}
.hudBox{display:flex;gap:8px;flex-wrap:wrap;align-items:center}.badge{padding:6px 9px;border-radius:999px;background:rgba(255,255,255,.05);border:1px solid var(--line);font-size:.72rem;color:var(--muted)} .badge strong{color:var(--text)}
.turn{justify-self:center;padding:8px 12px;border-radius:999px;border:1px solid rgba(255,211,94,.38);background:rgba(255,211,94,.08);font-family:Orbitron,sans-serif;font-size:.76rem;letter-spacing:.1em;color:var(--gold)}
.queueBar,.controls{padding:10px 12px;border:1px solid var(--line);border-radius:16px;background:var(--panel2)}
.queueBar{display:grid;grid-template-columns:auto 1fr auto;gap:10px;align-items:center}.queueLabel{font-family:Orbitron,sans-serif;font-size:.74rem;letter-spacing:.11em;color:var(--gold)}
.queueTrack{display:flex;gap:8px;overflow:auto;padding:2px}.queueCard{min-width:124px;padding:8px 10px;border-radius:12px;border:1px solid var(--line);background:rgba(255,255,255,.05);cursor:pointer;transition:.16s transform,.16s border-color}.queueCard:hover{transform:translateY(-1px)}.queueCard.active{border-color:rgba(255,211,94,.42)}.queueCard .qcName{font-weight:900;font-size:.8rem;color:var(--text)}.queueCard .qcMeta{font-size:.68rem;color:var(--muted);margin-top:4px}.queueCard .qcType{font-family:JetBrains Mono,monospace;font-size:.65rem}
.controls{display:flex;gap:8px;align-items:center;justify-content:space-between}.btn{padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:rgba(255,255,255,.05);color:var(--text);font-weight:800;cursor:pointer;transition:.16s transform,.16s border-color,.16s background}.btn:hover{transform:translateY(-1px)}.btn.primary{border-color:rgba(51,255,187,.42);background:rgba(51,255,187,.10);color:var(--mint)}.btn.gold{border-color:rgba(255,211,94,.42);background:rgba(255,211,94,.10);color:var(--gold)}.btn.rose{border-color:rgba(255,111,145,.42);background:rgba(255,111,145,.10);color:var(--rose)}.btn:disabled{opacity:.38;cursor:not-allowed;transform:none}
.sectionTitle{margin:0 0 10px;font-family:Orbitron,sans-serif;font-size:.82rem;letter-spacing:.1em;color:var(--gold)}
.tip,.cardItem,.logLine,.slotItem,.enemyItem{padding:10px;border-radius:12px;border:1px solid var(--line);background:rgba(255,255,255,.04);font-size:.76rem;color:var(--muted);line-height:1.45}
.tipList,.cardList,.slotList,.enemyList,.log{display:grid;gap:8px}.log{max-height:320px;overflow:auto}
.cardItem,.slotItem,.enemyItem{cursor:pointer;transition:.16s transform,.16s border-color,.16s box-shadow}.cardItem:hover,.slotItem:hover,.enemyItem:hover{transform:translateY(-1px)}
.cardItem.ready{border-color:rgba(68,221,255,.42);box-shadow:0 0 0 1px rgba(68,221,255,.16)} .cardItem.used{opacity:.42;filter:grayscale(.8);pointer-events:none}
.slotItem.targeted{border-color:rgba(68,221,255,.58);box-shadow:0 0 0 1px rgba(68,221,255,.22),0 0 26px rgba(68,221,255,.14)} .slotItem.broken{opacity:.45;filter:grayscale(.8)}
.enemyItem.targeted{border-color:rgba(255,111,145,.58);box-shadow:0 0 0 1px rgba(255,111,145,.22),0 0 26px rgba(255,111,145,.14)} .enemyItem.dead{opacity:.35;filter:grayscale(.85);pointer-events:none}
.cardHead,.slotHead,.enemyHead{display:flex;justify-content:space-between;gap:8px;margin-bottom:6px}.cardName,.slotName,.enemyName{font-weight:900;color:var(--text);font-size:.84rem}.cardType{font-family:JetBrains Mono,monospace;font-size:.68rem}
.hp{font-family:JetBrains Mono,monospace;font-size:.72rem;color:var(--cyan)} .bar{height:8px;border-radius:999px;background:rgba(255,255,255,.06);overflow:hidden;margin-top:8px}.fill{height:100%;border-radius:999px;background:linear-gradient(90deg,var(--rose),var(--amber))}
.small{font-size:.74rem;color:var(--muted)} .spot{padding:12px;border-radius:16px;border:1px solid var(--line);background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));margin-bottom:12px}.spotLabel{font-family:Orbitron,sans-serif;font-size:.68rem;letter-spacing:.12em;color:var(--cyan);margin-bottom:6px}.spotName{font-size:.96rem;font-weight:900;margin-bottom:6px}.spotText{font-size:.78rem;color:var(--muted);line-height:1.45}
.type-core{color:var(--gold)} .type-weapon{color:var(--rose)} .type-shield{color:var(--cyan)} .type-reactor{color:var(--mint)} .type-swarm{color:var(--violet)}
@media (max-width:1200px){#app{grid-template-columns:1fr;grid-template-rows:auto minmax(60vh,1fr) auto;height:auto;overflow:auto}body{overflow:auto}.center{min-height:70vh}}
</style>
</head>
<body>
  <div id="topbar">
    <div>
      <div class="title">HOMUNCULUS ASCENT â€” UPGRADE SIEGE</div>
      <div class="subtitle">Grow a living homunculus by socketing organs and body-part upgrade cards while robots and bosses attack. Chain explosions with bloom/HDR-style glow.</div>
    </div>
    <div class="livePill" id="modePill">BATTLE LAB ACTIVE</div>
  </div>

  <div id="app">
    <aside class="panel left">
      <h3 class="sectionTitle">ðŸ§  Loop</h3>
      <div class="tipList">
        <div class="tip"><strong>Auto-pilot still gathers.</strong> The ship harvests upgrade cards so movement stays painless.</div>
        <div class="tip"><strong>Pick a body slot.</strong> Click a body part or organ slot, then click gathered cards to queue upgrades into that slot.</div>
        <div class="tip"><strong>Resolve the queue.</strong> Upgrade missiles socket the homunculus, raising stats and unlocking weapon behavior.</div>
        <div class="tip"><strong>Fight back automatically.</strong> The upgraded homunculus fires at enemy robots and bosses. Explosions cascade into nearby enemies.</div>
      </div>
      <div class="spot" style="margin-top:14px">
        <div class="spotLabel">HOMUNCULUS BUILD</div>
        <div class="spotName">Cards Become Body Parts</div>
        <div class="spotText">Core, weapon, shield, reactor, and swarm cards permanently buff matching slots. Different slot types shape how the creature fights.</div>
      </div>
      <h3 class="sectionTitle">âš¡ Gathered Upgrade Cards</h3>
      <div class="cardList" id="powerList"></div>
    </aside>

    <main class="panel center">
      <div class="banner">
        <div>
          <div class="bannerTitle">AUTO GATHER + HOMUNCULUS UPGRADE SIEGE</div>
          <div class="bannerText">Queue upgrade cards onto body slots to evolve your creature while robot waves and bosses attack. Resolved upgrades immediately affect shields, weapon patterns, swarm count, reactor power, and core vitality.</div>
        </div>
        <div class="livePill" id="activityPill">BUILD PHASE</div>
      </div>

      <div id="arenaWrap"><canvas id="game" width="1360" height="800"></canvas></div>

      <div id="hud">
        <div class="hudBox">
          <div class="badge"><strong>Collected</strong> <span id="collectedCount">0</span></div>
          <div class="badge"><strong>Queue</strong> <span id="queueCount">0</span></div>
          <div class="badge"><strong>Level</strong> <span id="levelCount">1</span></div>
        </div>
        <div class="turn" id="statusText">BUILD PHASE</div>
        <div class="hudBox" style="justify-content:flex-end">
          <div class="badge"><strong>Target Slot</strong> <span id="targetName">none</span></div>
          <div class="badge"><strong>Boss</strong> <span id="bossHp">â€”</span></div>
          <div class="badge"><strong>Wave</strong> <span id="waveCount">1</span></div>
        </div>
      </div>

      <div class="queueBar">
        <div class="queueLabel">QUEUED UPGRADES</div>
        <div class="queueTrack" id="queueTrack"></div>
        <div class="small" id="queueHint">Select a slot, then click gathered cards to socket upgrades.</div>
      </div>

      <div class="controls">
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn primary" id="resolveBtn">â–¶ Resolve Upgrades</button>
          <button class="btn gold" id="burstBtn">ðŸ’¥ Chain Burst</button>
          <button class="btn rose" id="restartBtn">â†» Restart Siege</button>
        </div>
        <div class="small" id="hint">Queued upgrade cards will socket into the highlighted slot and immediately alter battle behavior.</div>
      </div>
    </main>

    <aside class="panel right">
      <div class="spot">
        <div class="spotLabel">LIVE ACTION</div>
        <div class="spotName" id="actionTitle">Waiting for slot lock</div>
        <div class="spotText" id="actionText">Choose a body slot to arm the upgrade queue. Enemies and bosses will keep attacking while you evolve.</div>
      </div>
      <h3 class="sectionTitle">ðŸ§¬ Homunculus Slots</h3>
      <div class="slotList" id="slotList"></div>
      <h3 class="sectionTitle" style="margin-top:12px">ðŸ¤– Enemies</h3>
      <div class="enemyList" id="enemyList"></div>
      <h3 class="sectionTitle" style="margin-top:12px">ðŸ“œ Event Log</h3>
      <div class="log" id="log"></div>
    </aside>
  </div>

  <div id="footer">
    <div>Homunculus slot upgrades Â· auto combat Â· bosses Â· cascading chain explosions Â· bloom-style glow</div>
    <div>Low-friction gathering, high-drama evolution combat</div>
  </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const ui = {
  collectedCount: document.getElementById('collectedCount'),
  queueCount: document.getElementById('queueCount'),
  levelCount: document.getElementById('levelCount'),
  targetName: document.getElementById('targetName'),
  bossHp: document.getElementById('bossHp'),
  waveCount: document.getElementById('waveCount'),
  statusText: document.getElementById('statusText'),
  hint: document.getElementById('hint'),
  powerList: document.getElementById('powerList'),
  queueTrack: document.getElementById('queueTrack'),
  queueHint: document.getElementById('queueHint'),
  slotList: document.getElementById('slotList'),
  enemyList: document.getElementById('enemyList'),
  log: document.getElementById('log'),
  actionTitle: document.getElementById('actionTitle'),
  actionText: document.getElementById('actionText'),
  activityPill: document.getElementById('activityPill'),
  resolveBtn: document.getElementById('resolveBtn')
};

const CARD_TYPES = [
  { type:'Core', color:'#ffd35e', css:'type-core', desc:'Increases max vitality and level gain.', effect:'core', slotType:'core', power:2 },
  { type:'Weapon', color:'#ff6f91', css:'type-weapon', desc:'Adds attack damage and extra projectiles.', effect:'weapon', slotType:'weapon', power:2 },
  { type:'Shield', color:'#44ddff', css:'type-shield', desc:'Adds shielding and damage reduction.', effect:'shield', slotType:'shield', power:2 },
  { type:'Reactor', color:'#33ffbb', css:'type-reactor', desc:'Improves fire rate and energy bloom.', effect:'reactor', slotType:'reactor', power:2 },
  { type:'Swarm', color:'#c79dff', css:'type-swarm', desc:'Spawns orbiting drones and splash chains.', effect:'swarm', slotType:'swarm', power:2 }
];

const SLOT_LAYOUT = [
  { id:'head', name:'Brain Crown', type:'core', x:W*0.33, y:H*0.22, hp:14 },
  { id:'torso', name:'Thorax Core', type:'core', x:W*0.33, y:H*0.42, hp:18 },
  { id:'leftArm', name:'Left Weapon Limb', type:'weapon', x:W*0.22, y:H*0.42, hp:12 },
  { id:'rightArm', name:'Right Weapon Limb', type:'weapon', x:W*0.44, y:H*0.42, hp:12 },
  { id:'leftLeg', name:'Left Reactor Leg', type:'reactor', x:W*0.28, y:H*0.67, hp:12 },
  { id:'rightLeg', name:'Right Reactor Leg', type:'reactor', x:W*0.38, y:H*0.67, hp:12 },
  { id:'heart', name:'Shield Heart', type:'shield', x:W*0.33, y:H*0.52, hp:15 },
  { id:'halo', name:'Swarm Halo', type:'swarm', x:W*0.33, y:H*0.10, hp:10 }
];

const state = {
  time: 0,
  combo: 0,
  totalCollected: 0,
  level: 1,
  xp: 0,
  nextXp: 18,
  wave: 1,
  cards: [],
  haloCards: [],
  powers: [],
  queue: [],
  slots: [],
  targetSlotId: null,
  enemies: [],
  bossId: null,
  particles: [],
  trails: [],
  missiles: [],
  playerProjectiles: [],
  enemyProjectiles: [],
  resolving: false,
  homunculus: { x:W*0.33, y:H*0.42, hp:100, maxHp:100, shield:0, fireRate:1, weapon:1, swarm:0 },
  ship: { x:W*0.15, y:H*0.55, vx:0, vy:0, angle:0, targetX:W*0.15, targetY:H*0.55, baseOrbit:78 },
  fireCooldown: 0,
  effects: { burstFlashUntil:0 }
};

function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(bx-ax,by-ay); }
function lerp(a,b,t){ return a+(b-a)*t; }
function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay,bx-ax); }

function log(msg){ const line=document.createElement('div'); line.className='logLine'; line.innerHTML=msg; ui.log.prepend(line); while(ui.log.children.length>30) ui.log.removeChild(ui.log.lastChild); }
function setAction(title,text){ ui.actionTitle.textContent=title; ui.actionText.textContent=text; }

function initSlots(){
  state.slots = SLOT_LAYOUT.map(s => ({ ...s, maxHp:s.hp, hp:s.hp, level:1, alive:true, installed:[] }));
  state.targetSlotId = state.slots[0].id;
  recomputeHomunculus();
}

function spawnCard(edgeBias=true){
  const meta = CARD_TYPES[Math.floor(Math.random()*CARD_TYPES.length)];
  let x = rand(30, W*0.55), y = rand(30, H-30);
  if (edgeBias) { const side=Math.floor(Math.random()*4); if(side===0){x=rand(30,W*0.55);y=30;} if(side===1){x=W*0.55;y=rand(30,H-30);} if(side===2){x=rand(30,W*0.55);y=H-30;} if(side===3){x=30;y=rand(30,H-30);} }
  const a=rand(0,Math.PI*2);
  state.cards.push({ id:(crypto.randomUUID?crypto.randomUUID():Math.random().toString(36).slice(2)), x,y, vx:Math.cos(a)*rand(.4,1.1), vy:Math.sin(a)*rand(.4,1.1), type:meta.type, css:meta.css, color:meta.color, desc:meta.desc, effect:meta.effect, slotType:meta.slotType, power:meta.power, collected:false, phase:rand(0,Math.PI*2) });
}

function spawnEnemy(boss=false){
  const ex = rand(W*0.60, W-80), ey = rand(80, H-80);
  const hp = boss ? 46 + state.wave*8 : 8 + state.wave*2;
  const enemy = { id:(crypto.randomUUID?crypto.randomUUID():Math.random().toString(36).slice(2)), x:ex, y:ey, vx: boss ? -18 : -26-rand(0,12), vy: rand(-12,12), hp, maxHp:hp, r: boss ? 34 : 18, boss, shotTimer: rand(.5,1.6), dead:false };
  state.enemies.push(enemy);
  if (boss) state.bossId = enemy.id;
}

function seedBattle(){
  state.cards=[]; state.haloCards=[]; state.powers=[]; state.queue=[]; state.enemies=[]; state.particles=[]; state.trails=[]; state.missiles=[]; state.playerProjectiles=[]; state.enemyProjectiles=[];
  state.combo=0; state.totalCollected=0; state.level=1; state.xp=0; state.nextXp=18; state.wave=1; state.resolving=false; state.bossId=null; state.fireCooldown=0;
  state.ship.x=W*0.15; state.ship.y=H*0.55; state.ship.vx=0; state.ship.vy=0; state.homunculus.hp=100; state.homunculus.maxHp=100; state.homunculus.shield=0; state.homunculus.fireRate=1; state.homunculus.weapon=1; state.homunculus.swarm=0;
  initSlots();
  for(let i=0;i<28;i++) spawnCard(true);
  for(let i=0;i<6;i++) spawnEnemy(false);
  renderPowerList(); renderQueue(); renderSlots(); renderEnemies(); updateUi();
  setAction('Waiting for slot lock','Choose a body slot to arm the upgrade queue. Enemies and bosses will keep attacking while you evolve.');
  log('ðŸ§ª <strong>Siege reset.</strong> Gather upgrade cards, socket them into the homunculus, and survive the assault.');
}

function recomputeHomunculus(){
  let maxHp=60, shield=0, fireRate=1, weapon=1, swarm=0;
  for (const slot of state.slots) {
    if (!slot.alive) continue;
    maxHp += slot.level * 5;
    if (slot.type==='core') maxHp += slot.level * 7;
    if (slot.type==='shield') shield += slot.level * 1.4;
    if (slot.type==='reactor') fireRate += slot.level * 0.12;
    if (slot.type==='weapon') weapon += slot.level * 0.45;
    if (slot.type==='swarm') swarm += slot.level - 1;
  }
  state.homunculus.maxHp = maxHp;
  state.homunculus.hp = Math.min(state.homunculus.hp, maxHp);
  state.homunculus.shield = shield;
  state.homunculus.fireRate = fireRate;
  state.homunculus.weapon = weapon;
  state.homunculus.swarm = Math.max(0, swarm);
}

function bestClusterTarget(){
  const loose = state.cards.filter(c=>!c.collected);
  if (!loose.length) return {x:W*0.15,y:H*0.55};
  let best=null;
  for (const card of loose){
    let score=0;
    for (const other of loose){ const d=dist(card.x,card.y,other.x,other.y); if(d<170) score += 1 - d/170; }
    const shipD=dist(state.ship.x,state.ship.y,card.x,card.y); score += clamp(1-shipD/560,0,1)*2;
    if(!best||score>best.score) best={x:card.x,y:card.y,score};
  }
  return best;
}

function collectCard(card, source='auto'){
  if(card.collected) return;
  card.collected=true; state.totalCollected += 1; state.combo += 1;
  state.powers.unshift({ id:card.id, name:`${card.type} Upgrade`, css:card.css, color:card.color, effect:card.effect, slotType:card.slotType, power:card.power, desc:card.desc, used:false });
  state.haloCards.push({ id:card.id, color:card.color, phase:rand(0,Math.PI*2) });
  for(let i=0;i<10;i++) state.particles.push({ x:card.x,y:card.y,vx:rand(-2.8,2.8),vy:rand(-2.8,2.8),life:rand(20,42),color:card.color,size:rand(1.8,3.6),glow:true });
  renderPowerList(); updateUi();
  log(`${source==='auto'?'âœ¨':'âš¡'} <strong>${card.type}</strong> upgrade card gathered.`);
}

function getTargetSlot(){ return state.slots.find(s=>s.id===state.targetSlotId); }
function getBoss(){ return state.enemies.find(e=>e.id===state.bossId && !e.dead) || null; }

function renderPowerList(){
  ui.powerList.innerHTML='';
  if(!state.powers.length){ const empty=document.createElement('div'); empty.className='tip'; empty.textContent='No gathered upgrade cards yet. Auto-pilot will fill this list as it harvests.'; ui.powerList.appendChild(empty); return; }
  state.powers.slice(0,14).forEach(power=>{
    const el=document.createElement('div'); el.className=`cardItem ${power.used?'used':'ready'}`;
    el.innerHTML=`<div class="cardHead"><div class="cardName">${power.name}</div><div class="cardType ${power.css}">${power.slotType.toUpperCase()}</div></div><div>${power.desc}</div>`;
    if(!power.used) el.addEventListener('click',()=>queueCard(power.id));
    ui.powerList.appendChild(el);
  });
}

function renderSlots(){
  ui.slotList.innerHTML='';
  state.slots.forEach(slot=>{
    const pct=Math.max(0,slot.hp/slot.maxHp)*100;
    const el=document.createElement('div'); el.className=`slotItem ${slot.id===state.targetSlotId?'targeted':''} ${slot.alive?'':'broken'}`;
    el.innerHTML=`<div class="slotHead"><div class="slotName">${slot.name}</div><div class="hp">${Math.max(0,Math.round(slot.hp))}/${slot.maxHp}</div></div><div>${slot.type.toUpperCase()} Â· Level ${slot.level}${slot.installed.length?` Â· ${slot.installed.length} mods`:''}</div><div class="bar"><div class="fill" style="width:${pct}%"></div></div>`;
    if(slot.alive) el.addEventListener('click',()=>{ state.targetSlotId=slot.id; renderSlots(); renderQueue(); updateUi(); setAction('Slot locked', `${slot.name} is ready for queued upgrades.`); });
    ui.slotList.appendChild(el);
  });
}

function renderEnemies(){
  ui.enemyList.innerHTML='';
  if(!state.enemies.length){ const empty=document.createElement('div'); empty.className='tip'; empty.textContent='No enemies alive.'; ui.enemyList.appendChild(empty); return; }
  state.enemies.forEach(enemy=>{
    const pct=Math.max(0,enemy.hp/enemy.maxHp)*100;
    const el=document.createElement('div'); el.className=`enemyItem ${enemy.boss?'targeted':''} ${enemy.dead?'dead':''}`;
    el.innerHTML=`<div class="enemyHead"><div class="enemyName">${enemy.boss?'Boss ':'Robot '}${enemy.id.slice(0,4)}</div><div class="hp">${Math.max(0,Math.round(enemy.hp))}/${enemy.maxHp}</div></div><div>${enemy.boss?'Heavy boss platform':'Assault robot'} Â· ${enemy.dead?'Destroyed':'Hostile'}</div><div class="bar"><div class="fill" style="width:${pct}%"></div></div>`;
    ui.enemyList.appendChild(el);
  });
}

function renderQueue(){
  ui.queueTrack.innerHTML='';
  if(!state.queue.length){ const empty=document.createElement('div'); empty.className='small'; empty.textContent='Queue is empty.'; ui.queueTrack.appendChild(empty); }
  else {
    state.queue.forEach((item,i)=>{
      const el=document.createElement('div'); el.className=`queueCard ${i===0?'active':''}`;
      el.innerHTML=`<div class="qcType ${item.css}">${item.slotType.toUpperCase()}</div><div class="qcName">${item.name}</div><div class="qcMeta">â†’ ${item.slotName} Â· +${item.power}</div>`;
      el.addEventListener('click',()=>removeQueued(item.id));
      ui.queueTrack.appendChild(el);
    });
  }
  const target=getTargetSlot(); ui.queueHint.textContent = target ? `Queued cards will socket into ${target.name}. Click a queued card to remove it.` : 'Select a living slot to arm the queue.';
}

function queueCard(id){
  if(state.resolving) return;
  const power=state.powers.find(p=>p.id===id && !p.used); const slot=getTargetSlot();
  if(!power || !slot || !slot.alive){ setAction('Need slot lock','Choose a living body slot before queueing upgrade cards.'); return; }
  power.used=true;
  state.queue.push({ id:power.id, name:power.name, css:power.css, color:power.color, slotType:power.slotType, effect:power.effect, slotId:slot.id, slotName:slot.name, power:power.power });
  renderPowerList(); renderQueue(); updateUi(); log(`ðŸ§· <strong>${power.name}</strong> queued for <strong>${slot.name}</strong>.`);
}

function removeQueued(id){
  if(state.resolving) return;
  const idx=state.queue.findIndex(q=>q.id===id); if(idx<0) return;
  const item=state.queue[idx]; state.queue.splice(idx,1);
  const power=state.powers.find(p=>p.id===id); if(power) power.used=false;
  renderPowerList(); renderQueue(); updateUi(); log(`â†© <strong>${item.name}</strong> removed from queue.`);
}

function updateUi(){
  ui.collectedCount.textContent = state.totalCollected;
  ui.queueCount.textContent = state.queue.length;
  ui.levelCount.textContent = state.level;
  const slot=getTargetSlot(); ui.targetName.textContent = slot ? slot.name : 'none';
  const boss=getBoss(); ui.bossHp.textContent = boss ? Math.max(0,Math.round(boss.hp)) : 'â€”'; ui.waveCount.textContent = state.wave;
  ui.statusText.textContent = state.resolving ? 'SOCKETING UPGRADES' : 'BUILD PHASE';
  ui.activityPill.textContent = state.resolving ? 'QUEUE FIRING' : 'BUILD PHASE';
  ui.resolveBtn.disabled = state.resolving || !state.queue.length || !slot || !slot.alive;
  renderEnemies();
}

function autopilot(dt){
  const target=bestClusterTarget(); const ship=state.ship;
  const dx=target.x-ship.x, dy=target.y-ship.y, d=Math.hypot(dx,dy)||1;
  const desiredSpeed=clamp(d*0.7,75,220);
  ship.vx=lerp(ship.vx, dx/d*desiredSpeed, 0.035); ship.vy=lerp(ship.vy, dy/d*desiredSpeed, 0.035);
  ship.x=clamp(ship.x+ship.vx*dt, 60, W*0.56); ship.y=clamp(ship.y+ship.vy*dt, 70, H-70); ship.angle=Math.atan2(ship.vy,ship.vx);
  for(const card of state.cards){
    if(card.collected) continue;
    card.phase += dt*2.2; card.x += card.vx; card.y += card.vy;
    if(card.x<22||card.x>W*0.56) card.vx*=-1; if(card.y<22||card.y>H-22) card.vy*=-1;
    const cd=dist(card.x,card.y,ship.x,ship.y); if(cd<210){ const pull=clamp(1-cd/210,0.04,0.16); card.vx += (ship.x-card.x)*pull*0.005; card.vy += (ship.y-card.y)*pull*0.005; }
    card.vx*=0.992; card.vy*=0.992; if(cd<110) collectCard(card,'auto');
  }
  if(state.cards.filter(c=>!c.collected).length<14) for(let i=0;i<2;i++) spawnCard(true);
}

function updateHalo(dt){
  const orbitR=state.ship.baseOrbit;
  for(let i=0;i<state.haloCards.length;i++){ const hc=state.haloCards[i]; hc.phase += dt*1.1; hc.x = state.ship.x + Math.cos(hc.phase+i*0.42)*(orbitR+(i%3)*9); hc.y = state.ship.y + Math.sin(hc.phase+i*0.42)*(orbitR*0.46+(i%2)*10); }
}

function addExplosion(x,y,color,count=26,spread=4.2){ for(let i=0;i<count;i++) state.particles.push({ x,y,vx:rand(-spread,spread),vy:rand(-spread,spread),life:rand(18,46),color,size:rand(2.2,5.8),glow:true }); }
function addBloomRing(x,y,color,base=18, rings=3){ for(let i=0;i<rings;i++) state.trails.push({ x,y,color,life:24+i*5, ring:true, radius:base+i*18 }); }
function addFog(x,y,color,count=18){ for(let i=0;i<count;i++) state.particles.push({ x,y,vx:rand(-1.5,1.5),vy:rand(-1.0,1.0),life:rand(28,56),color,size:rand(9,19),fog:true }); }

function spawnUpgradeMissile(item){
  const slot=state.slots.find(s=>s.id===item.slotId && s.alive); if(!slot) return false;
  state.missiles.push({ mode:'upgrade', x:state.ship.x, y:state.ship.y, tx:slot.x, ty:slot.y, color:item.color, item, progress:0 });
  return true;
}

function resolveQueue(){
  if(state.resolving || !state.queue.length) return;
  const slot=getTargetSlot(); if(!slot || !slot.alive) return;
  state.resolving=true; updateUi(); setAction('Socketing upgrades', `Launching ${state.queue.length} queued upgrade${state.queue.length===1?'':'s'} into ${slot.name}.`); log(`ðŸ§¬ <strong>Upgrade resolve.</strong> ${state.queue.length} queued upgrade${state.queue.length===1?'':'s'} launched into <strong>${slot.name}</strong>.`); fireNextQueued();
}

function fireNextQueued(){
  if(!state.queue.length){ state.resolving=false; updateUi(); renderQueue(); renderSlots(); setAction('Queue complete','Upgrade queue resolved. The homunculus has evolved.'); return; }
  const item=state.queue.shift(); renderQueue(); updateUi(); const ok=spawnUpgradeMissile(item); if(!ok){ setTimeout(fireNextQueued,120); return; } log(`ðŸš€ <strong>${item.name}</strong> launched toward <strong>${item.slotName}</strong>.`);
}

function applyUpgradeToSlot(slot,item){
  if(!slot.alive) return;
  slot.level += item.power;
  slot.installed.push(item.effect);
  slot.hp = Math.min(slot.maxHp + slot.level * 2, slot.hp + item.power * 2);
  slot.maxHp += item.power;
  if(item.effect==='core'){ state.homunculus.hp = Math.min(state.homunculus.maxHp + 8, state.homunculus.hp + 8); state.xp += 2; }
  addExplosion(slot.x,slot.y,item.color,18,3.0); addBloomRing(slot.x,slot.y,item.color,16,3); addFog(slot.x,slot.y,item.color,10);
  recomputeHomunculus(); renderSlots(); updateUi();
  log(`ðŸ”§ <strong>${slot.name}</strong> absorbed ${item.name} and rose to level ${slot.level}.`);
}

function gainXp(amount){
  state.xp += amount;
  while(state.xp >= state.nextXp){ state.xp -= state.nextXp; state.level += 1; state.nextXp = Math.round(state.nextXp * 1.36); state.homunculus.hp = Math.min(state.homunculus.maxHp, state.homunculus.hp + 8); log(`ðŸ†™ <strong>Level ${state.level}</strong> reached. Fire cadence and durability improved.`); }
}

function spawnPlayerProjectile(angle, speed, damage, color, splash=0){ state.playerProjectiles.push({ x:state.homunculus.x, y:state.homunculus.y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, damage, color, life:2.1, splash, width:3+splash }); }
function spawnEnemyProjectile(enemy, angle, speed, damage){ state.enemyProjectiles.push({ x:enemy.x, y:enemy.y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, damage, color:'#ff6f91', life:2.8, width:4 }); }

function fireHomunculus(dt){
  state.fireCooldown -= dt;
  const alive = state.enemies.filter(e=>!e.dead);
  if(!alive.length || state.fireCooldown > 0) return;
  const target = alive.reduce((best,e)=>!best||dist(state.homunculus.x,state.homunculus.y,e.x,e.y)<dist(state.homunculus.x,state.homunculus.y,best.x,best.y)?e:best,null);
  if(!target) return;
  const base = angleTo(state.homunculus.x,state.homunculus.y,target.x,target.y);
  const shots = Math.max(1, Math.round(state.homunculus.weapon));
  for(let i=0;i<shots;i++){ const off=(i-(shots-1)/2)*0.16; spawnPlayerProjectile(base+off, 360+state.level*18, 4+state.homunculus.weapon*1.3, '#ffd35e', state.homunculus.swarm>0?1:0); }
  for(let i=0;i<state.homunculus.swarm;i++){ const off = (i+1)*0.42; spawnPlayerProjectile(base+Math.sin(state.time*2+off)*0.35, 300, 2.4, '#c79dff', 1); }
  state.fireCooldown = Math.max(0.08, 0.42 / state.homunculus.fireRate);
}

function damageEnemy(enemy, damage, color, splashRadius=0){
  if(!enemy || enemy.dead) return;
  enemy.hp -= damage; addExplosion(enemy.x,enemy.y,color,18,3.2); addBloomRing(enemy.x,enemy.y,color,14,2);
  if(enemy.hp <= 0){ enemy.dead=true; addExplosion(enemy.x,enemy.y,'#ffffff',36,5.6); addFog(enemy.x,enemy.y,color,20); gainXp(enemy.boss?10:4); log(`${enemy.boss?'ðŸ‘¹ <strong>Boss destroyed.</strong>':'ðŸ’¥ <strong>Robot destroyed.</strong>'}`); if(enemy.boss) state.bossId=null; cascadeExplosion(enemy.x,enemy.y, enemy.boss?110:80, enemy.boss?9:5, color); }
  if(splashRadius>0) cascadeExplosion(enemy.x, enemy.y, 60+splashRadius*24, 2+splashRadius, color, enemy.id);
}

function cascadeExplosion(x,y,radius,damage,color,excludeId=null){
  for(const enemy of state.enemies){ if(enemy.dead || enemy.id===excludeId) continue; const d=dist(x,y,enemy.x,enemy.y); if(d<radius){ const scale = 1 - d / radius; enemy.hp -= damage * scale; addBloomRing(enemy.x,enemy.y,color,10+scale*10,2); if(enemy.hp<=0){ enemy.dead=true; addExplosion(enemy.x,enemy.y,color,28,4.8); } } }
}

function updateEnemies(dt){
  const live = state.enemies.filter(e=>!e.dead);
  if(!live.length){ state.wave += 1; for(let i=0;i<5+Math.min(4,state.wave);i++) spawnEnemy(false); if(state.wave % 3 === 0) spawnEnemy(true); log(`ðŸ›¸ <strong>Wave ${state.wave}</strong> entering${state.wave%3===0?' with boss support':''}.`); }
  for(const enemy of state.enemies){
    if(enemy.dead) continue;
    enemy.x += enemy.vx * dt; enemy.y += enemy.vy * dt; if(enemy.y<70||enemy.y>H-70) enemy.vy *= -1;
    enemy.shotTimer -= dt;
    if(enemy.shotTimer <= 0){ spawnEnemyProjectile(enemy, angleTo(enemy.x,enemy.y,state.homunculus.x,state.homunculus.y), enemy.boss?220:200, enemy.boss?9:6); if(enemy.boss) [-0.18,0.18].forEach(off=>spawnEnemyProjectile(enemy, angleTo(enemy.x,enemy.y,state.homunculus.x,state.homunculus.y)+off, 200, 6)); enemy.shotTimer = enemy.boss ? 0.9 : rand(1.0,2.1); }
    if(enemy.x < W*0.44){ const slot = state.slots.filter(s=>s.alive).sort((a,b)=>dist(enemy.x,enemy.y,a.x,a.y)-dist(enemy.x,enemy.y,b.x,b.y))[0]; if(slot){ slot.hp -= enemy.boss ? 8 : 4; addExplosion(slot.x,slot.y,'#ff6f91',16,2.8); if(slot.hp<=0){ slot.hp=0; slot.alive=false; log(`ðŸ©¸ <strong>${slot.name}</strong> has been broken.`); recomputeHomunculus(); renderSlots(); } } enemy.dead=true; }
  }
}

function updateProjectiles(dt){
  for(let i=state.playerProjectiles.length-1;i>=0;i--){ const p=state.playerProjectiles[i]; p.x += p.vx*dt; p.y += p.vy*dt; p.life -= dt; state.trails.push({ x:p.x,y:p.y,tx:p.x-p.vx*0.02,ty:p.y-p.vy*0.02,color:p.color,life:16, beam:true, width:p.width }); let hit=false; for(const enemy of state.enemies){ if(enemy.dead) continue; if(dist(p.x,p.y,enemy.x,enemy.y) < enemy.r + 8){ damageEnemy(enemy,p.damage,p.color,p.splash); hit=true; break; } } if(hit || p.life<=0 || p.x<0 || p.x>W || p.y<0 || p.y>H) state.playerProjectiles.splice(i,1); }
  for(let i=state.enemyProjectiles.length-1;i>=0;i--){ const p=state.enemyProjectiles[i]; p.x += p.vx*dt; p.y += p.vy*dt; p.life -= dt; state.trails.push({ x:p.x,y:p.y,tx:p.x-p.vx*0.02,ty:p.y-p.vy*0.02,color:p.color,life:14, beam:true, width:p.width }); if(dist(p.x,p.y,state.homunculus.x,state.homunculus.y) < 28){ const dmg=Math.max(1,p.damage - state.homunculus.shield*0.25); state.homunculus.hp -= dmg; addExplosion(state.homunculus.x,state.homunculus.y,'#44ddff',14,2.2); if(state.homunculus.hp<=0){ state.homunculus.hp=state.homunculus.maxHp; initSlots(); log('ðŸ› ï¸ <strong>Homunculus rebuilt.</strong> Core reconstituted after collapse.'); } state.enemyProjectiles.splice(i,1); continue; } if(p.life<=0 || p.x<0 || p.x>W || p.y<0 || p.y>H) state.enemyProjectiles.splice(i,1); }
}

function updateMissiles(dt){
  for(let i=state.missiles.length-1;i>=0;i--){ const m=state.missiles[i]; const slot=state.slots.find(s=>s.id===m.item.slotId); if(!slot || !slot.alive){ state.missiles.splice(i,1); setTimeout(fireNextQueued,90); continue; } m.tx=slot.x; m.ty=slot.y; const dx=m.tx-m.x, dy=m.ty-m.y, d=Math.hypot(dx,dy)||1; const speed=520; m.x += dx/d*speed*dt; m.y += dy/d*speed*dt; state.trails.push({ x:m.x,y:m.y,tx:m.x-dx/d*20,ty:m.y-dy/d*20,color:m.color,life:16, beam:true, width:4 }); if(d<16){ applyUpgradeToSlot(slot,m.item); state.missiles.splice(i,1); setTimeout(fireNextQueued,170); } }
}

function updateParticles(){ for(let i=state.particles.length-1;i>=0;i--){ const p=state.particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 1; p.vx *= .986; p.vy *= .986; if(p.life<=0) state.particles.splice(i,1); } }
function updateTrails(){ for(let i=state.trails.length-1;i>=0;i--){ const t=state.trails[i]; t.life -= 1; if(t.life<=0) state.trails.splice(i,1); } }

function drawBackground(){ ctx.clearRect(0,0,W,H); const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0a1326'); g.addColorStop(1,'#050913'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); ctx.strokeStyle='rgba(68,221,255,0.08)'; ctx.lineWidth=1; for(let x=0;x<W*0.58;x+=60){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); } for(let y=0;y<H;y+=60){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W*0.58,y); ctx.stroke(); } ctx.fillStyle='rgba(255,255,255,0.04)'; ctx.fillRect(W*0.60,40,2,H-80); if(state.effects.burstFlashUntil > state.time){ ctx.fillStyle='rgba(255,211,94,0.14)'; ctx.fillRect(0,0,W,H); } }

function drawCard(card,alpha=1){ ctx.save(); ctx.translate(card.x,card.y); const angle=Math.atan2(card.vy||0,card.vx||0)*0.15; ctx.rotate(angle); ctx.globalAlpha=alpha; ctx.fillStyle='rgba(12,18,36,0.96)'; ctx.strokeStyle=card.color; ctx.lineWidth=2; const w=26,h=34; ctx.beginPath(); ctx.roundRect(-w/2,-h/2,w,h,7); ctx.fill(); ctx.stroke(); ctx.fillStyle=card.color; ctx.fillRect(-w/2+3,-h/2+3,w-6,4); ctx.beginPath(); ctx.arc(0,0,6+Math.sin(card.phase||0)*1.2,0,Math.PI*2); ctx.fill(); ctx.restore(); }

function drawShip(){ const s=state.ship, orbitR=s.baseOrbit; ctx.save(); ctx.translate(s.x,s.y); ctx.strokeStyle='rgba(68,221,255,0.24)'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(0,0,orbitR,orbitR*0.46,0,0,Math.PI*2); ctx.stroke(); ctx.restore(); ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(s.angle); ctx.fillStyle='#dff9ff'; ctx.strokeStyle='#44ddff'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(20,0); ctx.lineTo(-16,-11); ctx.lineTo(-10,0); ctx.lineTo(-16,11); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle='rgba(51,255,187,0.8)'; ctx.fillRect(-20,-4,10,8); ctx.restore(); }

function drawHomunculus(){
  const h=state.homunculus; ctx.save(); ctx.translate(h.x,h.y);
  ctx.shadowBlur=28; ctx.shadowColor='rgba(68,221,255,0.22)';
  ctx.strokeStyle='rgba(68,221,255,0.30)'; ctx.lineWidth=14;
  ctx.beginPath(); ctx.moveTo(0,-120); ctx.lineTo(0,120); ctx.moveTo(-70,-10); ctx.lineTo(70,-10); ctx.moveTo(-50,90); ctx.lineTo(0,18); ctx.lineTo(50,90); ctx.stroke();
  for(const slot of state.slots){ const aliveAlpha=slot.alive?1:0.3; ctx.fillStyle=slot.type==='core'?'rgba(255,211,94,.85)':slot.type==='weapon'?'rgba(255,111,145,.85)':slot.type==='shield'?'rgba(68,221,255,.85)':slot.type==='reactor'?'rgba(51,255,187,.85)':'rgba(199,157,255,.85)'; ctx.globalAlpha=aliveAlpha; ctx.beginPath(); ctx.arc(slot.x-h.x,slot.y-h.y,12+slot.level*2,0,Math.PI*2); ctx.fill(); }
  ctx.restore();
  ctx.fillStyle='rgba(255,255,255,0.20)'; ctx.fillRect(h.x-54,h.y+132,108,8); ctx.fillStyle='#33ffbb'; ctx.fillRect(h.x-54,h.y+132,108*(h.hp/h.maxHp),8);
}

function drawEnemies(){ for(const enemy of state.enemies){ if(enemy.dead) continue; ctx.save(); ctx.translate(enemy.x,enemy.y); ctx.fillStyle=enemy.boss?'rgba(255,173,99,0.16)':'rgba(255,111,145,0.12)'; ctx.beginPath(); ctx.ellipse(0,0,enemy.r+14,enemy.r*0.68,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='rgba(22,14,20,0.95)'; ctx.strokeStyle=enemy.boss?'#ffad63':'#ff6f91'; ctx.lineWidth=enemy.boss?3:2; ctx.beginPath(); ctx.moveTo(0,-enemy.r); ctx.lineTo(enemy.r*1.1,0); ctx.lineTo(0,enemy.r); ctx.lineTo(-enemy.r*1.1,0); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle=enemy.boss?'#ffd35e':'#ff6f91'; ctx.beginPath(); ctx.arc(0,0,enemy.boss?7:5,0,Math.PI*2); ctx.fill(); ctx.restore(); ctx.fillStyle='rgba(255,255,255,0.24)'; ctx.fillRect(enemy.x-enemy.r, enemy.y+enemy.r+8, enemy.r*2, 5); ctx.fillStyle=enemy.boss?'#ffad63':'#ff6f91'; ctx.fillRect(enemy.x-enemy.r, enemy.y+enemy.r+8, enemy.r*2*(enemy.hp/enemy.maxHp), 5); } }

function drawTrails(){ for(const t of state.trails){ ctx.save(); ctx.globalAlpha=Math.max(0.08,t.life/28); if(t.ring){ ctx.strokeStyle=t.color; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(t.x,t.y,t.radius+(28-t.life),0,Math.PI*2); ctx.stroke(); } else { ctx.strokeStyle=t.color; ctx.lineWidth=t.width||3; ctx.beginPath(); ctx.moveTo(t.x,t.y); ctx.lineTo(t.tx,t.ty); ctx.stroke(); } ctx.restore(); } }
function drawMissiles(){ for(const m of state.missiles){ ctx.save(); ctx.translate(m.x,m.y); ctx.fillStyle=m.color; ctx.shadowColor=m.color; ctx.shadowBlur=18; ctx.beginPath(); ctx.arc(0,0,7,0,Math.PI*2); ctx.fill(); ctx.restore(); } }
function drawProjectiles(){ for(const p of state.playerProjectiles){ ctx.strokeStyle=p.color; ctx.lineWidth=3+p.splash; ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x-p.vx*0.02,p.y-p.vy*0.02); ctx.stroke(); } for(const p of state.enemyProjectiles){ ctx.strokeStyle=p.color; ctx.lineWidth=p.width; ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x-p.vx*0.02,p.y-p.vy*0.02); ctx.stroke(); } }
function drawParticles(){ for(const p of state.particles){ ctx.save(); ctx.globalAlpha=Math.max(0.05,p.life/46); ctx.fillStyle=p.color; ctx.shadowColor=p.color; ctx.shadowBlur=p.glow?22:0; ctx.beginPath(); ctx.arc(p.x,p.y,p.size||2.4,0,Math.PI*2); ctx.fill(); ctx.restore(); } }
function drawLabels(){ ctx.save(); ctx.fillStyle='rgba(255,255,255,0.72)'; ctx.font='12px JetBrains Mono, monospace'; const slot=getTargetSlot(); if(slot) ctx.fillText(`SLOT LOCK ${slot.name.toUpperCase()}`, W*0.60, 34); const boss=getBoss(); if(boss) ctx.fillText(`BOSS LOCK ${Math.max(0,Math.round(boss.hp))} HP`, W*0.70, 34); ctx.restore(); }

function render(){ drawBackground(); for(const card of state.cards) if(!card.collected) drawCard(card,0.95); for(const hc of state.haloCards) drawCard({ x:hc.x,y:hc.y,vx:0,vy:0,phase:hc.phase,color:hc.color },0.9); drawTrails(); drawShip(); drawHomunculus(); drawEnemies(); drawMissiles(); drawProjectiles(); drawParticles(); drawLabels(); }

let last=performance.now();
function frame(now){ const dt=Math.min((now-last)/1000,0.033); last=now; state.time += dt; autopilot(dt); updateHalo(dt); updateEnemies(dt); fireHomunculus(dt); updateProjectiles(dt); updateMissiles(dt); updateParticles(); updateTrails(); render(); updateUi(); requestAnimationFrame(frame); }

function burstAll(){ state.effects.burstFlashUntil = state.time + 0.35; for(const enemy of state.enemies){ if(enemy.dead) continue; damageEnemy(enemy, 6 + state.level, '#ffd35e', 2); } setAction('Chain Burst','Triggered a screen-wide chain burst across enemy robots.'); log('ðŸ’¥ <strong>Chain Burst</strong> triggered cascading explosions across the battlefield.'); }

function assert(name,cond){ if(!cond) console.error('[self-test failed]',name); }
function selfTest(){ seedBattle(); assert('slots seeded', state.slots.length===8); assert('enemies seeded', state.enemies.length>0); const loose=state.cards.find(c=>!c.collected); collectCard(loose,'test'); assert('powers gathered', state.powers.length>0); state.targetSlotId=state.slots[0].id; queueCard(state.powers[0].id); assert('queue populated', state.queue.length===1); recomputeHomunculus(); assert('homunculus max hp positive', state.homunculus.maxHp>0); }

document.getElementById('restartBtn').addEventListener('click', seedBattle);
document.getElementById('resolveBtn').addEventListener('click', resolveQueue);
document.getElementById('burstBtn').addEventListener('click', burstAll);

selfTest();
seedBattle();
requestAnimationFrame(frame);
</script>
</body>
</html>
