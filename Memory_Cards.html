<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Procedural Card Memory Trainer</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  #hud { position:absolute; top:20px; left:20px; color:white; font-family:Arial; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
<div id="hud">
  <h1>ðŸ§  Procedural Card Memory Trainer</h1>
  <div id="cardText">Press [SPACE] for next card</div>
</div>

<script>
// -----------------------------------------------------
//  CARD MAP (all 52)
// -----------------------------------------------------
const CARD_MAP = {
  // CLUBS
  "Aâ™£":"Cat","2â™£":"Cane","3â™£":"Comb","4â™£":"Car",
  "5â™£":"Coal","6â™£":"Cash","7â™£":"Cake","8â™£":"Cave",
  "9â™£":"Cup","10â™£":"Case","Jâ™£":"Club","Qâ™£":"Queen Latifah","Kâ™£":"Michael Jackson",

  // HEARTS
  "Aâ™¥":"Hat","2â™¥":"Han Solo","3â™¥":"Ham","4â™¥":"Hair",
  "5â™¥":"Hail","6â™¥":"Hash","7â™¥":"Hook","8â™¥":"Hoof",
  "9â™¥":"Hoop","10â™¥":"Hose","Jâ™¥":"Heart","Qâ™¥":"Dairy Queen","Kâ™¥":"Burger King",

  // DIAMONDS
  "Aâ™¦":"Date","2â™¦":"Dan Aykroyd","3â™¦":"Dam","4â™¦":"Door",
  "5â™¦":"Doll","6â™¦":"Dish","7â™¦":"Duck","8â™¦":"Dove",
  "9â™¦":"Dip","10â™¦":"Dice","Jâ™¦":"Diamond","Qâ™¦":"Queen Elizabeth","Kâ™¦":"King Tut",

  // SPADES
  "Aâ™ ":"Suit","2â™ ":"Sun","3â™ ":"Sam","4â™ ":"Sore",
  "5â™ ":"Soil","6â™ ":"Sash","7â™ ":"Sock","8â™ ":"Safe",
  "9â™ ":"Soap","10â™ ":"Sauce","Jâ™ ":"Spade","Qâ™ ":"Queen Bee","Kâ™ ":"King Kong",
};

// -----------------------------------------------------
//  THREE.JS SETUP
// -----------------------------------------------------
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.z = 10;

let renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// LIGHT
const light = new THREE.DirectionalLight(0xffffff, 1.2);
light.position.set(5,10,7);
light.castShadow = true;
scene.add(light);

const ambient = new THREE.AmbientLight(0x404040);
scene.add(ambient);

let currentObject = null;

// -----------------------------------------------------
//  PROCEDURAL FACTORY (core generator)
// -----------------------------------------------------
const ProceduralFactory = {
  // simple noise-based deformation
  deform(mesh, amount=0.3) {
    mesh.geometry.computeVertexNormals();
    const pos = mesh.geometry.attributes.position;
    for (let i=0; i<pos.count; i++){
      let nx = (Math.random()-0.5)*amount;
      let ny = (Math.random()-0.5)*amount;
      let nz = (Math.random()-0.5)*amount;
      pos.setXYZ(i, pos.getX(i)+nx, pos.getY(i)+ny, pos.getZ(i)+nz);
    }
    pos.needsUpdate = true;
  },

  createSphere(color=0xffffff){
    let geo = new THREE.SphereGeometry(1.2, 32, 32);
    let mat = new THREE.MeshStandardMaterial({ color, roughness:0.4, metalness:0.2 });
    let mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true;
    return mesh;
  },

  // Main gateway
  make(name){
    // Base mapping rules by first letter for generative style
    let first = name[0].toUpperCase();

    if (first === "C") return this.makeClubStyle(name);
    if (first === "H") return this.makeHeartStyle(name);
    if (first === "D") return this.makeDiamondStyle(name);
    if (first === "S") return this.makeSpadeStyle(name);

    return this.createSphere(0x888888);
  },

  // Suit styles
  makeClubStyle(name){
    // Mechanical - stacked boxes
    const group = new THREE.Group();
    for(let i=0;i<3;i++){
      let geo = new THREE.BoxGeometry(1.5, 0.4, 1.5);
      let mat = new THREE.MeshStandardMaterial({ color:0x44cc55 });
      let mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = i*0.5;
      mesh.castShadow=true;
      group.add(mesh);
    }
    return group;
  },

  makeHeartStyle(name){
    // Organic metaball-ish spheres
    const group = new THREE.Group();
    for (let i=0;i<4;i++){
      let s = this.createSphere(0xcc2244);
      s.position.set(
        (Math.random()-0.5)*1.5,
        (Math.random()-0.5)*1.5,
        (Math.random()-0.5)*1.5
      );
      this.deform(s, 0.4);
      group.add(s);
    }
    return group;
  },

  makeDiamondStyle(name){
    // Crystalline shapes
    const geo = new THREE.OctahedronGeometry(1.2);
    const mat = new THREE.MeshStandardMaterial({
      color:0x44aaff,
      roughness:0.1,
      metalness:0.8
    });
    let mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true;
    this.deform(mesh, 0.1);
    mesh.rotation.x = Math.PI/4;
    return mesh;
  },

  makeSpadeStyle(name){
    // Sharp silhouettes via extrusion
    const shape = new THREE.Shape();
    shape.moveTo(0,1);
    shape.bezierCurveTo(-1,0, -0.7,-1, 0,-0.5);
    shape.bezierCurveTo(0.7,-1, 1,0, 0,1);

    const geo = new THREE.ExtrudeGeometry(shape, { depth:0.4, bevelEnabled:false });
    const mat = new THREE.MeshStandardMaterial({
      color:0x222222,
      roughness:0.4,
      metalness:0.3
    });
    let mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow=true;
    return mesh;
  }
};

// -----------------------------------------------------
//  CARD SELECTOR
// -----------------------------------------------------
const allCards = Object.keys(CARD_MAP);

function nextCard(){
  let card = allCards[Math.floor(Math.random()*allCards.length)];
  let mnemonic = CARD_MAP[card];
  document.getElementById("cardText").innerHTML =
    `<h2>${card}</h2><h3>${mnemonic}</h3>`;

  if (currentObject) scene.remove(currentObject);

  currentObject = ProceduralFactory.make(mnemonic);
  currentObject.position.y = -1;
  scene.add(currentObject);
}

document.body.onkeyup = e => {
  if (e.code === "Space") nextCard();
};

// -----------------------------------------------------
//  LOOP
// -----------------------------------------------------
function animate(){
  requestAnimationFrame(animate);
  if (currentObject) currentObject.rotation.y += 0.01;
  renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>
