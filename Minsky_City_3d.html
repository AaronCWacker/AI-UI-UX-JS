<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minsky's Society of Mind - City Universe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            overflow: hidden;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            pointer-events: none;
            z-index: 100;
        }
        #location-panel {
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #0f0;
            padding: 15px;
            border-radius: 8px;
            max-width: 400px;
            pointer-events: all;
        }
        #location-panel h2 {
            color: #0ff;
            margin-bottom: 10px;
            font-size: 16px;
        }
        .location-btn {
            background: #001a00;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 8px 15px;
            margin: 5px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }
        .location-btn:hover {
            background: #003300;
            box-shadow: 0 0 10px #0f0;
        }
        .location-btn.active {
            background: #0f0;
            color: #000;
            font-weight: bold;
        }
        #network-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #0f0;
            padding: 15px;
            border-radius: 8px;
            max-width: 350px;
            pointer-events: all;
        }
        #network-info h3 {
            color: #ff0;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .network-stat {
            color: #0ff;
            font-size: 12px;
            margin: 4px 0;
        }
        .agent-count {
            color: #f0f;
            font-weight: bold;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #0f0;
            padding: 15px;
            border-radius: 8px;
            pointer-events: all;
        }
        .control-group {
            margin: 10px 0;
        }
        .control-group label {
            display: block;
            color: #0ff;
            font-size: 12px;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 200px;
        }
        #object-selector {
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #f0f;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
        }
        .object-item {
            background: #001a00;
            border: 1px solid #f0f;
            color: #f0f;
            padding: 6px 10px;
            margin: 4px 0;
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
        }
        .object-item:hover {
            background: #330033;
            box-shadow: 0 0 8px #f0f;
        }
        #minsky-quote {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #ff0;
            padding: 12px;
            border-radius: 8px;
            max-width: 350px;
            pointer-events: all;
            font-style: italic;
            color: #ff0;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <div id="location-panel">
            <h2>üèôÔ∏è LOCATION NETWORK NAVIGATOR</h2>
            <div>
                <button class="location-btn" data-scale="atom">‚öõÔ∏è Atomic</button>
                <button class="location-btn" data-scale="object">ü™ë Object</button>
                <button class="location-btn active" data-scale="room">üè† Room</button>
                <button class="location-btn" data-scale="home">üèòÔ∏è Home</button>
                <button class="location-btn" data-scale="neighborhood">üèôÔ∏è Neighborhood</button>
                <button class="location-btn" data-scale="city">üåÜ City</button>
                <button class="location-btn" data-scale="region">üó∫Ô∏è Region</button>
            </div>
            <div id="object-selector" style="display:none;">
                <h3 style="color: #f0f; font-size: 12px; margin-bottom: 5px;">Select Object:</h3>
            </div>
        </div>
    </div>

    <div id="network-info">
        <h3>üß† NETWORK CONSCIOUSNESS</h3>
        <div class="network-stat">Active Agents: <span class="agent-count" id="agent-count">0</span></div>
        <div class="network-stat">Connections: <span class="agent-count" id="connection-count">0</span></div>
        <div class="network-stat">Emergent Behaviors: <span class="agent-count" id="behavior-count">0</span></div>
        <div class="network-stat">Current Focus: <span class="agent-count" id="current-focus">Room</span></div>
        <div class="network-stat">Network Depth: <span class="agent-count" id="network-depth">3</span></div>
    </div>

    <div id="controls">
        <h3 style="color: #0ff; margin-bottom: 10px; font-size: 14px;">‚öôÔ∏è NETWORK PARAMETERS</h3>
        <div class="control-group">
            <label>Network Activity: <span id="activity-val">50</span>%</label>
            <input type="range" id="activity" min="0" max="100" value="50">
        </div>
        <div class="control-group">
            <label>Agent Speed: <span id="speed-val">1.0</span>x</label>
            <input type="range" id="speed" min="0" max="200" value="100">
        </div>
        <div class="control-group">
            <label>Network Depth: <span id="depth-val">3</span></label>
            <input type="range" id="depth" min="1" max="7" value="3">
        </div>
        <div class="control-group">
            <button class="location-btn" id="randomize">üé≤ Randomize Network</button>
        </div>
    </div>

    <div id="minsky-quote">
        "The secret of what anything means to us depends on how we've connected it to all the other things we know." - Marvin Minsky
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Minsky's Society of Mind - Network of Networks Architecture
        class Agent {
            constructor(id, type, position, role) {
                this.id = id;
                this.type = type;
                this.position = position.clone();
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02
                );
                this.role = role; // cognitive, motor, perceptual, memory, etc.
                this.activation = Math.random();
                this.connections = [];
                this.state = {};
                this.emergentProperty = null;
            }

            update(deltaTime, networkActivity) {
                // Agent behavior influenced by network activity
                this.activation = Math.sin(Date.now() * 0.001 + this.id) * 0.5 + 0.5;
                this.activation *= networkActivity;

                // Move based on connected agents
                let force = new THREE.Vector3();
                this.connections.forEach(conn => {
                    const dir = new THREE.Vector3().subVectors(conn.position, this.position);
                    const dist = dir.length();
                    if (dist > 0) {
                        dir.normalize().multiplyScalar(0.0001 / (dist + 0.1));
                        force.add(dir);
                    }
                });

                this.velocity.add(force);
                this.velocity.multiplyScalar(0.95); // damping
                this.position.add(this.velocity);

                // Keep within bounds
                const bound = 10;
                if (Math.abs(this.position.x) > bound) this.velocity.x *= -0.8;
                if (Math.abs(this.position.y) > bound) this.velocity.y *= -0.8;
                if (Math.abs(this.position.z) > bound) this.velocity.z *= -0.8;
            }
        }

        class NetworkOfNetworks {
            constructor(name, scale, parent = null) {
                this.name = name;
                this.scale = scale;
                this.parent = parent;
                this.children = [];
                this.agents = [];
                this.connections = [];
                this.emergentBehaviors = [];
                this.position = new THREE.Vector3();
            }

            addAgent(agent) {
                this.agents.push(agent);
            }

            addConnection(agent1, agent2, strength = 1.0) {
                this.connections.push({ agent1, agent2, strength });
                agent1.connections.push(agent2);
                agent2.connections.push(agent1);
            }

            createRandomNetwork(agentCount, connectionDensity = 0.3) {
                // Create agents with different roles
                const roles = ['cognitive', 'motor', 'perceptual', 'memory', 'emotional', 'planning'];
                for (let i = 0; i < agentCount; i++) {
                    const pos = new THREE.Vector3(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    );
                    const role = roles[Math.floor(Math.random() * roles.length)];
                    const agent = new Agent(i, this.scale, pos, role);
                    this.addAgent(agent);
                }

                // Create connections
                for (let i = 0; i < this.agents.length; i++) {
                    for (let j = i + 1; j < this.agents.length; j++) {
                        if (Math.random() < connectionDensity) {
                            this.addConnection(this.agents[i], this.agents[j]);
                        }
                    }
                }
            }

            update(deltaTime, networkActivity) {
                this.agents.forEach(agent => agent.update(deltaTime, networkActivity));
            }
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;
        camera.position.y = 10;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x00ff00, 1, 100);
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff00ff, 0.8, 100);
        pointLight2.position.set(-10, -10, 10);
        scene.add(pointLight2);

        // Network hierarchy - networks within networks
        const networks = {
            atom: null,
            object: null,
            room: null,
            home: null,
            neighborhood: null,
            city: null,
            region: null
        };

        const objects = {
            'Coffee Cup': { atoms: 50, connections: 0.4 },
            'Laptop': { atoms: 80, connections: 0.5 },
            'Plant': { atoms: 60, connections: 0.3 },
            'Chair': { atoms: 70, connections: 0.35 },
            'Book': { atoms: 40, connections: 0.4 }
        };

        let currentNetwork = null;
        let currentScale = 'room';
        let currentObject = null;

        // Visualization objects
        const agentMeshes = [];
        const connectionLines = [];

        function createVisualization(network) {
            // Clear previous visualization
            agentMeshes.forEach(mesh => scene.remove(mesh));
            connectionLines.forEach(line => scene.remove(line));
            agentMeshes.length = 0;
            connectionLines.length = 0;

            if (!network) return;

            // Create agent meshes
            const roleColors = {
                cognitive: 0x00ffff,
                motor: 0xff00ff,
                perceptual: 0xffff00,
                memory: 0x00ff00,
                emotional: 0xff0000,
                planning: 0x0000ff
            };

            network.agents.forEach(agent => {
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = new THREE.MeshPhongMaterial({
                    color: roleColors[agent.role] || 0xffffff,
                    emissive: roleColors[agent.role] || 0xffffff,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(agent.position);
                mesh.userData.agent = agent;
                scene.add(mesh);
                agentMeshes.push(mesh);
            });

            // Create connection lines
            network.connections.forEach(conn => {
                const points = [conn.agent1.position, conn.agent2.position];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.3
                });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                connectionLines.push({ line, conn });
            });
        }

        function initializeNetworks(depth) {
            // Room network - the base level
            networks.room = new NetworkOfNetworks('Living Room', 'room');
            networks.room.createRandomNetwork(30 + depth * 10, 0.3);

            // Object networks - nested within room
            Object.keys(objects).forEach(objName => {
                const objNetwork = new NetworkOfNetworks(objName, 'object', networks.room);
                objNetwork.createRandomNetwork(objects[objName].atoms, objects[objName].connections);
                networks.room.children.push(objNetwork);
            });

            // Home network - contains room
            networks.home = new NetworkOfNetworks('Home', 'home');
            networks.home.createRandomNetwork(50 + depth * 15, 0.25);
            networks.home.children.push(networks.room);

            // Neighborhood network
            networks.neighborhood = new NetworkOfNetworks('Lake Minnetonka Neighborhood', 'neighborhood');
            networks.neighborhood.createRandomNetwork(80 + depth * 20, 0.2);
            networks.neighborhood.children.push(networks.home);

            // City network
            networks.city = new NetworkOfNetworks('Minneapolis-St. Paul', 'city');
            networks.city.createRandomNetwork(120 + depth * 30, 0.15);
            networks.city.children.push(networks.neighborhood);

            // Region network
            networks.region = new NetworkOfNetworks('Minnesota', 'region');
            networks.region.createRandomNetwork(150 + depth * 40, 0.1);
            networks.region.children.push(networks.city);

            currentNetwork = networks.room;
            createVisualization(currentNetwork);
        }

        // Initialize with default depth
        initializeNetworks(3);

        // UI Controls
        document.querySelectorAll('.location-btn').forEach(btn => {
            if (btn.dataset.scale) {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.location-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    currentScale = btn.dataset.scale;
                    
                    if (currentScale === 'object') {
                        // Show object selector
                        const selector = document.getElementById('object-selector');
                        selector.style.display = 'block';
                        selector.innerHTML = '<h3 style="color: #f0f; font-size: 12px; margin-bottom: 5px;">Select Object:</h3>';
                        
                        Object.keys(objects).forEach(objName => {
                            const objBtn = document.createElement('div');
                            objBtn.className = 'object-item';
                            objBtn.textContent = objName;
                            objBtn.addEventListener('click', () => {
                                const objNetwork = networks.room.children.find(c => c.name === objName);
                                if (objNetwork) {
                                    currentNetwork = objNetwork;
                                    createVisualization(currentNetwork);
                                    currentObject = objName;
                                }
                            });
                            selector.appendChild(objBtn);
                        });
                    } else {
                        document.getElementById('object-selector').style.display = 'none';
                        currentNetwork = networks[currentScale];
                        currentObject = null;
                        createVisualization(currentNetwork);
                    }
                    
                    document.getElementById('current-focus').textContent = 
                        currentObject || currentScale.charAt(0).toUpperCase() + currentScale.slice(1);
                });
            }
        });

        // Parameter controls
        const activitySlider = document.getElementById('activity');
        const speedSlider = document.getElementById('speed');
        const depthSlider = document.getElementById('depth');

        activitySlider.addEventListener('input', (e) => {
            document.getElementById('activity-val').textContent = e.target.value;
        });

        speedSlider.addEventListener('input', (e) => {
            document.getElementById('speed-val').textContent = (e.target.value / 100).toFixed(1);
        });

        depthSlider.addEventListener('input', (e) => {
            const depth = parseInt(e.target.value);
            document.getElementById('depth-val').textContent = depth;
            document.getElementById('network-depth').textContent = depth;
            initializeNetworks(depth);
        });

        document.getElementById('randomize').addEventListener('click', () => {
            const depth = parseInt(depthSlider.value);
            initializeNetworks(depth);
        });

        // Animation loop
        let lastTime = Date.now();
        
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            const networkActivity = parseInt(activitySlider.value) / 100;
            const speedMultiplier = parseInt(speedSlider.value) / 100;

            // Update current network
            if (currentNetwork) {
                currentNetwork.update(deltaTime * speedMultiplier, networkActivity);

                // Update visualizations
                agentMeshes.forEach(mesh => {
                    const agent = mesh.userData.agent;
                    mesh.position.copy(agent.position);
                    
                    // Pulsing based on activation
                    const scale = 1 + agent.activation * 0.5;
                    mesh.scale.set(scale, scale, scale);
                    mesh.material.emissiveIntensity = agent.activation;
                });

                connectionLines.forEach(({ line, conn }) => {
                    const points = [conn.agent1.position, conn.agent2.position];
                    line.geometry.setFromPoints(points);
                    
                    // Connection strength based on agent activation
                    const avgActivation = (conn.agent1.activation + conn.agent2.activation) / 2;
                    line.material.opacity = 0.1 + avgActivation * 0.4;
                });

                // Update stats
                document.getElementById('agent-count').textContent = currentNetwork.agents.length;
                document.getElementById('connection-count').textContent = currentNetwork.connections.length;
                document.getElementById('behavior-count').textContent = 
                    Math.floor(currentNetwork.agents.length * networkActivity);
            }

            // Rotate camera
            const time = Date.now() * 0.0001;
            camera.position.x = Math.sin(time) * 25;
            camera.position.z = Math.cos(time) * 25;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Minsky quotes rotation
        const quotes = [
            "The secret of what anything means to us depends on how we've connected it to all the other things we know.",
            "No computer has ever been designed that is ever aware of what it's doing; but most of the time, we aren't either.",
            "We wanted to solve robot problems and problems of the mind, and we started our lab focused on those things.",
            "You don't understand anything until you learn it more than one way.",
            "Minds are simply what brains do.",
            "The brain happens to be a meat machine.",
            "The problem is basically that the brain is thinking all the time.",
            "In general, we're least aware of what our minds do best."
        ];

        setInterval(() => {
            const quote = quotes[Math.floor(Math.random() * quotes.length)];
            document.getElementById('minsky-quote').innerHTML = `"${quote}" - Marvin Minsky`;
        }, 15000);
    </script>
</body>
</html>
