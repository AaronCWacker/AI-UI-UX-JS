<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Vehicle Command - Advanced Logistics Simulator</title>
    <meta name="description" content="Command ships, trucks, helicopters, and submarines with advanced camera systems and volumetric lighting.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(to bottom, #001a33 0%, #000000 100%);
            color: #0ff;
            overflow: hidden;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.95), rgba(0, 50, 80, 0.95));
            border: 3px solid #00d4ff;
            padding: 20px;
            border-radius: 12px;
            min-width: 320px;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3);
        }
        .hud-title {
            color: #00d4ff;
            font-size: 20px;
            margin-bottom: 12px;
            text-shadow: 0 0 15px #00d4ff;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .hud-subtitle {
            color: #88ccff;
            font-size: 11px;
            margin-bottom: 15px;
            opacity: 0.8;
            font-style: italic;
        }
        .hud-stat {
            color: #88ccff;
            font-size: 14px;
            margin: 8px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
        }
        .hud-value {
            color: #00ff88;
            font-weight: bold;
            float: right;
        }
        #camera-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(20, 20, 60, 0.95), rgba(40, 20, 80, 0.95));
            border: 3px solid #ff00ff;
            padding: 20px;
            border-radius: 12px;
            pointer-events: all;
            box-shadow: 0 8px 32px rgba(255, 0, 255, 0.3);
        }
        .camera-title {
            color: #ff00ff;
            font-size: 16px;
            margin-bottom: 12px;
            text-shadow: 0 0 10px #ff00ff;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .camera-btn {
            background: linear-gradient(135deg, #1a0033, #330066);
            border: 2px solid #ff00ff;
            color: #ff00ff;
            padding: 12px 20px;
            margin: 6px 0;
            cursor: pointer;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s;
            width: 100%;
            display: block;
        }
        .camera-btn:hover {
            background: linear-gradient(135deg, #ff00ff, #ff0088);
            color: #000;
            box-shadow: 0 0 25px #ff00ff;
            transform: translateY(-2px);
        }
        .camera-btn.active {
            background: linear-gradient(135deg, #00ff00, #00aa00);
            border-color: #00ff00;
            color: #000;
            box-shadow: 0 0 25px #00ff00;
        }
        #controls-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(40, 20, 60, 0.95));
            border: 3px solid #ff00ff;
            padding: 20px;
            border-radius: 12px;
            pointer-events: all;
            box-shadow: 0 8px 32px rgba(255, 0, 255, 0.3);
        }
        .control-section-title {
            color: #ff00ff;
            font-size: 16px;
            margin-bottom: 12px;
            text-shadow: 0 0 10px #ff00ff;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .control-btn {
            background: linear-gradient(135deg, #001a33, #003366);
            border: 2px solid #00d4ff;
            color: #00d4ff;
            padding: 12px 24px;
            margin: 6px;
            cursor: pointer;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .control-btn:hover {
            background: linear-gradient(135deg, #00d4ff, #0088ff);
            color: #000;
            box-shadow: 0 0 25px #00d4ff;
            transform: translateY(-2px);
        }
        .control-btn.active {
            background: linear-gradient(135deg, #ff00ff, #ff0088);
            border-color: #ff00ff;
            color: #fff;
            box-shadow: 0 0 25px #ff00ff;
        }
        #vehicle-palette {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(40, 30, 0, 0.95), rgba(60, 40, 0, 0.95));
            border: 3px solid #ffaa00;
            padding: 20px;
            border-radius: 12px;
            pointer-events: all;
            box-shadow: 0 8px 32px rgba(255, 170, 0, 0.3);
        }
        .palette-title {
            color: #ffaa00;
            font-size: 16px;
            margin-bottom: 12px;
            text-shadow: 0 0 10px #ffaa00;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .vehicle-btn {
            background: linear-gradient(135deg, #332200, #554400);
            border: 2px solid #ffaa00;
            color: #ffaa00;
            padding: 15px 18px;
            margin: 6px;
            cursor: pointer;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: inline-block;
            min-width: 120px;
        }
        .vehicle-btn:hover {
            background: linear-gradient(135deg, #ffaa00, #ffcc00);
            color: #000;
            box-shadow: 0 0 20px #ffaa00;
            transform: translateY(-2px);
        }
        .vehicle-btn.selected {
            background: linear-gradient(135deg, #00ff00, #00aa00);
            color: #000;
            border-color: #00ff00;
            box-shadow: 0 0 25px #00ff00;
        }
        #ai-memory {
            position: absolute;
            top: 200px;
            right: 20px;
            background: rgba(40, 0, 40, 0.95);
            border: 2px solid #f0f;
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            max-height: 300px;
            overflow-y: auto;
            pointer-events: none;
        }
        .memory-entry {
            background: rgba(80, 0, 80, 0.5);
            border-left: 3px solid #f0f;
            padding: 8px;
            margin: 5px 0;
            font-size: 11px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="hud">
        <div class="hud-title">üéÆ MULTI-VEHICLE COMMAND</div>
        <div class="hud-subtitle">Advanced Multi-Domain Operations v3.0</div>
        <div class="hud-stat">Vehicle Type: <span class="hud-value" id="current-form">NAVAL SHIP</span></div>
        <div class="hud-stat">Altitude: <span class="hud-value" id="altitude">1.0m</span></div>
        <div class="hud-stat">Speed: <span class="hud-value" id="speed">0.0</span></div>
        <div class="hud-stat">Credits: <span class="hud-value" id="gold">$1000</span></div>
        <div class="hud-stat">Fleet Assets: <span class="hud-value" id="fleet-size">1</span></div>
        <div class="hud-stat">AI Units: <span class="hud-value" id="ai-ships">0</span></div>
        <div class="hud-stat">Mission Score: <span class="hud-value" id="score">0</span></div>
    </div>

    <div id="camera-controls">
        <div class="camera-title">üìπ CAMERA SYSTEM</div>
        <button class="camera-btn active" id="cam-champion">üéØ Champion View</button>
        <button class="camera-btn" id="cam-cloud">‚òÅÔ∏è Cloud View</button>
        <button class="camera-btn" id="cam-network">üåê Network View</button>
        <button class="camera-btn" id="cam-overhead">üó∫Ô∏è Overhead View</button>
    </div>

    <div id="controls-panel">
        <div class="control-section-title">‚öôÔ∏è OPERATIONS</div>
        <button class="control-btn" id="spawn-fleet">üö¢ Deploy Fleet</button>
        <button class="control-btn" id="start-battle">‚öîÔ∏è Combat: <span id="battle-status">OFF</span></button>
        <button class="control-btn" id="toggle-ai-build">ü§ñ AI Build: <span id="ai-build-status">OFF</span></button>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,0,255,0.3);">
            <div style="color: #88ccff; font-size: 11px; margin-bottom: 5px;">Controls: WASD + Shift=Boost</div>
            <div style="color: #88ccff; font-size: 11px;">Q/E = Altitude (Heli/Sub)</div>
        </div>
    </div>

    <div id="vehicle-palette">
        <div class="palette-title">üöó VEHICLE SELECTION</div>
        <button class="vehicle-btn selected" data-vehicle="ship">‚õ¥Ô∏è Naval Ship</button>
        <button class="vehicle-btn" data-vehicle="truck">üöõ Heavy Truck</button>
        <button class="vehicle-btn" data-vehicle="helicopter">üöÅ Helicopter</button>
        <button class="vehicle-btn" data-vehicle="submarine">üåä Submarine</button>
    </div>

    <div id="ai-memory">
        <div style="color: #f0f; font-size: 14px; margin-bottom: 10px;">üß† AI MEMORY</div>
        <div id="memory-log"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        const gameState = {
            gold: 1000,
            score: 0,
            currentVehicleType: 'ship',
            playerVehicles: [],
            aiVehicles: [],
            islands: [],
            playerTowers: [],
            aiTowers: [],
            projectiles: [],
            aiBuildEnabled: false,
            battleActive: false,
            cameraMode: 'champion' // champion, cloud, network, overhead
        };

        // AI Memory
        function logMemory(message) {
            const log = document.getElementById('memory-log');
            const entry = document.createElement('div');
            entry.className = 'memory-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.insertBefore(entry, log.firstChild);
            while (log.children.length > 15) {
                log.removeChild(log.lastChild);
            }
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x001a33, 50, 400);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 40, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Volumetric lighting for overhead view
        const volumetricLights = [];
        for (let i = 0; i < 5; i++) {
            const vLight = new THREE.SpotLight(0x00aaff, 0, 200, Math.PI / 4, 0.5, 2);
            vLight.position.set(
                (Math.random() - 0.5) * 200,
                80,
                (Math.random() - 0.5) * 200
            );
            vLight.castShadow = true;
            vLight.visible = false;
            scene.add(vLight);
            volumetricLights.push(vLight);
        }

        // Ocean/Ground
        const waterGeometry = new THREE.PlaneGeometry(500, 500, 50, 50);
        const waterMaterial = new THREE.MeshStandardMaterial({
            color: 0x1E90FF,
            roughness: 0.6,
            metalness: 0.3,
            transparent: true,
            opacity: 0.9
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.receiveShadow = true;
        scene.add(water);

        // Animate water
        function animateWater() {
            const time = Date.now() * 0.001;
            const positions = water.geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                positions.setZ(i, Math.sin(x * 0.1 + time) * 0.3 + Math.cos(y * 0.1 + time * 0.7) * 0.2);
            }
            positions.needsUpdate = true;
        }

        // Vehicle Base Class
        class Vehicle {
            constructor(x, z, type, isAI = false) {
                this.position = new THREE.Vector3(x, this.getDefaultAltitude(type), z);
                this.velocity = new THREE.Vector3();
                this.type = type;
                this.isAI = isAI;
                this.health = 100;
                this.maxHealth = 100;
                this.rotation = 0;
                this.scale = 1.0;
                this.connections = []; // For network view
                
                this.createMesh();
                this.createHealthBar();
            }

            getDefaultAltitude(type) {
                switch(type) {
                    case 'ship': return 1;
                    case 'truck': return 0.5;
                    case 'helicopter': return 25;
                    case 'submarine': return -5;
                    default: return 1;
                }
            }

            createMesh() {
                this.group = new THREE.Group();
                const color = this.isAI ? 0xff0000 : 0x00ffff;
                
                switch(this.type) {
                    case 'ship':
                        this.createShipMesh(color);
                        break;
                    case 'truck':
                        this.createTruckMesh(color);
                        break;
                    case 'helicopter':
                        this.createHelicopterMesh(color);
                        break;
                    case 'submarine':
                        this.createSubmarineMesh(color);
                        break;
                }
                
                this.group.position.copy(this.position);
                scene.add(this.group);
            }

            createShipMesh(color) {
                const hullGeom = new THREE.BoxGeometry(3, 1, 6);
                const hullMat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    metalness: 0.7,
                    roughness: 0.3
                });
                this.hull = new THREE.Mesh(hullGeom, hullMat);
                this.hull.position.y = 0.5;
                this.hull.castShadow = true;
                this.group.add(this.hull);

                const deckGeom = new THREE.BoxGeometry(2.5, 0.2, 5.5);
                const deck = new THREE.Mesh(deckGeom, new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
                deck.position.y = 1.1;
                this.group.add(deck);

                const mastGeom = new THREE.CylinderGeometry(0.15, 0.15, 8);
                const mast = new THREE.Mesh(mastGeom, new THREE.MeshStandardMaterial({ color: 0x654321 }));
                mast.position.y = 5;
                this.group.add(mast);

                const sailGeom = new THREE.PlaneGeometry(3, 5);
                const sail = new THREE.Mesh(sailGeom, new THREE.MeshStandardMaterial({
                    color: this.isAI ? 0xff6666 : 0xffffff,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                }));
                sail.position.set(1.5, 5, 0);
                this.group.add(sail);
            }

            createTruckMesh(color) {
                // Truck cab
                const cabGeom = new THREE.BoxGeometry(3, 2.5, 3);
                const cabMat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const cab = new THREE.Mesh(cabGeom, cabMat);
                cab.position.set(0, 1.5, -2);
                cab.castShadow = true;
                this.group.add(cab);

                // Cargo container
                const cargoGeom = new THREE.BoxGeometry(3, 3, 6);
                const cargo = new THREE.Mesh(cargoGeom, new THREE.MeshStandardMaterial({ 
                    color: this.isAI ? 0x880000 : 0x008888,
                    metalness: 0.5
                }));
                cargo.position.set(0, 2, 2);
                cargo.castShadow = true;
                this.group.add(cargo);

                // Wheels
                const wheelGeom = new THREE.CylinderGeometry(0.6, 0.6, 0.4);
                const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const wheelPositions = [
                    [-1.5, 0.6, -3], [1.5, 0.6, -3],
                    [-1.5, 0.6, 0], [1.5, 0.6, 0],
                    [-1.5, 0.6, 3], [1.5, 0.6, 3]
                ];
                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeom, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(...pos);
                    this.group.add(wheel);
                });

                // Headlights
                const lightGeom = new THREE.SphereGeometry(0.2);
                const light1 = new THREE.Mesh(lightGeom, new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                light1.position.set(-1, 1, -3.5);
                this.group.add(light1);
                const light2 = new THREE.Mesh(lightGeom, new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                light2.position.set(1, 1, -3.5);
                this.group.add(light2);
            }

            createHelicopterMesh(color) {
                // Fuselage
                const bodyGeom = new THREE.SphereGeometry(1.5, 8, 8);
                bodyGeom.scale(1.5, 1, 2);
                const bodyMat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.4,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const body = new THREE.Mesh(bodyGeom, bodyMat);
                body.castShadow = true;
                this.group.add(body);

                // Cockpit
                const cockpitGeom = new THREE.SphereGeometry(1, 6, 6);
                const cockpit = new THREE.Mesh(cockpitGeom, new THREE.MeshStandardMaterial({
                    color: 0x000033,
                    transparent: true,
                    opacity: 0.7,
                    metalness: 0.8
                }));
                cockpit.position.set(0, 0.5, -1);
                cockpit.scale.set(1.2, 0.8, 1.2);
                this.group.add(cockpit);

                // Tail boom
                const tailGeom = new THREE.CylinderGeometry(0.3, 0.3, 6);
                const tail = new THREE.Mesh(tailGeom, bodyMat);
                tail.rotation.z = Math.PI / 2;
                tail.position.set(0, 0.5, 4);
                this.group.add(tail);

                // Main rotor
                const rotorGeom = new THREE.BoxGeometry(8, 0.1, 0.4);
                this.mainRotor = new THREE.Mesh(rotorGeom, new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    metalness: 0.8
                }));
                this.mainRotor.position.y = 2;
                this.group.add(this.mainRotor);

                // Tail rotor
                const tailRotorGeom = new THREE.BoxGeometry(0.2, 2, 0.1);
                this.tailRotor = new THREE.Mesh(tailRotorGeom, new THREE.MeshStandardMaterial({ color: 0x333333 }));
                this.tailRotor.position.set(0.8, 0.5, 7);
                this.group.add(this.tailRotor);

                // Skids
                const skidGeom = new THREE.BoxGeometry(0.3, 0.2, 4);
                const skidMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
                const skid1 = new THREE.Mesh(skidGeom, skidMat);
                skid1.position.set(-1.2, -1, 0);
                this.group.add(skid1);
                const skid2 = new THREE.Mesh(skidGeom, skidMat);
                skid2.position.set(1.2, -1, 0);
                this.group.add(skid2);
            }

            createSubmarineMesh(color) {
                // Main hull (torpedo shape)
                const hullGeom = new THREE.CylinderGeometry(1, 1, 8, 16);
                const hullMat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.5,
                    metalness: 0.9,
                    roughness: 0.2
                });
                const hull = new THREE.Mesh(hullGeom, hullMat);
                hull.rotation.z = Math.PI / 2;
                hull.castShadow = true;
                this.group.add(hull);

                // Conning tower
                const towerGeom = new THREE.BoxGeometry(1.5, 2, 2);
                const tower = new THREE.Mesh(towerGeom, hullMat);
                tower.position.y = 1.5;
                this.group.add(tower);

                // Periscope
                const periscopeGeom = new THREE.CylinderGeometry(0.1, 0.1, 3);
                const periscope = new THREE.Mesh(periscopeGeom, new THREE.MeshStandardMaterial({ color: 0x666666 }));
                periscope.position.set(0, 4, 0);
                this.group.add(periscope);

                // Nose cone
                const noseGeom = new THREE.ConeGeometry(1, 2, 16);
                const nose = new THREE.Mesh(noseGeom, hullMat);
                nose.rotation.z = -Math.PI / 2;
                nose.position.z = -5;
                this.group.add(nose);

                // Fins
                const finGeom = new THREE.BoxGeometry(0.2, 2, 2);
                const finMat = new THREE.MeshStandardMaterial({ color: this.isAI ? 0x660000 : 0x006666 });
                
                const topFin = new THREE.Mesh(finGeom, finMat);
                topFin.position.set(0, 1.5, 2);
                this.group.add(topFin);

                const sideFin1 = new THREE.Mesh(finGeom, finMat);
                sideFin1.rotation.z = Math.PI / 2;
                sideFin1.position.set(1.5, 0, 2);
                this.group.add(sideFin1);

                const sideFin2 = new THREE.Mesh(finGeom, finMat);
                sideFin2.rotation.z = Math.PI / 2;
                sideFin2.position.set(-1.5, 0, 2);
                this.group.add(sideFin2);

                // Propeller
                const propGeom = new THREE.BoxGeometry(0.3, 3, 0.5);
                this.propeller = new THREE.Mesh(propGeom, new THREE.MeshStandardMaterial({ color: 0x333333 }));
                this.propeller.position.z = 4;
                this.group.add(this.propeller);
            }

            createHealthBar() {
                const barWidth = 3;
                const barHeight = 0.3;
                
                const barGeom = new THREE.PlaneGeometry(barWidth, barHeight);
                const barBg = new THREE.Mesh(barGeom, new THREE.MeshBasicMaterial({ color: 0x330000 }));
                barBg.position.y = 8;
                this.group.add(barBg);
                
                const healthGeom = new THREE.PlaneGeometry(barWidth, barHeight);
                this.healthBar = new THREE.Mesh(healthGeom, new THREE.MeshBasicMaterial({ 
                    color: this.isAI ? 0xff0000 : 0x00ff00 
                }));
                this.healthBar.position.y = 8;
                this.healthBar.position.z = 0.01;
                this.group.add(this.healthBar);
            }

            updateHealthBar() {
                const healthPercent = this.health / this.maxHealth;
                this.healthBar.scale.x = healthPercent;
                this.healthBar.position.x = -1.5 * (1 - healthPercent);
            }

            update(deltaTime, keys = {}) {
                // Type-specific animations
                if (this.type === 'helicopter') {
                    if (this.mainRotor) {
                        this.mainRotor.rotation.y += 0.5;
                    }
                    if (this.tailRotor) {
                        this.tailRotor.rotation.z += 0.8;
                    }
                }
                
                if (this.type === 'submarine' && this.propeller) {
                    this.propeller.rotation.x += this.velocity.length() * 2;
                }

                // Apply velocity
                this.position.add(this.velocity);
                this.velocity.multiplyScalar(0.95); // Drag

                // Update rotation
                if (this.velocity.length() > 0.01) {
                    this.rotation = Math.atan2(this.velocity.x, this.velocity.z);
                }

                // Keep in bounds
                this.position.x = Math.max(-200, Math.min(200, this.position.x));
                this.position.z = Math.max(-200, Math.min(200, this.position.z));

                // Type-specific altitude constraints
                switch(this.type) {
                    case 'ship':
                        this.position.y = Math.max(0.5, Math.min(2, this.position.y));
                        break;
                    case 'truck':
                        this.position.y = 0.5;
                        break;
                    case 'helicopter':
                        this.position.y = Math.max(5, Math.min(60, this.position.y));
                        break;
                    case 'submarine':
                        this.position.y = Math.max(-15, Math.min(1, this.position.y));
                        break;
                }

                this.group.position.copy(this.position);
                this.group.rotation.y = this.rotation;
                
                this.updateHealthBar();
                
                return true;
            }

            remove() {
                scene.remove(this.group);
            }
        }

        // Create islands
        class ProceduralIsland {
            constructor(x, z, size) {
                this.position = new THREE.Vector3(x, 0, z);
                this.size = size;
                this.createMesh();
            }

            createMesh() {
                const geometry = new THREE.CylinderGeometry(this.size, this.size * 1.2, 3, 8);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x228B22,
                    roughness: 0.9
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                this.mesh.position.y = 1.5;
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                scene.add(this.mesh);
            }
        }

        // Create island clusters
        const islandPositions = [
            [0, 0], [-60, -40], [70, -30], [-50, 60], [60, 70], [-80, 20],
            [40, -60], [-30, 80], [80, 0], [0, -70]
        ];
        islandPositions.forEach(([x, z]) => {
            const size = 5 + Math.random() * 5;
            gameState.islands.push(new ProceduralIsland(x, z, size));
        });

        // Create initial vehicle
        const initialVehicle = new Vehicle(0, 0, 'ship', false);
        gameState.playerVehicles.push(initialVehicle);

        // Keyboard controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Vehicle movement
        function updateVehicleMovement() {
            if (gameState.playerVehicles.length === 0) return;
            
            const vehicle = gameState.playerVehicles[0];
            const speed = keys['ShiftLeft'] ? 1.0 : 0.4;
            
            // Forward/backward
            if (keys['KeyW']) {
                vehicle.velocity.z -= speed * Math.cos(vehicle.rotation);
                vehicle.velocity.x -= speed * Math.sin(vehicle.rotation);
            }
            if (keys['KeyS']) {
                vehicle.velocity.z += speed * Math.cos(vehicle.rotation) * 0.5;
                vehicle.velocity.x += speed * Math.sin(vehicle.rotation) * 0.5;
            }
            
            // Strafe
            if (keys['KeyA']) {
                vehicle.rotation += 0.05;
            }
            if (keys['KeyD']) {
                vehicle.rotation -= 0.05;
            }
            
            // Altitude (helicopter and submarine)
            if (vehicle.type === 'helicopter' || vehicle.type === 'submarine') {
                if (keys['KeyQ']) vehicle.velocity.y += 0.2;
                if (keys['KeyE']) vehicle.velocity.y -= 0.2;
            }
            
            // Update all vehicles
            gameState.playerVehicles.forEach(v => v.update(0.016, keys));
            gameState.aiVehicles.forEach(v => v.update(0.016));
        }

        // Camera system
        function updateCamera() {
            if (gameState.playerVehicles.length === 0) return;
            
            const champion = gameState.playerVehicles[0];
            
            switch(gameState.cameraMode) {
                case 'champion':
                    // Follow behind vehicle
                    const offset = new THREE.Vector3(
                        Math.sin(champion.rotation) * 40,
                        30,
                        Math.cos(champion.rotation) * 40
                    );
                    const targetPos = champion.position.clone().add(offset);
                    camera.position.lerp(targetPos, 0.05);
                    camera.lookAt(champion.position);
                    
                    // Disable volumetric lights
                    volumetricLights.forEach(light => light.visible = false);
                    break;
                    
                case 'cloud':
                    // Overhead following
                    const cloudPos = champion.position.clone();
                    cloudPos.y += 80;
                    camera.position.lerp(cloudPos, 0.05);
                    camera.lookAt(champion.position);
                    
                    volumetricLights.forEach(light => light.visible = false);
                    break;
                    
                case 'network':
                    // Center on all connected vehicles
                    const allVehicles = [...gameState.playerVehicles, ...gameState.aiVehicles];
                    if (allVehicles.length > 0) {
                        const center = new THREE.Vector3();
                        allVehicles.forEach(v => center.add(v.position));
                        center.divideScalar(allVehicles.length);
                        center.y += 60;
                        
                        camera.position.lerp(center, 0.05);
                        camera.lookAt(center.x, 0, center.z);
                    }
                    
                    volumetricLights.forEach(light => light.visible = false);
                    break;
                    
                case 'overhead':
                    // Wide overhead with volumetric lighting
                    camera.position.lerp(new THREE.Vector3(0, 120, 0), 0.05);
                    camera.lookAt(0, 0, 0);
                    
                    // Enable and animate volumetric lights
                    volumetricLights.forEach((light, i) => {
                        light.visible = true;
                        light.intensity = 2 + Math.sin(Date.now() * 0.001 + i) * 1;
                        light.position.x += Math.sin(Date.now() * 0.0005 + i) * 0.5;
                        light.position.z += Math.cos(Date.now() * 0.0005 + i) * 0.5;
                    });
                    
                    // Set widescreen aspect for overhead
                    camera.aspect = 16 / 9;
                    camera.updateProjectionMatrix();
                    break;
            }
        }

        // Update UI
        function updateUI() {
            document.getElementById('gold').textContent = '$' + gameState.gold;
            document.getElementById('fleet-size').textContent = gameState.playerVehicles.length;
            document.getElementById('ai-ships').textContent = gameState.aiVehicles.length;
            document.getElementById('score').textContent = gameState.score;
            
            if (gameState.playerVehicles.length > 0) {
                const v = gameState.playerVehicles[0];
                const types = {
                    ship: 'NAVAL SHIP',
                    truck: 'HEAVY TRUCK',
                    helicopter: 'HELICOPTER',
                    submarine: 'SUBMARINE'
                };
                document.getElementById('current-form').textContent = types[v.type] || v.type.toUpperCase();
                document.getElementById('altitude').textContent = v.position.y.toFixed(1) + 'm';
                document.getElementById('speed').textContent = v.velocity.length().toFixed(2);
            }
        }

        // Vehicle selection
        document.querySelectorAll('.vehicle-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const vehicleType = btn.dataset.vehicle;
                
                if (gameState.playerVehicles.length > 0) {
                    // Remove old vehicle
                    gameState.playerVehicles[0].remove();
                    gameState.playerVehicles = [];
                }
                
                // Create new vehicle
                const newVehicle = new Vehicle(0, 0, vehicleType, false);
                gameState.playerVehicles.push(newVehicle);
                gameState.currentVehicleType = vehicleType;
                
                document.querySelectorAll('.vehicle-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                
                logMemory(`Switched to ${vehicleType.toUpperCase()}`);
            });
        });

        // Camera controls
        document.getElementById('cam-champion').addEventListener('click', () => {
            gameState.cameraMode = 'champion';
            updateCameraButtons();
            logMemory('üìπ Champion View activated');
        });

        document.getElementById('cam-cloud').addEventListener('click', () => {
            gameState.cameraMode = 'cloud';
            updateCameraButtons();
            logMemory('‚òÅÔ∏è Cloud View activated');
        });

        document.getElementById('cam-network').addEventListener('click', () => {
            gameState.cameraMode = 'network';
            updateCameraButtons();
            logMemory('üåê Network View activated');
        });

        document.getElementById('cam-overhead').addEventListener('click', () => {
            gameState.cameraMode = 'overhead';
            updateCameraButtons();
            logMemory('üó∫Ô∏è Overhead View with volumetric lighting activated');
        });

        function updateCameraButtons() {
            document.querySelectorAll('.camera-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`cam-${gameState.cameraMode}`).classList.add('active');
        }

        // Fleet spawning
        document.getElementById('spawn-fleet').addEventListener('click', () => {
            const types = ['ship', 'truck', 'helicopter', 'submarine'];
            for (let i = 0; i < 4; i++) {
                const angle = (Math.PI * 2 * i) / 4;
                const radius = 30;
                const type = types[i % types.length];
                const vehicle = new Vehicle(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    type,
                    true
                );
                gameState.aiVehicles.push(vehicle);
            }
            logMemory('üöÅ Deployed multi-vehicle fleet');
        });

        // Battle toggle
        document.getElementById('start-battle').addEventListener('click', () => {
            gameState.battleActive = !gameState.battleActive;
            if (gameState.battleActive) {
                document.getElementById('battle-status').textContent = 'ON';
                document.getElementById('start-battle').classList.add('active');
                logMemory('‚öîÔ∏è Combat mode activated');
            } else {
                document.getElementById('battle-status').textContent = 'OFF';
                document.getElementById('start-battle').classList.remove('active');
                logMemory('Combat mode deactivated');
            }
        });

        document.getElementById('toggle-ai-build').addEventListener('click', () => {
            gameState.aiBuildEnabled = !gameState.aiBuildEnabled;
            document.getElementById('ai-build-status').textContent = gameState.aiBuildEnabled ? 'ON' : 'OFF';
            if (gameState.aiBuildEnabled) {
                document.getElementById('toggle-ai-build').classList.add('active');
                logMemory('ü§ñ AI construction enabled');
            } else {
                document.getElementById('toggle-ai-build').classList.remove('active');
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            animateWater();
            updateVehicleMovement();
            updateCamera();
            updateUI();
            
            renderer.render(scene, camera);
        }

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        logMemory('üéÆ Multi-Vehicle Command System Online');
        logMemory('üöó 4 vehicle types available: Ship, Truck, Helicopter, Submarine');
        logMemory('üìπ 4 camera modes: Champion, Cloud, Network, Overhead');
        
        animate();
    </script>
</body>
</html>
