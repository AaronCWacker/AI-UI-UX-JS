<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üèéÔ∏è‚úàÔ∏è AERO-STRIKE RALLY V10</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; cursor: crosshair; font-family: 'Impact', sans-serif; }
    
    /* HUD */
    #hud {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
    }
    #crosshair {
      position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
      border: 2px solid #0ff; border-radius: 50%; transform: translate(-50%, -50%);
      box-shadow: 0 0 10px #0ff; opacity: 0.8; transition: border-color 0.2s;
    }
    .cross-dot {
      position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
      background: #f00; transform: translate(-50%, -50%); border-radius: 50%;
    }

    #score-ui {
      position: absolute; top: 20px; left: 20px; color: #fff;
      text-shadow: 2px 2px 0 #000;
    }
    .mode-label { font-size: 24px; color: #ffff00; letter-spacing: 2px; }
    .score-val { font-size: 48px; color: #fff; }

    #controls-hint {
      position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.6);
      font-family: monospace; font-size: 11px; background: rgba(0,0,0,0.5); padding: 10px;
    }
    
    /* Mobile Controls (hidden on desktop) */
    #mobile-layer { display: none; }
    @media (pointer: coarse) {
      #mobile-layer { display: block; position: absolute; width:100%; height:100%; pointer-events:none; }
      .touch-btn { 
        position:absolute; pointer-events:auto; background:rgba(255,255,255,0.1); 
        border:2px solid rgba(255,255,255,0.4); border-radius:50%; color:#fff; 
        text-align:center; line-height:60px; font-size:12px;
      }
      #btn-fire { bottom: 80px; right: 20px; width: 80px; height: 80px; background: rgba(255,0,0,0.2); border-color:#f00; }
      #btn-transform { bottom: 180px; right: 20px; width: 60px; height: 60px; border-color:#ff0; color:#ff0; }
    }
  </style>
</head>
<body>

  <div id="hud">
    <div id="crosshair"><div class="cross-dot"></div></div>
    <div id="score-ui">
      <div id="mode-text" class="mode-label">CAR MODE</div>
      <div id="score-text" class="score-val">0</div>
    </div>
    <div id="controls-hint">
      [WASD] Pitch/Roll ‚Ä¢ [Q/E] Yaw ‚Ä¢ [Space] TRANSFORM<br>
      [Mouse] Aim/Fire ‚Ä¢ [Z/X] Throttle
    </div>
  </div>

  <div id="mobile-layer">
    <div id="btn-fire" class="touch-btn">FIRE</div>
    <div id="btn-transform" class="touch-btn">MORPH</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // =========================================================
    // 1. ENGINE CONFIG
    // =========================================================
    const C = {
      gravity: 0.9,
      carSpeed: 1.5,
      planeSpeed: 2.5,
      fireRate: 0.15,
      worldSize: 3000
    };

    let scene, camera, renderer, clock;
    let player;
    let projectiles = [];
    let particles = [];
    let enemies = []; // Swarm bots
    let buildings = []; // Destructible env
    
    // Inputs
    const input = { 
      w:0, s:0, a:0, d:0, q:0, e:0, z:0, x:0, space:false, click:false, 
      mouseX:0, mouseY:0 
    };

    let score = 0;
    
    // =========================================================
    // 2. SETUP
    // =========================================================
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050510);
      scene.fog = new THREE.FogExp2(0x050510, 0.0015);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 1, 4000);
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.4));
      const sun = new THREE.DirectionalLight(0xffaa00, 1);
      sun.position.set(100, 500, 100);
      sun.castShadow = true;
      scene.add(sun);

      buildWorld();
      
      player = new Hero();
      scene.add(player.mesh);

      // Spawn Enemy Swarm
      for(let i=0; i<8; i++) spawnEnemy();

      setupInputs();
      clock = new THREE.Clock();
      loop();
    }

    // Procedural Hollow Architecture (L-System style Stacking)
    function buildWorld() {
      // Floor
      const grid = new THREE.GridHelper(4000, 100, 0x004444, 0x111111);
      scene.add(grid);
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(4000,4000), new THREE.MeshPhongMaterial({color:0x050505}));
      floor.rotation.x = -Math.PI/2;
      scene.add(floor);

      const matBuilding = new THREE.MeshPhongMaterial({color:0x222233, shininess:10});
      const matGlow = new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true});

      // Towers
      for(let i=0; i<40; i++) {
        const x = (Math.random()-0.5)*2000;
        const z = (Math.random()-0.5)*2000;
        const height = 100 + Math.random()*200;
        
        const group = new THREE.Group();
        group.position.set(x, 0, z);

        // Hollow Tube (Torus Stack)
        const segments = Math.floor(height / 20);
        for(let j=0; j<segments; j++) {
           // Ring
           const ring = new THREE.Mesh(new THREE.TorusGeometry(15, 4, 8, 16), matBuilding);
           ring.rotation.x = Math.PI/2;
           ring.position.y = j * 25 + 10;
           ring.castShadow = true; ring.receiveShadow = true;
           
           // Random missing chunks for "Hollow" feel
           if(Math.random() > 0.2) group.add(ring);

           // Connectors (Cylinders)
           if(j < segments-1) {
             const pillar = new THREE.Mesh(new THREE.CylinderGeometry(2,2,25,6), matGlow);
             pillar.position.set(12, j*25+22.5, 0);
             group.add(pillar);
             const p2 = pillar.clone(); p2.position.set(-12, j*25+22.5, 0);
             group.add(p2);
           }
        }
        
        // Tag for collision
        group.userData = { hp: 100, type: 'building' };
        scene.add(group);
        buildings.push(group);
      }
    }

    function spawnEnemy() {
      const geo = new THREE.OctahedronGeometry(4);
      const mat = new THREE.MeshBasicMaterial({color:0xff0000, wireframe:true});
      const mesh = new THREE.Mesh(geo, mat);
      
      mesh.position.set((Math.random()-0.5)*1000, 50 + Math.random()*100, (Math.random()-0.5)*1000);
      mesh.userData = { hp: 3, vel: new THREE.Vector3() };
      
      scene.add(mesh);
      enemies.push(mesh);
    }

    // =========================================================
    // 3. PLAYER HERO CLASS (Transformer)
    // =========================================================
    class Hero {
      constructor() {
        this.mesh = new THREE.Group();
        this.mode = 'CAR'; // CAR or PLANE
        
        // -- Models --
        // Car Model
        this.carMesh = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 8), new THREE.MeshPhongMaterial({color:0xffcc00}));
        body.position.y = 1;
        const w1 = new THREE.Mesh(new THREE.CylinderGeometry(1,1,1,16), new THREE.MeshBasicMaterial({color:0x333}));
        w1.rotation.z = Math.PI/2; w1.position.set(-2.2, 1, 2.5);
        const w2 = w1.clone(); w2.position.set(2.2, 1, 2.5);
        const w3 = w1.clone(); w3.position.set(-2.2, 1, -2.5);
        const w4 = w1.clone(); w4.position.set(2.2, 1, -2.5);
        this.carMesh.add(body, w1, w2, w3, w4);
        
        // Plane Model
        this.planeMesh = new THREE.Group();
        const fus = new THREE.Mesh(new THREE.ConeGeometry(2, 12, 8), new THREE.MeshPhongMaterial({color:0x00aaff}));
        fus.rotation.x = -Math.PI/2;
        const wing = new THREE.Mesh(new THREE.BoxGeometry(12, 0.5, 4), new THREE.MeshPhongMaterial({color:0x0088cc}));
        wing.position.z = 2;
        const eng = new THREE.Mesh(new THREE.CylinderGeometry(1, 0.5, 3, 8), new THREE.MeshBasicMaterial({color:0xff9900}));
        eng.rotation.x = Math.PI/2; eng.position.z = 6; // Thruster
        this.planeMesh.add(fus, wing, eng);
        this.planeMesh.visible = false;

        this.mesh.add(this.carMesh, this.planeMesh);

        // Physics
        this.pos = new THREE.Vector3(0, 5, 0);
        this.vel = new THREE.Vector3();
        this.quat = new THREE.Quaternion();
        this.onGround = false;
        
        this.fireTimer = 0;
      }

      update(dt) {
        // -- TRANSFORM LOGIC --
        if (input.space && !this.lockSpace) {
           this.lockSpace = true; // Debounce
           if (this.mode === 'CAR' && !this.onGround) {
             this.switchMode('PLANE');
             this.vel.y += 20; // Pop up
             this.vel.z -= 20; // Boost fwd
           } else if (this.mode === 'PLANE') {
             this.switchMode('CAR');
           } else if (this.mode === 'CAR' && this.onGround) {
             // Just jump
             this.vel.y = 30;
             this.onGround = false;
           }
        }
        if (!input.space) this.lockSpace = false;

        // -- WEAPONS --
        if (input.click && this.fireTimer <= 0) {
           this.fire();
           this.fireTimer = C.fireRate;
        }
        if (this.fireTimer > 0) this.fireTimer -= dt;

        // -- MOVEMENT --
        if (this.mode === 'CAR') {
           this.updateCar(dt);
        } else {
           this.updatePlane(dt);
        }

        // Apply
        this.pos.add(this.vel.clone().multiplyScalar(dt));
        this.mesh.position.copy(this.pos);
        this.mesh.quaternion.copy(this.quat);
        
        // World Bounds
        if(this.pos.y < 0) { this.pos.y = 0; this.vel.y = 0; this.onGround = true; }
        
        // HUD
        document.getElementById('mode-text').innerText = this.mode + " MODE";
        document.getElementById('mode-text').style.color = this.mode==='CAR'?'#ffff00':'#00aaff';
      }

      switchMode(newMode) {
        this.mode = newMode;
        if (newMode === 'PLANE') {
          this.carMesh.visible = false;
          this.planeMesh.visible = true;
          // Align plane to camera look
          // (Simplified: Just keep momentum)
        } else {
          this.carMesh.visible = true;
          this.planeMesh.visible = false;
          // Reset rotation to flat
          this.quat.setFromEuler(new THREE.Euler(0, this.mesh.rotation.y, 0));
        }
        
        // Explosion Effect on Transform
        spawnExplosion(this.pos, 10, 0xffffff);
      }

      updateCar(dt) {
        // Car Physics (Simplified for reliability)
        const accel = input.w - input.s;
        const turn = input.a - input.d;
        
        const fwd = new THREE.Vector3(0,0,1).applyQuaternion(this.quat);
        
        if (this.onGround) {
           this.vel.add(fwd.multiplyScalar(accel * C.carSpeed));
           this.vel.multiplyScalar(0.96); // Friction
           
           // Turn
           if (this.vel.length() > 1) {
             const qRot = new THREE.Quaternion();
             qRot.setFromAxisAngle(new THREE.Vector3(0,1,0), -turn * 0.05);
             this.quat.multiply(qRot);
           }
        } else {
           this.vel.y -= C.gravity; // Gravity
        }
        
        // Align car to flat
        const euler = new THREE.Euler().setFromQuaternion(this.quat);
        euler.x *= 0.9; euler.z *= 0.9;
        this.quat.setFromEuler(euler);
      }

      updatePlane(dt) {
        // Flight Physics (6-DOF-ish)
        const pitch = input.w - input.s;
        const roll = input.a - input.d;
        const yaw = input.q - input.e;
        const thrust = (input.z ? 1 : 0) - (input.x ? 1 : 0); // Z/X throttle
        
        // Rotate
        const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), pitch * 0.03);
        const qRoll = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -roll * 0.03);
        const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), -yaw * 0.03);
        
        this.quat.multiply(qPitch).multiply(qRoll).multiply(qYaw);
        
        // Thrust
        const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(this.quat); // Plane model faces -Z locally? fix below
        // Actually model faces -Z check init
        // Cone points up Y... rotated -90 X... so it points -Z. Correct.
        
        // Auto-throttle baseline + input
        const speed = C.planeSpeed + (thrust * 1.0);
        this.vel.lerp(fwd.multiplyScalar(speed * 30), 0.05);
      }

      fire() {
        // Raycast from camera for aim point
        const ray = new THREE.Raycaster();
        // Map mouse -1 to 1
        const mouse = new THREE.Vector2(
          (input.mouseX / window.innerWidth) * 2 - 1,
          -(input.mouseY / window.innerHeight) * 2 + 1
        );
        ray.setFromCamera(mouse, camera);
        
        // Shoot direction
        const dir = ray.ray.direction.clone();
        
        // Spawn Projectile
        const p = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({color:0x00ff00}));
        p.position.copy(this.pos);
        p.userData = { vel: dir.multiplyScalar(300), life: 2.0 };
        scene.add(p);
        projectiles.push(p);
      }
    }

    // =========================================================
    // 4. SYSTEMS (Loop, Physics, FX)
    // =========================================================
    
    function spawnExplosion(pos, count, color) {
      for(let i=0; i<count; i++) {
        const p = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshBasicMaterial({color:color}));
        p.position.copy(pos);
        p.userData = { 
           vel: new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50),
           life: 1.0 + Math.random() 
        };
        scene.add(p);
        particles.push(p);
      }
    }

    function loop() {
      requestAnimationFrame(loop);
      const dt = Math.min(clock.getDelta(), 0.1);

      player.update(dt);

      // Projectiles
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.position.add(p.userData.vel.clone().multiplyScalar(dt));
        p.userData.life -= dt;
        
        // Collision Check (Buildings)
        // Simple dist check for speed
        let hit = false;
        
        // Check Enemies
        for(let e of enemies) {
           if(p.position.distanceTo(e.position) < 15) {
              spawnExplosion(e.position, 20, 0xff0000);
              // Reset enemy
              e.position.set((Math.random()-0.5)*1000, 100, (Math.random()-0.5)*1000);
              hit = true;
              score += 100;
              break;
           }
        }
        
        if (hit || p.userData.life <= 0) {
          scene.remove(p);
          projectiles.splice(i, 1);
        }
      }

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.position.add(p.userData.vel.clone().multiplyScalar(dt));
        p.scale.multiplyScalar(0.95);
        p.userData.life -= dt;
        if(p.userData.life <= 0) { scene.remove(p); particles.splice(i, 1); }
      }

      // Enemy AI (Follow Player)
      enemies.forEach(e => {
         const dir = player.pos.clone().sub(e.position).normalize();
         e.position.add(dir.multiplyScalar(20 * dt));
         e.rotation.x += dt; e.rotation.y += dt; // Spin
      });

      // Camera Chase
      const offset = new THREE.Vector3(0, 10, 30).applyQuaternion(player.quat);
      const camTarget = player.pos.clone().add(offset);
      camera.position.lerp(camTarget, 0.1);
      camera.lookAt(player.pos.clone().add(new THREE.Vector3(0,0,-100).applyQuaternion(player.quat))); // Look ahead

      // HUD Update
      document.getElementById('score-text').innerText = score;
      
      // Update Crosshair (Visual only, follows mouse)
      const ch = document.getElementById('crosshair');
      ch.style.left = input.mouseX + 'px';
      ch.style.top = input.mouseY + 'px';
      ch.style.borderColor = input.click ? '#f00' : '#0ff';

      renderer.render(scene, camera);
    }

    // =========================================================
    // 5. INPUT HANDLING
    // =========================================================
    function setupInputs() {
      // Keys
      window.addEventListener('keydown', e => {
         const k = e.key.toLowerCase();
         if(k==='w') input.w=1; if(k==='s') input.s=1;
         if(k==='a') input.a=1; if(k==='d') input.d=1;
         if(k==='q') input.q=1; if(k==='e') input.e=1;
         if(k==='z') input.z=1; if(k==='x') input.x=1;
         if(k===' ') input.space=true;
      });
      window.addEventListener('keyup', e => {
         const k = e.key.toLowerCase();
         if(k==='w') input.w=0; if(k==='s') input.s=0;
         if(k==='a') input.a=0; if(k==='d') input.d=0;
         if(k==='q') input.q=0; if(k==='e') input.e=0;
         if(k==='z') input.z=0; if(k==='x') input.x=0;
         if(k===' ') input.space=false;
      });
      
      // Mouse
      window.addEventListener('mousemove', e => {
        input.mouseX = e.clientX;
        input.mouseY = e.clientY;
      });
      window.addEventListener('mousedown', () => input.click = true);
      window.addEventListener('mouseup', () => input.click = false);

      // Mobile Touch
      const touchBind = (id, fnDown, fnUp) => {
         const el = document.getElementById(id);
         el.addEventListener('touchstart', e => { e.preventDefault(); fnDown(); });
         el.addEventListener('touchend', e => { e.preventDefault(); fnUp(); });
      };
      
      touchBind('btn-fire', () => input.click=true, () => input.click=false);
      touchBind('btn-transform', () => input.space=true, () => input.space=false);

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    init();
  </script>
</body>
</html>
