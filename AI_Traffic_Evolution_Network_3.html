<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Traffic V5: Hive Mind</title>
  <style>
    body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #0f0; }
    
    #ui {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0, 15, 0, 0.9); padding: 15px; border: 1px solid #0f0; border-radius: 8px;
      pointer-events: none; user-select: none; min-width: 200px;
      box-shadow: 0 0 20px rgba(0, 255, 0, 0.1);
    }
    
    .hud-text { font-size: 12px; color: #8f8; margin-bottom: 4px; }
    .hud-val { font-weight: bold; color: #fff; float: right; }
    
    #console-overlay {
      position: absolute; bottom: 10px; left: 10px; right: 10px; height: 100px;
      pointer-events: none; display: flex; flex-direction: column-reverse;
      font-family: monospace; font-size: 11px; color: rgba(255,255,255,0.5);
      overflow: hidden;
    }
    
    #start-btn {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #000; border: 2px solid #0f0; color: #0f0; padding: 20px 40px;
      font-size: 24px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
      box-shadow: 0 0 30px #0f0; transition: all 0.2s;
    }
    #start-btn:hover { background: #0f0; color: #000; box-shadow: 0 0 50px #0f0; }
  </style>
</head>
<body>

  <div id="ui">
    <div style="font-size: 16px; font-weight:bold; color:#fff; border-bottom:1px solid #0f0; padding-bottom:5px; margin-bottom:10px;">
      HIVE MIND V5
    </div>
    <div class="hud-text">EPOCH <span id="epoch" class="hud-val">1</span></div>
    <div class="hud-text">ALIVE <span id="alive" class="hud-val">0</span></div>
    <div class="hud-text">BEST FIT <span id="fitness" class="hud-val">0</span></div>
    <div class="hud-text">CONVOYS <span id="convoys" class="hud-val">0</span></div>
    <div style="margin-top:10px; font-size:10px; color:#5a5;">
      • 8 WHISKERS ACTIVE<br>
      • PACK COMM: ENABLED<br>
      • REVERSE LOGIC: AUTO
    </div>
  </div>

  <div id="console-overlay"></div>
  <button id="start-btn">Initialize Simulation</button>

  <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>

  <script>
    // =========================================================
    // CONFIGURATION
    // =========================================================
    const CONFIG = {
      popSize: 60,
      mutationRate: 0.15,
      speed: 1.0,
      viewDist: 25,
      commDist: 30, // Distance to "talk" to car in front
      worldSize: 1200
    };

    let scene, camera, renderer, clock;
    let cars = [], roads = [], obstacles = [];
    let isRunning = false;
    let epoch = 1;
    let globalBestBrain = null;

    // =========================================================
    // NEURAL NETWORK (MLP)
    // =========================================================
    class Brain {
      constructor(copyFrom) {
        // Inputs: 8 Whiskers + 4 Comm (Dist, Speed, IsLeader, Angle) + 2 Self (Speed, OnRoad) = 14 Inputs
        // Outputs: 4 (Throttle, Turn, Reverse, Yield)
        this.inputSize = 14;
        this.outputSize = 4;
        this.hiddenSize = 16;
        
        if (copyFrom) {
          this.w1 = this.mutate(copyFrom.w1);
          this.b1 = this.mutate(copyFrom.b1);
          this.w2 = this.mutate(copyFrom.w2);
          this.b2 = this.mutate(copyFrom.b2);
        } else {
          this.w1 = this.randomWeights(this.inputSize * this.hiddenSize);
          this.b1 = this.randomWeights(this.hiddenSize);
          this.w2 = this.randomWeights(this.hiddenSize * this.outputSize);
          this.b2 = this.randomWeights(this.outputSize);
        }
      }

      randomWeights(n) { return new Float32Array(n).map(() => Math.random() * 2 - 1); }

      mutate(weights) {
        const newW = new Float32Array(weights);
        for(let i=0; i<newW.length; i++) {
          if(Math.random() < CONFIG.mutationRate) {
            newW[i] += (Math.random() - 0.5) * 0.5; // Tweak
          }
        }
        return newW;
      }

      activate(inputs) {
        // Hidden Layer (Tanh)
        const hidden = new Float32Array(this.hiddenSize);
        for(let i=0; i<this.hiddenSize; i++) {
          let sum = 0;
          for(let j=0; j<this.inputSize; j++) sum += inputs[j] * this.w1[i*this.inputSize + j];
          hidden[i] = Math.tanh(sum + this.b1[i]);
        }
        
        // Output Layer (Sigmoid)
        const output = new Float32Array(this.outputSize);
        for(let i=0; i<this.outputSize; i++) {
          let sum = 0;
          for(let j=0; j<this.hiddenSize; j++) sum += hidden[j] * this.w2[i*this.hiddenSize + j];
          output[i] = 1 / (1 + Math.exp(-(sum + this.b2[i])));
        }
        return output;
      }
    }

    // =========================================================
    // CAR AGENT
    // =========================================================
    class Car {
      constructor(brain, x, z, rot) {
        this.brain = new Brain(brain);
        this.mesh = this.createMesh();
        this.mesh.position.set(x, 1, z);
        this.mesh.rotation.y = rot;
        
        this.velocity = 0;
        this.fitness = 0;
        this.dead = false;
        this.stuckTimer = 0;
        
        this.whiskers = this.createWhiskers();
        this.raycaster = new THREE.Raycaster();
      }

      createMesh() {
        const g = new THREE.Group();
        // Main Body
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(2, 1, 4),
          new THREE.MeshLambertMaterial({ color: 0x444444 })
        );
        body.position.y = 0.5;
        body.castShadow = true;
        g.add(body);

        // Status Light (Roof)
        this.light = new THREE.Mesh(
          new THREE.BoxGeometry(1, 0.5, 1),
          new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        this.light.position.set(0, 1.2, 0);
        g.add(this.light);

        return g;
      }

      createWhiskers() {
        // 8 Whiskers: FL, F, FR, SL, SR, RL, R, RR
        // Angle offsets relative to forward (0)
        const defs = [
          {a: 0.6, l: CONFIG.viewDist},   // FL
          {a: 0.2, l: CONFIG.viewDist*1.2}, // F (Longer)
          {a: 0, l: CONFIG.viewDist*1.2},   // Center (Longer)
          {a: -0.2, l: CONFIG.viewDist*1.2},// F
          {a: -0.6, l: CONFIG.viewDist},  // FR
          {a: 1.5, l: 8},  // Side L
          {a: -1.5, l: 8}, // Side R
          {a: 3.14, l: 10} // Rear
        ];

        const lines = [];
        const mat = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.4 });
        
        defs.forEach(d => {
          const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,0,1)]);
          const line = new THREE.Line(geo, mat.clone());
          scene.add(line); // Add to scene to avoid rotation complexity
          lines.push({ mesh: line, angle: d.a, len: d.l });
        });
        return lines;
      }

      update(dt, allCars) {
        if(this.dead) return;

        // 1. SENSORS
        const inputs = new Float32Array(14);
        const pos = this.mesh.position;
        const rot = this.mesh.rotation.y;
        
        let hitBuilding = false;
        let hitCar = false;
        let neighbor = null;
        let neighborDist = CONFIG.commDist;

        // Update Whiskers
        this.whiskers.forEach((w, i) => {
          const dir = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), rot + w.angle);
          const origin = pos.clone().add(new THREE.Vector3(0, 0.5, 0));
          
          this.raycaster.set(origin, dir);
          
          // Check Buildings
          const bHits = this.raycaster.intersectObjects(obstacles);
          let dist = w.len;
          let type = 0; // 0=Clear, 1=Building, 2=Car, 3=Grass

          if(bHits.length > 0) {
            dist = Math.min(dist, bHits[0].distance);
            if(dist < w.len) { type = 1; hitBuilding = true; }
          }
          
          // Check Cars (Manual distance check for optimization)
          // Ideally use raycaster, but for speed we might skip if many cars.
          // Let's use simplified logic for cars: closest one in cone.
          
          // Grass Logic (Ray tip check)
          const tip = origin.clone().add(dir.multiplyScalar(dist));
          const onRoad = checkOnRoad(tip.x, tip.z);
          if(!onRoad && type !== 1) { type = 3; }

          // Visualize
          const positions = w.mesh.geometry.attributes.position.array;
          positions[0] = origin.x; positions[1] = origin.y; positions[2] = origin.z;
          positions[3] = tip.x; positions[4] = tip.y; positions[5] = tip.z;
          w.mesh.geometry.attributes.position.needsUpdate = true;
          
          if(type === 1) w.mesh.material.color.setHex(0xff0000); // Building (Red)
          else if(type === 3) w.mesh.material.color.setHex(0xffff00); // Grass (Yellow)
          else w.mesh.material.color.setHex(0x00ffff); // Clear (Cyan)

          inputs[i] = 1.0 - (dist / w.len); // Normalize
        });

        // Communication Sensor (Front Cone)
        let bestC = null;
        let bestD = CONFIG.commDist;
        
        allCars.forEach(c => {
          if (c === this || c.dead) return;
          const d = pos.distanceTo(c.mesh.position);
          if (d < bestD) {
            // Check angle
            const toCar = c.mesh.position.clone().sub(pos).normalize();
            const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), rot);
            if (fwd.dot(toCar) > 0.7) { // In front
              bestD = d;
              bestC = c;
            }
          }
        });

        if (bestC) {
          // Color whisker blue if close car
          this.whiskers[2].mesh.material.color.setHex(0x0000ff); 
          inputs[8] = 1.0 - (bestD / CONFIG.commDist);
          inputs[9] = bestC.velocity;
          inputs[10] = (bestC.fitness > this.fitness + 10) ? 1 : 0; // Is Leader?
          inputs[11] = 0; // Angle diff placeholder
        }

        // Self State
        inputs[12] = this.velocity;
        inputs[13] = checkOnRoad(pos.x, pos.z) ? 1 : 0;

        // 2. THINK
        const [throttle, turn, reverse, yieldIntent] = this.brain.activate(inputs);

        // 3. ACT
        let gas = throttle;
        let steer = (turn - 0.5) * 2 * 0.15; // -0.15 to 0.15

        // Logic Overrides
        if (hitBuilding && this.velocity < 0.1) {
          gas = -0.5; // Auto Reverse
          steer = -steer; // Invert steering to back out
        }
        else if (reverse > 0.7) {
          gas = -0.3; // Intentional reverse
        }

        // Grass Slowdown
        if (inputs[13] === 0) {
           gas *= 0.4; // Slower on grass
        }

        // Yielding (If leader is close behind, move over)
        if (yieldIntent > 0.7 && checkOnRoad(pos.x, pos.z)) {
           // Shift perpendicular to road
           // Simplified: just steer right
           steer += 0.05; 
        }

        // Physics
        this.velocity += gas * 0.05;
        this.velocity *= 0.95; // Friction
        
        // Steering Snap (15, 30, 45, 90)
        // If steer is low (trying to go straight), snap to grid angle
        if (Math.abs(steer) < 0.02) {
           const snapAngles = [0, 0.26, 0.52, 0.78, 1.57, 3.14, 4.71, 6.28]; // Rads
           let bestA = rot;
           let minDiff = 999;
           // Normalize rot
           let r = rot % (Math.PI*2);
           if(r<0) r+=Math.PI*2;
           
           snapAngles.forEach(a => {
             const diff = Math.abs(r - a);
             if(diff < 0.1) {
               // Apply gentle torque towards 'a'
               this.mesh.rotation.y += (a - r) * 0.1;
             }
           });
        }
        
        this.mesh.rotation.y += steer;
        const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), this.mesh.rotation.y);
        this.mesh.position.add(fwd.multiplyScalar(this.velocity * 10 * dt));

        // 4. FITNESS
        if (checkOnRoad(pos.x, pos.z)) {
          this.fitness += this.velocity; // Speed points
          this.stuckTimer = 0;
          this.light.material.color.setHex(0x00ff00); // Green light
        } else {
          this.fitness -= 0.1; // Offroad penalty
          this.light.material.color.setHex(0xffff00); // Yellow light
        }

        // Stuck/Crash logic
        if (Math.abs(this.velocity) < 0.01) {
          this.stuckTimer += dt;
          if (this.stuckTimer > 3.0) this.dead = true; // Die if stuck too long
        }

        // Bounds death
        if (pos.x > 600 || pos.x < -600 || pos.z > 600 || pos.z < -600) this.dead = true;

        if (this.dead) {
          this.mesh.visible = false;
          this.whiskers.forEach(w => w.mesh.visible = false);
        }
      }
    }

    // =========================================================
    // SYSTEM
    // =========================================================
    function init() {
      // Init ThreeJS
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050505);
      
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
      camera.position.set(0, 300, 200);
      camera.lookAt(0,0,0);
      
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      const sun = new THREE.DirectionalLight(0xffffff, 0.8);
      sun.position.set(100,200,50);
      sun.castShadow = true;
      scene.add(sun);
      scene.add(new THREE.AmbientLight(0x404040));
      
      buildWorld();
      
      document.getElementById('start-btn').addEventListener('click', () => {
        document.getElementById('start-btn').style.display = 'none';
        isRunning = true;
        resetEpoch();
        animate();
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      clock = new THREE.Clock();
    }

    function buildWorld() {
      // Grass
      const g = new THREE.Mesh(new THREE.PlaneGeometry(1200,1200), new THREE.MeshStandardMaterial({color:0x051a05}));
      g.rotation.x = -Math.PI/2;
      scene.add(g);
      
      // Grid
      const spacing = 150;
      const w = 34;
      roads = [];
      const createRoad = (x,z,rw,rh) => {
        const m = new THREE.Mesh(new THREE.PlaneGeometry(rw,rh), new THREE.MeshLambertMaterial({color:0x222}));
        m.rotation.x = -Math.PI/2; m.position.set(x,0.1,z);
        scene.add(m);
        roads.push({x,z,w:rw,h:rh});
      };
      
      for(let i=-2; i<=2; i++) {
        createRoad(0, i*spacing, 1200, w);
        createRoad(i*spacing, 0, w, 1200);
      }
      
      // Obstacles
      obstacles = [];
      const box = new THREE.BoxGeometry(90, 30, 90);
      const mat = new THREE.MeshLambertMaterial({color:0x111133});
      for(let x=-2; x<=2; x++) {
        for(let z=-2; z<=2; z++) {
          // In grid centers
          const bx = x*spacing + spacing/2;
          const bz = z*spacing + spacing/2;
          // Don't place on outer edge
          if(Math.abs(bx)<600 && Math.abs(bz)<600) {
            const b = new THREE.Mesh(box, mat);
            b.position.set(bx, 15, bz);
            scene.add(b);
            obstacles.push(b);
          }
        }
      }
    }

    function checkOnRoad(x, z) {
      // Simple grid check
      const half = 17; // 34/2
      const spacing = 150;
      // Modulo logic for infinite grid effect (clamped to world)
      // Check Horizontal Roads (z is constant 0, 150...)
      for(let i=-2; i<=2; i++) {
        if (Math.abs(z - (i*spacing)) < half) return true;
      }
      // Check Vertical
      for(let i=-2; i<=2; i++) {
        if (Math.abs(x - (i*spacing)) < half) return true;
      }
      return false;
    }

    function resetEpoch() {
      // Cleanup
      cars.forEach(c => {
         scene.remove(c.mesh);
         c.whiskers.forEach(w => scene.remove(w.mesh));
      });
      cars = [];

      // Sort and pick best brain
      // (If this isn't first run)
      
      for(let i=0; i<CONFIG.popSize; i++) {
        // Spawn Point
        const rIndex = Math.floor(Math.random() * roads.length); // Pick random road segment (horizontal or vertical)
        // Since we stored them as massive strips, let's just pick random coords on grid
        let sx, sz, rot;
        if (Math.random() > 0.5) {
           // Horizontal
           sz = Math.floor(Math.random()*5 - 2) * 150;
           sx = (Math.random()-0.5)*800;
           rot = Math.random()>0.5 ? Math.PI/2 : -Math.PI/2;
        } else {
           // Vertical
           sx = Math.floor(Math.random()*5 - 2) * 150;
           sz = (Math.random()-0.5)*800;
           rot = Math.random()>0.5 ? 0 : Math.PI;
        }

        cars.push(new Car(globalBestBrain, sx, sz, rot));
        scene.add(cars[i].mesh);
      }
      
      document.getElementById('epoch').innerText = epoch;
      epoch++;
    }

    function animate() {
      requestAnimationFrame(animate);
      if(!isRunning) return;

      const dt = 0.1; // fixed step
      
      let bestFit = -999;
      let aliveCount = 0;
      let convoyCount = 0;

      cars.forEach(c => {
        if(!c.dead) {
           c.update(dt, cars);
           aliveCount++;
           if(c.fitness > bestFit) {
             bestFit = c.fitness;
             globalBestBrain = c.brain; // Realtime cloning of the king
           }
           
           // Heuristic for convoy: Is it close to another car?
           if (c.whiskers[2].mesh.material.color.getHex() === 0x0000ff) convoyCount++;
        }
      });
      
      // Update UI
      document.getElementById('alive').innerText = aliveCount;
      document.getElementById('fitness').innerText = Math.floor(bestFit);
      document.getElementById('convoys').innerText = convoyCount;

      // Auto Reset
      if(aliveCount === 0 || clock.getElapsedTime() > 45) {
         resetEpoch();
         clock.start();
      }

      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
