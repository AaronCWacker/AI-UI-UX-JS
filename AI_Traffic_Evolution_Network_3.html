<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Traffic - Safe Mode</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: monospace; color: #0f0; }
    
    /* Error Console Overlay */
    #console-log {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); pointer-events: none; z-index: 999;
      padding: 20px; box-sizing: border-box; display: none; color: #ff5555; white-space: pre-wrap;
    }

    /* Start Screen */
    #start-screen {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      text-align: center; z-index: 100; cursor: pointer;
      background: #111; padding: 20px; border: 2px solid #0f0;
    }
    
    #ui {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0, 20, 0, 0.8); padding: 10px; border: 1px solid #0f0;
      pointer-events: none; user-select: none;
    }
  </style>
</head>
<body>

  <div id="console-log"></div>

  <div id="start-screen">
    <h1>AI DRIVER SIM</h1>
    <p>Status: <span id="status-text">Loading Library...</span></p>
    <br>
    <div style="font-size: 20px; border: 1px solid #fff; padding: 10px; display:inline-block;">CLICK TO START</div>
  </div>

  <div id="ui" style="display:none;">
    <div>Fit: <span id="score">0</span></div>
    <div>Alive: <span id="alive">0</span></div>
    <div>Ray Logic: Active</div>
  </div>

  <script>
    window.onerror = function(msg, url, lineNo, columnNo, error) {
      const log = document.getElementById('console-log');
      log.style.display = 'block';
      log.innerHTML += `CRITICAL ERROR:\n${msg}\nLine: ${lineNo}\n\n`;
      return false;
    };
  </script>

  <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>

  <script>
    // =========================================================
    // GLOBAL SETUP
    // =========================================================
    let scene, camera, renderer, clock;
    let cars = [];
    let roads = [];
    let obstacles = [];
    let isRunning = false;
    let epochTime = 0;

    const WORLD_SIZE = 1000;

    // Check if THREE loaded
    window.onload = function() {
      const status = document.getElementById('status-text');
      if (typeof THREE === 'undefined') {
        status.innerText = "ERROR: Three.js failed to load. Check internet.";
        status.style.color = "red";
      } else {
        status.innerText = "Ready. Engine Loaded.";
        status.style.color = "#0f0";
        
        document.getElementById('start-screen').addEventListener('click', () => {
          document.getElementById('start-screen').style.display = 'none';
          document.getElementById('ui').style.display = 'block';
          try {
            initGame();
          } catch(e) {
            alert("Crash during init: " + e.message);
          }
        });
      }
    };

    // =========================================================
    // GAME ENGINE
    // =========================================================
    function initGame() {
      // 1. Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);
      
      // 2. Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
      camera.position.set(0, 200, 100); // High up view
      camera.lookAt(0, 0, 0);

      // 3. Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 4. Light
      const amb = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(amb);
      const sun = new THREE.DirectionalLight(0xffffff, 1);
      sun.position.set(100, 200, 50);
      scene.add(sun);

      // 5. Build World
      buildEnvironment();

      // 6. Spawn Cars
      resetPopulation();

      // 7. Start Loop
      clock = new THREE.Clock();
      isRunning = true;
      animate();
    }

    function buildEnvironment() {
      // Grass
      const grass = new THREE.Mesh(
        new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE),
        new THREE.MeshLambertMaterial({ color: 0x0b200b })
      );
      grass.rotation.x = -Math.PI / 2;
      scene.add(grass);

      // Grid Roads
      const spacing = 150;
      const width = 30;
      roads = [];
      
      const createRoad = (x, z, w, h, type) => {
        const r = new THREE.Mesh(
          new THREE.PlaneGeometry(w, h),
          new THREE.MeshLambertMaterial({ color: 0x444444 })
        );
        r.rotation.x = -Math.PI / 2;
        r.position.set(x, 0.1, z);
        scene.add(r);
        
        // Store logical data for the Brain
        if(type === 'horz') {
           roads.push({ xMin: x - w/2, xMax: x + w/2, zMin: z - h/2, zMax: z + h/2, cx: x, cz: z });
        } else {
           roads.push({ xMin: x - w/2, xMax: x + w/2, zMin: z - h/2, zMax: z + h/2, cx: x, cz: z });
        }
      };

      // Draw 3x3 Grid
      for(let i = -1; i <= 1; i++) {
        createRoad(0, i*spacing, WORLD_SIZE, width, 'horz'); // Horizontal
        createRoad(i*spacing, 0, width, WORLD_SIZE, 'vert'); // Vertical
      }
      
      // Add Blocks (Buildings) between roads
      obstacles = [];
      const boxGeo = new THREE.BoxGeometry(80, 20, 80);
      const boxMat = new THREE.MeshLambertMaterial({ color: 0x222255 });
      
      for(let x = -1; x <= 1; x++) {
        for(let z = -1; z <= 1; z++) {
          // Calculate center of the square between roads
          let bx = x * spacing + (spacing/2); 
          let bz = z * spacing + (spacing/2);
          
          // Only place if it doesn't overlap the center intersection
          const b = new THREE.Mesh(boxGeo, boxMat);
          b.position.set(bx - spacing/2 + 75, 10, bz - spacing/2 + 75); // Offset hack to center in grid holes
          scene.add(b);
          obstacles.push(b);
        }
      }
    }

    // =========================================================
    // SIMPLE CAR LOGIC (No complex classes to minimize errors)
    // =========================================================
    function resetPopulation() {
      // Remove old
      cars.forEach(c => { scene.remove(c.mesh); scene.remove(c.whiskerObj); });
      cars = [];

      for(let i=0; i<40; i++) {
        spawnCar();
      }
    }

    function spawnCar() {
      const mesh = new THREE.Group();
      
      // Body
      const body = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 5), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
      body.position.y = 0.75;
      mesh.add(body);
      
      // Nose indicator
      const nose = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
      nose.position.set(0, 1.5, 1.5);
      mesh.add(nose);

      // Whisker Lines (Visuals)
      const whiskerMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });
      const whiskerGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,10)]);
      const whiskerObj = new THREE.Group();
      
      // Create 3 Visual Whiskers
      const wL = new THREE.Line(whiskerGeo.clone(), whiskerMat.clone());
      const wC = new THREE.Line(whiskerGeo.clone(), whiskerMat.clone());
      const wR = new THREE.Line(whiskerGeo.clone(), whiskerMat.clone());
      whiskerObj.add(wL); whiskerObj.add(wC); whiskerObj.add(wR);
      
      scene.add(mesh);
      scene.add(whiskerObj);

      // Random Road Start
      const startRoad = roads[Math.floor(Math.random() * roads.length)];
      
      // Align car
      let sx, sz, rot;
      if (Math.abs(startRoad.xMax - startRoad.xMin) > Math.abs(startRoad.zMax - startRoad.zMin)) {
        // Horizontal road
        sx = (Math.random() - 0.5) * 500;
        sz = startRoad.cz;
        rot = Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2;
      } else {
        // Vertical road
        sx = startRoad.cx;
        sz = (Math.random() - 0.5) * 500;
        rot = Math.random() > 0.5 ? 0 : Math.PI;
      }

      mesh.position.set(sx, 0.5, sz);
      mesh.rotation.y = rot;

      const car = {
        mesh: mesh,
        whiskerObj: whiskerObj,
        lines: [wL, wC, wR],
        velocity: 0,
        brain: createRandomBrain(),
        fitness: 0,
        dead: false
      };
      cars.push(car);
    }

    function createRandomBrain() {
      // Very simple weights: 3 inputs (L, C, R whiskers) -> 2 outputs (Steer, Gas)
      return {
        w: Array(6).fill(0).map(() => Math.random()*2 - 1)
      };
    }

    // =========================================================
    // MAIN LOOP
    // =========================================================
    function animate() {
      requestAnimationFrame(animate);
      if(!isRunning) return;

      const dt = 0.1; // Fixed timestep for stability
      const raycaster = new THREE.Raycaster();
      let bestFit = -999;
      let aliveCount = 0;

      cars.forEach(car => {
        if(car.dead) {
           car.mesh.visible = false;
           car.whiskerObj.visible = false;
           return;
        }
        aliveCount++;

        // 1. Raycast (Whiskers)
        // Angles: Left(0.5), Center(0), Right(-0.5)
        const angles = [0.6, 0, -0.6];
        const inputs = [];
        
        // Update Whisker Visual Position
        car.whiskerObj.position.copy(car.mesh.position);
        car.whiskerObj.rotation.y = car.mesh.rotation.y;

        let onRoad = checkOnRoad(car.mesh.position.x, car.mesh.position.z);
        let grassTouch = false;

        angles.forEach((ang, idx) => {
          const dir = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), car.mesh.rotation.y + ang);
          const origin = car.mesh.position.clone().add(new THREE.Vector3(0, 1, 0));
          
          raycaster.set(origin, dir);
          const hits = raycaster.intersectObjects(obstacles);
          let dist = 15; // Max view
          
          if(hits.length > 0) {
            dist = Math.min(dist, hits[0].distance);
          }
          
          // Check tip for grass logic
          const tip = origin.clone().add(dir.multiplyScalar(dist));
          const tipOnRoad = checkOnRoad(tip.x, tip.z);
          
          // VISUALS
          const line = car.lines[idx];
          const positions = line.geometry.attributes.position.array;
          // Local coords for line inside rotation group
          const localDir = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), ang);
          const localTip = localDir.multiplyScalar(dist);
          
          positions[3] = localTip.x; positions[4] = 0; positions[5] = localTip.z;
          line.geometry.attributes.position.needsUpdate = true;
          
          if (onRoad && !tipOnRoad) {
             grassTouch = true;
             line.material.color.setHex(0xffff00); // Warning Yellow
          } else if (dist < 15) {
             line.material.color.setHex(0xff0000); // Hit Wall Red
          } else {
             line.material.color.setHex(0x00ff00); // Clear Green
          }

          inputs.push(dist/15); // Normalize 0..1
        });

        // 2. Logic / Brain
        // Brain: [w0, w1, w2] -> Steer, [w3, w4, w5] -> Gas
        let steer = 0;
        let gas = 1;

        // Simple Heuristic Override (Since "nothing was working", let's code the "Self Training" logic directly first)
        // Rule: Avoid short rays, Seek long rays.
        if (inputs[0] < inputs[2]) steer = -0.15; // Left blocked, go right
        else if (inputs[2] < inputs[0]) steer = 0.15; // Right blocked, go left
        
        // Rule: "Brake if whiskers touch grass"
        if (onRoad && grassTouch) {
           gas = -0.5; // Reverse/Brake
        } 
        // Rule: "If in grass, seek road"
        else if (!onRoad) {
           gas = 0.2; // Slow crawl
           // Basic homing: Turn towards 0,0 (center of map) as a fallback since roads are grid
           const angleToCenter = Math.atan2(-car.mesh.position.x, -car.mesh.position.z);
           // very rough steering towards center
           steer = 0.1; 
        }

        // 3. Move
        car.velocity += gas * 0.05;
        car.velocity *= 0.95; // Friction
        
        car.mesh.rotation.y += steer;
        const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), car.mesh.rotation.y);
        car.mesh.position.add(fwd.multiplyScalar(car.velocity * 10 * dt));

        // 4. Score
        if (onRoad) car.fitness += car.velocity;
        else car.fitness -= 0.1;

        if (car.fitness > bestFit) bestFit = car.fitness;

        // Kill bounds
        if (car.mesh.position.x > 600 || car.mesh.position.x < -600) car.dead = true;
      });
      
      // Update UI
      document.getElementById('score').innerText = Math.floor(bestFit);
      document.getElementById('alive').innerText = aliveCount;
      
      renderer.render(scene, camera);
      
      // Auto Reset if all dead or long time
      if(aliveCount === 0 || clock.getElapsedTime() > 30) {
        resetPopulation();
        clock.start();
      }
    }

    function checkOnRoad(x, z) {
      // Simple Grid check
      // Roads are at x=0, 150, -150 (+/- width/2)
      // And z=0, 150, -150
      const halfW = 15; // 30 width / 2
      const locs = [0, 150, -150];
      
      let onX = false;
      let onZ = false;
      
      locs.forEach(l => {
        if (Math.abs(x - l) < halfW) onX = true;
        if (Math.abs(z - l) < halfW) onZ = true;
      });
      
      // Since it's a grid, if you are within the X strips OR the Z strips, you are on road.
      return onX || onZ;
    }

    // Handle Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

  </script>
</body>
</html>
