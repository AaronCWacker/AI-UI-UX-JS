<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üèéÔ∏è AllAI Road Rally: Arcade Edition</title>
  <style>
    body { margin:0; overflow:hidden; font-family: 'Segoe UI', Tahoma, monospace; background:#050505; color:#0f0; }
    
    /* UI Container */
    #ui {
      position:absolute; top:10px; left:10px; 
      background:rgba(0, 10, 0, 0.9); border: 1px solid #0f0;
      padding:15px; border-radius:8px; z-index:100; min-width:280px;
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
    }
    
    /* Controls Panel */
    #controls {
      position:absolute; top:10px; right:10px; 
      background:rgba(0, 0, 0, 0.8); border: 1px solid #444;
      padding:15px; border-radius:8px; z-index:100; min-width:260px;
      color: #ccc;
    }

    button {
      background:#004400; border:1px solid #0f0; color:#0f0; 
      padding:8px 12px; margin:4px; cursor:pointer; font-family:inherit;
      text-transform: uppercase; font-size: 11px; letter-spacing: 1px;
      transition: all 0.2s;
    }
    button:hover { background:#0f0; color:#000; box-shadow: 0 0 10px #0f0; }

    input, textarea {
      width:100%; background:#111; color:#0f0; border:1px solid #333;
      padding:8px; margin-top:5px; font-family: monospace; font-size:12px;
    }

    /* HUD Elements */
    .hud-row { display:flex; justify-content:space-between; margin-bottom:4px; font-size:12px; }
    .hud-label { color: #888; }
    .hud-val { font-weight:bold; color: #fff; }
    .highlight { color:#0f0; font-weight:bold; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 5px; margin-bottom: 10px; display:block; }
    
    /* Connection Bar */
    .progress-bar { width:100%; height:4px; background:#222; margin-top:10px; }
    .progress-fill { height:100%; background:#0f0; width:0%; transition:width 0.3s ease; }

    /* Chat Area */
    #chatHistory {
      max-height: 100px; overflow-y: auto; font-size: 11px; color: #aaa; margin-top: 10px; border-top: 1px solid #333; padding-top: 5px;
    }
    .chat-msg { margin-bottom: 2px; }
    .chat-name { color: #0f0; font-weight: bold; }

  </style>
</head>

<body>

  <div id="ui">
    <span class="highlight">üèéÔ∏è ROAD RALLY: ARCADE</span>
    
    <div class="hud-row"><span class="hud-label">ROOM:</span> <span id="roomLabel" class="hud-val">LOBBY</span></div>
    <div class="hud-row"><span class="hud-label">DRIVER:</span> <span id="youLabel" class="hud-val">--</span></div>
    <div class="hud-row"><span class="hud-label">PLAYERS:</span> <span id="playerCount" class="hud-val">0</span></div>
    <div class="hud-row"><span class="hud-label">CAMERA:</span> <span id="camLabel" class="hud-val">CHASE</span></div>
    <div class="hud-row"><span class="hud-label">PING:</span> <span id="pingLabel" class="hud-val">0ms</span></div>
    
    <div class="progress-bar"><div class="progress-fill" id="netProgress"></div></div>
    <div style="font-size:10px; color:#666; margin-top:5px;">STATUS: <span id="netStatus">Offline</span></div>
  </div>

  <div id="controls">
    <span class="highlight" style="color:#fff; border-color:#555">MULTIPLAYER SETUP</span>
    
    <div style="font-size:10px; color:#888;">SPACE ID</div>
    <input id="spaceId" value="awacke1/Stateful_Multiplayer_Gradio" />

    <div style="display:flex; gap:5px; margin-top:5px;">
      <input id="roomInput" value="RACE1" placeholder="Room Name" />
      <input id="nameInput" placeholder="Your Name" />
    </div>

    <div style="margin-top:10px; display:flex; flex-wrap:wrap;">
      <button id="connectBtn">Connect</button>
      <button id="joinBtn">Join Race</button>
      <button id="cameraBtn">Cam [C]</button>
    </div>

    <div style="margin-top:15px;">
      <span class="highlight" style="font-size:12px; color:#fff;">COMMUNICATIONS</span>
      <div id="chatHistory"></div>
      <div style="display:flex; margin-top:5px;">
        <input id="chatInput" placeholder="Say something..." />
        <button id="sendBtn" style="width:60px;">Send</button>
      </div>
    </div>
    
    <div style="margin-top:10px; font-size:10px; text-align:center; color:#555;">
      WASD / Arrows to Drive ‚Ä¢ SPACE Brake
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script type="module">
    import { Client } from "https://cdn.jsdelivr.net/npm/@gradio/client/+esm";

    // --- UTILS ---
    const $ = (id) => document.getElementById(id);
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    function nowMs(){ return performance.now(); }

    // --- GAME STATE ---
    let app = null;
    let connected = false;
    let room = "LOBBY";
    let myName = "Racer";
    let mySeat = null;
    
    // --- THREE JS ---
    let scene, camera, renderer, clock;
    let cars = new Map(); // seat -> Car object
    let roadRects = [];
    let buildings = [];
    
    // Camera Modes
    const CAM_MODES = ["CHASE", "TOP_DOWN", "OVERVIEW"];
    let camIndex = 0;

    // Inputs
    const input = { up:false, down:false, left:false, right:false, brake:false };

    // =========================================================
    // 1. CAR CLASS (Fun Dynamics + Visuals)
    // =========================================================
    class Car {
      constructor(colorHex, isMe=false){
        this.isMe = isMe;
        this.group = new THREE.Group();

        // CHASSIS
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(2, 0.8, 4),
          new THREE.MeshLambertMaterial({ color: colorHex })
        );
        body.position.y = 0.6;
        body.castShadow = true;
        
        // CABIN
        const cabin = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 0.6, 2),
          new THREE.MeshLambertMaterial({ color: 0x222222 })
        );
        cabin.position.y = 1.0;
        cabin.position.z = -0.5;
        
        // HEADLIGHTS (Visual Mesh)
        const lLight = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.1), new THREE.MeshBasicMaterial({color:0xffffaa}));
        lLight.position.set(-0.6, 0.6, 2.0);
        const rLight = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.1), new THREE.MeshBasicMaterial({color:0xffffaa}));
        rLight.position.set(0.6, 0.6, 2.0);

        // TAILLIGHTS
        const tLightMat = new THREE.MeshBasicMaterial({color:0xff0000});
        const tl = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.1), tLightMat);
        tl.position.set(-0.6, 0.6, -2.0);
        const tr = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.1), tLightMat);
        tr.position.set(0.6, 0.6, -2.0);

        this.group.add(body, cabin, lLight, rLight, tl, tr);

        // DYNAMIC LIGHTS (Spotlights for night feel)
        if (isMe) {
          const spot = new THREE.SpotLight(0xffffee, 2, 60, 0.5, 0.5, 1);
          spot.position.set(0, 2, 1);
          spot.target.position.set(0, 0, 20);
          this.group.add(spot);
          this.group.add(spot.target);
        }

        // WHISKERS (Visual Rays)
        this.whiskers = [];
        const wAngles = [0.8, 0.4, 0, -0.4, -0.8];
        const wMat = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent:true, opacity:0.3 });
        wAngles.forEach(a => {
           const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,0,12)]);
           const line = new THREE.Line(geo, wMat.clone());
           line.visible = true;
           this.group.add(line); // Attached to group so they rotate with car
           // Store data for raycasting
           this.whiskers.push({ mesh: line, angle: a, len: 12 });
        });

        this.group.position.set(0, 1, 0);
        
        // PHYSICS STATE
        this.velocity = 0;
        this.drift = 0;
        this.maxSpeed = 40;
        this.acceleration = 30;
        this.friction = 0.96;
        
        this.raycaster = new THREE.Raycaster();
      }

      setPose(p){
        // For remote cars, just teleport/lerp
        this.group.position.x = p.x;
        this.group.position.z = p.z;
        this.group.rotation.y = p.ry;
        this.velocity = p.v || 0;
      }

      getPose(){
        return {
          x: this.group.position.x,
          z: this.group.position.z,
          ry: this.group.rotation.y,
          v: this.velocity
        };
      }

      update(dt, input) {
        // 1. Raycast Whiskers (Visual + Logic)
        const pos = this.group.position;
        const rot = this.group.rotation.y;
        
        // Update whiskers visually
        this.whiskers.forEach(w => {
           // We need world coordinates for raycasting
           const origin = pos.clone().add(new THREE.Vector3(0,0.5,0));
           const dir = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), rot + w.angle);
           
           this.raycaster.set(origin, dir);
           const hits = this.raycaster.intersectObjects(buildings);
           
           let dist = w.len;
           let hit = false;
           if(hits.length > 0) {
             dist = Math.min(dist, hits[0].distance);
             if (dist < w.len) hit = true;
           }

           // Visual update (local space to the group)
           // Actually, standard Line geometry is hard to update locally when group rotates.
           // Easier trick: Toggle color if hit.
           if (hit) w.mesh.material.color.setHex(0xff0000);
           else w.mesh.material.color.setHex(0x00ff00);
        });

        // 2. Physics
        let throttle = (input.up ? 1 : 0) - (input.down ? 1 : 0);
        let turn = (input.left ? 1 : 0) - (input.right ? 1 : 0);
        
        // Acceleration
        if (throttle !== 0) {
          this.velocity += throttle * this.acceleration * dt;
        }

        // Friction / Drag
        if (input.brake) {
          this.velocity *= 0.90; // Hard brake
        } else {
          this.velocity *= this.friction; // Coasting
        }

        // Turn Logic (Drift feel)
        if (Math.abs(this.velocity) > 0.5) {
          const turnSpeed = Math.min(Math.abs(this.velocity)/10, 2.5);
          this.group.rotation.y += turn * turnSpeed * dt;
        }

        // Apply Velocity
        const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), this.group.rotation.y);
        this.group.position.add(fwd.multiplyScalar(this.velocity * dt));

        // Bounds Check
        const limit = 400;
        if (this.group.position.x > limit) this.group.position.x = limit;
        if (this.group.position.x < -limit) this.group.position.x = -limit;
        if (this.group.position.z > limit) this.group.position.z = limit;
        if (this.group.position.z < -limit) this.group.position.z = -limit;
      }
    }

    // =========================================================
    // 2. WORLD GENERATION
    // =========================================================
    function init3D(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050510);
      scene.fog = new THREE.FogExp2(0x050510, 0.002);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      
      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Lights
      const amb = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(amb);
      const moon = new THREE.DirectionalLight(0xaaccff, 0.5);
      moon.position.set(100, 200, 100);
      moon.castShadow = true;
      scene.add(moon);

      createEnvironment();
      clock = new THREE.Clock();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function createEnvironment(){
      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(1000, 1000),
        new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 })
      );
      ground.rotation.x = -Math.PI/2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid Roads
      const spacing = 120;
      const width = 30;
      const roadMat = new THREE.MeshLambertMaterial({color:0x333333});

      // Create a Grid
      for(let x=-360; x<=360; x+=spacing){
        const r = new THREE.Mesh(new THREE.PlaneGeometry(width, 1000), roadMat);
        r.rotation.x = -Math.PI/2;
        r.position.set(x, 0.05, 0);
        r.receiveShadow = true;
        scene.add(r);
      }
      for(let z=-360; z<=360; z+=spacing){
        const r = new THREE.Mesh(new THREE.PlaneGeometry(1000, width), roadMat);
        r.rotation.x = -Math.PI/2;
        r.position.set(0, 0.06, z); // slight offset to prevent z-fighting
        r.receiveShadow = true;
        scene.add(r);
      }

      // Buildings
      buildings = [];
      const boxGeo = new THREE.BoxGeometry(1,1,1);
      const bMat = new THREE.MeshLambertMaterial({color:0x111122});
      
      for(let x=-360; x<=360; x+=spacing){
        for(let z=-360; z<=360; z+=spacing){
           // Place buildings in the empty squares
           const bx = x + spacing/2;
           const bz = z + spacing/2;
           if (Math.abs(bx) < 450 && Math.abs(bz) < 450) {
             const h = 20 + Math.random()*60;
             const w = spacing - width - 10;
             const b = new THREE.Mesh(boxGeo, bMat);
             b.position.set(bx, h/2, bz);
             b.scale.set(w, h, w);
             b.castShadow = true; b.receiveShadow = true;
             scene.add(b);
             buildings.push(b);
           }
        }
      }
    }

    // =========================================================
    // 3. MULTIPLAYER LOGIC (Gradio)
    // =========================================================
    
    // Helper to pick car color based on seat ID
    function getColor(seat) {
      const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0x00ffff, 0xff00ff, 0xff8800, 0x88ff00];
      return colors[seat % colors.length];
    }

    function ensureCar(seat) {
       if (cars.has(seat)) return cars.get(seat);
       const isMe = (seat === mySeat);
       const car = new Car(getColor(seat), isMe);
       // Spawn location logic
       car.group.position.set((seat%5)*30, 1, 0);
       scene.add(car.group);
       cars.set(seat, car);
       return car;
    }

    async function connect(){
      $("netStatus").textContent = "Connecting...";
      $("netProgress").style.width = "50%";
      try {
        app = await Client.connect($("spaceId").value);
        connected = true;
        $("netStatus").textContent = "Online";
        $("netStatus").style.color = "#0f0";
        $("netProgress").style.width = "100%";
        startLoops();
      } catch(e) {
        $("netStatus").textContent = "Error";
        $("netStatus").style.color = "#f00";
        console.error(e);
      }
    }

    async function joinRoom() {
      if(!connected) await connect();
      room = $("roomInput").value;
      myName = $("nameInput").value || "Racer"+Math.floor(Math.random()*100);
      
      const res = await app.predict("/cmd", [room, `join ${myName}`]);
      // Get state immediately to find seat
      const s = await app.predict("/state", [room]);
      const data = s.data[0]; // Gradio returns array
      
      if(data.you && data.you.joined) {
         mySeat = data.you.seat;
         $("youLabel").textContent = myName;
         $("roomLabel").textContent = room;
         ensureCar(mySeat);
      }
    }

    async function sendPose() {
      if(!connected || mySeat === null) return;
      const car = cars.get(mySeat);
      if(!car) return;
      const pose = car.getPose();
      await app.predict("/cmd", [room, `put pose:${mySeat} ${JSON.stringify(pose)}`]);
    }

    async function pollState() {
       if(!connected) return;
       const t0 = nowMs();
       const res = await app.predict("/state", [room]);
       const dt = Math.round(nowMs() - t0);
       $("pingLabel").textContent = dt + "ms";

       const data = res.data[0];
       if(!data) return;

       // Update roster count
       $("playerCount").textContent = data.roster.length;

       // Apply Remote Poses
       const kv = data.public.kv;
       Object.keys(kv).forEach(key => {
          if(key.startsWith("pose:")) {
             const seat = parseInt(key.split(":")[1]);
             if(seat !== mySeat) {
                const pose = JSON.parse(kv[key]);
                const car = ensureCar(seat);
                
                // Simple interpolation
                const currentPos = car.group.position;
                const targetPos = new THREE.Vector3(pose.x, 1, pose.z);
                currentPos.lerp(targetPos, 0.3);
                
                // Rotation lerp
                let dRot = pose.ry - car.group.rotation.y;
                // shortest path angle
                while (dRot > Math.PI) dRot -= Math.PI*2;
                while (dRot < -Math.PI) dRot += Math.PI*2;
                car.group.rotation.y += dRot * 0.3;
                
                car.velocity = pose.v;
             }
          }
       });

       // Chat
       processEvents(data.events_tail);
    }

    let lastSeq = -1;
    function processEvents(events) {
       if(!events) return;
       events.forEach(e => {
          if(e.seq > lastSeq) {
             lastSeq = e.seq;
             if(e.kind === 'say') {
                const div = document.createElement('div');
                div.className = 'chat-msg';
                div.innerHTML = `<span class="chat-name">${e.data.name}:</span> ${e.data.text}`;
                $("chatHistory").prepend(div);
             }
          }
       });
    }

    function startLoops() {
       // State polling (~1s)
       setInterval(pollState, 1000);
       // Pose sending (~100ms)
       setInterval(sendPose, 100);
    }

    // =========================================================
    // 4. CONTROLS & RENDER
    // =========================================================
    
    // Keyboard
    window.addEventListener("keydown", (e)=>{
      if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") input.up = true;
      if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") input.down = true;
      if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") input.left = true;
      if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") input.right = true;
      if (e.key === " ") input.brake = true;
      if (e.key.toLowerCase() === "c") toggleCamera();
    });
    window.addEventListener("keyup", (e)=>{
      if (e.key === "ArrowUp" || e.key.toLowerCase() === "w") input.up = false;
      if (e.key === "ArrowDown" || e.key.toLowerCase() === "s") input.down = false;
      if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") input.left = false;
      if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") input.right = false;
      if (e.key === " ") input.brake = false;
    });

    // Camera Toggle
    function toggleCamera() {
      camIndex = (camIndex + 1) % CAM_MODES.length;
      $("camLabel").textContent = CAM_MODES[camIndex];
    }
    
    // UI Buttons
    $("connectBtn").onclick = connect;
    $("joinBtn").onclick = joinRoom;
    $("cameraBtn").onclick = toggleCamera;
    $("sendBtn").onclick = async () => {
       const txt = $("chatInput").value;
       if(txt && connected) {
          await app.predict("/cmd", [room, `say ${txt}`]);
          $("chatInput").value = "";
       }
    };

    function updateCameraPos(car) {
       const mode = CAM_MODES[camIndex];
       const target = car.group.position.clone();
       
       if (mode === "CHASE") {
          // Standard racing cam
          const offset = new THREE.Vector3(0, 15, 30).applyAxisAngle(new THREE.Vector3(0,1,0), car.group.rotation.y);
          const pos = target.clone().add(offset);
          camera.position.lerp(pos, 0.1);
          camera.lookAt(target.x, target.y + 5, target.z);
       } 
       else if (mode === "TOP_DOWN") {
          // Drone view directly above
          camera.position.lerp(new THREE.Vector3(target.x, 150, target.z), 0.1);
          camera.lookAt(target);
          // Keep rotation aligned north for map feel, or car rotation?
          // Let's keep North up for map feel
          camera.rotation.z = 0; 
       }
       else if (mode === "OVERVIEW") {
          // Slow spin
          const t = Date.now() * 0.0002;
          camera.position.x = Math.sin(t) * 200;
          camera.position.z = Math.cos(t) * 200;
          camera.position.y = 150;
          camera.lookAt(0,0,0);
       }
    }

    function animate() {
       requestAnimationFrame(animate);
       const dt = Math.min(clock.getDelta(), 0.1);

       // Update My Car
       if (mySeat !== null) {
          const c = cars.get(mySeat);
          if (c) {
             c.update(dt, input);
             updateCameraPos(c);
          }
       } else if (CAM_MODES[camIndex] === "OVERVIEW") {
          // Spin cam if not playing
          const t = Date.now() * 0.0002;
          camera.position.set(Math.sin(t)*200, 150, Math.cos(t)*200);
          camera.lookAt(0,0,0);
       }

       // Remote Cars visual update (whiskers etc)
       cars.forEach((c, seat) => {
         if (seat !== mySeat) {
            // Just update visual rays based on position
            // (Physics update is skipped, handled by interpolation)
         }
       });

       renderer.render(scene, camera);
    }

    // BOOT
    init3D();
    animate();

  </script>
</body>
</html>
