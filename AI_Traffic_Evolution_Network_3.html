<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AI Traffic V6: The Explorer</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Consolas', monospace; color: #0f0; touch-action: none; }
    
    /* HUD */
    #ui {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0, 20, 0, 0.85); padding: 10px; 
      border-left: 3px solid #0f0;
      pointer-events: none; user-select: none;
      font-size: 12px; text-shadow: 0 0 5px #0f0;
    }
    .stat { display: flex; justify-content: space-between; min-width: 180px; margin-bottom: 2px; }
    .val { font-weight: bold; color: #fff; }

    /* Progress Bar */
    #timer-bar {
      position: absolute; top: 0; left: 0; height: 4px; background: #0f0; width: 100%;
      box-shadow: 0 0 10px #0f0; transition: width 0.1s linear;
    }

    /* Mobile Controls */
    #mobile-controls {
      position: absolute; bottom: 20px; right: 20px;
      width: 120px; height: 120px;
      display: none; /* Shown via JS detection */
      pointer-events: auto;
    }
    .d-btn {
      position: absolute; width: 40px; height: 40px;
      background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
      border-radius: 5px; color: white; text-align: center; line-height: 40px;
      font-size: 20px; user-select: none;
    }
    .d-btn:active { background: rgba(0, 255, 0, 0.5); }
    #btn-up { top: 0; left: 40px; }
    #btn-down { bottom: 0; left: 40px; }
    #btn-left { top: 40px; left: 0; }
    #btn-right { top: 40px; right: 0; }

    /* Control Hint */
    #controls-hint {
      position: absolute; bottom: 10px; left: 10px; color: #555; font-size: 10px;
    }
  </style>
</head>
<body>

  <div id="timer-bar"></div>

  <div id="ui">
    <div style="color:#fff; font-weight:bold; border-bottom:1px solid #444; margin-bottom:5px;">GENETIC EXPLORER V6</div>
    <div class="stat"><span>EPOCH:</span> <span id="epoch" class="val">1</span></div>
    <div class="stat"><span>POPULATION:</span> <span id="alive" class="val">0</span></div>
    <div class="stat"><span>MAX SECTORS:</span> <span id="sectors" class="val">0</span></div>
    <div class="stat"><span>AVG SPEED:</span> <span id="speed" class="val">0</span></div>
    <div style="margin-top:5px; color:#aaa; font-size:10px;">
      Obj: DISCOVER UNIQUE SECTORS
    </div>
  </div>

  <div id="controls-hint">
    [C] Camera | [R] Reset | Touch/WASD to Drive
  </div>

  <div id="mobile-controls">
    <div id="btn-up" class="d-btn">▲</div>
    <div id="btn-down" class="d-btn">▼</div>
    <div id="btn-left" class="d-btn">◀</div>
    <div id="btn-right" class="d-btn">▶</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    // =========================================================
    // CONFIGURATION & STATE
    // =========================================================
    const CONFIG = {
      popSize: 50,
      epochTime: 45,      // Seconds per generation
      mutationRate: 0.2,  // High mutation to force new behaviors
      worldSize: 1500,
      sectorSize: 50      // Size of "unique place" grid squares
    };

    let scene, camera, renderer, clock;
    let cars = [], roads = [], buildings = [];
    let epoch = 1, timeLeft = CONFIG.epochTime;
    let bestBrainJSON = null; // Store best weights
    let cameraMode = 'overview'; // 'overview', 'follow'
    let manualOverride = { accel: 0, turn: 0, active: false };

    // =========================================================
    // NEURAL NETWORK (Optimized for JS)
    // =========================================================
    class Brain {
      constructor(parentBrain) {
        // Inputs: 
        // 0-4: Whisker Distances
        // 5-9: Whisker Type (Road/Wall)
        // 10: Current Speed
        // 11: Angle to Road Alignment
        // 12: Time Since Last New Sector (Urgency)
        this.inputSize = 13;
        this.outputSize = 3; // Throttle, Turn, Brake/Reverse
        this.hiddenSize = 12;

        if (parentBrain) {
          this.w1 = this.mutate(parentBrain.w1);
          this.b1 = this.mutate(parentBrain.b1);
          this.w2 = this.mutate(parentBrain.w2);
          this.b2 = this.mutate(parentBrain.b2);
        } else {
          this.w1 = this.randomWeights(this.inputSize * this.hiddenSize);
          this.b1 = this.randomWeights(this.hiddenSize);
          this.w2 = this.randomWeights(this.hiddenSize * this.outputSize);
          this.b2 = this.randomWeights(this.outputSize);
        }
      }

      randomWeights(n) { return new Float32Array(n).fill(0).map(() => Math.random()*2 - 1); }
      
      mutate(weights) {
        const w = new Float32Array(weights);
        for(let i=0; i<w.length; i++) {
          if(Math.random() < CONFIG.mutationRate) w[i] += (Math.random()-0.5)*0.5;
        }
        return w;
      }

      activate(inputs) {
        const hidden = new Float32Array(this.hiddenSize);
        for(let i=0; i<this.hiddenSize; i++) {
          let sum = 0;
          for(let j=0; j<this.inputSize; j++) sum += inputs[j] * this.w1[i*this.inputSize+j];
          hidden[i] = Math.tanh(sum + this.b1[i]);
        }
        const out = new Float32Array(this.outputSize);
        for(let i=0; i<this.outputSize; i++) {
          let sum = 0;
          for(let j=0; j<this.hiddenSize; j++) sum += hidden[j] * this.w2[i*this.hiddenSize+j];
          out[i] = Math.tanh(sum + this.b2[i]); // -1 to 1 output
        }
        return out;
      }
    }

    // =========================================================
    // CAR AGENT
    // =========================================================
    class Car {
      constructor(brain, x, z, rot) {
        this.brain = new Brain(brain);
        this.mesh = this.createCarMesh();
        this.mesh.position.set(x, 0.5, z);
        this.mesh.rotation.y = rot;
        
        this.velocity = 0;
        this.dead = false;
        
        // Exploration Memory
        this.visitedSectors = new Set();
        this.lastSectorTime = 0;
        this.fitness = 0;

        this.raycaster = new THREE.Raycaster();
        this.whiskers = this.createWhiskers();
      }

      createCarMesh() {
        const g = new THREE.Group();
        // Chassis
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(2.2, 1, 4.5),
          new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff })
        );
        body.position.y = 0.5;
        body.castShadow = true;
        g.add(body);
        
        // Cabin
        const cabin = new THREE.Mesh(
          new THREE.BoxGeometry(2, 0.8, 2.5),
          new THREE.MeshLambertMaterial({ color: 0x333333 })
        );
        cabin.position.set(0, 1.2, -0.5);
        g.add(cabin);

        // Lights
        const lightGeo = new THREE.BoxGeometry(0.5, 0.2, 0.1);
        const l1 = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({color:0xff0000}));
        l1.position.set(-0.8, 0.8, -2.25);
        const l2 = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({color:0xff0000}));
        l2.position.set(0.8, 0.8, -2.25);
        g.add(l1); g.add(l2);

        return g;
      }

      createWhiskers() {
        const angles = [1.0, 0.5, 0, -0.5, -1.0]; // Left to Right
        const len = 15;
        const lines = [];
        const mat = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent:true, opacity:0.3 });
        
        angles.forEach(a => {
           const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,0,len)]);
           const line = new THREE.Line(geo, mat.clone());
           scene.add(line);
           lines.push({ mesh: line, angle: a, len: len });
        });
        return lines;
      }

      getSector(x, z) {
        // Quantize position into a string "10:5"
        const sx = Math.floor(x / CONFIG.sectorSize);
        const sz = Math.floor(z / CONFIG.sectorSize);
        return `${sx}:${sz}`;
      }

      update(dt) {
        if (this.dead) return;

        // 1. Inputs
        const inputs = new Float32Array(13);
        const pos = this.mesh.position;
        const rot = this.mesh.rotation.y;
        
        let wallDanger = false;
        
        this.whiskers.forEach((w, i) => {
          // Calculate Ray
          const dir = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), rot + w.angle);
          const origin = pos.clone().add(new THREE.Vector3(0,1,0));
          this.raycaster.set(origin, dir);
          
          // Cast
          const hits = this.raycaster.intersectObjects(buildings);
          let dist = w.len;
          let type = 1; // 1 = Road/Air, -1 = Wall

          if (hits.length > 0) {
            dist = Math.min(dist, hits[0].distance);
            if (dist < w.len) {
              type = -1; // Wall Hit
              if (dist < 3) wallDanger = true;
            }
          }

          // Visuals
          const tip = origin.clone().add(dir.multiplyScalar(dist));
          const positions = w.mesh.geometry.attributes.position.array;
          positions[0] = origin.x; positions[1] = origin.y; positions[2] = origin.z;
          positions[3] = tip.x; positions[4] = tip.y; positions[5] = tip.z;
          w.mesh.geometry.attributes.position.needsUpdate = true;
          
          if (type === -1) w.mesh.material.color.setHex(0xff0000);
          else w.mesh.material.color.setHex(0x00ff00);

          inputs[i] = dist / w.len; // Distance (0 to 1)
          inputs[i+5] = type;       // Type
        });

        // Current Sector Logic
        const currentSector = this.getSector(pos.x, pos.z);
        if (!this.visitedSectors.has(currentSector)) {
          this.visitedSectors.add(currentSector);
          this.fitness += 50; // MASSIVE REWARD FOR EXPLORATION
          this.lastSectorTime = 0;
          // Spawn "Breadcrumb" visual
          const crumb = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.5}));
          crumb.position.set(pos.x, 2, pos.z);
          scene.add(crumb);
          setTimeout(() => scene.remove(crumb), 2000); // Temporary visual
        } else {
          this.lastSectorTime += dt;
        }
        
        // Inputs Continued
        inputs[10] = this.velocity / 2.0;
        inputs[11] = 0; // Alignment placeholder (removed for pure exploration)
        inputs[12] = this.lastSectorTime; // Panic factor

        // 2. Think
        let [accel, steer, brake] = this.brain.activate(inputs);

        // MANUAL OVERRIDE (For testing)
        if (manualOverride.active && this === getBestCar()) {
          accel = manualOverride.accel;
          steer = manualOverride.turn;
        }

        // 3. Act
        // Reflex: Prevent dead-on collision
        if (wallDanger && accel > 0) accel = -1; 
        
        // Reverse Logic: If stuck in same sector too long, randomly reverse/turn
        if (this.lastSectorTime > 3.0) {
          accel = -0.5;
          steer = Math.random() > 0.5 ? 1 : -1;
        }

        this.velocity += accel * 2.0 * dt;
        if (brake > 0.5) this.velocity *= 0.9;
        
        this.velocity *= 0.95; // Drag

        this.mesh.rotation.y += steer * 2.5 * dt * (this.velocity > 0 ? 1 : -1);
        
        const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), this.mesh.rotation.y);
        this.mesh.position.add(fwd.multiplyScalar(this.velocity * 30 * dt));

        // 4. Fitness & Bounds
        if (Math.abs(pos.x) > CONFIG.worldSize/2 || Math.abs(pos.z) > CONFIG.worldSize/2) {
          this.dead = true;
          this.fitness -= 20;
        }
        if (wallDanger && this.velocity > 0.2) {
          this.fitness -= 1; // Collision penalty
        }

        if (this.dead) {
           this.mesh.visible = false;
           this.whiskers.forEach(w => w.mesh.visible = false);
        }
      }
    }

    // =========================================================
    // WORLD GENERATION (Complex Geometry)
    // =========================================================
    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a10);
      scene.fog = new THREE.FogExp2(0x0a0a10, 0.0015);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 2000);
      camera.position.set(0, 300, 200);
      camera.lookAt(0,0,0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Lights
      const amb = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(amb);
      const sun = new THREE.DirectionalLight(0xffffaa, 0.8);
      sun.position.set(100, 200, 100);
      sun.castShadow = true;
      sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
      sun.shadow.camera.left = -800; sun.shadow.camera.right = 800;
      sun.shadow.camera.top = 800; sun.shadow.camera.bottom = -800;
      scene.add(sun);

      buildCity();
      resetEpoch();

      // Controls
      setupInputs();

      clock = new THREE.Clock();
      animate();
    }

    function buildCity() {
      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize),
        new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 })
      );
      ground.rotation.x = -Math.PI/2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Procedural City Grid
      buildings = [];
      const blockSize = 120;
      const roadWidth = 40;
      
      const geoBox = new THREE.BoxGeometry(1,1,1);
      const matBuild = new THREE.MeshPhongMaterial({ color: 0x222233 });
      const matWindow = new THREE.MeshBasicMaterial({ color: 0xffffaa });

      for(let x = -CONFIG.worldSize/2; x < CONFIG.worldSize/2; x += blockSize) {
        for(let z = -CONFIG.worldSize/2; z < CONFIG.worldSize/2; z += blockSize) {
           
           // Leave space for roads
           if (Math.random() < 0.1) continue; // Random park/open space

           // Create Skyscraper
           const h = 20 + Math.random() * 80;
           const w = blockSize - roadWidth;
           
           const b = new THREE.Mesh(geoBox, matBuild);
           b.position.set(x + blockSize/2, h/2, z + blockSize/2);
           b.scale.set(w - 2, h, w - 2);
           b.castShadow = true; b.receiveShadow = true;
           scene.add(b);
           buildings.push(b);

           // Windows (Simple texture trick using wireframe or small cubes is too heavy, 
           // so we use a secondary mesh slightly larger with emissive dots if performance allowed,
           // but for V6 optimization we stick to geometry).
           
           // Road Markings
           const line = new THREE.Mesh(new THREE.PlaneGeometry(2, blockSize), new THREE.MeshBasicMaterial({color:0x555555}));
           line.rotation.x = -Math.PI/2;
           line.position.set(x + roadWidth/2, 0.1, z + blockSize/2);
           scene.add(line);
        }
      }
    }

    // =========================================================
    // GAME LOOP
    // =========================================================
    function resetEpoch() {
      // Kill old
      cars.forEach(c => {
        scene.remove(c.mesh);
        c.whiskers.forEach(w => scene.remove(w.mesh));
      });
      
      // Select Best Brain
      let parentBrain = null;
      if (cars.length > 0) {
        cars.sort((a,b) => b.fitness - a.fitness);
        parentBrain = cars[0].brain;
        console.log(`Epoch ${epoch} Best Fitness: ${cars[0].fitness} (Sectors: ${cars[0].visitedSectors.size})`);
      }

      cars = [];
      for(let i=0; i<CONFIG.popSize; i++) {
        // Spawn at center (0,0) or random clear spots?
        // Center spawn is chaotic, let's distribute slightly
        const ox = (Math.random() - 0.5) * 100;
        const oz = (Math.random() - 0.5) * 100;
        cars.push(new Car(parentBrain, ox, oz, Math.random()*6.28));
        scene.add(cars[i].mesh);
      }

      epoch++;
      timeLeft = CONFIG.epochTime;
      
      // Update UI
      document.getElementById('epoch').innerText = epoch;
    }

    function getBestCar() {
      return cars.reduce((prev, current) => (prev.fitness > current.fitness) ? prev : current);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      const dt = Math.min(clock.getDelta(), 0.1);
      timeLeft -= dt;
      document.getElementById('timer-bar').style.width = (timeLeft / CONFIG.epochTime * 100) + '%';

      if (timeLeft <= 0) resetEpoch();

      let alive = 0;
      let maxSectors = 0;
      let totalSpeed = 0;

      cars.forEach(c => {
        c.update(dt);
        if (!c.dead) {
          alive++;
          totalSpeed += c.velocity;
          if (c.visitedSectors.size > maxSectors) maxSectors = c.visitedSectors.size;
        }
      });

      // Camera
      if (cameraMode === 'follow' && alive > 0) {
        const target = getBestCar().mesh.position;
        camera.position.lerp(new THREE.Vector3(target.x, 50, target.z + 50), 0.1);
        camera.lookAt(target);
      } else {
        // Slow rotation overview
        const t = Date.now() * 0.0001;
        camera.position.x = Math.sin(t) * 400;
        camera.position.z = Math.cos(t) * 400;
        camera.lookAt(0, 0, 0);
      }

      // UI
      document.getElementById('alive').innerText = alive;
      document.getElementById('sectors').innerText = maxSectors;
      document.getElementById('speed').innerText = (totalSpeed / (alive||1)).toFixed(2);

      renderer.render(scene, camera);
    }

    // =========================================================
    // INPUTS (PC & MOBILE)
    // =========================================================
    function setupInputs() {
      // Keyboard
      window.addEventListener('keydown', e => {
        if(e.key === 'c') cameraMode = (cameraMode === 'overview') ? 'follow' : 'overview';
        if(e.key === 'r') resetEpoch();
        
        // Manual Control Override
        manualOverride.active = true;
        if(e.key === 'ArrowUp' || e.key === 'w') manualOverride.accel = 1;
        if(e.key === 'ArrowDown' || e.key === 's') manualOverride.accel = -1;
        if(e.key === 'ArrowLeft' || e.key === 'a') manualOverride.turn = 1;
        if(e.key === 'ArrowRight' || e.key === 'd') manualOverride.turn = -1;
      });

      window.addEventListener('keyup', e => {
        if(['ArrowUp','w','ArrowDown','s'].includes(e.key)) manualOverride.accel = 0;
        if(['ArrowLeft','a','ArrowRight','d'].includes(e.key)) manualOverride.turn = 0;
      });

      // Touch / Mobile Detection
      if ('ontouchstart' in window) {
        document.getElementById('mobile-controls').style.display = 'block';
        
        const bindBtn = (id, actionStart, actionEnd) => {
          const el = document.getElementById(id);
          el.addEventListener('touchstart', (e) => { e.preventDefault(); manualOverride.active = true; actionStart(); });
          el.addEventListener('touchend', (e) => { e.preventDefault(); actionEnd(); });
        };

        bindBtn('btn-up', () => manualOverride.accel = 1, () => manualOverride.accel = 0);
        bindBtn('btn-down', () => manualOverride.accel = -1, () => manualOverride.accel = 0);
        bindBtn('btn-left', () => manualOverride.turn = 1, () => manualOverride.turn = 0);
        bindBtn('btn-right', () => manualOverride.turn = -1, () => manualOverride.turn = 0);
      }
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    init();
  </script>
</body>
</html>
