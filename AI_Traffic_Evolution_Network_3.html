<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üèéÔ∏è ECHO STUNT RALLY</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial Black', sans-serif; }
    
    /* HUD */
    #ui {
      position: absolute; top: 20px; left: 20px;
      color: #fff; text-shadow: 2px 2px 0 #000;
      pointer-events: none;
    }
    .score-big { font-size: 48px; color: #ffeb3b; font-style: italic; }
    .label { font-size: 14px; color: #00e5ff; letter-spacing: 2px; }
    
    /* Speedometer */
    #speedo {
      position: absolute; bottom: 20px; right: 20px;
      font-size: 32px; color: #fff; text-align: right;
    }
    #bar-container { width: 200px; height: 10px; background: #333; transform: skewX(-20deg); margin-top: 5px; }
    #speed-bar { height: 100%; background: #ff0055; width: 0%; transition: width 0.1s; }

    /* Controls Overlay */
    #controls-help {
      position: absolute; bottom: 20px; left: 20px;
      color: rgba(255,255,255,0.5); font-size: 12px; font-family: monospace;
    }
    .key { display: inline-block; padding: 2px 6px; border: 1px solid #777; border-radius: 4px; color: #fff; margin: 0 2px; }

    /* Messages */
    #msg-area {
      position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
      text-align: center; font-size: 32px; color: #fff;
      text-shadow: 0 0 10px #ff00ff;
      opacity: 0; transition: opacity 0.5s;
    }
  </style>
</head>
<body>

  <div id="ui">
    <div class="label">SCORE</div>
    <div id="score" class="score-big">0</div>
    <div class="label" style="margin-top:10px">ECHO CLOUD</div>
    <div id="ghost-count" style="font-size:24px; color:#ff00ff">0 BOTS</div>
  </div>

  <div id="msg-area">AIR TIME! +500</div>

  <div id="speedo">
    <div id="kph">0 KM/H</div>
    <div id="bar-container"><div id="speed-bar"></div></div>
  </div>

  <div id="controls-help">
    <span class="key">WASD</span> DRIVE &nbsp; 
    <span class="key">SPACE</span> JUMP/HANDBRAKE &nbsp; 
    <span class="key">C</span> CAMERA &nbsp;
    <span class="key">R</span> RECOVER
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // =========================================================
    // 1. ENGINE & PHYSICS CONSTANTS
    // =========================================================
    const CONSTANTS = {
      gravity: 0.8,
      groundFriction: 0.97,
      airFriction: 0.995,
      accel: 1.2,
      turnSpeed: 0.04,
      jumpForce: 1.8,
      maxSpeed: 3.0,
      maxGhosts: 50
    };

    let scene, camera, renderer, clock;
    let player;
    let ghosts = [];
    let worldMeshes = []; // For collision detection
    let raycaster = new THREE.Raycaster();
    let downVector = new THREE.Vector3(0, -1, 0);

    // Recording History
    let playerHistory = []; // { pos, rot, wheelRot }
    let frameCount = 0;
    
    // Game State
    let score = 0;
    let cameraMode = 0; // 0=Chase, 1=FirstPerson
    let inputs = { w:0, s:0, a:0, d:0, space:0 };

    // =========================================================
    // 2. WORLD BUILDER (Ramps & Roads)
    // =========================================================
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x100010);
      scene.fog = new THREE.FogExp2(0x100010, 0.0025);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Lights
      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);
      
      const sun = new THREE.DirectionalLight(0xff00ff, 0.8);
      sun.position.set(100, 200, 50);
      sun.castShadow = true;
      sun.shadow.camera.left = -500; sun.shadow.camera.right = 500;
      sun.shadow.camera.top = 500; sun.shadow.camera.bottom = -500;
      sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
      scene.add(sun);

      buildStuntCourse();
      player = new Car(0xffeb3b, true); // Yellow Hero Car
      scene.add(player.mesh);

      clock = new THREE.Clock();
      
      // Events
      window.addEventListener('resize', onResize);
      window.addEventListener('keydown', e => handleKey(e.code, 1));
      window.addEventListener('keyup', e => handleKey(e.code, 0));

      loop();
    }

    function buildStuntCourse() {
      const matGround = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 10 });
      const matGrid = new THREE.MeshBasicMaterial({ color: 0x222222, wireframe: true });
      const matRamp = new THREE.MeshPhongMaterial({ color: 0x00e5ff, emissive: 0x004455 });
      const matRoad = new THREE.MeshPhongMaterial({ color: 0x333333 });

      // Infinite Floor
      const floorGeo = new THREE.PlaneGeometry(2000, 2000, 50, 50);
      const floor = new THREE.Mesh(floorGeo, matGround);
      floor.rotation.x = -Math.PI/2;
      floor.receiveShadow = true;
      scene.add(floor);
      worldMeshes.push(floor);

      // Grid Overlay for speed sensation
      const grid = new THREE.Mesh(floorGeo, matGrid);
      grid.rotation.x = -Math.PI/2;
      grid.position.y = 0.1;
      scene.add(grid);

      // Procedural Ramps & Obstacles
      for(let i=0; i<40; i++) {
        const type = Math.floor(Math.random() * 3);
        const x = (Math.random() - 0.5) * 800;
        const z = (Math.random() - 0.5) * 800;
        const rot = Math.random() * Math.PI * 2;

        const group = new THREE.Group();
        group.position.set(x, 0, z);
        group.rotation.y = rot;

        if (type === 0) { // Wedge Ramp
          const rampGeo = new THREE.BoxGeometry(20, 5, 30);
          // Slope geometry manually to make it physics-friendly
          rampGeo.verticesNeedUpdate = true; // (Conceptually)
          // Simple visual ramp: Rotate a box
          const mesh = new THREE.Mesh(new THREE.BoxGeometry(20, 2, 40), matRamp);
          mesh.rotation.x = -0.25; // Slope up
          mesh.position.y = 4.8;
          mesh.castShadow = true; mesh.receiveShadow = true;
          group.add(mesh);
          
          // Add collider logic later via simple Raycast, but for now we rely on the visual mesh
          worldMeshes.push(mesh);
        } 
        else if (type === 1) { // High Platform
          const plat = new THREE.Mesh(new THREE.BoxGeometry(40, 10, 40), matRoad);
          plat.position.y = 5;
          plat.receiveShadow = true;
          worldMeshes.push(plat);
          group.add(plat);
          
          // Ramps leading up
          const r1 = new THREE.Mesh(new THREE.BoxGeometry(20, 2, 40), matRamp);
          r1.rotation.x = -0.35; r1.position.z = 35; r1.position.y = 5;
          group.add(r1); worldMeshes.push(r1);
        }
        else { // Loop-de-loop (Fake visual, physics handles it as jump)
          const ring = new THREE.Mesh(new THREE.TorusGeometry(15, 2, 16, 100), matRamp);
          ring.position.y = 15;
          ring.rotation.y = Math.PI/2;
          group.add(ring);
          // No collision for ring, fly through it
        }

        scene.add(group);
      }
    }

    // =========================================================
    // 3. CAR & GHOST LOGIC
    // =========================================================
    class Car {
      constructor(color, isPlayer) {
        this.isPlayer = isPlayer;
        this.mesh = new THREE.Group();
        
        // Chassis
        const bodyGeo = new THREE.BoxGeometry(2, 0.8, 4.5);
        const bodyMat = new THREE.MeshPhongMaterial({ color: color, shininess: 80 });
        this.body = new THREE.Mesh(bodyGeo, bodyMat);
        this.body.position.y = 0.8;
        this.body.castShadow = true;
        this.mesh.add(this.body);

        // Cabin
        const cabin = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 0.6, 2.5),
          new THREE.MeshLambertMaterial({ color: 0x111111 })
        );
        cabin.position.set(0, 1.4, -0.2);
        this.mesh.add(cabin);

        // Wheels
        this.wheels = [];
        const wGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16);
        const wMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
        const wPos = [[-1,0.5,1.5], [1,0.5,1.5], [-1,0.5,-1.5], [1,0.5,-1.5]];
        wPos.forEach(p => {
          const w = new THREE.Mesh(wGeo, wMat);
          w.rotation.z = Math.PI/2;
          w.position.set(...p);
          this.mesh.add(w);
          this.wheels.push(w);
        });

        // Headlights
        if(isPlayer) {
          const l1 = new THREE.SpotLight(0xffffff, 2, 100, 0.5, 0.5);
          l1.position.set(-0.8, 1, 2);
          l1.target.position.set(-0.8, 0, 20);
          this.mesh.add(l1); this.mesh.add(l1.target);
          const l2 = l1.clone();
          l2.position.set(0.8, 1, 2);
          l2.target.position.set(0.8, 0, 20);
          this.mesh.add(l2); this.mesh.add(l2.target);
        }

        // Physics State
        this.pos = new THREE.Vector3(0, 5, 0);
        this.vel = new THREE.Vector3(0, 0, 0);
        this.rot = 0;
        this.onGround = false;
        this.airTime = 0;
      }

      update(dt) {
        if (!this.isPlayer) return; // Ghosts handle their own update

        // 1. Controls
        const accel = inputs.w - inputs.s;
        const turn = inputs.a - inputs.d;
        const jump = inputs.space;

        // 2. Turn
        // Effective turn speed depends on velocity (cannot turn while stopped)
        const speed = Math.sqrt(this.vel.x**2 + this.vel.z**2);
        if (this.onGround && speed > 0.1) {
           this.rot -= turn * CONSTANTS.turnSpeed * (this.vel.dot(this.getForward()) > 0 ? 1 : -1);
        } else if (!this.onGround) {
           // Air control (fun factor)
           this.rot -= turn * CONSTANTS.turnSpeed * 0.5;
           // Tilt car in air
           this.mesh.rotation.z = -turn * 0.2;
           this.mesh.rotation.x = accel * 0.2;
        }

        // 3. Acceleration / Ground Physics
        const fwd = this.getForward();
        
        if (this.onGround) {
          // Motor
          this.vel.add(fwd.multiplyScalar(accel * CONSTANTS.accel * dt));
          
          // Jump (Hydraulics)
          if (jump) {
             this.vel.y += CONSTANTS.jumpForce;
             this.onGround = false;
             this.mesh.position.y += 0.5; // unstuck
          }

          // Friction
          this.vel.x *= CONSTANTS.groundFriction;
          this.vel.z *= CONSTANTS.groundFriction;
          
          // Visual leveling
          this.mesh.rotation.z *= 0.9;
          this.mesh.rotation.x *= 0.9;
        } else {
          // Air Drag
          this.vel.x *= CONSTANTS.airFriction;
          this.vel.z *= CONSTANTS.airFriction;
          this.airTime += dt;
        }

        // 4. Gravity
        this.vel.y -= CONSTANTS.gravity * dt;

        // 5. Integration
        this.pos.add(this.vel.clone().multiplyScalar(1)); // Velocity is units/frame roughly
        
        // 6. Collision / Ground Check
        this.checkGround();

        // 7. Apply to Mesh
        this.mesh.position.copy(this.pos);
        this.mesh.rotation.y = this.rot;

        // 8. Wheel Rotation
        const speedVal = this.vel.length();
        this.wheels.forEach(w => w.rotation.x -= speedVal * 0.2);

        // 9. Scoring Logic
        if (this.onGround && this.airTime > 0.5) {
           const bonus = Math.floor(this.airTime * 100);
           addScore(bonus);
           showMsg("AIR TIME! +" + bonus);
           this.airTime = 0;
        }
      }

      getForward() {
        return new THREE.Vector3(Math.sin(this.rot), 0, Math.cos(this.rot));
      }

      checkGround() {
        // Raycast down
        const rayOrigin = this.pos.clone().add(new THREE.Vector3(0, 1, 0));
        raycaster.set(rayOrigin, downVector);
        
        const hits = raycaster.intersectObjects(worldMeshes);
        
        if (hits.length > 0 && hits[0].distance < 1.5) {
           // Hit Ground
           if (this.vel.y < 0) {
             this.pos.y = hits[0].point.y + 0.5; // Snap to surface
             this.vel.y = 0;
             this.onGround = true;
             
             // Simple slope physics (accelerate down hill)
             // (Not implemented fully for arcade feel, simple gravity is enough)
           }
        } else {
           this.onGround = false;
        }
        
        // Floor fail-safe
        if (this.pos.y < 0) {
          this.pos.y = 0;
          this.vel.y = 0;
          this.onGround = true;
        }
      }
    }

    class Ghost {
      constructor(color, delayFrames) {
        this.delay = delayFrames;
        this.mesh = new Car(color, false).mesh;
        // Make ghost transparent
        this.mesh.traverse(c => {
          if (c.material) {
            c.material = c.material.clone();
            c.material.transparent = true;
            c.material.opacity = 0.5;
            c.material.emissive = new THREE.Color(color);
            c.material.emissiveIntensity = 0.2;
          }
        });
        scene.add(this.mesh);
      }
      
      step(currentFrame, history) {
        const idx = currentFrame - this.delay;
        if (idx >= 0 && idx < history.length) {
          const state = history[idx];
          // Lerp for smoothness
          this.mesh.position.lerp(state.pos, 0.5);
          this.mesh.rotation.y = state.rot;
          this.mesh.rotation.x = state.rx;
          this.mesh.rotation.z = state.rz;
          this.mesh.visible = true;
        } else {
          this.mesh.visible = false;
        }
      }
    }

    // =========================================================
    // 4. MAIN LOOP
    // =========================================================
    
    function handleKey(code, val) {
      if(code==='KeyW') inputs.w = val;
      if(code==='KeyS') inputs.s = val;
      if(code==='KeyA') inputs.a = val;
      if(code==='KeyD') inputs.d = val;
      if(code==='Space') inputs.space = val;
      if(val === 1 && code==='KeyC') toggleCamera();
      if(val === 1 && code==='KeyR') resetPlayer();
    }

    function toggleCamera() {
      cameraMode = (cameraMode === 0) ? 1 : 0;
    }

    function resetPlayer() {
      player.pos.set(0, 5, 0);
      player.vel.set(0, 0, 0);
      player.rot = 0;
    }

    function addScore(n) {
      score += n;
      document.getElementById('score').innerText = score;
    }

    function showMsg(text) {
      const el = document.getElementById('msg-area');
      el.innerText = text;
      el.style.opacity = 1;
      setTimeout(() => el.style.opacity = 0, 1500);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function loop() {
      requestAnimationFrame(loop);
      const dt = 1; // Simplified dt for physics loop

      // 1. Player Logic
      player.update(dt/60);

      // 2. Record History (Every frame)
      frameCount++;
      playerHistory.push({
        pos: player.mesh.position.clone(),
        rot: player.mesh.rotation.y,
        rx: player.mesh.rotation.x,
        rz: player.mesh.rotation.z
      });

      // 3. Spawn Ghosts (Every 300 frames / 5 seconds)
      if (frameCount % 300 === 0 && ghosts.length < CONSTANTS.maxGhosts) {
         // Create a ghost that is 300 frames behind current time
         // Add random color
         const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
         const g = new Ghost(color, 0); // They start playing from frame 0
         // Actually, "copycat following" means they play history starting now?
         // No, typical "ghost" means they replay the track.
         // "Cloud following lovingly" -> Let's make them replay history but with offset?
         // Let's make them Replay the WHOLE history from start, effectively creating a train.
         g.delay = 0; // All ghosts re-run the track from start
         // To make it a "cloud", we need them to exist simultaneously at different history points?
         // Let's set delay to create a snake effect.
         const delay = ghosts.length * 20; 
         g.delay = delay;
         ghosts.push(g);
         document.getElementById('ghost-count').innerText = ghosts.length + " BOTS";
      }

      // 4. Update Ghosts
      ghosts.forEach(g => g.step(frameCount, playerHistory));

      // 5. Camera Update
      if (cameraMode === 0) { // Chase
        const relativeOffset = new THREE.Vector3(0, 6, 15);
        const cameraOffset = relativeOffset.applyMatrix4(player.mesh.matrixWorld);
        camera.position.lerp(cameraOffset, 0.1);
        camera.lookAt(player.mesh.position.x, player.mesh.position.y + 2, player.mesh.position.z);
      } else { // First Person (Bumper)
        const relativeOffset = new THREE.Vector3(0, 1.8, 0.5);
        const cameraOffset = relativeOffset.applyMatrix4(player.mesh.matrixWorld);
        camera.position.copy(cameraOffset);
        // Look slightly ahead
        const target = player.mesh.position.clone().add(player.getForward().multiplyScalar(20));
        camera.lookAt(target);
      }

      // 6. UI Speedo
      const speedKm = Math.floor(player.vel.length() * 40);
      document.getElementById('kph').innerText = speedKm + " KM/H";
      document.getElementById('speed-bar').style.width = Math.min(100, speedKm) + "%";

      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
