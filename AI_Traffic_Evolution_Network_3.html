<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AI Traffic V7: The Teacher</title>
  <style>
    body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', monospace; touch-action: none; }
    
    #ui {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0, 0, 0, 0.8); border-left: 4px solid #00aaff;
      padding: 15px; color: #fff; pointer-events: none;
      box-shadow: 0 0 20px rgba(0, 170, 255, 0.2);
    }
    .hud-row { display: flex; justify-content: space-between; min-width: 200px; margin-bottom: 5px; font-size: 13px; }
    .hud-val { font-weight: bold; color: #00aaff; }
    
    #tutorial {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      color: rgba(255,255,255,0.7); font-size: 12px; text-align: center;
      background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 20px;
    }

    /* Mobile Controls */
    #mobile-controls {
      position: absolute; bottom: 20px; right: 20px; width: 140px; height: 140px;
      display: none; /* Auto-detect */
      pointer-events: auto;
    }
    .d-pad-btn {
      position: absolute; width: 45px; height: 45px;
      background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3);
      border-radius: 8px; text-align: center; line-height: 45px; color: #fff; font-size: 20px;
      user-select: none; backdrop-filter: blur(4px);
    }
    .d-pad-btn:active { background: #00aaff; color: #000; }
    #btn-w { top: 0; left: 47.5px; }
    #btn-s { bottom: 0; left: 47.5px; }
    #btn-a { top: 47.5px; left: 0; }
    #btn-d { top: 47.5px; right: 0; }

  </style>
</head>
<body>

  <div id="ui">
    <div style="font-weight:bold; font-size:16px; margin-bottom:10px; border-bottom:1px solid #333; padding-bottom:5px;">
      TEACHER MODE
    </div>
    <div class="hud-row"><span>YOU:</span> <span class="hud-val">WHITE CAR</span></div>
    <div class="hud-row"><span>STUDENTS:</span> <span id="alive" class="hud-val">0</span></div>
    <div class="hud-row"><span>IMITATION SCORE:</span> <span id="imitation" class="hud-val">0%</span></div>
    <div style="margin-top:5px; font-size:10px; color:#888;">
      • YOU DRIVE, THEY LEARN<br>
      • ROAD CLAMP: ACTIVE<br>
      • COLLISION: BLOCKED
    </div>
  </div>

  <div id="tutorial">Use WASD / Arrow Keys to Drive the Teacher Car</div>

  <div id="mobile-controls">
    <div id="btn-w" class="d-pad-btn">W</div>
    <div id="btn-s" class="d-pad-btn">S</div>
    <div id="btn-a" class="d-pad-btn">A</div>
    <div id="btn-d" class="d-pad-btn">D</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // =========================================================
    // CONFIGURATION
    // =========================================================
    const CONFIG = {
      worldSize: 1200,
      roadWidth: 45, // Slightly wider for easier teaching
      blockSize: 160,
      studentCount: 40,
      imitationRate: 0.2 // How much the AI weights the teacher's actions
    };

    let scene, camera, renderer, clock;
    let teacherCar = null;
    let students = [];
    let roadRects = []; // For coordinate clamping
    let buildings = [];
    
    // Input State
    let input = { w: 0, s: 0, a: 0, d: 0 };
    let globalImitationScore = 0;

    // =========================================================
    // BRAIN (Simple Perceptron + Imitation Bias)
    // =========================================================
    class Brain {
      constructor(copy) {
        // Inputs: 5 Whisker Distances + Speed
        // Outputs: 2 (Steer, Gas)
        this.inputSize = 6;
        this.weights = copy ? [...copy.weights] : new Array(12).fill(0).map(()=>Math.random()*2-1);
        this.bias = copy ? copy.bias : 0;
      }
      
      decide(inputs) {
        // Simple linear activation for speed
        let steer = 0;
        let gas = 0;
        
        // Whisker weights (First 5 inputs)
        for(let i=0; i<5; i++) {
          steer += inputs[i] * this.weights[i]; 
          gas += inputs[i] * this.weights[i+5];
        }
        
        // Speed weight
        steer += inputs[5] * this.weights[10];
        gas += inputs[5] * this.weights[11];
        
        return { steer: Math.tanh(steer), gas: Math.tanh(gas) };
      }
      
      learn(inputs, teacherSteer, teacherGas) {
        // Crude backprop / reinforcement
        // Adjust weights slightly to match teacher output
        const rate = 0.05;
        const myOut = this.decide(inputs);
        
        const steerErr = teacherSteer - myOut.steer;
        const gasErr = teacherGas - myOut.gas;

        for(let i=0; i<5; i++) {
           // Hebbian-ish learning: If input high and error high, adjust weight
           this.weights[i] += inputs[i] * steerErr * rate;
           this.weights[i+5] += inputs[i] * gasErr * rate;
        }
      }
    }

    // =========================================================
    // CAR AGENT
    // =========================================================
    class Car {
      constructor(isTeacher, x, z) {
        this.isTeacher = isTeacher;
        this.mesh = this.createMesh(isTeacher ? 0xffffff : 0x00aaff);
        this.mesh.position.set(x, 0.5, z);
        this.mesh.rotation.y = Math.random() < 0.5 ? 0 : Math.PI/2;
        
        this.velocity = 0;
        this.brain = new Brain();
        this.dead = false;
        
        this.whiskers = this.createWhiskers();
        this.raycaster = new THREE.Raycaster();
      }

      createMesh(color) {
        const g = new THREE.Group();
        const body = new THREE.Mesh(
          new THREE.BoxGeometry(2.5, 1.2, 5),
          new THREE.MeshLambertMaterial({ color: color })
        );
        body.position.y = 0.6;
        body.castShadow = true;
        g.add(body);
        
        if (this.isTeacher) {
          // Add "TEACHER" beacon
          const beam = new THREE.Mesh(new THREE.BoxGeometry(0.5, 20, 0.5), new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0.2}));
          beam.position.y = 10;
          g.add(beam);
        }
        return g;
      }

      createWhiskers() {
        // 5 Whiskers
        const lines = [];
        const angles = [1, 0.5, 0, -0.5, -1];
        angles.forEach(a => {
           const l = new THREE.Line(
             new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(0,0,1)]),
             new THREE.LineBasicMaterial({ color: 0x00ff00 })
           );
           l.visible = false; // Hide by default for cleanliness
           scene.add(l);
           lines.push({ mesh: l, angle: a });
        });
        return lines;
      }

      update(dt) {
        // 1. Physics Inputs
        let gas = 0; 
        let steer = 0;

        // 2. Sensor Data
        const inputs = this.sense();

        // 3. Control Logic
        if (this.isTeacher) {
          // Human Control
          gas = input.w - input.s;
          steer = (input.a - input.d) * 0.05;
          
          // Debug Whiskers only for teacher
          this.whiskers.forEach(w => w.mesh.visible = true);
        } else {
          // AI Control
          const decision = this.brain.decide(inputs);
          gas = decision.gas;
          steer = decision.steer * 0.05;

          // TEACHING MECHANIC:
          // If close to teacher, learn from them
          if (teacherCar) {
            const dist = this.mesh.position.distanceTo(teacherCar.mesh.position);
            if (dist < 100) {
               // What is the teacher doing?
               // We approximate teacher's "Steer intent" by their rotational velocity
               // But simpler: just pull the global input var
               const tGas = input.w - input.s;
               const tSteer = (input.a - input.d); // -1 to 1
               
               this.brain.learn(inputs, tSteer, tGas);
               
               // Visual feedback: Turn Gold when learning
               this.mesh.children[0].material.color.setHex(0xffd700);
               globalImitationScore++;
            } else {
               this.mesh.children[0].material.color.setHex(0x00aaff);
            }
          }
        }

        // 4. Physics Engine
        this.velocity += gas * 2.0 * dt;
        this.velocity *= 0.96; // Friction
        
        // Turn
        if (Math.abs(this.velocity) > 0.1) {
           this.mesh.rotation.y += steer * (this.velocity > 0 ? 1 : -1);
        }

        // 5. ROAD CLAMP (The "Never Leave Roads" Logic)
        const nextPos = this.mesh.position.clone();
        const fwd = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), this.mesh.rotation.y);
        nextPos.add(fwd.multiplyScalar(this.velocity * 30 * dt));
        
        if (checkOnRoad(nextPos.x, nextPos.z)) {
          this.mesh.position.copy(nextPos);
        } else {
          // Hit the "Invisible Wall"
          this.velocity *= -0.5; // Bounce back
          // Try to slide along wall?
          // Simplified: Just stop movement to prevent glitching out
        }
        
        // Update Whisker Visuals
        this.whiskers.forEach((w, i) => {
           const origin = this.mesh.position.clone().add(new THREE.Vector3(0,1,0));
           const dir = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), this.mesh.rotation.y + w.angle);
           const end = origin.clone().add(dir.multiplyScalar(15 * inputs[i])); // Scale by distance reading
           
           const pos = w.mesh.geometry.attributes.position.array;
           pos[0] = origin.x; pos[1] = origin.y; pos[2] = origin.z;
           pos[3] = end.x; pos[4] = end.y; pos[5] = end.z;
           w.mesh.geometry.attributes.position.needsUpdate = true;
        });
      }

      sense() {
        const inputs = [];
        const pos = this.mesh.position;
        const rot = this.mesh.rotation.y;
        
        this.whiskers.forEach(w => {
           const dir = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), rot + w.angle);
           const origin = pos.clone().add(new THREE.Vector3(0,1,0));
           
           this.raycaster.set(origin, dir);
           const hits = this.raycaster.intersectObjects(buildings);
           
           let dist = 15; // Max view
           if(hits.length > 0) dist = Math.min(dist, hits[0].distance);
           
           inputs.push(dist / 15);
        });
        
        inputs.push(this.velocity);
        return inputs;
      }
    }

    // =========================================================
    // ROAD & CITY LOGIC
    // =========================================================
    function checkOnRoad(x, z) {
      // Check collision with our defined road rectangles
      for(let r of roadRects) {
        // Slight buffer (radius of car ~ 2 units)
        if (x > r.x - r.w/2 + 2 && x < r.x + r.w/2 - 2 &&
            z > r.z - r.h/2 + 2 && z < r.z + r.h/2 - 2) {
          return true;
        }
      }
      return false;
    }

    function init() {
      // Setup ThreeJS
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050510);
      
      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1500);
      camera.position.set(0, 400, 200); // High Angle
      camera.lookAt(0,0,0);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      const sun = new THREE.DirectionalLight(0xffffff, 0.9);
      sun.position.set(100, 300, 100);
      sun.castShadow = true;
      sun.shadow.camera.left = -600; sun.shadow.camera.right = 600;
      sun.shadow.camera.top = 600; sun.shadow.camera.bottom = -600;
      scene.add(sun);
      scene.add(new THREE.AmbientLight(0x444444));

      buildCity();
      spawnTraffic();
      
      setupControls();
      
      clock = new THREE.Clock();
      animate();
    }

    function buildCity() {
      // Ground
      const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshStandardMaterial({color:0x111}));
      ground.rotation.x = -Math.PI/2;
      scene.add(ground);

      buildings = [];
      roadRects = [];
      
      const roadMat = new THREE.MeshLambertMaterial({color:0x333});
      const buildMat = new THREE.MeshLambertMaterial({color:0x222244});
      
      // Grid Generation
      const range = CONFIG.worldSize / 2;
      const block = CONFIG.blockSize;
      const roadW = CONFIG.roadWidth;

      // 1. Create Roads (Full strips for clamping)
      // Horizontal Roads
      for(let z = -range; z <= range; z += block) {
         const r = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.worldSize * 1.5, roadW), roadMat);
         r.rotation.x = -Math.PI/2; r.position.set(0, 0.1, z);
         scene.add(r);
         roadRects.push({ x: 0, z: z, w: CONFIG.worldSize * 1.5, h: roadW });
      }
      // Vertical Roads
      for(let x = -range; x <= range; x += block) {
         const r = new THREE.Mesh(new THREE.PlaneGeometry(roadW, CONFIG.worldSize * 1.5), roadMat);
         r.rotation.x = -Math.PI/2; r.position.set(x, 0.11, 0); // Slight Y offset to stop z-fighting
         scene.add(r);
         roadRects.push({ x: x, z: 0, w: roadW, h: CONFIG.worldSize * 1.5 });
      }

      // 2. Create Buildings in the gaps
      const geo = new THREE.BoxGeometry(1,1,1);
      for(let x = -range; x < range; x += block) {
        for(let z = -range; z < range; z += block) {
          // Center of block
          const bx = x + block/2;
          const bz = z + block/2;
          
          // Width of building is block size minus road width
          const w = block - roadW;
          const h = 20 + Math.random() * 60;
          
          const b = new THREE.Mesh(geo, buildMat);
          b.position.set(bx, h/2, bz);
          b.scale.set(w, h, w);
          b.castShadow = true; b.receiveShadow = true;
          scene.add(b);
          buildings.push(b);
        }
      }
    }

    function spawnTraffic() {
      // Spawn Teacher
      teacherCar = new Car(true, 0, 0);
      scene.add(teacherCar.mesh);

      // Spawn Students
      for(let i=0; i<CONFIG.studentCount; i++) {
         const r = roadRects[Math.floor(Math.random()*roadRects.length)];
         let sx, sz;
         if (r.w > r.h) { // Horizontal road
            sx = (Math.random()-0.5) * CONFIG.worldSize;
            sz = r.z;
         } else { // Vertical road
            sx = r.x;
            sz = (Math.random()-0.5) * CONFIG.worldSize;
         }
         
         // Ensure spawn point is clamped (though logic above is robust)
         const c = new Car(false, sx, sz);
         students.push(c);
         scene.add(c.mesh);
      }
    }

    function setupControls() {
      // Keyboard
      window.addEventListener('keydown', e => {
        if(e.key==='w' || e.key==='ArrowUp') input.w = 1;
        if(e.key==='s' || e.key==='ArrowDown') input.s = 1;
        if(e.key==='a' || e.key==='ArrowLeft') input.a = 1;
        if(e.key==='d' || e.key==='ArrowRight') input.d = 1;
      });
      window.addEventListener('keyup', e => {
        if(e.key==='w' || e.key==='ArrowUp') input.w = 0;
        if(e.key==='s' || e.key==='ArrowDown') input.s = 0;
        if(e.key==='a' || e.key==='ArrowLeft') input.a = 0;
        if(e.key==='d' || e.key==='ArrowRight') input.d = 0;
      });

      // Mobile
      if('ontouchstart' in window) {
        document.getElementById('mobile-controls').style.display = 'block';
        document.getElementById('tutorial').style.display = 'none';
        
        const bind = (id, key) => {
           const el = document.getElementById(id);
           el.addEventListener('touchstart', e => { e.preventDefault(); input[key] = 1; });
           el.addEventListener('touchend', e => { e.preventDefault(); input[key] = 0; });
        }
        bind('btn-w','w'); bind('btn-s','s'); bind('btn-a','a'); bind('btn-d','d');
      }

      window.addEventListener('resize', () => {
         camera.aspect = window.innerWidth / window.innerHeight;
         camera.updateProjectionMatrix();
         renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.1);
      
      teacherCar.update(dt);
      
      students.forEach(s => s.update(dt));
      
      // Camera Follow Teacher
      const tPos = teacherCar.mesh.position;
      camera.position.lerp(new THREE.Vector3(tPos.x, 300, tPos.z + 150), 0.05);
      camera.lookAt(tPos);

      // UI
      document.getElementById('alive').innerText = students.length;
      document.getElementById('imitation').innerText = Math.min(100, Math.floor(globalImitationScore / 10)) + "%";

      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
