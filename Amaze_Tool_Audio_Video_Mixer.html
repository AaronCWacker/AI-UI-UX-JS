<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ğŸ›ï¸âœ¨ AMAZE Tool â€” Record + Chop + Pads + Timeline + Video</title>
  <style>
    :root{
      --bg:#060812; --panel:rgba(10,18,40,.85); --panel2:rgba(10,30,60,.9);
      --c:#00f5ff; --c2:#7afcff; --txt:#e9ffff; --mut:#9bd;
      --good:#36f58f; --warn:#ffcf5a; --bad:#ff5a7a;
      --line:rgba(0,245,255,.25);
      --r:14px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; background:radial-gradient(1200px 700px at 30% 0%, #141a3a 0%, var(--bg) 55%, #000 100%);
      color:var(--txt); font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      overflow:hidden;
    }
    #root{ position:relative; width:100vw; height:100vh; }
    .hud{
      position:absolute; left:16px; top:16px; width:360px; max-height: calc(100vh - 32px);
      background:linear-gradient(135deg, var(--panel), var(--panel2));
      border:1px solid var(--line); border-radius:var(--r); padding:14px;
      box-shadow:0 10px 40px rgba(0,0,0,.45); overflow:auto;
      backdrop-filter: blur(10px);
    }
    .hud h1{ margin:0 0 10px 0; font-size:16px; letter-spacing:.5px; color:var(--c2); }
    .row{ display:flex; gap:10px; align-items:center; margin:8px 0; }
    .row.wrap{ flex-wrap:wrap; }
    .label{ font-size:12px; color:var(--mut); }
    button, select, input[type="range"]{
      font:inherit; color:var(--txt);
      border-radius:12px; border:1px solid var(--line);
      background:rgba(0,0,0,.35);
      padding:9px 10px;
      outline:none;
    }
    button{ cursor:pointer; }
    button:hover{ border-color:rgba(0,245,255,.5); }
    button.good{ border-color:rgba(54,245,143,.5); }
    button.warn{ border-color:rgba(255,207,90,.5); }
    button.bad{ border-color:rgba(255,90,122,.5); }
    .tiny{ font-size:12px; padding:7px 9px; border-radius:10px; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--line); background:rgba(0,0,0,.25);
      font-size:12px; color:var(--mut);
    }
    .grid{
      display:grid; grid-template-columns: repeat(4, 1fr);
      gap:10px; margin-top:12px;
    }
    .pad{
      border-radius:14px; padding:10px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.25);
      cursor:pointer; user-select:none;
      transition:transform .05s ease, border-color .2s ease, background .2s ease;
      min-height:58px;
    }
    .pad:hover{ border-color:rgba(0,245,255,.55); }
    .pad.on{
      border-color:rgba(54,245,143,.75);
      background:rgba(54,245,143,.12);
    }
    .pad .t{ font-size:12px; color:var(--c2); }
    .pad .s{ font-size:11px; color:var(--mut); margin-top:4px; }
    #stage{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
    }
    canvas{
      width:100vw; height:100vh; display:block;
    }
    #timeline{
      position:absolute; left:390px; right:16px; bottom:16px; height:160px;
      background:linear-gradient(135deg, rgba(0,0,0,.35), rgba(10,30,60,.75));
      border:1px solid var(--line); border-radius:var(--r);
      box-shadow:0 10px 40px rgba(0,0,0,.45);
      padding:12px;
      backdrop-filter: blur(10px);
    }
    #timelineHeader{ display:flex; align-items:center; justify-content:space-between; margin-bottom:10px; }
    #tlGrid{
      display:grid; grid-template-columns: 120px repeat(16, 1fr);
      gap:6px;
    }
    .tlCell, .tlHead{
      border-radius:10px; border:1px solid rgba(0,245,255,.18);
      background:rgba(0,0,0,.25);
      min-height:26px;
      display:flex; align-items:center; justify-content:center;
      font-size:11px; color:var(--mut);
      user-select:none;
    }
    .tlHead{ background:rgba(0,245,255,.06); color:var(--c2); }
    .tlRowLabel{
      justify-content:flex-start; padding-left:10px;
      color:var(--c2);
      background:rgba(0,245,255,.06);
    }
    .tlOn{ border-color:rgba(54,245,143,.75); background:rgba(54,245,143,.12); color:#dff; }
    .playhead{
      position:absolute; bottom:16px; height:160px;
      width:2px; background:rgba(0,245,255,.85);
      box-shadow:0 0 14px rgba(0,245,255,.5);
      pointer-events:none;
    }
    #videoDock{
      margin-top:10px;
      border:1px solid rgba(0,245,255,.18);
      border-radius:14px;
      overflow:hidden;
      background:rgba(0,0,0,.25);
    }
    video{ width:100%; display:block; }
    .mono{ font-size:12px; color:var(--mut); line-height:1.35; }
    .sep{ height:1px; background:rgba(0,245,255,.18); margin:12px 0; }
  </style>
</head>
<body>
<div id="root">
  <div id="stage"><canvas id="viz"></canvas></div>
  <div class="hud" id="hud">
    <h1>ğŸ›ï¸âœ¨ AMAZE Tool</h1>
    <div class="row wrap">
      <span class="pill">ğŸ§  OOP core</span>
      <span class="pill">ğŸµ Chopâ†’Pads</span>
      <span class="pill">ğŸ§¾ Timeline 16-step</span>
      <span class="pill">ğŸ“¹ Video loop</span>
      <span class="pill">ğŸ’¾ Save/Load</span>
    </div>
    <div class="sep"></div>
    <div class="row wrap">
      <button id="btnLoadAudio" class="tiny good">ğŸµ Load Audio</button>
      <button id="btnRec" class="tiny warn">ğŸ™ï¸ Record</button>
      <button id="btnStopRec" class="tiny bad">ğŸ›‘ Stop</button>
      <input id="fileAudio" type="file" accept="audio/*" hidden />
    </div>
    <div class="row">
      <div class="label" style="width:110px;">â±ï¸ Slices</div>
      <select id="selSlices">
        <option>8</option><option selected>16</option><option>32</option>
      </select>
      <button id="btnChop" class="tiny">âœ‚ï¸ Chop</button>
    </div>
    <div class="row">
      <div class="label" style="width:110px;">ğŸ›ï¸ BPM</div>
      <input id="rngBpm" type="range" min="60" max="180" value="120" style="flex:1;" />
      <span id="txtBpm" class="pill">120</span>
    </div>
    <div class="row wrap">
      <button id="btnPlay" class="tiny good">â–¶ï¸ Play</button>
      <button id="btnPause" class="tiny warn">â¸ï¸ Pause</button>
      <button id="btnStop" class="tiny bad">â¹ï¸ Stop</button>
      <button id="btnClear" class="tiny">ğŸ§¹ Clear</button>
    </div>
    <div class="sep"></div>
    <div class="row wrap">
      <button id="btnLoadVideo" class="tiny good">ğŸ“¹ Load Video</button>
      <button id="btnLoadVideos" class="tiny good">ğŸ“¹ Load Videos (multi)</button>
      <button id="btnConcatVideos" class="tiny">ğŸ”— Concat MP4</button>
      <button id="btnVideoLoop" class="tiny">ğŸ” Video Loop</button>
      <input id="fileVideo" type="file" accept="video/*" hidden />
      <input id="fileVideos" type="file" accept="video/*" multiple hidden />
    </div>
    <div id="videoDock">
      <video id="video" playsinline muted></video>
    </div>
    <div class="sep"></div>
    <div class="row wrap">
      <button id="btnSave" class="tiny good">ğŸ’¾ Save</button>
      <button id="btnLoad" class="tiny warn">ğŸ“‚ Load</button>
      <button id="btnExport" class="tiny">ğŸ“¦ Export JSON</button>
    </div>
    <div class="sep"></div>
    <div class="mono" id="status">ğŸ§­ Status: waitingâ€¦</div>
    <div class="grid" id="padGrid"></div>
  </div>
  <div id="timeline">
    <div id="timelineHeader">
      <div class="pill">ğŸ§¾ Timeline â€” 16 steps (click cells)</div>
      <div class="row" style="margin:0;">
        <button id="btnTlFollow" class="tiny">ğŸ§² Follow</button>
        <button id="btnTlQuant" class="tiny">ğŸ§· Quantize</button>
      </div>
    </div>
    <div id="tlGrid"></div>
    <div class="playhead" id="playhead" style="left:-9999px;"></div>
  </div>
</div>
<script>
/* ============================================================================
  ğŸ›ï¸âœ¨ AMAZE Tool â€” Core Philosophy
  âœ… Keep features by isolating them into modules
  âœ… Merge later by *moving functions into the right class*, not rewriting
  âœ… Full single-file GitHub Pages friendly
============================================================================ */
/* =========================
  ğŸ§° Tiny Utils
========================= */
const U = {
  now: () => performance.now(),
  clamp: (v,a,b) => Math.max(a, Math.min(b, v)),
  el: (id) => document.getElementById(id),
  fmt: (n,d=2)=> Number.isFinite(n)? n.toFixed(d) : "â€”",
  log: (...a)=> console.log("[AMAZE]", ...a),
};
/* =========================
  ğŸ§  Event Bus (loose coupling)
========================= */
class Bus {
  constructor(){ this.m = new Map(); }
  on(ev, fn){ (this.m.get(ev)||this.m.set(ev,[]).get(ev)).push(fn); }
  emit(ev, data){ (this.m.get(ev)||[]).forEach(fn=>fn(data)); }
}
/* =========================
  ğŸ’¾ Storage (local-first)
========================= */
class ProjectStore {
  constructor(key="amaze.project.v1"){ this.key = key; }
  save(obj){
    localStorage.setItem(this.key, JSON.stringify(obj));
  }
  load(){
    const raw = localStorage.getItem(this.key);
    return raw ? JSON.parse(raw) : null;
  }
  export(obj){
    const blob = new Blob([JSON.stringify(obj,null,2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "amaze_project.json";
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  }
}
/* =========================
  ğŸ§ Audio Engine (WebAudio)
========================= */
class AudioEngine {
  constructor(bus){
    this.bus = bus;
    this.ctx = null; // ğŸ§ lazy init
    this.master = null; // ğŸ”Š master gain
    this.an = null; // ğŸ“ˆ analyser for viz
    this.buffer = null; // ğŸµ loaded audio
    this.slices = []; // âœ‚ï¸ slice regions in seconds [{a,b}]
    this.padVoices = new Map(); // ğŸŸ© active loop voices per pad
    this.bpm = 120; // ğŸ§· tempo
    this.isPlaying = false;
    this.t0 = 0; // â±ï¸ transport start time
    this.loopLenSteps = 16; // ğŸ§¾ steps
  }
  /* ğŸ§ ensure context exists */
  ensure(){
    if (this.ctx) return;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    this.ctx = new Ctx();
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.9;
    this.an = this.ctx.createAnalyser();
    this.an.fftSize = 2048;
    this.master.connect(this.an);
    this.an.connect(this.ctx.destination);
    this.bus.emit("audio.ready", {});
  }
  setBpm(bpm){
    this.bpm = bpm;
    this.bus.emit("audio.bpm", {bpm});
  }
  /* ğŸµ Load audio from File */
  async loadFile(file){
    this.ensure();
    const arr = await file.arrayBuffer();
    this.buffer = await this.ctx.decodeAudioData(arr);
    this.bus.emit("audio.loaded", {dur:this.buffer.duration});
  }
  /* âœ‚ï¸ Chop buffer into N equal slices (upgrade later with transients) */
  chopEqual(n){
    if (!this.buffer) return;
    const dur = this.buffer.duration;
    const step = dur / n;
    this.slices = Array.from({length:n}, (_,i)=>({ a:i*step, b:(i+1)*step }));
    this.bus.emit("audio.chopped", {n, slices:this.slices});
  }
  /* ğŸ” Toggle pad loop: click = start/stop loop */
  togglePad(padIndex){
    if (!this.buffer || !this.slices[padIndex]) return;
    this.ensure();
    if (this.padVoices.has(padIndex)){
      this._stopPad(padIndex);
      return;
    }
    this._startPadLoop(padIndex);
  }
  _startPadLoop(padIndex){
    const sl = this.slices[padIndex];
    const src = this.ctx.createBufferSource();
    src.buffer = this.buffer;
    // ğŸ›ï¸ per-pad gain (future: EQ/FX)
    const g = this.ctx.createGain();
    g.gain.value = 1.0;
    src.connect(g);
    g.connect(this.master);
    // ğŸ” loop region
    src.loop = true;
    src.loopStart = sl.a;
    src.loopEnd = sl.b;
    // ğŸ¯ start at region start (tight)
    src.start(0, sl.a);
    this.padVoices.set(padIndex, {src, g, sl});
    this.bus.emit("pad.on", {padIndex});
  }
  _stopPad(padIndex){
    const v = this.padVoices.get(padIndex);
    if (!v) return;
    try { v.src.stop(); } catch {}
    this.padVoices.delete(padIndex);
    this.bus.emit("pad.off", {padIndex});
  }
  stopAllPads(){
    [...this.padVoices.keys()].forEach(i=>this._stopPad(i));
  }
  /* ğŸš¦ Transport for timeline scheduling (simple first pass) */
  playTransport(){
    this.ensure();
    this.isPlaying = true;
    this.t0 = this.ctx.currentTime;
    this.bus.emit("transport.play", {});
  }
  pauseTransport(){
    this.isPlaying = false;
    this.bus.emit("transport.pause", {});
  }
  stopTransport(){
    this.isPlaying = false;
    this.stopAllPads();
    this.bus.emit("transport.stop", {});
  }
  /* ğŸ›ï¸ read analyser data for viz */
  getWave(out){
    if (!this.an) return 0;
    this.an.getByteTimeDomainData(out);
    return 1;
  }
  /* â±ï¸ current step index for playhead */
  getStepIndex(){
    if (!this.ctx || !this.isPlaying) return 0;
    const secPerBeat = 60 / this.bpm;
    const secPerStep = secPerBeat / 1; // ğŸ§· 1 step = 1 beat (adjust later)
    const t = this.ctx.currentTime - this.t0;
    return Math.floor(t / secPerStep) % this.loopLenSteps;
  }
}
/* =========================
  ğŸ§¾ Timeline (16-step grid)
========================= */
class Timeline {
  constructor(bus, steps=16){
    this.bus = bus;
    this.steps = steps;
    this.follow = true; // ğŸ§² follow playhead
    this.quantize = true; // ğŸ§· future hooks
    this.rows = []; // rows represent pads
  }
  initRows(padCount){
    this.rows = Array.from({length:padCount}, (_,pi)=>({
      padIndex: pi,
      steps: Array.from({length:this.steps}, ()=>0) // 0/1 toggles
    }));
    this.bus.emit("timeline.ready", {padCount, steps:this.steps});
  }
  toggleCell(padIndex, stepIndex){
    const row = this.rows[padIndex];
    if (!row) return;
    row.steps[stepIndex] = row.steps[stepIndex] ? 0 : 1;
    this.bus.emit("timeline.changed", {padIndex, stepIndex, v:row.steps[stepIndex]});
  }
  clear(){
    this.rows.forEach(r=>r.steps.fill(0));
    this.bus.emit("timeline.changed", {all:true});
  }
  serialize(){ return {steps:this.steps, rows:this.rows}; }
  hydrate(obj){
    if (!obj || !obj.rows) return;
    this.steps = obj.steps || this.steps;
    this.rows = obj.rows;
    this.bus.emit("timeline.ready", {padCount:this.rows.length, steps:this.steps});
    this.bus.emit("timeline.changed", {all:true});
  }
}
/* =========================
  ğŸ›ï¸ Conductor (ties timeline + pads)
========================= */
class Conductor {
  constructor(bus, audio, timeline){
    this.bus = bus;
    this.audio = audio;
    this.timeline = timeline;
    this.lastStep = -1;
    // ğŸšï¸ On each animation tick, check step and trigger pads
    this.bus.on("tick", ()=>this._tick());
  }
  _tick(){
    const step = this.audio.getStepIndex();
    if (step === this.lastStep) return;
    this.lastStep = step;
    // ğŸ¯ Step change event
    this.bus.emit("transport.step", {step});
    // ğŸ”¥ Trigger pads whose cell is ON at this step
    if (!this.audio.isPlaying) return;
    for (const row of this.timeline.rows){
      if (!row) continue;
      if (row.steps[step]){
        // ğŸ§  Pro move: if pad is not looping, start it; else leave it (keeps vibe)
        if (!this.audio.padVoices.has(row.padIndex)) this.audio.togglePad(row.padIndex);
      } else {
        // ğŸ§¼ Optional: if you want timeline to *gate* pads, stop here (feature flag later)
        // if (this.audio.padVoices.has(row.padIndex)) this.audio.togglePad(row.padIndex);
      }
    }
  }
}
/* =========================
  ğŸ“¹ Video Engine (loop + sync hooks)
========================= */
class VideoEngine {
  constructor(bus, videoEl){
    this.bus = bus;
    this.v = videoEl;
    this.loop = true;
    // ğŸ” loop behavior (tight)
    this.v.addEventListener("ended", ()=>{ if(this.loop){ this.v.currentTime=0; this.v.play().catch(()=>{}); }});
  }
  async loadFile(file){
    const url = URL.createObjectURL(file);
    this.v.src = url;
    await this.v.play().catch(()=>{});
    this.bus.emit("video.loaded", {});
  }
  setLoop(on){
    this.loop = on;
    this.v.loop = on; // native loop also
    this.bus.emit("video.loop", {on});
    if (on && this.v.paused) this.v.play().catch(()=>{});
  }
  // ğŸ§² Sync hook placeholder (later: snap video loops to BPM/steps)
  syncToStep(step){
    // âœ¨ Pro move later: adjust playbackRate or jump on bar boundaries
  }
}
/* =========================
  ğŸ”— Video Concat Engine (new feature for concatenating videos)
========================= */
class VideoConcat {
  constructor(bus, audio){
    this.bus = bus;
    this.audio = audio;
    this.videos = []; // array of {url, duration, video}
  }
  async loadFiles(files){
    this.videos = await Promise.all(Array.from(files).map(async (f) => {
      const url = URL.createObjectURL(f);
      const video = document.createElement('video');
      video.src = url;
      await new Promise((res) => {
        video.onloadedmetadata = () => res();
      });
      return {url, duration: video.duration, video};
    }));
    this.bus.emit("videos.loaded", {count: this.videos.length});
  }
  async concatenate(){
    if (!this.videos.length) return;
    // Assume all videos have same dimensions/codecs for simplicity
    const firstVideo = this.videos[0].video;
    const width = firstVideo.videoWidth;
    const height = firstVideo.videoHeight;
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    const stream = canvas.captureStream();
    // Choose mimeType
    const mp4Mime = 'video/mp4;codecs=avc1.42E01E';
    const webmMime = 'video/webm;codecs=vp9';
    const mimeType = MediaRecorder.isTypeSupported(mp4Mime) ? mp4Mime : webmMime;
    const ext = mimeType.startsWith('video/mp4') ? 'mp4' : 'webm';
    const recorder = new MediaRecorder(stream, {mimeType});
    const chunks = [];
    recorder.ondataavailable = (e) => chunks.push(e.data);
    recorder.onstop = () => {
      const blob = new Blob(chunks, {type: mimeType});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `concat.${ext}`;
      a.click();
      URL.revokeObjectURL(a.href);
    };
    recorder.start();
    // Drawing loop
    const draw = () => {
      ctx.drawImage(videoEl, 0, 0, width, height);
      requestAnimationFrame(draw);
    };
    // Video player
    const videoEl = document.createElement('video');
    videoEl.muted = true;
    let currentIndex = 0;
    const videos = this.videos;
    const targetDur = this.audio.buffer ? this.audio.buffer.duration : null;
    const startTime = Date.now();
    const playNext = () => {
      videoEl.src = videos[currentIndex % videos.length].url;
      videoEl.play().catch(U.log);
      currentIndex++;
    };
    if (targetDur == null) {
      // Concat once
      videoEl.onended = () => {
        currentIndex++;
        if (currentIndex < videos.length) {
          playNext();
        } else {
          recorder.stop();
        }
      };
    } else {
      // Loop until duration reached
      videoEl.onended = () => playNext();
      const checkTime = () => {
        const elapsed = (Date.now() - startTime) / 1000;
        if (elapsed >= targetDur) {
          videoEl.pause();
          recorder.stop();
          return;
        }
        requestAnimationFrame(checkTime);
      };
      checkTime();
    }
    draw();
    playNext();
  }
}
/* =========================
  ğŸ–¼ï¸ Viz Engine (audio-reactive canvas)
========================= */
class Viz {
  constructor(bus, audio, canvas){
    this.bus = bus;
    this.audio = audio;
    this.c = canvas;
    this.g = canvas.getContext("2d");
    this.wave = new Uint8Array(2048);
    this.w = 0; this.h = 0;
    window.addEventListener("resize", ()=>this._resize());
    this._resize();
  }
  _resize(){
    this.w = this.c.width = Math.floor(window.innerWidth * devicePixelRatio);
    this.h = this.c.height = Math.floor(window.innerHeight * devicePixelRatio);
  }
  draw(step){
    const g = this.g, w=this.w, h=this.h;
    g.clearRect(0,0,w,h);
    // ğŸŒŒ background faint grid
    g.globalAlpha = 0.12;
    g.strokeStyle = "#00f5ff";
    for (let x=0; x<w; x+=Math.floor(80*devicePixelRatio)){
      g.beginPath(); g.moveTo(x,0); g.lineTo(x,h); g.stroke();
    }
    for (let y=0; y<h; y+=Math.floor(80*devicePixelRatio)){
      g.beginPath(); g.moveTo(0,y); g.lineTo(w,y); g.stroke();
    }
    g.globalAlpha = 1.0;
    // ğŸ“ˆ waveform
    if (this.audio.getWave(this.wave)){
      g.globalAlpha = 0.9;
      g.lineWidth = Math.max(1, 2*devicePixelRatio);
      g.strokeStyle = "#7afcff";
      g.beginPath();
      const mid = h*0.55;
      for (let i=0; i<this.wave.length; i++){
        const t = i/(this.wave.length-1);
        const x = t*w;
        const v = (this.wave[i]-128)/128;
        const y = mid + v*(h*0.18);
        if (i===0) g.moveTo(x,y); else g.lineTo(x,y);
      }
      g.stroke();
      g.globalAlpha = 1.0;
    }
    // ğŸ§¾ step badge
    g.globalAlpha = 0.9;
    g.fillStyle = "#00f5ff";
    g.font = `${Math.floor(18*devicePixelRatio)}px ui-monospace, monospace`;
    g.fillText(`STEP ${String(step).padStart(2,"0")}`, Math.floor(18*devicePixelRatio), Math.floor(30*devicePixelRatio));
    g.globalAlpha = 1.0;
  }
}
/* =========================
  ğŸ§© UI (pads + timeline grid)
========================= */
class UI {
  constructor(bus, audio, timeline){
    this.bus = bus;
    this.audio = audio;
    this.timeline = timeline;
    this.padGrid = U.el("padGrid");
    this.tlGrid = U.el("tlGrid");
    this.playhead = U.el("playhead");
    this.status = U.el("status");
    this.padCount = 16;
    this.stepCount = 16;
    // ğŸ›ï¸ bus listeners
    bus.on("audio.loaded", ({dur})=>this.setStatus(`ğŸµ Audio loaded â€” ${U.fmt(dur,2)}s`));
    bus.on("audio.chopped", ({n})=>this.setStatus(`âœ‚ï¸ Chopped into ${n} slices`));
    bus.on("pad.on", ({padIndex})=>this.setPadState(padIndex, true));
    bus.on("pad.off", ({padIndex})=>this.setPadState(padIndex, false));
    bus.on("timeline.ready", ({padCount, steps})=>{
      this.padCount = padCount; this.stepCount = steps;
      this.renderTimeline();
      this.renderPads();
    });
    bus.on("timeline.changed", ()=>this.renderTimelineCellsOnly());
    bus.on("transport.step", ({step})=>this.updatePlayhead(step));
    bus.on("videos.loaded", ({count})=>this.setStatus(`ğŸ“¹ ${count} videos loaded`));
  }
  setStatus(s){ this.status.textContent = `ğŸ§­ Status: ${s}`; }
  renderPads(){
    this.padGrid.innerHTML = "";
    for (let i=0; i<this.padCount; i++){
      const el = document.createElement("div");
      el.className = "pad";
      el.dataset.i = String(i);
      el.innerHTML = `<div class="t">ğŸŸ¦ Pad ${i+1}</div><div class="s">ğŸ” toggle loop</div>`;
      el.addEventListener("click", ()=> this.bus.emit("ui.pad", {padIndex:i}));
      this.padGrid.appendChild(el);
    }
  }
  setPadState(i, on){
    const el = this.padGrid.querySelector(`.pad[data-i="${i}"]`);
    if (!el) return;
    el.classList.toggle("on", !!on);
  }
  renderTimeline(){
    this.tlGrid.innerHTML = "";
    // ğŸ§¾ header row
    const headLabel = document.createElement("div");
    headLabel.className = "tlHead tlRowLabel";
    headLabel.textContent = "ğŸ›ï¸ PAD / STEP";
    this.tlGrid.appendChild(headLabel);
    for (let s=0; s<this.stepCount; s++){
      const h = document.createElement("div");
      h.className = "tlHead";
      h.textContent = String(s+1);
      this.tlGrid.appendChild(h);
    }
    // ğŸ§¾ pad rows
    for (let p=0; p<this.padCount; p++){
      const lbl = document.createElement("div");
      lbl.className = "tlCell tlRowLabel";
      lbl.textContent = `ğŸŸ¦ Pad ${p+1}`;
      this.tlGrid.appendChild(lbl);
      for (let s=0; s<this.stepCount; s++){
        const c = document.createElement("div");
        c.className = "tlCell";
        c.dataset.p = String(p);
        c.dataset.s = String(s);
        c.addEventListener("click", ()=>{
          this.bus.emit("ui.timeline.toggle", {padIndex:p, stepIndex:s});
        });
        this.tlGrid.appendChild(c);
      }
    }
    this.renderTimelineCellsOnly();
  }
  renderTimelineCellsOnly(){
    for (let p=0; p<this.padCount; p++){
      const row = this.timeline.rows[p];
      if (!row) continue;
      for (let s=0; s<this.stepCount; s++){
        const c = this.tlGrid.querySelector(`.tlCell[data-p="${p}"][data-s="${s}"]`);
        if (!c) continue;
        c.classList.toggle("tlOn", !!row.steps[s]);
        c.textContent = row.steps[s] ? "âœ…" : "";
      }
    }
  }
  updatePlayhead(step){
    const tl = U.el("timeline");
    const rect = tl.getBoundingClientRect();
    const grid = this.tlGrid.getBoundingClientRect();
    // ğŸ§® compute x for step column
    const cols = this.stepCount;
    const labelW = 120;
    const innerW = grid.width - 0; // already includes label col
    const colW = (innerW - labelW) / cols;
    const x = (grid.left - rect.left) + labelW + (step * colW) + (colW/2);
    this.playhead.style.left = `${x}px`;
  }
}
/* =========================
  ğŸ™ï¸ Recorder (MediaRecorder)
========================= */
class Recorder {
  constructor(bus, audio){
    this.bus = bus;
    this.audio = audio;
    this.rec = null; // MediaRecorder ğŸ™ï¸
    this.chunks = [];
    this.stream = null;
    this.isRec = false;
  }
  async start(){
    // ğŸ™ï¸ mic only in this first pass; later: system audio merging
    this.audio.ensure();
    this.stream = await navigator.mediaDevices.getUserMedia({audio:true});
    this.rec = new MediaRecorder(this.stream);
    this.chunks = [];
    this.rec.ondataavailable = (e)=>{ if(e.data.size) this.chunks.push(e.data); };
    this.rec.onstop = async ()=>{
      const blob = new Blob(this.chunks, {type:this.rec.mimeType});
      const arr = await blob.arrayBuffer();
      this.audio.buffer = await this.audio.ctx.decodeAudioData(arr);
      this.bus.emit("audio.loaded", {dur:this.audio.buffer.duration, recorded:true});
      this.stream.getTracks().forEach(t=>t.stop());
      this.stream = null;
    };
    this.rec.start();
    this.isRec = true;
    this.bus.emit("rec.start", {});
  }
  stop(){
    if (!this.rec || !this.isRec) return;
    this.rec.stop();
    this.isRec = false;
    this.bus.emit("rec.stop", {});
  }
}
/* =========================
  ğŸ§  App Orchestrator (single owner)
========================= */
class AmazeApp {
  constructor(){
    this.bus = new Bus();
    this.store = new ProjectStore();
    this.audio = new AudioEngine(this.bus);
    this.timeline = new Timeline(this.bus, 16);
    this.ui = new UI(this.bus, this.audio, this.timeline);
    this.rec = new Recorder(this.bus, this.audio);
    this.video = new VideoEngine(this.bus, U.el("video"));
    this.videoConcat = new VideoConcat(this.bus, this.audio);
    this.viz = new Viz(this.bus, this.audio, U.el("viz"));
    this.conductor = new Conductor(this.bus, this.audio, this.timeline);
    // ğŸ§  state
    this.follow = true;
    this._wireUI();
    this._boot();
    this._loop();
  }
  _boot(){
    // âœ… initial pad grid & timeline
    const n = 16;
    this.timeline.initRows(n);
    this.ui.setStatus("ready â€” load audio to begin");
  }
  _wireUI(){
    // ğŸµ load audio
    U.el("btnLoadAudio").onclick = ()=> U.el("fileAudio").click();
    U.el("fileAudio").onchange = async (e)=>{
      const f = e.target.files?.[0]; if(!f) return;
      await this.audio.loadFile(f);
      this._autoChopFromUI();
    };
    // ğŸ™ï¸ record
    U.el("btnRec").onclick = async ()=>{
      try { await this.rec.start(); this.ui.setStatus("recordingâ€¦ ğŸ™ï¸"); }
      catch(err){ this.ui.setStatus("record failed (permissions?) ğŸš«"); U.log(err); }
    };
    U.el("btnStopRec").onclick = ()=>{ this.rec.stop(); this.ui.setStatus("stoppingâ€¦ ğŸ›‘"); };
    // âœ‚ï¸ chop
    U.el("btnChop").onclick = ()=> this._autoChopFromUI();
    // ğŸ›ï¸ bpm
    const rng = U.el("rngBpm"), txt = U.el("txtBpm");
    const setB = ()=>{ const bpm = Number(rng.value)|0; txt.textContent = String(bpm); this.audio.setBpm(bpm); };
    rng.oninput = setB; setB();
    // ğŸš¦ transport
    U.el("btnPlay").onclick = ()=>{ this.audio.playTransport(); this.ui.setStatus("playing â–¶ï¸"); };
    U.el("btnPause").onclick = ()=>{ this.audio.pauseTransport(); this.ui.setStatus("paused â¸ï¸"); };
    U.el("btnStop").onclick = ()=>{ this.audio.stopTransport(); this.ui.setStatus("stopped â¹ï¸"); };
    // ğŸ§¹ clear
    U.el("btnClear").onclick = ()=>{
      this.audio.stopAllPads();
      this.timeline.clear();
      this.ui.setStatus("cleared ğŸ§¹");
    };
    // ğŸ“¹ load single video
    U.el("btnLoadVideo").onclick = ()=> U.el("fileVideo").click();
    U.el("fileVideo").onchange = async (e)=>{
      const f = e.target.files?.[0]; if(!f) return;
      await this.video.loadFile(f);
      this.ui.setStatus("video loaded ğŸ“¹");
    };
    // ğŸ“¹ load multiple videos for concat
    U.el("btnLoadVideos").onclick = ()=> U.el("fileVideos").click();
    U.el("fileVideos").onchange = async (e)=>{
      const files = e.target.files; if(!files.length) return;
      await this.videoConcat.loadFiles(files);
      this.ui.setStatus(`${files.length} videos loaded for concat ğŸ”—`);
    };
    // ğŸ”— concat videos
    U.el("btnConcatVideos").onclick = async ()=>{
      await this.videoConcat.concatenate();
      this.ui.setStatus("concatenation complete â€” file downloaded ğŸ“¦");
    };
    U.el("btnVideoLoop").onclick = ()=>{
      this.video.setLoop(!this.video.loop);
      this.ui.setStatus(`video loop ${this.video.loop ? "ON ğŸ”" : "OFF â›”"}`);
    };
    // ğŸ§² timeline toggles
    U.el("btnTlFollow").onclick = ()=>{
      this.follow = !this.follow;
      this.ui.setStatus(`follow ${this.follow ? "ON ğŸ§²" : "OFF ğŸ§Š"}`);
    };
    U.el("btnTlQuant").onclick = ()=>{
      this.timeline.quantize = !this.timeline.quantize;
      this.ui.setStatus(`quantize ${this.timeline.quantize ? "ON ğŸ§·" : "OFF ğŸŒ€"}`);
    };
    // ğŸ’¾ save/load/export
    U.el("btnSave").onclick = ()=>{ this.store.save(this._snapshot()); this.ui.setStatus("saved ğŸ’¾"); };
    U.el("btnLoad").onclick = ()=>{
      const p = this.store.load();
      if (!p){ this.ui.setStatus("no saved project ğŸ“­"); return; }
      this._hydrate(p);
      this.ui.setStatus("loaded ğŸ“‚");
    };
    U.el("btnExport").onclick = ()=> this.store.export(this._snapshot());
    // ğŸ›ï¸ pad click
    this.bus.on("ui.pad", ({padIndex})=> this.audio.togglePad(padIndex));
    // ğŸ§¾ timeline cell click
    this.bus.on("ui.timeline.toggle", ({padIndex, stepIndex})=>{
      this.timeline.toggleCell(padIndex, stepIndex);
    });
    // ğŸ§  when chopped, ensure timeline rows match pad count
    this.bus.on("audio.chopped", ({n})=>{
      this.timeline.initRows(n);
      this.audio.loopLenSteps = 16;
    });
  }
  _autoChopFromUI(){
    const n = Number(U.el("selSlices").value) || 16;
    this.audio.chopEqual(n);
  }
  _snapshot(){
    // ğŸ§  NOTE: weâ€™re not serializing raw audio buffer here (big).
    // âœ… This snapshot keeps behavior + timeline; later we add audio exporting via WAV/OGG.
    return {
      v: 1,
      meta: { t: Date.now(), bpm: this.audio.bpm },
      timeline: this.timeline.serialize(),
      slices: this.audio.slices, // âœ‚ï¸ slice boundaries
      video: { loop: this.video.loop },
    };
  }
  _hydrate(p){
    if (!p) return;
    if (p.meta?.bpm) this.audio.setBpm(p.meta.bpm);
    this.timeline.hydrate(p.timeline);
    if (p.video?.loop != null) this.video.setLoop(!!p.video.loop);
    // âœ‚ï¸ restore slices (buffer still must be loaded/recorded)
    if (Array.isArray(p.slices)) this.audio.slices = p.slices;
  }
  _loop(){
    const tick = ()=>{
      this.bus.emit("tick", {});
      const step = this.audio.getStepIndex();
      // ğŸ“¹ (future) sync hook
      if (this.audio.isPlaying) this.video.syncToStep(step);
      // ğŸ–¼ï¸ draw viz
      this.viz.draw(step);
      requestAnimationFrame(tick);
    };
    requestAnimationFrame(tick);
  }
}
// ğŸš€ Launch
window.addEventListener("DOMContentLoaded", ()=> new AmazeApp());
</script>
</body>
</html>
