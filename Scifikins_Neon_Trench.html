<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ScifiKin: Neon Trench Redux</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root { --neon-blue: #00f3ff; --neon-pink: #bc13fe; }
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: 'Orbitron', sans-serif; touch-action: none; user-select: none; }
        
        /* UI LAYOUT */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        
        .hud-panel { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); }
        .hud-bottom { padding: 30px; text-align: center; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); display: flex; justify-content: center; gap: 20px; pointer-events: auto; }

        /* BARS & STATS */
        .bar-frame { width: 200px; height: 12px; border: 1px solid #333; transform: skewX(-20deg); background: rgba(0,0,0,0.5); overflow: hidden; }
        .bar-fill { height: 100%; background: #00ff88; box-shadow: 0 0 15px #00ff88; width: 100%; transition: width 0.2s ease-out; }
        .score-display { text-align: right; text-shadow: 0 0 10px rgba(255, 215, 0, 0.7); }

        /* SCREENS */
        .screen { position: absolute; inset: 0; background: rgba(5, 5, 16, 0.95); z-index: 50; display: flex; flex-direction: column; align-items: center; justify-content: center; backdrop-filter: blur(8px); transition: opacity 0.4s; pointer-events: auto; }
        .screen.hidden { opacity: 0; pointer-events: none; }

        /* CARDS */
        .card-grid { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; max-width: 1000px; padding: 20px; }
        .char-card {
            background: rgba(255,255,255,0.03); border: 1px solid #333; padding: 20px; width: 220px;
            cursor: pointer; transition: all 0.2s; position: relative; overflow: hidden;
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
        }
        .char-card:hover { transform: translateY(-5px); background: rgba(255,255,255,0.08); }
        .char-card.selected { border-color: var(--neon-pink); background: rgba(188, 19, 254, 0.1); box-shadow: 0 0 20px rgba(188, 19, 254, 0.2); }

        /* BUTTONS */
        .btn-neon {
            background: var(--neon-blue); color: #000; border: none; padding: 15px 50px;
            font-family: 'Orbitron'; font-weight: 900; font-size: 1.2rem; cursor: pointer;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
            transition: 0.2s; margin-top: 20px; text-transform: uppercase;
        }
        .btn-neon:hover { background: #fff; box-shadow: 0 0 25px var(--neon-blue); transform: scale(1.05); }
        .btn-neon:active { transform: scale(0.95); }

        h1 { font-size: 3.5rem; line-height: 1; margin-bottom: 10px; background: -webkit-linear-gradient(#00ffff, #ff00ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 15px rgba(0,255,255,0.3)); text-align: center; }
    </style>
</head>
<body>

<canvas id="gl"></canvas>

<div id="ui-layer">
    <div class="hud-panel">
        <div>
            <div class="text-xs text-cyan-300 mb-1 tracking-widest">SHIELD INTEGRITY</div>
            <div class="bar-frame"><div id="hp-bar" class="bar-fill"></div></div>
        </div>
        <div class="score-display">
            <div class="text-xs text-yellow-300 mb-1 tracking-widest">SCORE</div>
            <div id="score-el" class="text-4xl font-bold text-yellow-400">0</div>
        </div>
    </div>
    
    <div id="tutorial-msg" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-white opacity-50 text-center pointer-events-none transition-opacity duration-500">
        <p>DRAG TO MOVE</p>
        <p class="text-sm mt-2">AUTO-FIRE ACTIVE</p>
    </div>

    <div class="hud-bottom">
        </div>
</div>

<div id="start-screen" class="screen">
    <h1>NEON<br>TRENCH</h1>
    <p class="text-gray-400 mb-8 tracking-widest">SELECT UNIT CONFIGURATION</p>
    <div class="card-grid" id="char-grid"></div>
    <button id="start-btn" class="btn-neon hidden">INITIALIZE</button>
</div>

<div id="game-over" class="screen hidden">
    <h1 style="background: none; -webkit-text-fill-color: #ff0055; text-shadow: 0 0 20px #ff0055;">SYSTEM FAILURE</h1>
    <p class="text-xl text-white mb-2">FINAL SCORE</p>
    <p id="final-score" class="text-5xl text-yellow-400 font-bold mb-8">0</p>
    <button onclick="location.reload()" class="btn-neon">REBOOT</button>
</div>

<script>
/**
 * AUDIO SYSTEM (Simple Synth)
 */
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        // Envelope
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    shoot() { this.playTone(300, 'square', 0.1, 0.05); },
    hit() { this.playTone(100, 'sawtooth', 0.1, 0.1); },
    explode() { 
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.4);
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.4);
    }
};

/**
 * GAME CONFIG & STATE
 */
const CHARACTERS = [
    { id: 'striker', name: 'STRIKER', role: 'Balanced', color: 0x00ffff, hp: 100, speed: 1.0 },
    { id: 'heavy', name: 'TITAN', role: 'Heavy Armor', color: 0xffaa00, hp: 150, speed: 0.7 },
    { id: 'speed', name: 'GHOST', role: 'Agility', color: 0xff00ff, hp: 70, speed: 1.4 }
];

const STATE = {
    active: false,
    score: 0,
    time: 0,
    player: null,
    input: { x: 0, y: 0, isDown: false },
    entities: { bullets: [], enemies: [], particles: [] }
};

/**
 * THREE.JS SETUP
 */
const canvas = document.querySelector('#gl');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050510);
scene.fog = new THREE.FogExp2(0x050510, 0.035);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 8, 8);
camera.lookAt(0, 0, -5);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5, 10, 5);
scene.add(ambientLight, dirLight);

/**
 * GAME OBJECTS
 */

// 1. Moving Floor Grid
const gridHelper = new THREE.GridHelper(200, 100, 0xff00ff, 0x220033);
gridHelper.position.y = -2;
scene.add(gridHelper);

class Player {
    constructor(config) {
        this.config = config;
        this.hp = config.hp;
        this.maxHp = config.hp;
        
        // Mesh Group
        this.mesh = new THREE.Group();
        
        // Ship Body
        const bodyGeo = new THREE.ConeGeometry(0.8, 3, 4);
        const bodyMat = new THREE.MeshStandardMaterial({ 
            color: 0x222222, emissive: config.color, emissiveIntensity: 0.5, roughness: 0.2 
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.rotation.x = -Math.PI / 2;
        
        // Engine Glow
        const engGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const engMat = new THREE.MeshBasicMaterial({ color: config.color });
        const engine = new THREE.Mesh(engGeo, engMat);
        engine.position.z = 1.5;

        this.mesh.add(body, engine);
        scene.add(this.mesh);
        
        // Player Light
        this.light = new THREE.PointLight(config.color, 2, 10);
        this.light.position.y = 2;
        scene.add(this.light);

        this.lastShot = 0;
    }

    update(dt) {
        // Smooth Movement (Lerp)
        const targetX = STATE.input.x * 18; // 18 is lane width boundary
        const targetZ = -(STATE.input.y * 10); 
        
        this.mesh.position.x += (targetX - this.mesh.position.x) * 8 * dt;
        this.mesh.position.z += (targetZ - this.mesh.position.z) * 8 * dt;
        
        // Tilt effect
        this.mesh.rotation.z = -(this.mesh.position.x - targetX) * 0.1;
        this.mesh.rotation.y = -(this.mesh.position.x - targetX) * 0.05;

        // Keep light with ship
        this.light.position.copy(this.mesh.position);
        this.light.position.y += 2;

        // Auto Fire
        if (STATE.input.isDown && STATE.time - this.lastShot > 0.15) {
            this.shoot();
            this.lastShot = STATE.time;
        }
    }

    shoot() {
        AudioSys.shoot();
        const b = new Bullet(this.mesh.position, this.config.color);
        STATE.entities.bullets.push(b);
    }

    hit(damage) {
        this.hp -= damage;
        const pct = Math.max(0, (this.hp / this.maxHp) * 100);
        document.getElementById('hp-bar').style.width = pct + '%';
        
        // Screen shake
        camera.position.x += (Math.random() - 0.5) * 1;
        
        if (this.hp <= 0) endGame();
    }
}

class Bullet {
    constructor(pos, color) {
        this.mesh = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.15, 1, 4, 8), 
            new THREE.MeshBasicMaterial({ color: color })
        );
        this.mesh.position.copy(pos);
        this.mesh.rotation.x = -Math.PI / 2;
        scene.add(this.mesh);
        this.active = true;
    }
    update(dt) {
        this.mesh.position.z -= 40 * dt;
        if (this.mesh.position.z < -60) this.kill();
    }
    kill() {
        this.active = false;
        scene.remove(this.mesh);
    }
}

class Enemy {
    constructor() {
        this.mesh = new THREE.Group();
        
        // Visuals
        const geo = new THREE.OctahedronGeometry(1);
        const mat = new THREE.MeshStandardMaterial({ color: 0xff0044, wireframe: true });
        const core = new THREE.Mesh(geo, mat);
        
        const glowGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const glow = new THREE.Mesh(glowGeo, glowMat);

        this.mesh.add(core, glow);
        
        // Random Spawn Position
        const x = (Math.random() - 0.5) * 30;
        this.mesh.position.set(x, 0, -60);
        scene.add(this.mesh);
        
        this.active = true;
        this.hp = 3;
        this.speed = 10 + Math.random() * 5;
    }
    
    update(dt) {
        this.mesh.position.z += this.speed * dt;
        this.mesh.rotation.x += dt * 2;
        this.mesh.rotation.z += dt * 2;
        
        // Clean up if passed player
        if (this.mesh.position.z > 10) this.kill();
    }

    hit() {
        this.hp--;
        AudioSys.hit();
        // Flash white
        this.mesh.children[1].scale.setScalar(2);
        setTimeout(() => { if(this.active) this.mesh.children[1].scale.setScalar(1); }, 50);

        if (this.hp <= 0) {
            spawnExplosion(this.mesh.position);
            this.kill();
            STATE.score += 100;
            document.getElementById('score-el').innerText = STATE.score;
        }
    }

    kill() {
        this.active = false;
        scene.remove(this.mesh);
    }
}

// Simple Particle System
function spawnExplosion(pos) {
    AudioSys.explode();
    for(let i=0; i<8; i++) {
        const p = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.3),
            new THREE.MeshBasicMaterial({ color: 0xffaa00 })
        );
        p.position.copy(pos);
        // Random velocity
        p.userData = {
            vel: new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10),
            life: 1.0
        };
        scene.add(p);
        STATE.entities.particles.push(p);
    }
}

/**
 * INPUT HANDLER
 */
function handleInput(e) {
    if (!STATE.active) return;
    
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

    // Normalize -1 to 1
    STATE.input.x = (clientX / window.innerWidth) * 2 - 1;
    STATE.input.y = -(clientY / window.innerHeight) * 2 + 1;
    
    // Hide tutorial
    document.getElementById('tutorial-msg').style.opacity = 0;
}

window.addEventListener('mousedown', () => STATE.input.isDown = true);
window.addEventListener('mouseup', () => STATE.input.isDown = false);
window.addEventListener('mousemove', (e) => { if(STATE.input.isDown) handleInput(e); });

window.addEventListener('touchstart', (e) => {
    // Allow clicking UI buttons
    if(e.target.tagName === 'BUTTON') return;
    e.preventDefault();
    STATE.input.isDown = true;
    handleInput(e);
}, {passive: false});

window.addEventListener('touchmove', (e) => {
    e.preventDefault();
    handleInput(e);
}, {passive: false});
window.addEventListener('touchend', () => STATE.input.isDown = false);

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

/**
 * MAIN LOOP
 */
let lastTime = 0;

function loop(time) {
    requestAnimationFrame(loop);
    
    const dt = Math.min((time - lastTime) / 1000, 0.1);
    lastTime = time;
    STATE.time += dt;

    // Animate Grid
    gridHelper.position.z = (STATE.time * 10) % 10;

    if (STATE.active) {
        // Spawn Enemies
        if (Math.random() < 0.03 + (STATE.score * 0.0001)) {
            STATE.entities.enemies.push(new Enemy());
        }

        // Update Player
        STATE.player.update(dt);

        // Update Bullets
        for (let i = STATE.entities.bullets.length - 1; i >= 0; i--) {
            const b = STATE.entities.bullets[i];
            b.update(dt);
            if (!b.active) {
                STATE.entities.bullets.splice(i, 1);
                continue;
            }
            
            // Collision: Bullet vs Enemy
            for (const e of STATE.entities.enemies) {
                if (e.active && b.mesh.position.distanceTo(e.mesh.position) < 2) {
                    e.hit();
                    b.kill();
                    break;
                }
            }
        }

        // Update Enemies
        for (let i = STATE.entities.enemies.length - 1; i >= 0; i--) {
            const e = STATE.entities.enemies[i];
            e.update(dt);
            
            // Collision: Enemy vs Player
            if (e.active && e.mesh.position.distanceTo(STATE.player.mesh.position) < 2) {
                STATE.player.hit(20);
                e.kill();
                spawnExplosion(e.mesh.position);
            }
            
            if (!e.active) STATE.entities.enemies.splice(i, 1);
        }

        // Update Particles
        for (let i = STATE.entities.particles.length - 1; i >= 0; i--) {
            const p = STATE.entities.particles[i];
            p.position.addScaledVector(p.userData.vel, dt);
            p.rotation.x += dt;
            p.userData.life -= dt * 2;
            p.scale.setScalar(p.userData.life);
            
            if (p.userData.life <= 0) {
                scene.remove(p);
                STATE.entities.particles.splice(i, 1);
            }
        }
    }

    // Camera Sway
    if (STATE.player) {
        camera.position.x += (STATE.player.mesh.position.x * 0.5 - camera.position.x) * 2 * dt;
    }

    renderer.render(scene, camera);
}

/**
 * UI & INIT
 */
function initUI() {
    const grid = document.getElementById('char-grid');
    CHARACTERS.forEach(c => {
        const card = document.createElement('div');
        card.className = 'char-card';
        card.innerHTML = `
            <div style="width:30px; height:4px; background:#${c.color.toString(16)}; margin-bottom:10px;"></div>
            <h3 class="text-xl font-bold text-white">${c.name}</h3>
            <p class="text-xs text-gray-400 mb-2">${c.role}</p>
            <div class="flex gap-2 text-xs text-gray-300">
                <span>HP ${c.hp}</span> â€¢ <span>SPD ${c.speed}</span>
            </div>
        `;
        card.onclick = () => {
            document.querySelectorAll('.char-card').forEach(x => x.classList.remove('selected'));
            card.classList.add('selected');
            document.getElementById('start-btn').classList.remove('hidden');
            STATE.selectedChar = c;
            AudioSys.init(); // Init audio on interaction
        };
        grid.appendChild(card);
    });

    document.getElementById('start-btn').onclick = () => {
        document.getElementById('start-screen').classList.add('hidden');
        startGame();
    };
}

function startGame() {
    STATE.active = true;
    STATE.score = 0;
    STATE.player = new Player(STATE.selectedChar);
    document.getElementById('score-el').innerText = '0';
    document.getElementById('hp-bar').style.width = '100%';
}

function endGame() {
    STATE.active = false;
    document.getElementById('game-over').classList.remove('hidden');
    document.getElementById('final-score').innerText = STATE.score;
}

// Start everything
initUI();
loop(0);

</script>
</body>
</html>
