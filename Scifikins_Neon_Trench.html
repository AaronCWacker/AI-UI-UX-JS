<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ScifiKin: Neon Trench</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #050510; font-family: 'Orbitron', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* HUD & UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        .hud-top { display: flex; justify-content: space-between; padding: 20px; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); }
        .hud-bottom { padding: 20px; padding-bottom: 40px; text-align: center; background: linear-gradient(to top, rgba(0,0,0,0.8), transparent); }
        
        .stat-box { text-shadow: 0 0 10px currentColor; }
        .health-bar-container { width: 200px; height: 10px; background: #333; border: 1px solid #555; transform: skewX(-20deg); overflow: hidden; }
        .health-fill { height: 100%; background: #00ff88; box-shadow: 0 0 10px #00ff88; transition: width 0.2s; }
        
        .ability-btn { 
            pointer-events: auto; width: 80px; height: 80px; border-radius: 50%; 
            background: rgba(255, 0, 255, 0.2); border: 2px solid #ff00ff; 
            display: flex; align-items: center; justify-content: center; 
            color: #ff00ff; font-weight: bold; font-size: 14px;
            transition: all 0.2s; margin: 0 auto;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.3);
            backdrop-filter: blur(5px);
        }
        .ability-btn.ready { background: rgba(255, 0, 255, 0.8); color: #fff; box-shadow: 0 0 30px #ff00ff; transform: scale(1.1); cursor: pointer; }
        .ability-btn:active { transform: scale(0.95); }

        /* SCREENS */
        .screen { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(5, 5, 16, 0.95); z-index: 50; pointer-events: auto; transition: opacity 0.5s; backdrop-filter: blur(10px); }
        .hidden { opacity: 0; pointer-events: none; }
        
        h1 { font-size: 3rem; background: -webkit-linear-gradient(#00ffff, #ff00ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 20px rgba(255,0,255,0.5)); margin-bottom: 0.5rem; text-align: center; }
        
        .card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; width: 90%; max-width: 1000px; padding: 20px; overflow-y: auto; max-height: 70vh; -webkit-overflow-scrolling: touch; }
        
        /* NOTE: Changed to button for better touch semantics */
        .char-card { 
            background: rgba(255,255,255,0.05); border: 1px solid #333; padding: 20px; cursor: pointer; transition: all 0.2s; 
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
            text-align: left; width: 100%; position: relative;
        }
        .char-card:active { transform: scale(0.98); background: rgba(255, 255, 255, 0.1); }
        .char-card.selected { border-color: #ff00ff !important; background: rgba(255, 0, 255, 0.15); box-shadow: 0 0 30px rgba(255, 0, 255, 0.2); transform: scale(1.02); }
        
        .btn-main { 
            margin-top: 30px; padding: 20px 60px; font-size: 1.5rem; font-family: 'Orbitron'; 
            background: #00ffff; color: #000; border: none; font-weight: 900; 
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            cursor: pointer; transition: 0.3s; pointer-events: auto;
        }
        .btn-main:hover { background: #fff; box-shadow: 0 0 20px #00ffff; }
        .btn-main:active { transform: scale(0.95); }

        /* TUTORIAL OVERLAY */
        .tutorial { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255,255,255,0.5); font-size: 1.2rem; pointer-events: none; animation: pulse 2s infinite; text-align: center; width: 100%; }
        @keyframes pulse { 0%, 100% { opacity: 0.3; } 50% { opacity: 0.8; } }
    </style>
</head>
<body>

<canvas id="gl"></canvas>

<div id="ui-layer">
    <div class="hud-top">
        <div class="stat-box text-cyan-400">
            <div class="text-xs opacity-70">SHIELD INTEGRITY</div>
            <div class="health-bar-container"><div id="hp-bar" class="health-fill"></div></div>
        </div>
        <div class="stat-box text-yellow-400 text-right">
            <div class="text-xs opacity-70">SCORE</div>
            <div id="score-el" class="text-3xl font-bold tracking-widest">0</div>
        </div>
    </div>
    
    <div class="tutorial" id="tutorial-text">DRAG TO MOVE â€¢ TAP TO SHOOT</div>

    <div class="hud-bottom">
        <div id="ability-btn" class="ability-btn">
            <div>ULT<br><span id="cd-text" class="text-xs">READY</span></div>
        </div>
    </div>
</div>

<div id="start-screen" class="screen">
    <h1>SCIFIKIN<br><span style="font-size:1.5rem; letter-spacing: 0.5em; color:white; -webkit-text-fill-color:white;">NEON TRENCH</span></h1>
    <p class="text-gray-400 mb-8">SELECT CHAMPION</p>
    
    <div class="card-grid" id="char-grid"></div>
    
    <button id="start-btn" class="btn-main hidden">ENGAGE</button>
</div>

<div id="game-over" class="screen hidden">
    <h1 style="color: #ff0055; -webkit-text-fill-color: #ff0055;">CRITICAL FAILURE</h1>
    <p class="text-2xl text-white mb-4">SECTOR REACHED: <span id="final-wave" class="text-cyan-400"></span></p>
    <p class="text-xl text-gray-400 mb-8">SCORE: <span id="final-score"></span></p>
    <button onclick="location.reload()" class="btn-main">REBOOT SYSTEM</button>
</div>

<script>
/**
 * ENGINE CONFIGURATION
 */
const CONFIG = {
    laneWidth: 35,
    speed: 0.8,
    camLerp: 0.08,
    tilt: 0.6,
    colors: {
        grid: 0xff00ff,
        fog: 0x050510
    }
};

const CHARACTERS = [
    { id: 'godsworn', name: 'GODSWORN', role: 'Paladin', color: 0xffd700, hp: 120, speed: 1.0, ability: 'NOVA STUN' },
    { id: 'decker', name: 'DECKER', role: 'Cyberpunk', color: 0x00ff88, hp: 100, speed: 1.3, ability: 'TIME DILATION' },
    { id: 'inquisitor', name: 'INQUISITOR', role: 'Heavy', color: 0xff4400, hp: 160, speed: 0.8, ability: 'PURGE BEAM' },
    { id: 'pooka', name: 'POOKA', role: 'Trickster', color: 0xaa00ff, hp: 90, speed: 1.5, ability: 'MIRROR IMAGE' }
];

/* ---------------- AUDIO SYSTEM ---------------- */
const AudioSys = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    play(type) {
        if (!this.ctx) return;
        if(this.ctx.state === 'suspended') this.ctx.resume();
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const now = this.ctx.currentTime;
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        if (type === 'shoot') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'hit') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'explosion') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(50, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 0.3);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now);
            osc.stop(now + 0.3);
        }
    }
};

/* ---------------- GAME STATE ---------------- */
const Game = {
    active: false,
    score: 0,
    wave: 1,
    time: 0,
    player: null,
    pointer: { x: 0, y: 0, isDown: false },
    entities: {
        enemies: [],
        bullets: [],
        particles: [],
        scenery: []
    }
};

/* ---------------- THREE.JS SETUP ---------------- */
const canvas = document.querySelector('#gl');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(CONFIG.colors.fog);
scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.025);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 12, 10);
camera.lookAt(0, 0, -10);

const ambientLight = new THREE.AmbientLight(0x404040, 2);
scene.add(ambientLight);
const sunLight = new THREE.DirectionalLight(0xffffff, 1);
sunLight.position.set(10, 20, 10);
scene.add(sunLight);
const pointLight = new THREE.PointLight(0x00ffff, 2, 50);
scene.add(pointLight);

/* ---------------- GEOMETRY & MATERIALS ---------------- */
const GEOS = {
    box: new THREE.BoxGeometry(1, 1, 1),
    bullet: new THREE.CapsuleGeometry(0.2, 1, 4, 8),
    tetra: new THREE.TetrahedronGeometry(1)
};
const MATS = {
    wireGrid: new THREE.MeshBasicMaterial({ color: CONFIG.colors.grid, wireframe: true, transparent: true, opacity: 0.3 }),
    player: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3, metalness: 0.8 }),
    enemy: new THREE.MeshStandardMaterial({ color: 0xff0055, roughness: 0.2, metalness: 0.6 }),
    bullet: new THREE.MeshBasicMaterial({ color: 0x00ffff }),
    glow: new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
};

/* ---------------- WORLD ---------------- */
class TrenchWorld {
    constructor() {
        this.group = new THREE.Group();
        scene.add(this.group);
        const planeGeo = new THREE.PlaneGeometry(200, 200, 40, 40);
        this.floor = new THREE.Mesh(planeGeo, MATS.wireGrid);
        this.floor.rotation.x = -Math.PI / 2;
        this.group.add(this.floor);
        this.monoliths = [];
        const mGeo = new THREE.BoxGeometry(2, 15, 2);
        const mMat = new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.1 });
        for(let i=0; i<16; i++) {
            const m = new THREE.Mesh(mGeo, mMat);
            const side = i % 2 === 0 ? 1 : -1;
            m.position.set(side * 25, 0, -i * 20);
            const strip = new THREE.Mesh(new THREE.BoxGeometry(0.2, 12, 0.2), new THREE.MeshBasicMaterial({color: 0xff00ff}));
            strip.position.set(side < 0 ? 0.9 : -0.9, 0, 0);
            m.add(strip);
            this.monoliths.push(m);
            this.group.add(m);
        }
    }
    update(speed) {
        this.floor.position.z = (Game.time * speed * 20) % 5;
        this.monoliths.forEach(m => {
            m.position.z += speed;
            if (m.position.z > 15) { m.position.z -= 320; m.position.y = Math.random() * 5 - 2; }
        });
    }
}

/* ---------------- PLAYER ---------------- */
class Player {
    constructor(config) {
        this.stats = config;
        this.hp = config.hp;
        this.mesh = new THREE.Group();
        const body = new THREE.Mesh(new THREE.ConeGeometry(1, 4, 4), MATS.player.clone());
        body.material.color.setHex(config.color);
        body.material.emissive.setHex(config.color);
        body.material.emissiveIntensity = 0.5;
        body.rotation.x = -Math.PI / 2;
        const engine = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.8, 1, 8), MATS.glow);
        engine.position.z = 2.2; engine.rotation.x = -Math.PI / 2;
        const w1 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.1, 1), MATS.player);
        w1.position.z = 0.5;
        this.mesh.add(body, engine, w1);
        this.mesh.position.y = 2;
        scene.add(this.mesh);
        pointLight.color.setHex(config.color);
    }
    update(dt) {
        let targetX = this.mesh.position.x;
        let targetZ = this.mesh.position.z;
        if (Game.pointer.isDown) {
            targetX = Game.pointer.x * (CONFIG.laneWidth / 2 + 5);
            targetZ = -(Game.pointer.y * 10 + 5); 
        }
        this.mesh.position.x += (targetX - this.mesh.position.x) * 5 * dt;
        this.mesh.position.z += (targetZ - this.mesh.position.z) * 5 * dt;
        const velX = (targetX - this.mesh.position.x);
        this.mesh.rotation.z = -velX * CONFIG.tilt;
        this.mesh.position.y = 2 + Math.sin(Game.time * 5) * 0.2;
        pointLight.position.copy(this.mesh.position);
        pointLight.position.y += 2;
        if (Game.pointer.isDown && Game.time % 0.15 < dt) this.shoot();
    }
    shoot() {
        AudioSys.play('shoot');
        const b = new Bullet(this.mesh.position, this.stats.color);
        Game.entities.bullets.push(b);
    }
    takeDamage(amt) {
        this.hp -= amt;
        const pct = Math.max(0, this.hp / this.stats.hp * 100);
        document.getElementById('hp-bar').style.width = pct + '%';
        camera.position.x += (Math.random()-0.5);
        if (this.hp <= 0) endGame();
    }
}

class Bullet {
    constructor(pos, col) {
        this.mesh = new THREE.Mesh(GEOS.bullet, MATS.bullet.clone());
        this.mesh.material.color.setHex(col);
        this.mesh.position.copy(pos);
        this.mesh.rotation.x = -Math.PI / 2;
        scene.add(this.mesh);
        this.active = true;
    }
    update(dt) {
        this.mesh.position.z -= 40 * dt;
        if (this.mesh.position.z < -60) this.kill();
    }
    kill() { this.active = false; scene.remove(this.mesh); }
}

class Enemy {
    constructor(x, z) {
        this.mesh = new THREE.Group();
        const core = new THREE.Mesh(GEOS.tetra, MATS.enemy);
        core.rotation.set(Math.random(), Math.random(), 0);
        const ring = new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.1, 4, 16), MATS.enemy);
        this.mesh.add(core, ring);
        this.mesh.position.set(x, 2, z);
        scene.add(this.mesh);
        this.active = true;
        this.hp = 3;
    }
    update(dt) {
        this.mesh.position.z += (15 * dt);
        this.mesh.rotation.x += dt;
        if (this.mesh.position.distanceTo(Game.player.mesh.position) < 2.5) {
            Game.player.takeDamage(20);
            this.kill();
        }
        if (this.mesh.position.z > 20) this.kill();
    }
    kill() { if(!this.active) return; this.active = false; scene.remove(this.mesh); createExplosion(this.mesh.position); }
}

function createExplosion(pos) {
    AudioSys.play('explosion');
    for(let i=0; i<8; i++) {
        const p = new THREE.Mesh(GEOS.box, MATS.glow.clone());
        p.position.copy(pos);
        p.scale.setScalar(Math.random() * 0.5);
        p.userData = { vel: new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10), life: 1.0 };
        scene.add(p);
        Game.entities.particles.push(p);
    }
}

/* ---------------- LOOP ---------------- */
const world = new TrenchWorld();
let lastTime = 0;
function loop(now) {
    if (!Game.active) return;
    requestAnimationFrame(loop);
    const dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    Game.time += dt;
    world.update(20 * dt);
    const targetCamX = Game.player.mesh.position.x * 0.3;
    camera.position.x += (targetCamX - camera.position.x) * 2 * dt;
    Game.player.update(dt);
    
    if (Math.random() < 0.05 + (Game.time * 0.001)) {
        const x = (Math.random() - 0.5) * CONFIG.laneWidth;
        const e = new Enemy(x, -60);
        Game.entities.enemies.push(e);
    }
    
    for (let i = Game.entities.bullets.length - 1; i >= 0; i--) {
        const b = Game.entities.bullets[i];
        b.update(dt);
        if (!b.active) { Game.entities.bullets.splice(i, 1); continue; }
        for (let j = Game.entities.enemies.length - 1; j >= 0; j--) {
            const e = Game.entities.enemies[j];
            if (b.mesh.position.distanceTo(e.mesh.position) < 2) {
                e.hp--; b.kill(); AudioSys.play('hit');
                if (e.hp <= 0) { e.kill(); Game.score += 100; document.getElementById('score-el').innerText = Game.score; }
                break;
            }
        }
    }
    for (let i = Game.entities.enemies.length - 1; i >= 0; i--) { const e = Game.entities.enemies[i]; e.update(dt); if (!e.active) Game.entities.enemies.splice(i, 1); }
    for (let i = Game.entities.particles.length - 1; i >= 0; i--) {
        const p = Game.entities.particles[i];
        p.position.addScaledVector(p.userData.vel, dt);
        p.userData.life -= dt * 2;
        p.material.opacity = p.userData.life;
        p.rotation.x += dt;
        if (p.userData.life <= 0) { scene.remove(p); Game.entities.particles.splice(i, 1); }
    }
    renderer.render(scene, camera);
}

/* ---------------- INPUT & LOGIC ---------------- */
function handleInput(x, y, isDown) {
    Game.pointer.isDown = isDown;
    if (isDown) {
        Game.pointer.x = (x / window.innerWidth) * 2 - 1;
        Game.pointer.y = -(y / window.innerHeight) * 2 + 1;
        document.getElementById('tutorial-text').style.opacity = 0;
    }
}

window.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY, true));
window.addEventListener('mousemove', e => { if(Game.pointer.isDown) handleInput(e.clientX, e.clientY, true); });
window.addEventListener('mouseup', () => Game.pointer.isDown = false);

// BUG FIX: Prevent default ONLY on gameplay, allow UI clicks
window.addEventListener('touchstart', e => {
    // If touching a UI element (card, button, screen overlay), allow standard behavior
    if(e.target.closest('.screen') || e.target.closest('.ability-btn') || e.target.closest('.char-card')) return;
    
    e.preventDefault(); 
    handleInput(e.touches[0].clientX, e.touches[0].clientY, true);
}, {passive: false});

window.addEventListener('touchmove', e => {
    e.preventDefault();
    handleInput(e.touches[0].clientX, e.touches[0].clientY, true);
}, {passive: false});
window.addEventListener('touchend', () => Game.pointer.isDown = false);
window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

function initUI() {
    const grid = document.getElementById('char-grid');
    CHARACTERS.forEach(c => {
        const card = document.createElement('button'); // Changed to button
        card.className = 'char-card';
        // Fix hex string padding
        const hex = c.color.toString(16).padStart(6, '0');
        card.style.borderLeft = `4px solid #${hex}`;
        card.innerHTML = `
            <h3 class="text-xl font-bold mb-1" style="color:#${hex}">${c.name}</h3>
            <p class="text-xs text-gray-400 mb-2">${c.role}</p>
            <div class="flex gap-2 text-xs">
                <span class="bg-gray-800 px-2 py-1 rounded">HP: ${c.hp}</span>
                <span class="bg-gray-800 px-2 py-1 rounded">SPD: ${c.speed}</span>
            </div>
        `;
        card.onclick = () => {
            document.querySelectorAll('.char-card').forEach(x => x.classList.remove('selected'));
            card.classList.add('selected');
            document.getElementById('start-btn').classList.remove('hidden');
            Game.selectedChar = c;
            AudioSys.init(); // Pre-init audio context on click
        };
        grid.appendChild(card);
    });
    document.getElementById('start-btn').onclick = startGame;
}

function startGame() {
    AudioSys.init();
    document.getElementById('start-screen').classList.add('hidden');
    Game.active = true;
    Game.player = new Player(Game.selectedChar);
    lastTime = performance.now();
    loop(lastTime);
}

function endGame() {
    Game.active = false;
    document.getElementById('game-over').classList.remove('hidden');
    document.getElementById('final-score').innerText = Game.score;
    document.getElementById('final-wave').innerText = 'SECTOR ' + Math.floor(Game.time / 20);
}

initUI();
renderer.render(scene, camera);
</script>
</body>
</html>
