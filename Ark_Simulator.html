<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>üõ†Ô∏è Ark Architect v2 ‚Äî Cymbal & Kettle Designer</title>
  <style>
    :root{
      --bg: rgba(22,24,29,.92);
      --line: rgba(255,255,255,.12);
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --accent: #61dafb;
      --ok: #50c878;
      --warn:#e24a4a;
      --btn:#4a90e2;
      --btn2:#2f6fb6;
    }
    html,body{ margin:0; height:100%; overflow:hidden; background:#000; font-family: "Segoe UI", system-ui, -apple-system, Arial; }
    canvas{ display:block; }
    #ui {
      position:absolute; top:10px; left:10px; width:280px;
      background: var(--bg); color:var(--txt);
      border:1px solid var(--line); border-radius:12px;
      padding:12px; pointer-events:auto;
      box-shadow: 0 12px 40px rgba(0,0,0,.45);
      display:flex; flex-direction:column; gap:10px;
      max-height: calc(100vh - 20px);
      overflow:auto;
    }
    #ui h3{ margin:0; font-size:16px; color:var(--accent); letter-spacing:.2px; }
    .row{ display:flex; gap:8px; align-items:center; }
    .row > * { flex:1; }
    .mini{ font-size:12px; color:var(--muted); line-height:1.25; }
    hr{ border:none; border-top:1px solid var(--line); margin:6px 0; }
    button{
      background: var(--btn);
      border:none; color:white; padding:9px 10px;
      border-radius:10px; cursor:pointer;
      font-weight:700; letter-spacing:.2px;
      transition: transform .06s, background .2s, opacity .2s;
    }
    button:hover{ background: var(--btn2); }
    button:active{ transform: translateY(1px); }
    button.secondary{ background: rgba(255,255,255,.10); }
    button.secondary:hover{ background: rgba(255,255,255,.16); }
    button.ok{ background: var(--ok); }
    button.ok:hover{ filter: brightness(.95); }
    button.danger{ background: var(--warn); }
    button.danger:hover{ filter: brightness(.95); }
    button.tiny{ padding:7px 8px; border-radius:9px; font-size:12px; }
    label{ font-size:12px; color:var(--muted); display:flex; justify-content:space-between; gap:10px; }
    input[type="range"]{ width:100%; }
    input[type="text"]{
      width:100%; padding:8px 10px; border-radius:10px;
      border:1px solid var(--line); outline:none;
      background: rgba(255,255,255,.06); color:var(--txt);
    }
    select{
      width:100%; padding:8px 10px; border-radius:10px;
      border:1px solid var(--line); outline:none;
      background: rgba(255,255,255,.06); color:var(--txt);
    }
    #help{
      position:absolute; bottom:10px; left:10px;
      color: rgba(255,255,255,.70);
      font-size:12px; pointer-events:none;
      text-shadow: 0 2px 10px rgba(0,0,0,.65);
      max-width: 60vw;
      line-height:1.25;
    }
    #crosshair{
      position:absolute; top:50%; left:50%;
      width:10px; height:10px; border-radius:50%;
      border:2px solid rgba(255,255,255,.55);
      transform: translate(-50%,-50%);
      display:none; pointer-events:none;
    }

    /* Hierarchy */
    #hier{
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
    }
    #hierHead{
      padding:8px 10px;
      background: rgba(255,255,255,.06);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      font-size:12px; color:var(--muted);
    }
    #hierList{
      max-height: 160px;
      overflow:auto;
      background: rgba(0,0,0,.12);
    }
    .item{
      padding:8px 10px;
      border-top:1px solid var(--line);
      display:flex; gap:8px; align-items:center;
      cursor:pointer;
      user-select:none;
    }
    .item:hover{ background: rgba(255,255,255,.06); }
    .dot{ width:10px; height:10px; border-radius:50%; background: rgba(255,255,255,.35); }
    .item.sel .dot{ background: var(--accent); }
    .item .name{ flex:1; font-size:12px; color:var(--txt); opacity:.95; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .lock{ font-size:12px; opacity:.7; }
    .pill{
      font-size:10px; padding:2px 6px; border-radius:999px;
      border:1px solid var(--line); color:var(--muted);
    }

    /* Touch fly controls */
    #touchHUD{
      position:absolute; inset:0;
      pointer-events:none;
      display:none;
    }
    .stick{
      position:absolute; bottom:16px; width:140px; height:140px;
      border-radius:50%;
      border:2px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.12);
      pointer-events:auto;
      touch-action:none;
    }
    #stickMove{ left:16px; }
    #stickLook{ right:16px; }
    .nub{
      position:absolute; left:50%; top:50%;
      width:54px; height:54px; border-radius:50%;
      transform: translate(-50%,-50%);
      border:2px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.06);
    }
    #toast{
      position:absolute; top:10px; right:10px;
      background: rgba(0,0,0,.55);
      color: rgba(255,255,255,.9);
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      font-size:12px;
      max-width: 44vw;
      display:none;
      pointer-events:none;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="crosshair"></div>

  <div id="ui">
    <h3>üõ†Ô∏è Ark Architect v2</h3>

    <div class="row">
      <button id="btnFly" class="ok">Enter Fly</button>
      <button id="btnPlace" class="secondary">Place: Off</button>
    </div>
    <div class="mini">Fly = walk inside. Place = click a deck to drop new objects.</div>

    <hr>

    <label>Material <span class="mini" id="matHint"></span></label>
    <select id="matSelect">
      <option value="random">üé≤ Random Color</option>
      <option value="woodLight">ü™µ Light Wood</option>
      <option value="woodDark">ü™µ Dark Wood</option>
      <option value="white">‚¨ú White</option>
      <option value="copper">ü•Å Copper</option>
      <option value="glass">ü™ü Glass</option>
    </select>

    <label>Primitive</label>
    <div class="row">
      <button id="addCube">‚ûï Cube</button>
      <button id="addCyl">‚ûï Cylinder</button>
    </div>
    <button id="addWall" class="secondary">‚ûï Partition Wall</button>

    <hr>

    <label>Transform</label>
    <div class="row">
      <button id="modeMove" class="tiny">Move (W)</button>
      <button id="modeRot" class="tiny secondary">Rot (E)</button>
      <button id="modeScale" class="tiny secondary">Scale (R)</button>
    </div>

    <label>Snapping</label>
    <label>Grid (units) <span id="snapTVal" class="mini">1.00</span></label>
    <input id="snapT" type="range" min="0" max="5" step="0.25" value="1" />
    <label>Rotate (deg) <span id="snapRVal" class="mini">15¬∞</span></label>
    <input id="snapR" type="range" min="0" max="45" step="1" value="15" />
    <label>Scale (units) <span id="snapSVal" class="mini">0.25</span></label>
    <input id="snapS" type="range" min="0" max="2" step="0.05" value="0.25" />
    <div class="row">
      <button id="btnSnap" class="secondary">Snap: On</button>
      <button id="btnOrtho" class="secondary">Ortho: Off</button>
    </div>

    <hr>

    <div id="hier">
      <div id="hierHead">
        <span>Hierarchy</span>
        <span class="mini" id="hierCount">0</span>
      </div>
      <div id="hierList"></div>
    </div>

    <label>Selected Name</label>
    <input id="nameBox" type="text" placeholder="(select something)" />

    <div class="row">
      <button id="btnLock" class="secondary">Lock</button>
      <button id="btnDel" class="danger">Delete</button>
    </div>

    <hr>

    <div class="row">
      <button id="btnUndo" class="secondary">Undo</button>
      <button id="btnRedo" class="secondary">Redo</button>
    </div>

    <div class="row">
      <button id="btnSave" class="secondary">Save JSON</button>
      <button id="btnLoad" class="secondary">Load JSON</button>
      <input id="fileIn" type="file" accept=".json" style="display:none"/>
    </div>

    <div class="mini">
      Shortcuts: Ctrl+Z/Y, Ctrl+D, F frame, Del delete, ESC exit fly/place
    </div>
  </div>

  <div id="toast"></div>

  <div id="touchHUD">
    <div id="stickMove" class="stick"><div class="nub" id="nubMove"></div></div>
    <div id="stickLook" class="stick"><div class="nub" id="nubLook"></div></div>
  </div>

  <div id="help">
    <b>Editor:</b> click to select ‚Ä¢ W/E/R gizmo ‚Ä¢ Ctrl+D duplicate ‚Ä¢ F frame<br>
    <b>Place mode:</b> click a deck to drop the selected primitive<br>
    <b>Fly:</b> desktop = WASD + mouse look (ESC to exit). touch = left stick move, right stick look.
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { TransformControls } from "three/addons/controls/TransformControls.js";
    import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
    import { VRButton } from "three/addons/webxr/VRButton.js";

    // -----------------------------
    // Core scene
    // -----------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 30, 220);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer));

    // Camera
    let cameraPersp = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1500);
    cameraPersp.position.set(60, 38, 60);

    let cameraOrtho = null;
    let useOrtho = false;

    const camera = () => useOrtho ? cameraOrtho : cameraPersp;

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x334455, 0.85);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.4);
    sun.position.set(80, 140, 70);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.near = 10;
    sun.shadow.camera.far = 400;
    sun.shadow.camera.left = -140;
    sun.shadow.camera.right = 140;
    sun.shadow.camera.top = 140;
    sun.shadow.camera.bottom = -140;
    scene.add(sun);

    // Ground fog reference
    const ambientFloor = new THREE.Mesh(
      new THREE.PlaneGeometry(800,800),
      new THREE.MeshStandardMaterial({ color:0x2b3a45, roughness:1, metalness:0 })
    );
    ambientFloor.rotation.x = -Math.PI/2;
    ambientFloor.position.y = -25;
    ambientFloor.receiveShadow = true;
    scene.add(ambientFloor);

    // Controls
    const orbit = new OrbitControls(cameraPersp, renderer.domElement);
    orbit.enableDamping = true;
    orbit.target.set(0, 6, 0);

    const transform = new TransformControls(cameraPersp, renderer.domElement);
    transform.addEventListener("dragging-changed", (e)=> orbit.enabled = !e.value);
    scene.add(transform);

    const fly = new PointerLockControls(cameraPersp, document.body);

    // Raycast selection / placement
    const raycaster = new THREE.Raycaster();
    const mouseNDC = new THREE.Vector2();

    // -----------------------------
    // Ark parameters + build
    // -----------------------------
    const ARK_RADIUS = 25;
    const arkGroup = new THREE.Group();
    scene.add(arkGroup);

    const surfaces = [];     // decks you can place on
    let editables = [];      // user-created objects

    const MAT = {
      woodDark: new THREE.MeshStandardMaterial({ color:0x5c4033, roughness:0.85, metalness:0.05 }),
      woodLight: new THREE.MeshStandardMaterial({ color:0xdeb887, roughness:0.55, metalness:0.05 }),
      white: new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.65, metalness:0.0 }),
      copper: new THREE.MeshStandardMaterial({ color:0xb87333, metalness:0.65, roughness:0.35, side:THREE.DoubleSide }),
      glass: new THREE.MeshPhysicalMaterial({ color:0xffffff, transmission:0.9, opacity:1, transparent:true, roughness:0.0, thickness:0.6 })
    };

    function buildArk(){
      // Hull materials
      const hullMatOuter = MAT.woodDark.clone();
      const hullMatInner = MAT.woodLight.clone();

      // Outer hull (bowl)
      const hullGeo = new THREE.SphereGeometry(ARK_RADIUS, 64, 32, 0, Math.PI*2, 0, Math.PI/2);
      hullGeo.scale(1, 0.6, 1);
      hullGeo.rotateZ(Math.PI);
      const hullOuter = new THREE.Mesh(hullGeo, hullMatOuter);
      hullOuter.castShadow = true;
      hullOuter.receiveShadow = true;
      hullOuter.userData.static = true;
      arkGroup.add(hullOuter);

      // Inner hull
      const innerGeo = hullGeo.clone();
      innerGeo.scale(0.98,0.98,0.98);
      const hullInner = new THREE.Mesh(innerGeo, hullMatInner);
      hullInner.material.side = THREE.BackSide;
      hullInner.userData.static = true;
      arkGroup.add(hullInner);

      // Decks
      const lowerDeck = new THREE.Mesh(
        new THREE.CylinderGeometry(ARK_RADIUS*0.75, ARK_RADIUS*0.75, 0.6, 40),
        MAT.woodLight.clone()
      );
      lowerDeck.position.y = -8;
      lowerDeck.receiveShadow = true;
      lowerDeck.userData.surface = true;
      lowerDeck.userData.name = "Lower Deck";
      arkGroup.add(lowerDeck);
      surfaces.push(lowerDeck);

      const upperDeck = new THREE.Mesh(
        new THREE.CylinderGeometry(ARK_RADIUS*0.95, ARK_RADIUS*0.95, 0.6, 48),
        MAT.woodLight.clone()
      );
      upperDeck.position.y = 0;
      upperDeck.receiveShadow = true;
      upperDeck.userData.surface = true;
      upperDeck.userData.name = "Upper Deck";
      arkGroup.add(upperDeck);
      surfaces.push(upperDeck);

      // Roof cymbal (cone shell)
      const roof = new THREE.Mesh(
        new THREE.ConeGeometry(ARK_RADIUS+2, 9, 72, 1, true),
        MAT.copper.clone()
      );
      roof.position.y = 4.5;
      roof.castShadow = true;
      roof.userData.static = true;
      arkGroup.add(roof);

      // Window band (glass)
      const band = new THREE.Mesh(
        new THREE.CylinderGeometry(ARK_RADIUS, ARK_RADIUS, 4.5, 48, 1, true),
        MAT.glass.clone()
      );
      band.position.y = 2.25;
      band.userData.static = true;
      arkGroup.add(band);

      // Central spine
      const spine = new THREE.Mesh(
        new THREE.CylinderGeometry(2,2,20,18),
        MAT.woodLight.clone()
      );
      spine.position.y = -5;
      spine.castShadow = true;
      spine.receiveShadow = true;
      spine.userData.static = true;
      arkGroup.add(spine);

      // Spiral stairs (static)
      const stepMat = MAT.woodLight.clone();
      for(let i=0;i<42;i++){
        const step = new THREE.Mesh(new THREE.BoxGeometry(4,0.22,1), stepMat);
        const a = i*0.5;
        const y = 5 - i*0.42;
        step.position.set(Math.cos(a)*3, y, Math.sin(a)*3);
        step.rotation.y = -a;
        step.castShadow = true;
        step.receiveShadow = true;
        step.userData.static = true;
        arkGroup.add(step);
      }

      // Hatch
      const hatch = new THREE.Mesh(new THREE.CylinderGeometry(2.5,2.5,1,18), MAT.woodDark.clone());
      hatch.position.y = 8.5;
      hatch.castShadow = true;
      hatch.receiveShadow = true;
      hatch.userData.static = true;
      arkGroup.add(hatch);
    }

    // Animated water
    let water = null;
    let waterBase = null;
    function buildWater(){
      const geo = new THREE.PlaneGeometry(600,600,140,140);
      const mat = new THREE.MeshStandardMaterial({
        color:0x004466, roughness:0.25, metalness:0.7, transparent:true, opacity:0.84
      });
      water = new THREE.Mesh(geo, mat);
      water.rotation.x = -Math.PI/2;
      water.position.y = -2.2;
      water.receiveShadow = true;
      scene.add(water);

      const pos = geo.attributes.position;
      waterBase = new Float32Array(pos.array.length);
      waterBase.set(pos.array);
    }

    buildWater();
    buildArk();

    // -----------------------------
    // UI + state
    // -----------------------------
    const $ = (id)=>document.getElementById(id);
    const ui = {
      btnFly: $("btnFly"),
      btnPlace: $("btnPlace"),
      addCube: $("addCube"),
      addCyl: $("addCyl"),
      addWall: $("addWall"),
      modeMove: $("modeMove"),
      modeRot: $("modeRot"),
      modeScale: $("modeScale"),
      btnDel: $("btnDel"),
      btnLock: $("btnLock"),
      nameBox: $("nameBox"),
      hierList: $("hierList"),
      hierCount: $("hierCount"),
      matSelect: $("matSelect"),
      matHint: $("matHint"),
      btnSnap: $("btnSnap"),
      btnOrtho: $("btnOrtho"),
      snapT: $("snapT"),
      snapR: $("snapR"),
      snapS: $("snapS"),
      snapTVal: $("snapTVal"),
      snapRVal: $("snapRVal"),
      snapSVal: $("snapSVal"),
      btnUndo: $("btnUndo"),
      btnRedo: $("btnRedo"),
      btnSave: $("btnSave"),
      btnLoad: $("btnLoad"),
      fileIn: $("fileIn"),
      crosshair: $("crosshair"),
      touchHUD: $("touchHUD"),
      toast: $("toast"),
    };

    const isTouch = matchMedia("(pointer: coarse)").matches || ("ontouchstart" in window);
    ui.matHint.textContent = isTouch ? " (touch-friendly)" : " (desktop)";

    let isFlyMode = false;
    let placeMode = false;
    let snapOn = true;

    let spawnType = "cube"; // cube/cyl/wall
    let selected = null;

    // Visual selection highlight (emissive)
    const prevEmissive = new Map();
    function highlight(obj, on){
      if(!obj || !obj.material || !("emissive" in obj.material)) return;
      if(on){
        if(!prevEmissive.has(obj)) prevEmissive.set(obj, obj.material.emissive.clone());
        obj.material.emissive.setHex(0x2a7fff);
        obj.material.emissiveIntensity = 0.7;
      }else{
        const prev = prevEmissive.get(obj);
        if(prev){
          obj.material.emissive.copy(prev);
          obj.material.emissiveIntensity = 0.15;
        }else{
          obj.material.emissive.setHex(0x000000);
          obj.material.emissiveIntensity = 0.0;
        }
      }
    }

    // -----------------------------
    // Materials / primitives
    // -----------------------------
    function pickMaterial(){
      const key = ui.matSelect.value;
      if(key === "random"){
        return { key:"random", mat: new THREE.MeshStandardMaterial({ color: Math.random()*0xffffff, roughness:0.6, metalness:0.1 }) };
      }
      return { key, mat: MAT[key].clone() };
    }

    function makePrimitive(type){
      const { key, mat } = pickMaterial();
      let geo;
      if(type === "cube") geo = new THREE.BoxGeometry(2,2,2);
      if(type === "cyl") geo = new THREE.CylinderGeometry(1,1,2,18);
      if(type === "wall") geo = new THREE.BoxGeometry(10,8,0.5);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;

      mesh.userData.editable = true;
      mesh.userData.type = type;
      mesh.userData.matKey = key;
      mesh.userData.locked = false;
      mesh.userData.name = type === "cube" ? "Cube" : type === "cyl" ? "Cylinder" : "Wall";
      mesh.name = mesh.userData.name;

      // default spawn
      mesh.position.set(0, 2, 0);

      scene.add(mesh);
      editables.push(mesh);
      select(mesh);
      pushUndo(); // new action
      refreshHierarchy();
      return mesh;
    }

    // -----------------------------
    // Selection + hierarchy
    // -----------------------------
    function select(obj){
      if(selected === obj) return;
      if(selected) highlight(selected,false);

      selected = obj || null;

      if(selected){
        highlight(selected,true);
        transform.attach(selected);
        ui.nameBox.value = selected.userData.name || selected.name || "";
        ui.btnLock.textContent = selected.userData.locked ? "Unlock" : "Lock";
      }else{
        transform.detach();
        ui.nameBox.value = "";
        ui.btnLock.textContent = "Lock";
      }
      refreshHierarchy();
    }

    function refreshHierarchy(){
      ui.hierList.innerHTML = "";
      ui.hierCount.textContent = String(editables.length);
      editables.forEach((o, idx)=>{
        const div = document.createElement("div");
        div.className = "item" + (o === selected ? " sel" : "");
        div.title = "Click to select";
        const dot = document.createElement("div");
        dot.className = "dot";
        const name = document.createElement("div");
        name.className = "name";
        name.textContent = (o.userData.name || o.name || ("Object "+idx));
        const pill = document.createElement("span");
        pill.className = "pill";
        pill.textContent = o.userData.type || "obj";
        const lock = document.createElement("span");
        lock.className = "lock";
        lock.textContent = o.userData.locked ? "üîí" : "";
        div.append(dot,name,pill,lock);
        div.onclick = ()=> select(o);
        ui.hierList.appendChild(div);
      });
    }

    ui.nameBox.addEventListener("change", ()=>{
      if(!selected) return;
      selected.userData.name = ui.nameBox.value.trim() || selected.userData.name;
      selected.name = selected.userData.name;
      refreshHierarchy();
      pushUndo();
    });

    ui.btnLock.onclick = ()=>{
      if(!selected) return;
      selected.userData.locked = !selected.userData.locked;
      ui.btnLock.textContent = selected.userData.locked ? "Unlock" : "Lock";
      transform.enabled = !selected.userData.locked;
      showToast(selected.userData.locked ? "Locked selection üîí" : "Unlocked üîì");
      refreshHierarchy();
      pushUndo();
    };

    ui.btnDel.onclick = ()=>{
      deleteSelected();
    };

    function deleteSelected(){
      if(!selected) return;
      if(selected.userData.locked){ showToast("That object is locked üîí"); return; }
      transform.detach();
      highlight(selected,false);
      scene.remove(selected);
      editables = editables.filter(x=>x!==selected);
      selected = null;
      refreshHierarchy();
      pushUndo();
    }

    // -----------------------------
    // Snapping
    // -----------------------------
    function applySnap(){
      const t = Number(ui.snapT.value);
      const r = THREE.MathUtils.degToRad(Number(ui.snapR.value));
      const s = Number(ui.snapS.value);

      ui.snapTVal.textContent = t.toFixed(2);
      ui.snapRVal.textContent = `${ui.snapR.value}¬∞`;
      ui.snapSVal.textContent = s.toFixed(2);

      if(snapOn){
        transform.setTranslationSnap(t > 0 ? t : null);
        transform.setRotationSnap(r > 0 ? r : null);
        transform.setScaleSnap(s > 0 ? s : null);
      }else{
        transform.setTranslationSnap(null);
        transform.setRotationSnap(null);
        transform.setScaleSnap(null);
      }
    }

    ui.btnSnap.onclick = ()=>{
      snapOn = !snapOn;
      ui.btnSnap.textContent = snapOn ? "Snap: On" : "Snap: Off";
      applySnap();
    };
    ui.snapT.oninput = ui.snapR.oninput = ui.snapS.oninput = applySnap;
    applySnap();

    // -----------------------------
    // Ortho camera toggle
    // -----------------------------
    function ensureOrtho(){
      if(cameraOrtho) return;
      const aspect = window.innerWidth/window.innerHeight;
      const d = 45;
      cameraOrtho = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 0.1, 2000);
      cameraOrtho.position.copy(cameraPersp.position);
      cameraOrtho.lookAt(orbit.target);
    }
    ui.btnOrtho.onclick = ()=>{
      useOrtho = !useOrtho;
      ui.btnOrtho.textContent = useOrtho ? "Ortho: On" : "Ortho: Off";
      ensureOrtho();

      // Rebind controls + transform to the active camera
      orbit.object = camera();
      transform.camera = camera();
      if(isFlyMode){
        // fly is tied to cameraPersp; force exit fly if switching
        exitFly();
      }
    };

    // -----------------------------
    // Transform mode buttons
    // -----------------------------
    function setMode(mode){
      transform.setMode(mode);
      ui.modeMove.classList.toggle("secondary", mode!=="translate");
      ui.modeRot.classList.toggle("secondary", mode!=="rotate");
      ui.modeScale.classList.toggle("secondary", mode!=="scale");
    }
    ui.modeMove.onclick = ()=> setMode("translate");
    ui.modeRot.onclick = ()=> setMode("rotate");
    ui.modeScale.onclick = ()=> setMode("scale");
    setMode("translate");

    // -----------------------------
    // Place mode + primitive spawn
    // -----------------------------
    ui.btnPlace.onclick = ()=>{
      placeMode = !placeMode;
      ui.btnPlace.textContent = placeMode ? "Place: On" : "Place: Off";
      showToast(placeMode ? "Place mode ON: click a deck" : "Place mode OFF");
    };

    ui.addCube.onclick = ()=> { spawnType="cube"; makePrimitive("cube"); };
    ui.addCyl.onclick  = ()=> { spawnType="cyl";  makePrimitive("cyl");  };
    ui.addWall.onclick = ()=> { spawnType="wall"; makePrimitive("wall"); };

    function placeAtHit(hit){
      const obj = makePrimitive(spawnType);
      obj.position.copy(hit.point);

      // lift to sit on surface
      const bb = new THREE.Box3().setFromObject(obj);
      const height = (bb.max.y - bb.min.y);
      obj.position.y += height/2 + 0.02;

      // optional: walls face outward from center
      if(spawnType === "wall"){
        const dir = new THREE.Vector3(hit.point.x, 0, hit.point.z).normalize();
        const ang = Math.atan2(dir.x, dir.z);
        obj.rotation.y = ang;
      }

      if(snapOn && Number(ui.snapT.value) > 0){
        const g = Number(ui.snapT.value);
        obj.position.x = Math.round(obj.position.x / g) * g;
        obj.position.z = Math.round(obj.position.z / g) * g;
      }
      pushUndo();
    }

    // -----------------------------
    // Undo/Redo (snapshot-based)
    // -----------------------------
    const undoStack = [];
    const redoStack = [];
    const UNDO_LIMIT = 60;

    function serializeScene(){
      return {
        version: 2,
        objects: editables.map(o=>({
          type: o.userData.type,
          name: o.userData.name,
          matKey: o.userData.matKey,
          color: (o.material && o.material.color) ? o.material.color.getHex() : null,
          locked: !!o.userData.locked,
          pos: o.position.toArray(),
          quat: o.quaternion.toArray(),
          scale: o.scale.toArray(),
        })),
        snapOn, placeMode,
        cam: {
          perspPos: cameraPersp.position.toArray(),
          target: orbit.target.toArray(),
          useOrtho
        }
      };
    }

    function clearEditables(){
      transform.detach();
      if(selected) highlight(selected,false);
      selected = null;
      editables.forEach(o=> scene.remove(o));
      editables = [];
      refreshHierarchy();
    }

    function materialFromKey(matKey, colorHex){
      if(matKey === "random"){
        const m = new THREE.MeshStandardMaterial({ color: colorHex ?? (Math.random()*0xffffff), roughness:0.6, metalness:0.1 });
        return m;
      }
      const base = MAT[matKey] || MAT.woodLight;
      const m = base.clone();
      if(colorHex != null && m.color) m.color.setHex(colorHex);
      return m;
    }

    function buildFromSnapshot(snap){
      clearEditables();
      (snap.objects || []).forEach(d=>{
        let geo;
        if(d.type === "cube") geo = new THREE.BoxGeometry(2,2,2);
        if(d.type === "cyl") geo = new THREE.CylinderGeometry(1,1,2,18);
        if(d.type === "wall") geo = new THREE.BoxGeometry(10,8,0.5);
        if(!geo) return;

        const mat = materialFromKey(d.matKey, d.color);
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.userData.editable = true;
        mesh.userData.type = d.type;
        mesh.userData.matKey = d.matKey;
        mesh.userData.locked = !!d.locked;
        mesh.userData.name = d.name || d.type;
        mesh.name = mesh.userData.name;

        mesh.position.fromArray(d.pos);
        mesh.quaternion.fromArray(d.quat);
        mesh.scale.fromArray(d.scale);

        scene.add(mesh);
        editables.push(mesh);
      });

      // restore camera
      if(snap.cam){
        cameraPersp.position.fromArray(snap.cam.perspPos || cameraPersp.position.toArray());
        orbit.target.fromArray(snap.cam.target || orbit.target.toArray());
        useOrtho = !!snap.cam.useOrtho;
        ui.btnOrtho.textContent = useOrtho ? "Ortho: On" : "Ortho: Off";
        ensureOrtho();
        if(cameraOrtho){
          cameraOrtho.position.copy(cameraPersp.position);
          cameraOrtho.lookAt(orbit.target);
        }
      }

      snapOn = (snap.snapOn !== undefined) ? snap.snapOn : snapOn;
      placeMode = (snap.placeMode !== undefined) ? snap.placeMode : placeMode;
      ui.btnSnap.textContent = snapOn ? "Snap: On" : "Snap: Off";
      ui.btnPlace.textContent = placeMode ? "Place: On" : "Place: Off";
      applySnap();
      refreshHierarchy();
    }

    function pushUndo(){
      const snap = serializeScene();
      undoStack.push(snap);
      while(undoStack.length > UNDO_LIMIT) undoStack.shift();
      redoStack.length = 0;
      // lightweight autosave
      try{ localStorage.setItem("ark_architect_autosave_v2", JSON.stringify(snap)); }catch{}
      ui.btnUndo.style.opacity = undoStack.length > 1 ? "1" : ".5";
      ui.btnRedo.style.opacity = redoStack.length ? "1" : ".5";
    }

    function undo(){
      if(undoStack.length <= 1) return;
      const cur = undoStack.pop();
      redoStack.push(cur);
      const prev = undoStack[undoStack.length-1];
      buildFromSnapshot(prev);
      ui.btnUndo.style.opacity = undoStack.length > 1 ? "1" : ".5";
      ui.btnRedo.style.opacity = redoStack.length ? "1" : ".5";
      showToast("Undo");
    }

    function redo(){
      if(!redoStack.length) return;
      const snap = redoStack.pop();
      undoStack.push(snap);
      buildFromSnapshot(snap);
      ui.btnUndo.style.opacity = undoStack.length > 1 ? "1" : ".5";
      ui.btnRedo.style.opacity = redoStack.length ? "1" : ".5";
      showToast("Redo");
    }

    ui.btnUndo.onclick = undo;
    ui.btnRedo.onclick = redo;

    // Initialize undo history with current empty state
    pushUndo();

    // Try autosave restore
    try{
      const saved = localStorage.getItem("ark_architect_autosave_v2");
      if(saved){
        const snap = JSON.parse(saved);
        if(snap && snap.version === 2 && Array.isArray(snap.objects)){
          buildFromSnapshot(snap);
          undoStack.length = 0;
          undoStack.push(snap);
          showToast("Restored autosave ‚úÖ");
        }
      }
    }catch{}

    // Save/Load JSON
    ui.btnSave.onclick = ()=>{
      const data = JSON.stringify(serializeScene(), null, 2);
      const blob = new Blob([data], { type:"application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = `ArkScene_${new Date().toISOString().replace(/[:.]/g,"-")}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
      showToast("Saved scene JSON ‚¨áÔ∏è");
    };

    ui.btnLoad.onclick = ()=> ui.fileIn.click();
    ui.fileIn.onchange = async (e)=>{
      const f = e.target.files?.[0];
      if(!f) return;
      const text = await f.text();
      const snap = JSON.parse(text);
      if(!snap || snap.version !== 2){ showToast("Not a v2 scene JSON"); return; }
      buildFromSnapshot(snap);
      undoStack.length = 0;
      redoStack.length = 0;
      undoStack.push(serializeScene());
      showToast("Loaded scene ‚úÖ");
      ui.fileIn.value = "";
    };

    // -----------------------------
    // Fly mode (desktop pointer lock) + touch fallback
    // -----------------------------
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let moveF=false, moveB=false, moveL=false, moveR=false;
    let prevTime = performance.now();

    function enterFly(){
      if(useOrtho){ showToast("Fly requires Perspective (turn Ortho off)"); return; }
      if(isTouch){
        isFlyMode = true;
        ui.crosshair.style.display = "block";
        ui.touchHUD.style.display = "block";
        ui.ui?.style?.display; // noop
        $("ui").style.display = "none";
        showToast("Touch Fly ON");
        return;
      }
      fly.lock();
    }

    function exitFly(){
      if(isTouch){
        isFlyMode = false;
        ui.crosshair.style.display = "none";
        ui.touchHUD.style.display = "none";
        $("ui").style.display = "flex";
        showToast("Touch Fly OFF");
        return;
      }
      fly.unlock();
    }

    fly.addEventListener("lock", ()=>{
      isFlyMode = true;
      ui.crosshair.style.display = "block";
      $("ui").style.display = "none";
      showToast("Fly ON");
    });
    fly.addEventListener("unlock", ()=>{
      isFlyMode = false;
      ui.crosshair.style.display = "none";
      $("ui").style.display = "flex";
      // keep you above the decks a bit
      cameraPersp.position.y = Math.max(cameraPersp.position.y, -12);
      showToast("Fly OFF");
    });

    ui.btnFly.onclick = ()=>{
      if(isFlyMode) exitFly();
      else enterFly();
      ui.btnFly.textContent = isFlyMode ? "Exit Fly" : "Enter Fly";
    };

    // Fly keys
    window.addEventListener("keydown", (e)=>{
      if(e.ctrlKey && (e.key==="z" || e.key==="Z")){ e.preventDefault(); undo(); return; }
      if(e.ctrlKey && (e.key==="y" || e.key==="Y")){ e.preventDefault(); redo(); return; }
      if(e.ctrlKey && (e.key==="d" || e.key==="D")){
        e.preventDefault();
        if(selected && !selected.userData.locked){
          const snap = serializeOne(selected);
          const dup = deserializeOne(snap);
          dup.position.add(new THREE.Vector3(2,0,2));
          select(dup);
          pushUndo();
          showToast("Duplicated (Ctrl+D)");
        }
        return;
      }
      if(e.key === "Escape"){
        if(isFlyMode) exitFly();
        if(placeMode){ placeMode=false; ui.btnPlace.textContent="Place: Off"; showToast("Place OFF"); }
        return;
      }

      if(!isFlyMode){
        if(e.key === "w" || e.key==="W") setMode("translate");
        if(e.key === "e" || e.key==="E") setMode("rotate");
        if(e.key === "r" || e.key==="R") setMode("scale");
        if(e.key === "Delete") deleteSelected();
        if(e.key === "f" || e.key==="F") frameSelected();
      }else{
        if(e.code==="KeyW" || e.code==="ArrowUp") moveF=true;
        if(e.code==="KeyS" || e.code==="ArrowDown") moveB=true;
        if(e.code==="KeyA" || e.code==="ArrowLeft") moveL=true;
        if(e.code==="KeyD" || e.code==="ArrowRight") moveR=true;
      }
    });

    window.addEventListener("keyup", (e)=>{
      if(!isFlyMode) return;
      if(e.code==="KeyW" || e.code==="ArrowUp") moveF=false;
      if(e.code==="KeyS" || e.code==="ArrowDown") moveB=false;
      if(e.code==="KeyA" || e.code==="ArrowLeft") moveL=false;
      if(e.code==="KeyD" || e.code==="ArrowRight") moveR=false;
    });

    // Touch fly: sticks
    const stickState = {
      move: { id:null, cx:0, cy:0, x:0, y:0 },
      look: { id:null, cx:0, cy:0, x:0, y:0 }
    };

    function bindStick(el, nub, state){
      const rectOf = ()=> el.getBoundingClientRect();
      const clamp = (v, m)=> Math.max(-m, Math.min(m, v));

      el.addEventListener("pointerdown", (e)=>{
        el.setPointerCapture(e.pointerId);
        const r = rectOf();
        state.id = e.pointerId;
        state.cx = r.left + r.width/2;
        state.cy = r.top + r.height/2;
        state.x = 0; state.y = 0;
      });

      el.addEventListener("pointermove", (e)=>{
        if(state.id !== e.pointerId) return;
        const dx = e.clientX - state.cx;
        const dy = e.clientY - state.cy;
        const max = 44;
        state.x = clamp(dx, max)/max;
        state.y = clamp(dy, max)/max;
        nub.style.transform = `translate(${state.x*44 - 27}px, ${state.y*44 - 27}px)`;
      });

      const up = (e)=>{
        if(state.id !== e.pointerId) return;
        state.id = null;
        state.x = 0; state.y = 0;
        nub.style.transform = "translate(-50%,-50%)";
      };
      el.addEventListener("pointerup", up);
      el.addEventListener("pointercancel", up);
    }

    bindStick($("stickMove"), $("nubMove"), stickState.move);
    bindStick($("stickLook"), $("nubLook"), stickState.look);

    // -----------------------------
    // Selection / placement pointer
    // -----------------------------
    renderer.domElement.addEventListener("pointerdown", (e)=>{
      if(isFlyMode) return;

      // ignore UI clicks
      if(e.target.closest("#ui")) return;

      mouseNDC.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouseNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouseNDC, camera());
      if(placeMode){
        const hits = raycaster.intersectObjects(surfaces, false);
        if(hits.length){
          placeAtHit(hits[0]);
        }else{
          showToast("Click a deck to place.");
        }
        return;
      }

      // select
      const hits = raycaster.intersectObjects(editables, false);
      if(hits.length){
        const o = hits[0].object;
        select(o);
      }else{
        select(null);
      }
    });

    // Prevent transforming locked objects
    transform.addEventListener("mouseDown", ()=>{
      if(selected && selected.userData.locked){
        transform.detach();
        showToast("Locked üîí");
      }
    });
    transform.addEventListener("mouseUp", ()=>{
      if(selected && !selected.userData.locked) pushUndo();
    });

    // -----------------------------
    // Helpers: duplicate / frame / toast
    // -----------------------------
    function serializeOne(o){
      return {
        type: o.userData.type,
        name: o.userData.name,
        matKey: o.userData.matKey,
        color: (o.material && o.material.color) ? o.material.color.getHex() : null,
        locked: !!o.userData.locked,
        pos: o.position.toArray(),
        quat: o.quaternion.toArray(),
        scale: o.scale.toArray(),
      };
    }
    function deserializeOne(d){
      let geo;
      if(d.type === "cube") geo = new THREE.BoxGeometry(2,2,2);
      if(d.type === "cyl") geo = new THREE.CylinderGeometry(1,1,2,18);
      if(d.type === "wall") geo = new THREE.BoxGeometry(10,8,0.5);
      const mat = materialFromKey(d.matKey, d.color);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData.editable = true;
      mesh.userData.type = d.type;
      mesh.userData.matKey = d.matKey;
      mesh.userData.locked = !!d.locked;
      mesh.userData.name = d.name || d.type;
      mesh.name = mesh.userData.name;
      mesh.position.fromArray(d.pos);
      mesh.quaternion.fromArray(d.quat);
      mesh.scale.fromArray(d.scale);
      scene.add(mesh);
      editables.push(mesh);
      refreshHierarchy();
      return mesh;
    }

    function frameSelected(){
      if(!selected) return;
      const box = new THREE.Box3().setFromObject(selected);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      orbit.target.copy(center);

      const maxDim = Math.max(size.x, size.y, size.z);
      const dist = maxDim * 2.2 + 10;
      const dir = new THREE.Vector3(1, 0.6, 1).normalize();
      cameraPersp.position.copy(center.clone().add(dir.multiplyScalar(dist)));
      cameraPersp.lookAt(center);

      if(cameraOrtho){
        cameraOrtho.position.copy(cameraPersp.position);
        cameraOrtho.lookAt(center);
      }
      showToast("Framed (F)");
    }

    let toastTimer = null;
    function showToast(msg){
      ui.toast.textContent = msg;
      ui.toast.style.display = "block";
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=> ui.toast.style.display = "none", 1200);
    }

    // -----------------------------
    // Basic ‚Äúkeep inside ark‚Äù clamp for fly (simple bounds)
    // -----------------------------
    function clampFly(){
      const p = cameraPersp.position;

      // keep near the ark region (simple cylindrical clamp)
      const maxR = ARK_RADIUS * 0.93;
      const r = Math.hypot(p.x, p.z);
      if(r > maxR){
        const k = maxR / r;
        p.x *= k; p.z *= k;
      }

      // vertical bounds (approx inside + stairs)
      p.y = Math.min(14, Math.max(-16, p.y));

      // don‚Äôt fall through water plane too far
      p.y = Math.max(p.y, -18);
    }

    // -----------------------------
    // Render loop
    // -----------------------------
    function animate(t){
      renderer.setAnimationLoop(()=> {
        const time = performance.now();

        // Water animation
        if(water && waterBase){
          const geo = water.geometry;
          const pos = geo.attributes.position;
          const arr = pos.array;
          const tt = time * 0.0012;
          for(let i=0;i<arr.length;i+=3){
            const x = waterBase[i];
            const z = waterBase[i+2];
            const w = Math.sin((x*0.06)+tt) * 0.42 + Math.cos((z*0.05)+tt*1.1) * 0.36;
            arr[i+1] = waterBase[i+1] + w;
          }
          pos.needsUpdate = true;
          geo.computeVertexNormals();
        }

        // Fly motion
        if(isFlyMode){
          const delta = Math.min(0.05, (time - prevTime) / 1000);
          prevTime = time;

          // Desktop pointer lock fly
          if(!isTouch && fly.isLocked){
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveF) - Number(moveB);
            direction.x = Number(moveR) - Number(moveL);
            direction.normalize();

            const speed = 70;
            if (moveF || moveB) velocity.z -= direction.z * speed * delta;
            if (moveL || moveR) velocity.x -= direction.x * speed * delta;

            fly.moveRight(-velocity.x * delta);
            fly.moveForward(-velocity.z * delta);
          }

          // Touch fly using sticks
          if(isTouch){
            const mv = stickState.move;
            const lk = stickState.look;

            // move
            const speed = 28;
            const forward = new THREE.Vector3();
            cameraPersp.getWorldDirection(forward);
            forward.y = 0; forward.normalize();
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

            cameraPersp.position.add(forward.multiplyScalar((-mv.y) * speed * 0.016));
            cameraPersp.position.add(right.multiplyScalar((mv.x) * speed * 0.016));

            // look (yaw/pitch)
            const yaw = -lk.x * 0.035;
            const pitch = -lk.y * 0.025;

            const euler = new THREE.Euler().setFromQuaternion(cameraPersp.quaternion, "YXZ");
            euler.y += yaw;
            euler.x = THREE.MathUtils.clamp(euler.x + pitch, -1.2, 1.2);
            cameraPersp.quaternion.setFromEuler(euler);
          }

          clampFly();
        }else{
          orbit.update();
          if(cameraOrtho){
            cameraOrtho.position.copy(cameraPersp.position);
            cameraOrtho.lookAt(orbit.target);
          }
        }

        renderer.render(scene, camera());
      });
    }
    animate();

    // Resize
    window.addEventListener("resize", ()=>{
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

      cameraPersp.aspect = window.innerWidth/window.innerHeight;
      cameraPersp.updateProjectionMatrix();

      if(cameraOrtho){
        const aspect = window.innerWidth/window.innerHeight;
        const d = 45;
        cameraOrtho.left = -d*aspect;
        cameraOrtho.right = d*aspect;
        cameraOrtho.top = d;
        cameraOrtho.bottom = -d;
        cameraOrtho.updateProjectionMatrix();
      }
    });

    // Update fly button label live
    setInterval(()=>{
      ui.btnFly.textContent = isFlyMode ? "Exit Fly" : "Enter Fly";
    }, 200);

    // Start with a nice view
    showToast("Ark Architect v2 ready ‚úÖ");
    refreshHierarchy();
  </script>
</body>
</html>
