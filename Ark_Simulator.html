<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>üõ†Ô∏è Ark Architect v3 ‚Äî Physics Walk + Sails</title>
  <style>
    :root{
      --bg: rgba(22,24,29,.92);
      --line: rgba(255,255,255,.12);
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --accent: #61dafb;
      --ok: #50c878;
      --warn:#e24a4a;
      --btn:#4a90e2;
      --btn2:#2f6fb6;
    }
    html,body{ margin:0; height:100%; overflow:hidden; background:#000; font-family: "Segoe UI", system-ui, -apple-system, Arial; }
    canvas{ display:block; }

    #ui{
      position:absolute; top:10px; left:10px; width:300px;
      background: var(--bg); color:var(--txt);
      border:1px solid var(--line); border-radius:12px;
      padding:12px; pointer-events:auto;
      box-shadow: 0 12px 40px rgba(0,0,0,.45);
      display:flex; flex-direction:column; gap:10px;
      max-height: calc(100vh - 20px);
      overflow:auto;
    }
    #ui h3{ margin:0; font-size:16px; color:var(--accent); letter-spacing:.2px; }
    .row{ display:flex; gap:8px; align-items:center; }
    .row > * { flex:1; }
    .mini{ font-size:12px; color:var(--muted); line-height:1.25; }
    hr{ border:none; border-top:1px solid var(--line); margin:6px 0; }

    button{
      background: var(--btn);
      border:none; color:white; padding:9px 10px;
      border-radius:10px; cursor:pointer;
      font-weight:700; letter-spacing:.2px;
      transition: transform .06s, background .2s, opacity .2s;
    }
    button:hover{ background: var(--btn2); }
    button:active{ transform: translateY(1px); }
    button.secondary{ background: rgba(255,255,255,.10); }
    button.secondary:hover{ background: rgba(255,255,255,.16); }
    button.ok{ background: var(--ok); }
    button.danger{ background: var(--warn); }
    button.tiny{ padding:7px 8px; border-radius:9px; font-size:12px; }

    label{ font-size:12px; color:var(--muted); display:flex; justify-content:space-between; gap:10px; }
    input[type="range"]{ width:100%; }
    input[type="text"]{
      width:100%; padding:8px 10px; border-radius:10px;
      border:1px solid var(--line); outline:none;
      background: rgba(255,255,255,.06); color:var(--txt);
    }
    select{
      width:100%; padding:8px 10px; border-radius:10px;
      border:1px solid var(--line); outline:none;
      background: rgba(255,255,255,.06); color:var(--txt);
    }

    #help{
      position:absolute; bottom:10px; left:10px;
      color: rgba(255,255,255,.70);
      font-size:12px; pointer-events:none;
      text-shadow: 0 2px 10px rgba(0,0,0,.65);
      max-width: 64vw;
      line-height:1.25;
    }
    #crosshair{
      position:absolute; top:50%; left:50%;
      width:10px; height:10px; border-radius:50%;
      border:2px solid rgba(255,255,255,.55);
      transform: translate(-50%,-50%);
      display:none; pointer-events:none;
    }
    #toast{
      position:absolute; top:10px; right:10px;
      background: rgba(0,0,0,.55);
      color: rgba(255,255,255,.9);
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      font-size:12px;
      max-width: 44vw;
      display:none;
      pointer-events:none;
    }

    /* Hierarchy */
    #hier{
      border:1px solid var(--line);
      border-radius:12px;
      overflow:hidden;
    }
    #hierHead{
      padding:8px 10px;
      background: rgba(255,255,255,.06);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      font-size:12px; color:var(--muted);
    }
    #hierList{
      max-height: 160px;
      overflow:auto;
      background: rgba(0,0,0,.12);
    }
    .item{
      padding:8px 10px;
      border-top:1px solid var(--line);
      display:flex; gap:8px; align-items:center;
      cursor:pointer;
      user-select:none;
    }
    .item:hover{ background: rgba(255,255,255,.06); }
    .dot{ width:10px; height:10px; border-radius:50%; background: rgba(255,255,255,.35); }
    .item.sel .dot{ background: var(--accent); }
    .item .name{ flex:1; font-size:12px; color:var(--txt); opacity:.95; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
    .lock{ font-size:12px; opacity:.7; }
    .pill{
      font-size:10px; padding:2px 6px; border-radius:999px;
      border:1px solid var(--line); color:var(--muted);
    }

    /* Touch walk controls */
    #touchHUD{ position:absolute; inset:0; pointer-events:none; display:none; }
    .stick{
      position:absolute; bottom:16px; width:140px; height:140px;
      border-radius:50%;
      border:2px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.12);
      pointer-events:auto;
      touch-action:none;
    }
    #stickMove{ left:16px; }
    #stickLook{ right:16px; }
    .nub{
      position:absolute; left:50%; top:50%;
      width:54px; height:54px; border-radius:50%;
      transform: translate(-50%,-50%);
      border:2px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.06);
    }
    #jumpBtn{
      position:absolute; right:16px; bottom:170px;
      width:140px; height:52px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.9);
      font-weight:800;
      pointer-events:auto;
      touch-action:none;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="crosshair"></div>
  <div id="toast"></div>

  <div id="ui">
    <h3>üõ†Ô∏è Ark Architect v3</h3>

    <div class="row">
      <button id="btnWalk" class="ok">Enter Walk (Physics)</button>
      <button id="btnPlace" class="secondary">Place: Off</button>
    </div>
    <div class="mini">Walk = collisions + gravity. Place = click a deck to drop new objects.</div>

    <div class="row">
      <button id="btnWindows" class="secondary">Roof Windows: Open</button>
      <button id="btnSails" class="secondary">Sails: Deployed</button>
    </div>

    <hr>

    <label>Material</label>
    <select id="matSelect">
      <option value="random">üé≤ Random Color</option>
      <option value="woodLight">ü™µ Light Wood</option>
      <option value="woodDark">ü™µ Dark Wood</option>
      <option value="white">‚¨ú White</option>
      <option value="copper">ü•Å Copper</option>
      <option value="glass">ü™ü Glass</option>
      <option value="cloth">üßµ Cloth</option>
    </select>

    <label>Primitive</label>
    <div class="row">
      <button id="addCube">‚ûï Cube</button>
      <button id="addCyl">‚ûï Cylinder</button>
    </div>
    <div class="row">
      <button id="addWall" class="secondary">‚ûï Wall</button>
      <button id="addDoor" class="secondary">‚ûï Door</button>
    </div>

    <hr>

    <label>Transform</label>
    <div class="row">
      <button id="modeMove" class="tiny">Move (W)</button>
      <button id="modeRot" class="tiny secondary">Rot (E)</button>
      <button id="modeScale" class="tiny secondary">Scale (R)</button>
    </div>

    <label>Snapping</label>
    <label>Grid (units) <span id="snapTVal" class="mini">1.00</span></label>
    <input id="snapT" type="range" min="0" max="5" step="0.25" value="1" />
    <label>Rotate (deg) <span id="snapRVal" class="mini">15¬∞</span></label>
    <input id="snapR" type="range" min="0" max="45" step="1" value="15" />
    <label>Scale (units) <span id="snapSVal" class="mini">0.25</span></label>
    <input id="snapS" type="range" min="0" max="2" step="0.05" value="0.25" />
    <div class="row">
      <button id="btnSnap" class="secondary">Snap: On</button>
      <button id="btnRebuild" class="secondary">Rebuild Physics</button>
    </div>

    <hr>

    <div id="hier">
      <div id="hierHead">
        <span>Hierarchy</span>
        <span class="mini" id="hierCount">0</span>
      </div>
      <div id="hierList"></div>
    </div>

    <label>Selected Name</label>
    <input id="nameBox" type="text" placeholder="(select something)" />

    <div class="row">
      <button id="btnLock" class="secondary">Lock</button>
      <button id="btnDel" class="danger">Delete</button>
    </div>

    <hr>

    <div class="mini">
      Walk: WASD ‚Ä¢ Mouse look ‚Ä¢ Space jump ‚Ä¢ Shift sprint ‚Ä¢ ESC exit<br>
      Editor: click select ‚Ä¢ W/E/R gizmo ‚Ä¢ Del delete ‚Ä¢ Place mode drop objects<br>
      Doors: click a Door to toggle open/close (also blocks physics)
    </div>
  </div>

  <div id="touchHUD">
    <div id="stickMove" class="stick"><div class="nub" id="nubMove"></div></div>
    <div id="stickLook" class="stick"><div class="nub" id="nubLook"></div></div>
    <button id="jumpBtn">JUMP</button>
  </div>

  <div id="help">
    <b>Walk Mode:</b> collisions + gravity + ‚Äúrescue‚Äù if you get into a bad spot.<br>
    <b>Roof Windows:</b> retractable skylights + cloth sail shutters (toggle buttons).
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { TransformControls } from "three/addons/controls/TransformControls.js";
    import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
    import { Octree } from "three/addons/math/Octree.js";
    import { Capsule } from "three/addons/math/Capsule.js";

    // ------------------------------------------------------------
    // Utils
    // ------------------------------------------------------------
    const $ = (id)=>document.getElementById(id);
    let toastTimer=null;
    function showToast(msg){
      $("toast").textContent = msg;
      $("toast").style.display = "block";
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=> $("toast").style.display = "none", 1200);
    }

    const isTouch = matchMedia("(pointer: coarse)").matches || ("ontouchstart" in window);

    // ------------------------------------------------------------
    // Scene
    // ------------------------------------------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 30, 240);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Cameras
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1500);
    camera.position.set(60, 38, 60);

    // Lighting
    scene.add(new THREE.HemisphereLight(0xffffff, 0x334455, 0.85));
    const sun = new THREE.DirectionalLight(0xffffff, 1.35);
    sun.position.set(80, 140, 70);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.camera.near = 10;
    sun.shadow.camera.far = 450;
    sun.shadow.camera.left = -160;
    sun.shadow.camera.right = 160;
    sun.shadow.camera.top = 160;
    sun.shadow.camera.bottom = -160;
    scene.add(sun);

    // Controls
    const orbit = new OrbitControls(camera, renderer.domElement);
    orbit.enableDamping = true;
    orbit.target.set(0, 6, 0);

    const transform = new TransformControls(camera, renderer.domElement);
    transform.addEventListener("dragging-changed", (e)=> orbit.enabled = !e.value);
    scene.add(transform);

    // Pointer lock for WALK
    const walkControls = new PointerLockControls(camera, document.body);

    // ------------------------------------------------------------
    // Materials
    // ------------------------------------------------------------
    const MAT = {
      woodDark: new THREE.MeshStandardMaterial({ color:0x5c4033, roughness:0.85, metalness:0.05 }),
      woodLight: new THREE.MeshStandardMaterial({ color:0xdeb887, roughness:0.55, metalness:0.05 }),
      white: new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.65, metalness:0.0 }),
      copper: new THREE.MeshStandardMaterial({ color:0xb87333, metalness:0.65, roughness:0.35, side:THREE.DoubleSide }),
      glass: new THREE.MeshPhysicalMaterial({ color:0xffffff, transmission:0.9, opacity:1, transparent:true, roughness:0.0, thickness:0.6 }),
      cloth: new THREE.MeshStandardMaterial({ color:0xf3f0e6, roughness:0.95, metalness:0.0, side:THREE.DoubleSide })
    };
    function pickMaterial(){
      const key = $("matSelect").value;
      if(key === "random"){
        return { key:"random", mat: new THREE.MeshStandardMaterial({ color: Math.random()*0xffffff, roughness:0.6, metalness:0.1 }) };
      }
      return { key, mat: MAT[key].clone() };
    }

    // ------------------------------------------------------------
    // Ark geometry + features
    // ------------------------------------------------------------
    const ARK_RADIUS = 25;

    const arkGroup = new THREE.Group();
    scene.add(arkGroup);

    const staticCollidersGroup = new THREE.Group(); // things used for physics octree
    scene.add(staticCollidersGroup);

    const surfaces = []; // decks (place targets)

    // Roof windows + sails
    const roofWindows = []; // { shutterMesh, clothMesh, open01 }
    let windowsOpen = true;

    const sailCloths = []; // cloth meshes that wave
    let sailsDeployed = true;

    // --- Water ---
    let water=null, waterBase=null;
    function buildWater(){
      const geo = new THREE.PlaneGeometry(650,650,140,140);
      const mat = new THREE.MeshStandardMaterial({ color:0x004466, roughness:0.25, metalness:0.7, transparent:true, opacity:0.85 });
      water = new THREE.Mesh(geo, mat);
      water.rotation.x = -Math.PI/2;
      water.position.y = -2.2;
      water.receiveShadow = true;
      scene.add(water);
      waterBase = new Float32Array(geo.attributes.position.array.length);
      waterBase.set(geo.attributes.position.array);
    }

    function addRailRing(y, r){
      // A thin invisible railing ring (as boxes around circle)
      const n = 24;
      const segLen = (2*Math.PI*r)/n;
      for(let i=0;i<n;i++){
        const a = (i/n)*Math.PI*2;
        const box = new THREE.Mesh(
          new THREE.BoxGeometry(segLen*0.9, 2.2, 0.35),
          new THREE.MeshBasicMaterial({ transparent:true, opacity:0.0 })
        );
        box.position.set(Math.cos(a)*r, y+1.1, Math.sin(a)*r);
        box.rotation.y = -a;
        box.userData.staticCollider = true;
        staticCollidersGroup.add(box);
      }
    }

    function buildArk(){
      // Outer hull
      const hullGeo = new THREE.SphereGeometry(ARK_RADIUS, 64, 32, 0, Math.PI*2, 0, Math.PI/2);
      hullGeo.scale(1, 0.6, 1);
      hullGeo.rotateZ(Math.PI);

      const hullOuter = new THREE.Mesh(hullGeo, MAT.woodDark.clone());
      hullOuter.castShadow = true;
      hullOuter.receiveShadow = true;
      arkGroup.add(hullOuter);

      // Inner hull collider + visible
      const innerGeo = hullGeo.clone();
      innerGeo.scale(0.98,0.98,0.98);
      const hullInner = new THREE.Mesh(innerGeo, MAT.woodLight.clone());
      hullInner.material.side = THREE.BackSide;
      hullInner.receiveShadow = true;
      arkGroup.add(hullInner);

      // Physics collider uses the same mesh
      const hullCollider = hullInner.clone();
      hullCollider.material = new THREE.MeshBasicMaterial({ visible:false });
      hullCollider.userData.staticCollider = true;
      staticCollidersGroup.add(hullCollider);

      // Decks (now 3 floors)
      const deckM = MAT.woodLight.clone();

      const lower = new THREE.Mesh(new THREE.CylinderGeometry(ARK_RADIUS*0.72, ARK_RADIUS*0.72, 0.65, 42), deckM);
      lower.position.y = -10.5;
      lower.receiveShadow = true;
      lower.userData.surface = true;
      arkGroup.add(lower);
      surfaces.push(lower);

      const mid = new THREE.Mesh(new THREE.CylinderGeometry(ARK_RADIUS*0.82, ARK_RADIUS*0.82, 0.65, 46), deckM.clone());
      mid.position.y = -5.0;
      mid.receiveShadow = true;
      mid.userData.surface = true;
      arkGroup.add(mid);
      surfaces.push(mid);

      const upper = new THREE.Mesh(new THREE.CylinderGeometry(ARK_RADIUS*0.92, ARK_RADIUS*0.92, 0.65, 50), deckM.clone());
      upper.position.y = 0.0;
      upper.receiveShadow = true;
      upper.userData.surface = true;
      arkGroup.add(upper);
      surfaces.push(upper);

      // Add invisible railings so you can't fall off into ‚Äútrap spots‚Äù
      addRailRing(lower.position.y, ARK_RADIUS*0.72);
      addRailRing(mid.position.y,   ARK_RADIUS*0.82);
      addRailRing(upper.position.y, ARK_RADIUS*0.92);

      // Add floor colliders
      [lower, mid, upper].forEach(d=>{
        const c = d.clone();
        c.material = new THREE.MeshBasicMaterial({ visible:false });
        c.userData.staticCollider = true;
        staticCollidersGroup.add(c);
      });

      // Roof cymbal
      const roof = new THREE.Mesh(new THREE.ConeGeometry(ARK_RADIUS+2, 9, 72, 1, true), MAT.copper.clone());
      roof.position.y = 4.5;
      roof.castShadow = true;
      arkGroup.add(roof);

      // Window band
      const band = new THREE.Mesh(new THREE.CylinderGeometry(ARK_RADIUS, ARK_RADIUS, 4.5, 48, 1, true), MAT.glass.clone());
      band.position.y = 2.25;
      arkGroup.add(band);

      // Central mast/spine
      const spine = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.9,24,18), MAT.woodLight.clone());
      spine.position.y = -2.5;
      spine.castShadow = true;
      spine.receiveShadow = true;
      arkGroup.add(spine);

      const spineCollider = spine.clone();
      spineCollider.material = new THREE.MeshBasicMaterial({ visible:false });
      spineCollider.userData.staticCollider = true;
      staticCollidersGroup.add(spineCollider);

      // Spiral stairs (colliders + visible)
      const stepMat = MAT.woodLight.clone();
      for(let i=0;i<46;i++){
        const step = new THREE.Mesh(new THREE.BoxGeometry(4,0.26,1.05), stepMat);
        const a = i*0.48;
        const y = 6 - i*0.43;
        step.position.set(Math.cos(a)*3.1, y, Math.sin(a)*3.1);
        step.rotation.y = -a;
        step.castShadow = true;
        step.receiveShadow = true;
        arkGroup.add(step);

        const stepC = step.clone();
        stepC.material = new THREE.MeshBasicMaterial({ visible:false });
        stepC.userData.staticCollider = true;
        staticCollidersGroup.add(stepC);
      }

      // Interior partitions + human doors
      buildInteriorRooms(upper.position.y, ARK_RADIUS*0.72);
      buildInteriorRooms(mid.position.y,   ARK_RADIUS*0.62);

      // Roof sail windows (retractable)
      buildRoofWindows(roof.position.y + 1.8);

      // Cloth sails (decor + wind)
      buildClothSails(spine);
    }

    function buildInteriorRooms(levelY, roomR){
      // Simple radial walls + doorways
      const wallMat = MAT.woodDark.clone();
      const h = 2.6;            // human-ish
      const t = 0.28;
      const doorW = 1.0;
      const doorH = 2.1;

      // 4 ‚Äúrooms‚Äù
      for(let i=0;i<4;i++){
        const a = i*(Math.PI/2);
        const wallLen = roomR*1.1;

        // Wall segment left of doorway
        const seg1 = new THREE.Mesh(new THREE.BoxGeometry((wallLen/2)-doorW, h, t), wallMat);
        seg1.position.set(Math.cos(a)*0.0, levelY + h/2, Math.sin(a)*0.0);
        seg1.rotation.y = a;
        seg1.position.x += Math.cos(a+Math.PI/2)*((doorW/2)+(wallLen/4));
        seg1.position.z += Math.sin(a+Math.PI/2)*((doorW/2)+(wallLen/4));
        seg1.castShadow = seg1.receiveShadow = true;
        arkGroup.add(seg1);

        const seg1C = seg1.clone();
        seg1C.material = new THREE.MeshBasicMaterial({ visible:false });
        seg1C.userData.staticCollider = true;
        staticCollidersGroup.add(seg1C);

        // Wall segment right of doorway
        const seg2 = new THREE.Mesh(new THREE.BoxGeometry((wallLen/2)-doorW, h, t), wallMat.clone());
        seg2.position.copy(seg1.position);
        seg2.position.x -= Math.cos(a+Math.PI/2)*((doorW)+(wallLen/2));
        seg2.position.z -= Math.sin(a+Math.PI/2)*((doorW)+(wallLen/2));
        seg2.rotation.y = a;
        seg2.castShadow = seg2.receiveShadow = true;
        arkGroup.add(seg2);

        const seg2C = seg2.clone();
        seg2C.material = new THREE.MeshBasicMaterial({ visible:false });
        seg2C.userData.staticCollider = true;
        staticCollidersGroup.add(seg2C);

        // Door (hinged)
        const door = createDoorMesh(doorW, doorH, t*0.8);
        door.position.set(Math.cos(a+Math.PI/2)*(roomR*0.35), levelY + doorH/2, Math.sin(a+Math.PI/2)*(roomR*0.35));
        door.rotation.y = a;
        arkGroup.add(door);

        // Door collider (separate; we toggle visibility + inclusion)
        door.userData.doorCollider = door.children.find(ch=>ch.userData.isDoorCollider) || null;
      }
    }

    function createDoorMesh(w, h, t){
      const group = new THREE.Group();
      group.userData.editable = false;
      group.userData.isDoor = true;
      group.userData.open01 = 0; // 0 closed, 1 open
      group.userData.locked = false;
      group.userData.name = "Door";
      group.name = "Door";

      // Frame
      const frameMat = MAT.woodDark.clone();
      const frame = new THREE.Mesh(new THREE.BoxGeometry(w+0.18, h+0.18, t+0.12), frameMat);
      frame.castShadow = frame.receiveShadow = true;
      group.add(frame);

      // Door leaf (hinge at left)
      const leafMat = MAT.woodLight.clone();
      const leafPivot = new THREE.Group();
      leafPivot.position.x = -(w/2);
      group.add(leafPivot);

      const leaf = new THREE.Mesh(new THREE.BoxGeometry(w, h, t), leafMat);
      leaf.position.x = (w/2);
      leaf.castShadow = leaf.receiveShadow = true;
      leafPivot.add(leaf);

      // Collider for closed door (invisible box over leaf)
      const coll = new THREE.Mesh(new THREE.BoxGeometry(w, h, t), new THREE.MeshBasicMaterial({ visible:false }));
      coll.position.copy(leaf.position);
      coll.userData.staticCollider = true;
      coll.userData.isDoorCollider = true;
      leafPivot.add(coll);
      staticCollidersGroup.add(coll); // initially closed => collides

      group.userData.leafPivot = leafPivot;
      group.userData.leaf = leaf;
      group.userData.collider = coll;

      return group;
    }

    function buildRoofWindows(yTop){
      // 3 retractable ‚Äúsail windows‚Äù around roof
      const n = 3;
      const r = ARK_RADIUS * 0.55;
      for(let i=0;i<n;i++){
        const a = (i/n)*Math.PI*2;

        // A circular opening rim
        const rim = new THREE.Mesh(
          new THREE.TorusGeometry(2.8, 0.18, 10, 48),
          MAT.copper.clone()
        );
        rim.position.set(Math.cos(a)*r, yTop, Math.sin(a)*r);
        rim.rotation.x = Math.PI/2;
        rim.castShadow = true;
        arkGroup.add(rim);

        // A retractable copper shutter (slides back)
        const shutter = new THREE.Mesh(
          new THREE.BoxGeometry(6.0, 0.12, 3.2),
          MAT.copper.clone()
        );
        shutter.position.set(Math.cos(a)*r, yTop+0.15, Math.sin(a)*r);
        shutter.rotation.y = -a;
        shutter.castShadow = true;
        arkGroup.add(shutter);

        // Cloth ‚Äúsail‚Äù that also retracts (like a pull-back shade)
        const clothGeo = new THREE.PlaneGeometry(5.8, 3.0, 18, 10);
        const cloth = new THREE.Mesh(clothGeo, MAT.cloth.clone());
        cloth.position.set(Math.cos(a)*r, yTop+0.06, Math.sin(a)*r);
        cloth.rotation.x = -Math.PI/2;
        cloth.rotation.z = a;
        cloth.castShadow = true;
        arkGroup.add(cloth);

        cloth.userData.isCloth = true;
        roofWindows.push({ shutter, cloth, open01: 1, anchor: new THREE.Vector3(Math.cos(a)*r, yTop, Math.sin(a)*r), a });
        sailCloths.push(cloth);
      }
    }

    function buildClothSails(spine){
      // Two big cloth sails attached near top (decor + motion)
      const sailMat = MAT.cloth.clone();
      sailMat.color.setHex(0xf7f2e6);

      function makeSail(width, height){
        const geo = new THREE.PlaneGeometry(width, height, 26, 18);
        const m = new THREE.Mesh(geo, sailMat.clone());
        m.castShadow = true;
        m.userData.isCloth = true;
        sailCloths.push(m);
        return m;
      }

      const sail1 = makeSail(12, 8);
      sail1.position.set(0, 8.5, -6);
      sail1.rotation.y = 0.25;
      arkGroup.add(sail1);

      const sail2 = makeSail(10, 7);
      sail2.position.set(0, 7.8, 7);
      sail2.rotation.y = -0.3;
      arkGroup.add(sail2);
    }

    buildWater();
    buildArk();

    // ------------------------------------------------------------
    // Editor objects (user placed) + selection/hierarchy
    // ------------------------------------------------------------
    let editables = []; // placed primitives (collidable)
    let selected = null;
    const prevEmissive = new Map();
    function highlight(obj, on){
      if(!obj || !obj.material || !("emissive" in obj.material)) return;
      if(on){
        if(!prevEmissive.has(obj)) prevEmissive.set(obj, obj.material.emissive.clone());
        obj.material.emissive.setHex(0x2a7fff);
        obj.material.emissiveIntensity = 0.7;
      }else{
        const prev = prevEmissive.get(obj);
        if(prev){
          obj.material.emissive.copy(prev);
          obj.material.emissiveIntensity = 0.15;
        }else{
          obj.material.emissive.setHex(0x000000);
          obj.material.emissiveIntensity = 0.0;
        }
      }
    }

    function select(obj){
      if(selected === obj) return;
      if(selected) highlight(selected,false);

      selected = obj || null;

      if(selected){
        highlight(selected,true);
        transform.attach(selected);
        $("nameBox").value = selected.userData.name || selected.name || "";
        $("btnLock").textContent = selected.userData.locked ? "Unlock" : "Lock";
      }else{
        transform.detach();
        $("nameBox").value = "";
        $("btnLock").textContent = "Lock";
      }
      refreshHierarchy();
    }

    function refreshHierarchy(){
      const list = $("hierList");
      list.innerHTML = "";
      $("hierCount").textContent = String(editables.length);

      editables.forEach((o, idx)=>{
        const div = document.createElement("div");
        div.className = "item" + (o === selected ? " sel" : "");
        const dot = document.createElement("div"); dot.className="dot";
        const name = document.createElement("div"); name.className="name";
        name.textContent = o.userData.name || o.name || ("Object "+idx);
        const pill = document.createElement("span"); pill.className="pill";
        pill.textContent = o.userData.type || "obj";
        const lock = document.createElement("span"); lock.className="lock";
        lock.textContent = o.userData.locked ? "üîí" : "";
        div.append(dot,name,pill,lock);
        div.onclick = ()=> select(o);
        list.appendChild(div);
      });
    }

    $("nameBox").addEventListener("change", ()=>{
      if(!selected) return;
      selected.userData.name = $("nameBox").value.trim() || selected.userData.name;
      selected.name = selected.userData.name;
      refreshHierarchy();
      scheduleRebuildPhysics();
    });

    $("btnLock").onclick = ()=>{
      if(!selected) return;
      selected.userData.locked = !selected.userData.locked;
      $("btnLock").textContent = selected.userData.locked ? "Unlock" : "Lock";
      transform.enabled = !selected.userData.locked;
      showToast(selected.userData.locked ? "Locked üîí" : "Unlocked üîì");
      refreshHierarchy();
    };

    function deleteSelected(){
      if(!selected) return;
      if(selected.userData.locked){ showToast("Locked üîí"); return; }
      transform.detach();
      highlight(selected,false);
      scene.remove(selected);
      editables = editables.filter(x=>x!==selected);
      selected = null;
      refreshHierarchy();
      scheduleRebuildPhysics();
    }
    $("btnDel").onclick = deleteSelected;

    // ------------------------------------------------------------
    // Snapping
    // ------------------------------------------------------------
    let snapOn = true;
    function applySnap(){
      const t = Number($("snapT").value);
      const r = THREE.MathUtils.degToRad(Number($("snapR").value));
      const s = Number($("snapS").value);

      $("snapTVal").textContent = t.toFixed(2);
      $("snapRVal").textContent = `${$("snapR").value}¬∞`;
      $("snapSVal").textContent = s.toFixed(2);

      if(snapOn){
        transform.setTranslationSnap(t > 0 ? t : null);
        transform.setRotationSnap(r > 0 ? r : null);
        transform.setScaleSnap(s > 0 ? s : null);
      }else{
        transform.setTranslationSnap(null);
        transform.setRotationSnap(null);
        transform.setScaleSnap(null);
      }
    }
    $("btnSnap").onclick = ()=>{
      snapOn = !snapOn;
      $("btnSnap").textContent = snapOn ? "Snap: On" : "Snap: Off";
      applySnap();
    };
    $("snapT").oninput = $("snapR").oninput = $("snapS").oninput = applySnap;
    applySnap();

    // ------------------------------------------------------------
    // Place mode + primitives
    // ------------------------------------------------------------
    let placeMode = false;
    $("btnPlace").onclick = ()=>{
      placeMode = !placeMode;
      $("btnPlace").textContent = placeMode ? "Place: On" : "Place: Off";
      showToast(placeMode ? "Place ON: click a deck" : "Place OFF");
    };

    let spawnType = "cube";

    function materialFromKey(matKey, colorHex){
      if(matKey === "random"){
        return new THREE.MeshStandardMaterial({ color: colorHex ?? (Math.random()*0xffffff), roughness:0.6, metalness:0.1 });
      }
      const base = MAT[matKey] || MAT.woodLight;
      const m = base.clone();
      if(colorHex != null && m.color) m.color.setHex(colorHex);
      return m;
    }

    function makePrimitive(type){
      const { key, mat } = pickMaterial();
      let geo;
      if(type === "cube") geo = new THREE.BoxGeometry(2,2,2);
      if(type === "cyl") geo = new THREE.CylinderGeometry(1,1,2,18);
      if(type === "wall") geo = new THREE.BoxGeometry(10,2.8,0.35); // human-height wall segment

      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData.editable = true;
      mesh.userData.type = type;
      mesh.userData.matKey = key;
      mesh.userData.locked = false;
      mesh.userData.name = type === "cube" ? "Cube" : type === "cyl" ? "Cylinder" : "Wall";
      mesh.name = mesh.userData.name;

      mesh.position.set(0, 2, 0);
      scene.add(mesh);
      editables.push(mesh);
      select(mesh);
      refreshHierarchy();
      scheduleRebuildPhysics();
      return mesh;
    }

    function makeDoor(){
      // A standalone door you can place (click to open/close)
      const door = createDoorMesh(1.0, 2.1, 0.22);
      door.position.set(0, 1.05, 0);
      // treat as ‚Äúeditable-ish‚Äù for selection: we select the whole group but don't attach transform
      door.userData.selectableDoor = true;

      // Use an invisible selection proxy
      const proxy = new THREE.Mesh(new THREE.BoxGeometry(1.2,2.2,0.4), new THREE.MeshBasicMaterial({ visible:false }));
      proxy.position.y = 1.1;
      proxy.userData.doorProxy = true;
      door.add(proxy);

      // For hierarchy + selection we store proxy
      proxy.userData.editable = true;
      proxy.userData.type = "door";
      proxy.userData.matKey = "woodLight";
      proxy.userData.locked = false;
      proxy.userData.name = "Door";
      proxy.name = "Door";

      proxy.userData.doorGroup = door;

      scene.add(door);
      editables.push(proxy);
      select(proxy);
      refreshHierarchy();
      scheduleRebuildPhysics();
      return door;
    }

    $("addCube").onclick = ()=>{ spawnType="cube"; makePrimitive("cube"); };
    $("addCyl").onclick  = ()=>{ spawnType="cyl";  makePrimitive("cyl");  };
    $("addWall").onclick = ()=>{ spawnType="wall"; makePrimitive("wall"); };
    $("addDoor").onclick = ()=>{ spawnType="door"; makeDoor(); };

    // Transform mode buttons
    function setMode(mode){
      transform.setMode(mode);
      $("modeMove").classList.toggle("secondary", mode!=="translate");
      $("modeRot").classList.toggle("secondary", mode!=="rotate");
      $("modeScale").classList.toggle("secondary", mode!=="scale");
    }
    $("modeMove").onclick = ()=> setMode("translate");
    $("modeRot").onclick = ()=> setMode("rotate");
    $("modeScale").onclick = ()=> setMode("scale");
    setMode("translate");

    // ------------------------------------------------------------
    // Roof windows + sails toggles
    // ------------------------------------------------------------
    function setWindowsOpen(open){
      windowsOpen = open;
      $("btnWindows").textContent = windowsOpen ? "Roof Windows: Open" : "Roof Windows: Closed";
      roofWindows.forEach(w=>{
        w.open01 = windowsOpen ? 1 : 0;
      });
    }
    function setSailsDeployed(on){
      sailsDeployed = on;
      $("btnSails").textContent = sailsDeployed ? "Sails: Deployed" : "Sails: Stowed";
    }
    $("btnWindows").onclick = ()=> setWindowsOpen(!windowsOpen);
    $("btnSails").onclick = ()=> setSailsDeployed(!sailsDeployed);

    // ------------------------------------------------------------
    // Physics (Octree + Capsule Character Controller)
    // ------------------------------------------------------------
    const worldOctree = new Octree();

    // Player capsule (human sized)
    const playerCollider = new Capsule(
      new THREE.Vector3(0, 0.35, 0),  // feet-ish
      new THREE.Vector3(0, 1.65, 0),  // head-ish
      0.35                            // radius
    );

    const playerVelocity = new THREE.Vector3();
    const playerDirection = new THREE.Vector3();
    let playerOnFloor = false;

    const GRAVITY = 28;
    const WALK_SPEED = 8.0;
    const SPRINT_MULT = 1.55;
    const JUMP_VELOCITY = 10.5;

    // Safe spawn points (used for ‚Äúnever get stuck‚Äù rescue)
    const safeSpawns = [
      new THREE.Vector3(0, 1.8, 0),      // upper
      new THREE.Vector3(0, -3.2, 0),     // mid
      new THREE.Vector3(0, -8.8, 0),     // lower
    ];
    let lastSafe = safeSpawns[0].clone();
    let rescueCooldown = 0;

    function rebuildWorldOctree(){
      worldOctree.clear();

      // Build a temporary node that contains all collider meshes
      const root = new THREE.Group();

      // static colliders
      root.add(staticCollidersGroup.clone(true));

      // user editables colliders:
      // - primitives collide
      // - doors collide only if closed
      editables.forEach(o=>{
        // door proxies: collide via the door collider child (only when closed)
        if(o.userData.type === "door" && o.userData.doorGroup){
          const dg = o.userData.doorGroup;
          const coll = dg.userData.collider;
          if(coll && dg.userData.open01 < 0.5){
            // collider already exists in staticCollidersGroup too for built-in doors,
            // but for placed doors we add it via clone
            root.add(coll.clone());
          }
          return;
        }

        // normal primitives
        if(o.userData.type === "cube" || o.userData.type === "cyl" || o.userData.type === "wall"){
          // use the visible mesh as collider (clone invisible)
          const v = o.clone();
          v.material = new THREE.MeshBasicMaterial({ visible:false });
          root.add(v);
        }
      });

      worldOctree.fromGraphNode(root);
      showToast("Physics rebuilt ‚úÖ");
    }

    let rebuildTimer = null;
    function scheduleRebuildPhysics(){
      clearTimeout(rebuildTimer);
      rebuildTimer = setTimeout(rebuildWorldOctree, 220);
    }
    $("btnRebuild").onclick = rebuildWorldOctree;

    // Initial physics build
    rebuildWorldOctree();

    // Movement input
    let keyF=false, keyB=false, keyL=false, keyR=false, keyShift=false;

    function getForwardVector(){
      camera.getWorldDirection(playerDirection);
      playerDirection.y = 0;
      playerDirection.normalize();
      return playerDirection;
    }
    function getSideVector(){
      camera.getWorldDirection(playerDirection);
      playerDirection.y = 0;
      playerDirection.normalize();
      playerDirection.cross(camera.up);
      return playerDirection;
    }

    function playerCollisions(){
      const result = worldOctree.capsuleIntersect(playerCollider);
      playerOnFloor = false;

      if(result){
        playerOnFloor = result.normal.y > 0;

        if(!playerOnFloor){
          // slide off surfaces
          playerVelocity.addScaledVector(result.normal, -result.normal.dot(playerVelocity));
        }
        playerCollider.translate(result.normal.multiplyScalar(result.depth));
      }
    }

    function updatePlayer(delta){
      // gravity
      if(!playerOnFloor){
        playerVelocity.y -= GRAVITY * delta;
      }else{
        // small damping on floor
        playerVelocity.y = Math.max(0, playerVelocity.y);
      }

      // damping
      const damping = Math.exp(-6 * delta) - 1;
      playerVelocity.addScaledVector(playerVelocity, damping);

      // movement
      const speed = WALK_SPEED * (keyShift ? SPRINT_MULT : 1);
      const move = new THREE.Vector3();

      if(keyF) move.add(getForwardVector());
      if(keyB) move.add(getForwardVector().multiplyScalar(-1));
      if(keyL) move.add(getSideVector().multiplyScalar(-1));
      if(keyR) move.add(getSideVector());

      if(move.lengthSq() > 0){
        move.normalize();
        playerVelocity.addScaledVector(move, speed * delta * 18);
      }

      // apply velocity
      const deltaPos = playerVelocity.clone().multiplyScalar(delta);
      playerCollider.translate(deltaPos);

      // collisions
      playerCollisions();

      // ‚ÄúNever stuck / never unrecoverable‚Äù: clamp inside ark + rescue
      clampAndRescue(delta);

      // camera follows capsule head
      camera.position.copy(playerCollider.end);
    }

    function teleportTo(v){
      const h = playerCollider.end.y - playerCollider.start.y;
      playerCollider.start.set(v.x, v.y - (h-0.35), v.z);
      playerCollider.end.set(v.x, v.y, v.z);
      playerVelocity.set(0,0,0);
      camera.position.copy(playerCollider.end);
    }

    function nearestSafe(pos){
      let best = safeSpawns[0];
      let bestD = Infinity;
      for(const s of safeSpawns){
        const d = s.distanceToSquared(pos);
        if(d < bestD){ bestD = d; best = s; }
      }
      return best.clone();
    }

    function clampAndRescue(delta){
      rescueCooldown = Math.max(0, rescueCooldown - delta);

      const p = playerCollider.end;
      const r = Math.hypot(p.x, p.z);
      const maxR = ARK_RADIUS * 0.88;

      // clamp sideways so you never end up outside the hull interior
      if(r > maxR){
        const k = maxR / r;
        p.x *= k; p.z *= k;
        const h = playerCollider.end.y - playerCollider.start.y;
        playerCollider.start.set(p.x, p.y - h, p.z);
      }

      // record last safe position when on a floor and inside bounds
      if(playerOnFloor && p.y > -14 && p.y < 12 && r < maxR-1.0){
        lastSafe.copy(p);
      }

      // Hard rescue if you fall too low or get wedged
      const outOfBounds = (p.y < -18) || (p.y > 18) || (r > maxR + 6);
      const ‚Äústuckish‚Äù = (!playerOnFloor && Math.abs(playerVelocity.y) < 0.05 && p.y < -14.5);

      if((outOfBounds || ‚Äústuckish‚Äù) && rescueCooldown <= 0){
        rescueCooldown = 1.2;
        const safe = lastSafe ? lastSafe.clone() : nearestSafe(p);
        safe.y = Math.max(safe.y, -8.8);
        teleportTo(safe);
        showToast("Rescued to safe deck ‚úÖ");
      }
    }

    // ------------------------------------------------------------
    // Walk Mode toggle (physics on/off)
    // ------------------------------------------------------------
    let isWalkMode = false;

    function enterWalk(){
      isWalkMode = true;
      $("crosshair").style.display = "block";
      $("ui").style.display = "none";
      orbit.enabled = false;
      transform.detach();

      if(isTouch){
        $("touchHUD").style.display = "block";
      }else{
        walkControls.lock();
      }
      showToast("Walk Mode ON");
    }
    function exitWalk(){
      isWalkMode = false;
      $("crosshair").style.display = "none";
      $("ui").style.display = "flex";
      orbit.enabled = true;
      $("touchHUD").style.display = "none";

      if(!isTouch) walkControls.unlock();
      showToast("Walk Mode OFF");
    }

    $("btnWalk").onclick = ()=>{
      if(isWalkMode) exitWalk();
      else enterWalk();
    };

    walkControls.addEventListener("lock", ()=>{ /* already handled */ });
    walkControls.addEventListener("unlock", ()=>{
      // If user ESC's out, return to editor
      if(isWalkMode && !isTouch) exitWalk();
    });

    // ------------------------------------------------------------
    // Touch sticks (walk)
    // ------------------------------------------------------------
    const stickState = {
      move: { id:null, cx:0, cy:0, x:0, y:0 },
      look: { id:null, cx:0, cy:0, x:0, y:0 }
    };
    function bindStick(el, nub, state){
      const clamp = (v,m)=>Math.max(-m,Math.min(m,v));
      const rectOf = ()=> el.getBoundingClientRect();

      el.addEventListener("pointerdown", (e)=>{
        el.setPointerCapture(e.pointerId);
        const r = rectOf();
        state.id = e.pointerId;
        state.cx = r.left + r.width/2;
        state.cy = r.top + r.height/2;
        state.x = 0; state.y = 0;
      });
      el.addEventListener("pointermove", (e)=>{
        if(state.id !== e.pointerId) return;
        const dx = e.clientX - state.cx;
        const dy = e.clientY - state.cy;
        const max = 44;
        state.x = clamp(dx,max)/max;
        state.y = clamp(dy,max)/max;
        nub.style.transform = `translate(${state.x*44 - 27}px, ${state.y*44 - 27}px)`;
      });
      const up = (e)=>{
        if(state.id !== e.pointerId) return;
        state.id = null;
        state.x = 0; state.y = 0;
        nub.style.transform = "translate(-50%,-50%)";
      };
      el.addEventListener("pointerup", up);
      el.addEventListener("pointercancel", up);
    }
    bindStick($("stickMove"), $("nubMove"), stickState.move);
    bindStick($("stickLook"), $("nubLook"), stickState.look);

    $("jumpBtn").addEventListener("pointerdown", ()=>{
      if(isWalkMode && playerOnFloor){
        playerVelocity.y = JUMP_VELOCITY;
      }
    });

    // Touch look (manual yaw/pitch while in walk mode)
    let touchYaw = 0;
    let touchPitch = 0;

    // ------------------------------------------------------------
    // Raycast click: selection / placing / door toggles
    // ------------------------------------------------------------
    const raycaster = new THREE.Raycaster();
    const mouseNDC = new THREE.Vector2();

    function toggleDoor(doorGroup){
      // animate open01 target (simple)
      doorGroup.userData.open01 = doorGroup.userData.open01 > 0.5 ? 0 : 1;
      showToast(doorGroup.userData.open01 > 0.5 ? "Door opened" : "Door closed");
      scheduleRebuildPhysics();
    }

    renderer.domElement.addEventListener("pointerdown", (e)=>{
      if(isWalkMode) return;
      if(e.target.closest("#ui")) return;

      mouseNDC.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouseNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouseNDC, camera);

      // Place mode => place on decks
      if(placeMode){
        const hits = raycaster.intersectObjects(surfaces, false);
        if(hits.length){
          const hit = hits[0];
          const obj = (spawnType === "door") ? null : makePrimitive(spawnType);
          if(spawnType === "door"){
            const d = makeDoor();
            d.position.copy(hit.point);
            // lift to sit on surface
            d.position.y += 1.05;
          }else{
            obj.position.copy(hit.point);
            const bb = new THREE.Box3().setFromObject(obj);
            const h = bb.max.y - bb.min.y;
            obj.position.y += h/2 + 0.02;

            if(snapOn && Number($("snapT").value) > 0){
              const g = Number($("snapT").value);
              obj.position.x = Math.round(obj.position.x / g) * g;
              obj.position.z = Math.round(obj.position.z / g) * g;
            }
          }
          scheduleRebuildPhysics();
        }else{
          showToast("Click a deck to place.");
        }
        return;
      }

      // Otherwise: selection / door toggle
      const hits = raycaster.intersectObjects(editables, true);
      if(hits.length){
        const hit = hits[0].object;

        if(hit.userData.doorProxy && hit.userData.doorGroup){
          toggleDoor(hit.userData.doorGroup);
          select(hit); // select proxy
          return;
        }

        // select only top-level editable mesh
        const top = hit.userData.editable ? hit : (hit.parent?.userData?.editable ? hit.parent : hit);
        if(top.userData.editable){
          // prevent TransformControls on door proxies (keep stable)
          if(top.userData.type === "door"){
            transform.detach();
          }else{
            transform.attach(top);
          }
          select(top);
        }else{
          select(null);
        }
      }else{
        select(null);
      }
    });

    // Prevent transforming locked objects
    transform.addEventListener("mouseDown", ()=>{
      if(selected && selected.userData.locked){
        transform.detach();
        showToast("Locked üîí");
      }
    });
    transform.addEventListener("mouseUp", ()=>{
      scheduleRebuildPhysics();
    });

    // ------------------------------------------------------------
    // Keyboard
    // ------------------------------------------------------------
    window.addEventListener("keydown", (e)=>{
      if(e.key === "Escape"){
        if(isWalkMode) exitWalk();
        if(placeMode){ placeMode=false; $("btnPlace").textContent="Place: Off"; showToast("Place OFF"); }
        return;
      }

      if(isWalkMode){
        if(e.code==="KeyW" || e.code==="ArrowUp") keyF=true;
        if(e.code==="KeyS" || e.code==="ArrowDown") keyB=true;
        if(e.code==="KeyA" || e.code==="ArrowLeft") keyL=true;
        if(e.code==="KeyD" || e.code==="ArrowRight") keyR=true;
        if(e.code==="ShiftLeft" || e.code==="ShiftRight") keyShift=true;

        if(e.code==="Space" && playerOnFloor){
          playerVelocity.y = JUMP_VELOCITY;
        }
        return;
      }

      // Editor shortcuts
      if(e.key === "w" || e.key==="W") setMode("translate");
      if(e.key === "e" || e.key==="E") setMode("rotate");
      if(e.key === "r" || e.key==="R") setMode("scale");
      if(e.key === "Delete") deleteSelected();
    });

    window.addEventListener("keyup", (e)=>{
      if(!isWalkMode) return;
      if(e.code==="KeyW" || e.code==="ArrowUp") keyF=false;
      if(e.code==="KeyS" || e.code==="ArrowDown") keyB=false;
      if(e.code==="KeyA" || e.code==="ArrowLeft") keyL=false;
      if(e.code==="KeyD" || e.code==="ArrowRight") keyR=false;
      if(e.code==="ShiftLeft" || e.code==="ShiftRight") keyShift=false;
    });

    // ------------------------------------------------------------
    // Animation loop
    // ------------------------------------------------------------
    let prevTime = performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const time = performance.now();
      const delta = Math.min(0.05, (time - prevTime) / 1000);
      prevTime = time;

      // water wave
      if(water && waterBase){
        const geo = water.geometry;
        const pos = geo.attributes.position;
        const arr = pos.array;
        const tt = time * 0.0012;
        for(let i=0;i<arr.length;i+=3){
          const x = waterBase[i];
          const z = waterBase[i+2];
          const w = Math.sin((x*0.06)+tt) * 0.42 + Math.cos((z*0.05)+tt*1.1) * 0.36;
          arr[i+1] = waterBase[i+1] + w;
        }
        pos.needsUpdate = true;
        geo.computeVertexNormals();
      }

      // animate roof windows (shutter slides + cloth retracts)
      roofWindows.forEach((w, idx)=>{
        const target = w.open01;
        // smooth
        w.open01 += (target - w.open01) * 0.08;

        // shutter slides back along its local X (approx)
        const slide = (1 - w.open01) * 3.2; // closed -> slide in place
        w.shutter.position.x = w.anchor.x + Math.cos(w.a + Math.PI/2) * slide;
        w.shutter.position.z = w.anchor.z + Math.sin(w.a + Math.PI/2) * slide;

        // cloth retract by scaling toward one edge
        const s = THREE.MathUtils.lerp(1.0, 0.05, (1 - w.open01));
        w.cloth.scale.set(1, s, 1);
      });

      // cloth wind waves (sails + shades)
      const wind = sailsDeployed ? 1.0 : 0.12;
      sailCloths.forEach((m, i)=>{
        const geo = m.geometry;
        const pos = geo.attributes.position;
        const baseKey = "_base";
        if(!m.userData[baseKey]){
          m.userData[baseKey] = new Float32Array(pos.array.length);
          m.userData[baseKey].set(pos.array);
        }
        const base = m.userData[baseKey];
        const t = time * 0.001;
        for(let j=0;j<pos.array.length;j+=3){
          const x = base[j];
          const y = base[j+1];
          // wave in normal-ish direction (z)
          const wave = Math.sin((x*0.7) + t*2.2 + i) * 0.12 * wind
                     + Math.cos((y*0.9) + t*1.6) * 0.08 * wind;
          pos.array[j+2] = base[j+2] + wave;
        }
        pos.needsUpdate = true;
        geo.computeVertexNormals();

        // stow sails by easing opacity/scale
        const targetOp = sailsDeployed ? 1 : 0.0;
        m.material.opacity = THREE.MathUtils.lerp(m.material.opacity ?? 1, targetOp, 0.06);
        m.material.transparent = true;
        m.scale.y = THREE.MathUtils.lerp(m.scale.y, sailsDeployed ? 1 : 0.02, 0.06);
      });

      // animate doors open/close
      scene.traverse(obj=>{
        if(obj.userData && obj.userData.isDoor){
          const open = obj.userData.open01;
          // hinge rotate leafPivot
          const pivot = obj.userData.leafPivot;
          if(pivot){
            const targetAngle = THREE.MathUtils.lerp(0, -Math.PI*0.55, open);
            pivot.rotation.y += (targetAngle - pivot.rotation.y) * 0.12;
          }
        }
      });

      // Walk physics
      if(isWalkMode){
        if(isTouch){
          // touch stick -> movement keys
          keyF = stickState.move.y < -0.15;
          keyB = stickState.move.y > 0.15;
          keyL = stickState.move.x < -0.15;
          keyR = stickState.move.x > 0.15;

          // look
          const yaw = -stickState.look.x * 0.05;
          const pitch = -stickState.look.y * 0.035;
          touchYaw += yaw;
          touchPitch = THREE.MathUtils.clamp(touchPitch + pitch, -1.2, 1.2);
          camera.rotation.set(touchPitch, touchYaw, 0, "YXZ");
        }

        updatePlayer(delta);
      }else{
        orbit.update();
      }

      renderer.render(scene, camera);
    }
    animate();

    // ------------------------------------------------------------
    // Resize
    // ------------------------------------------------------------
    window.addEventListener("resize", ()=>{
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // ------------------------------------------------------------
    // Start position (upper deck)
    // ------------------------------------------------------------
    teleportTo(new THREE.Vector3(0, 1.8, 0));
    showToast("v3 ready: Walk Physics ‚úÖ");
    refreshHierarchy();
  </script>
</body>
</html>
