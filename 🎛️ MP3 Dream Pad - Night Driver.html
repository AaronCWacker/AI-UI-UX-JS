<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üéõÔ∏è MP3 Dream Pad - Night Driver</title>
  <style>
    :root{
      --bg:#070913; --panel:rgba(255,255,255,.07); --line:rgba(255,255,255,.12);
      --txt:rgba(255,255,255,.92); --muted:rgba(255,255,255,.70);
      --accent:rgba(125,211,252,.70); --good:rgba(52,211,153,.35); --warn:rgba(251,191,36,.45);
      --hot: rgba(251,191,36,.90);
    }
    body{ margin:0; background:var(--bg); color:var(--txt); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap{ max-width:1100px; margin:22px auto; padding:0 14px 26px; }
    .card{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 14px 14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 60px rgba(0,0,0,.35);
    }
    h1{ font-size: 18px; margin: 0 0 10px; letter-spacing:.2px; }
    .sub{ font-size: 13px; color: var(--muted); line-height:1.35; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin:10px 0; }
    .btn{
      cursor:pointer; user-select:none;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      color: var(--txt);
      padding: 10px 12px;
      font-weight: 900;
      font-size: 13px;
    }
    .btn:hover{ background: rgba(255,255,255,.10); }
    .btn.primary{ background: rgba(125,211,252,.16); border-color: rgba(125,211,252,.32); }
    .btn.good{ background: rgba(52,211,153,.14); border-color: rgba(52,211,153,.28); }
    .btn.danger{ background: rgba(248,113,113,.12); border-color: rgba(248,113,113,.25); }
    .kv{ display:flex; gap:8px; align-items:center; }
    input[type="number"]{
      width: 92px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--txt);
      font-weight: 900;
    }
    .msg{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.20);
      font-size: 13px;
      min-height: 18px;
      color: var(--muted);
      white-space: pre-wrap;
    }
    .grid{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }
    .pad{
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.06);
      padding: 12px 12px;
      cursor: pointer;
      user-select:none;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      min-height: 90px;
    }
    .pad:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
    .pad.on{ background: rgba(52,211,153,.14); border-color: rgba(52,211,153,.35); }
    .pad.sel{ outline: 2px solid rgba(125,211,252,.90); outline-offset: 2px; }
    .pad.playing{ outline: 2px solid rgba(251,191,36,.95); outline-offset: 2px; }
    .pad .top{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .pad .name{ font-weight: 1000; font-size: 13px; }
    .pad .time{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; opacity: .9; }
    .pad .meta{ margin-top: 6px; font-size: 12px; color: var(--muted); line-height:1.3; }

    .timeline{
      margin-top: 12px;
      border-radius: 16px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      padding: 10px;
    }
    .toggles{
      display:grid;
      grid-template-columns: repeat(16, minmax(0, 1fr));
      gap: 6px;
      margin-bottom: 10px;
    }
    .chip{
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      padding: 8px 0;
      text-align:center;
      font-weight: 1000;
      font-size: 12px;
      cursor: pointer;
      user-select:none;
    }
    .chip.on{ background: rgba(52,211,153,.14); border-color: rgba(52,211,153,.35); }
    .chip.sel{ outline: 2px solid rgba(125,211,252,.90); outline-offset: 2px; }
    .chip.playing{ outline: 2px solid rgba(251,191,36,.95); outline-offset: 2px; }

    .bar{
      position: relative;
      height: 60px;
      border-radius: 12px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.08);
      overflow: hidden;
      cursor: crosshair;
    }
    .slice{
      position:absolute; top: 10px; height: 40px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(52,211,153,.10);
    }
    .slice.sel{
      background: rgba(125,211,252,.16);
      border-color: rgba(125,211,252,.35);
    }
    .slice.on{
      background: rgba(52,211,153,.18);
      border-color: rgba(52,211,153,.42);
    }
    .slice.playing{
      box-shadow: 0 0 0 2px rgba(251,191,36,.65) inset;
      border-color: rgba(251,191,36,.75);
    }
    .handle{
      position:absolute; top: 8px; height: 44px; width: 10px;
      border-radius: 10px;
      background: rgba(251,191,36,.85);
      border: 1px solid rgba(0,0,0,.35);
      cursor: ew-resize;
    }
    .playhead{
      position:absolute; top:0; bottom:0;
      width: 2px;
      background: rgba(251,191,36,.95);
      pointer-events:none;
    }
    .small{ font-size: 12px; color: var(--muted); }
    code{ color: rgba(125,211,252,.95); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>üéõÔ∏è Looping Pads + Song Timeline</h1>
      <div class="sub">
        Same-name MP3: <b>game.html</b> loads <b>game.mp3</b>. Click <b>Enable Audio + Decode</b>.
        <br/>Pad click toggles loop ON/OFF and plays immediately. Click again to stop looping.
      </div>

      <div class="row">
        <button class="btn primary" id="enable">üîä Enable Audio + Decode MP3</button>
        <button class="btn" id="auditionSel">üéß Play Selected Once</button>
        <button class="btn" id="stopAll">‚èπ Stop All Audio</button>
        <button class="btn danger" id="reset">üßπ Reset to Equal 16 Slices</button>

        <div class="kv"><span class="small">BPM</span><input type="number" id="bpm" value="120" min="40" max="240" /></div>
        <button class="btn good" id="loopPlay">‚ñ∂ 16-Step Loop Play</button>
        <button class="btn" id="loopStop">‚èπ 16-Step Loop Stop</button>
      </div>

      <div class="timeline">
        <div class="small">
          Timeline toggles mirror pads (ON/OFF). Click chips to toggle. Click slice blocks to select.
          Drag yellow handles to edit slice boundaries. The timeline spans the full song duration.
        </div>

        <div class="toggles" id="toggles"></div>

        <div class="bar" id="bar">
          <div class="playhead" id="playhead" style="left:0px"></div>
        </div>

        <div class="row" style="margin-top:10px">
          <div class="small">Selected: <b id="selLabel">None</b></div>
          <div class="small">Start: <b id="selStart">‚Äì</b>s</div>
          <div class="small">End: <b id="selEnd">‚Äì</b>s</div>
          <div class="small">Dur: <b id="selDur">‚Äì</b>s</div>
        </div>
      </div>

      <div class="msg" id="msg">Ready. Click ‚ÄúEnable Audio + Decode MP3‚Äù.</div>

      <div class="grid" id="grid"></div>

      <div class="small" style="margin-top:10px">
        Shortcuts: <code>Space</code> toggles 16-step loop play/stop. Number keys 1‚Äì9 toggle pads 1‚Äì9 ON/OFF.
      </div>
    </div>
  </div>

<script>
/* ========= Same-name MP3 ========= */
function mp3UrlFromHtml() {
  const url = new URL(window.location.href);
  const base = url.pathname.replace(/\.html?$/i, "");
  return url.origin + base + ".mp3";
}

/* ========= Helpers ========= */
const $ = (id) => document.getElementById(id);
const msg = (t) => $("msg").textContent = t;
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const fmt = (x)=>(Math.round(x*100)/100).toFixed(2);

/* ========= WebAudio decode ========= */
let audioCtx = null;
let buffer = null;
let durationSec = 0;

/* ========= Slice model ========= */
const N = 16; // if you really want 18 pads, set to 18 and update CSS grid columns accordingly
const STORAGE_KEY = "mp3_chop_slices_v2";
let slices = [];
let selected = 0;

/* ========= Pad states ========= */
const padOn = new Array(N).fill(false);        // ON means "loop this slice continuously"
const padLoopTimers = new Array(N).fill(null); // setInterval ids
const padPlaying = new Array(N).fill(false);   // UI only
let activeSources = new Set();

/* ========= 16-step sequencer ========= */
let stepLooping = false;
let stepTimer = null;
let stepNextAt = 0;
let stepIndex = 0;

/* ========= Timeline edit state ========= */
const bar = $("bar");
const playheadEl = $("playhead");
let playheadSec = 0;
let dragging = null; // {sliceId, which:"start"|"end"}

/* ========= Slices load/save/default ========= */
function defaultSlicesEqual(dur) {
  const step = dur / N;
  return Array.from({length:N}, (_, i) => ({
    id: i,
    name: `Pad ${i+1}`,
    note: "click toggles loop",
    start: i * step,
    end: (i+1) * step
  }));
}
function loadSlices() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    const s = JSON.parse(raw);
    if (!Array.isArray(s) || s.length !== N) return null;
    return s;
  } catch { return null; }
}
function saveSlices() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(slices));
}

/* ========= Playback primitives ========= */
function stopSources() {
  for (const src of activeSources) { try { src.stop(); } catch {} }
  activeSources.clear();
}

function playOnce(i) {
  if (!audioCtx || !buffer) { msg("Decode first."); return; }
  const s = slices[i];
  const offset = clamp(s.start, 0, durationSec);
  const dur = clamp(s.end - s.start, 0.01, durationSec);

  const src = audioCtx.createBufferSource();
  src.buffer = buffer;

  const gain = audioCtx.createGain();
  gain.gain.value = 0.95;

  src.connect(gain);
  gain.connect(audioCtx.destination);

  // mark playing for UI
  setPadPlaying(i, true);

  src.start(0, offset, dur);
  activeSources.add(src);

  src.onended = () => {
    activeSources.delete(src);
    setPadPlaying(i, false);
  };
}

function setPadPlaying(i, val) {
  padPlaying[i] = val;
  const pad = document.getElementById(`pad-${i}`);
  const chip = document.getElementById(`chip-${i}`);
  const sliceEl = document.getElementById(`slice-${i}`);
  if (pad) pad.classList.toggle("playing", val);
  if (chip) chip.classList.toggle("playing", val);
  if (sliceEl) sliceEl.classList.toggle("playing", val);
}

function startPadLoop(i) {
  if (padLoopTimers[i]) return; // already looping
  const s = slices[i];
  const dur = clamp(s.end - s.start, 0.05, durationSec);

  // Play immediately
  playOnce(i);

  // Then retrigger every duration (simple, musical enough)
  padLoopTimers[i] = setInterval(() => {
    // If user turned it off while waiting
    if (!padOn[i]) return;
    playOnce(i);
  }, Math.max(50, dur * 1000));
}

function stopPadLoop(i) {
  if (padLoopTimers[i]) {
    clearInterval(padLoopTimers[i]);
    padLoopTimers[i] = null;
  }
  padOn[i] = false;
  renderPads();
  renderTimeline(); // update ON shading
}

/* ========= Toggle behavior you requested =========
   - Single click pad: selects + toggles ON/OFF
   - If toggled ON: loops at end of slice until clicked again
*/
function togglePad(i) {
  setSelected(i, false);

  // toggle state
  padOn[i] = !padOn[i];
  renderPads();
  renderToggles();
  renderTimeline();

  if (padOn[i]) {
    msg(`Pad ${i+1} ON ‚úÖ looping slice`);
    startPadLoop(i);
  } else {
    msg(`Pad ${i+1} OFF ‚õî`);
    stopPadLoop(i);
  }
}

/* ========= UI: Pads ========= */
function renderPads() {
  const grid = $("grid");
  grid.innerHTML = "";
  for (let i=0;i<N;i++){
    const s = slices[i];
    const el = document.createElement("div");
    el.className = "pad" + (padOn[i] ? " on" : "") + (selected===i ? " sel" : "");
    el.id = `pad-${i}`;
    el.innerHTML = `
      <div class="top">
        <div class="name">${s.name}</div>
        <div class="time">${fmt(s.start)} ‚Üí ${fmt(s.end)}s</div>
      </div>
      <div class="meta">${s.note || ""}</div>
    `;
    el.addEventListener("click", () => togglePad(i));
    grid.appendChild(el);
  }
}

/* ========= UI: Selected ========= */
function setSelected(i, rerender=true) {
  selected = i;
  const s = slices[i];
  $("selLabel").textContent = s.name;
  $("selStart").textContent = fmt(s.start);
  $("selEnd").textContent = fmt(s.end);
  $("selDur").textContent = fmt(Math.max(0, s.end - s.start));
  if (rerender) { renderPads(); renderToggles(); renderTimeline(); }
}

/* ========= UI: Timeline toggles row ========= */
function renderToggles() {
  const host = $("toggles");
  host.innerHTML = "";
  for (let i=0;i<N;i++){
    const chip = document.createElement("div");
    chip.className = "chip" + (padOn[i] ? " on" : "") + (selected===i ? " sel" : "");
    chip.id = `chip-${i}`;
    chip.textContent = i+1;
    chip.addEventListener("click", () => togglePad(i));
    host.appendChild(chip);
  }
}

/* ========= Timeline mapping ========= */
function pxFromSec(sec) {
  const w = bar.clientWidth;
  const dur = Math.max(0.001, durationSec || 1);
  return (sec / dur) * w;
}
function secFromPx(px) {
  const w = bar.clientWidth;
  const dur = Math.max(0.001, durationSec || 1);
  return clamp((px / w) * dur, 0, dur);
}

/* ========= Timeline render ========= */
function renderTimeline() {
  [...bar.querySelectorAll(".slice,.handle")].forEach(n => n.remove());
  if (!durationSec) return;

  for (let i=0;i<N;i++){
    const s = slices[i];
    const left = pxFromSec(s.start);
    const right = pxFromSec(s.end);
    const width = Math.max(3, right - left);

    const seg = document.createElement("div");
    seg.className =
      "slice" +
      (selected===i ? " sel" : "") +
      (padOn[i] ? " on" : "");
    seg.id = `slice-${i}`;
    seg.style.left = left + "px";
    seg.style.width = width + "px";
    seg.title = `${s.name} ${fmt(s.start)}‚Äì${fmt(s.end)}s`;
    seg.addEventListener("click", (e) => {
      e.stopPropagation();
      setSelected(i);
      // clicking slice toggles like pad too (musician brain)
      togglePad(i);
    });
    bar.appendChild(seg);

    // start handle
    const h1 = document.createElement("div");
    h1.className = "handle";
    h1.style.left = (left - 5) + "px";
    h1.title = "Drag to change start";
    h1.addEventListener("pointerdown", (e) => {
      e.preventDefault(); e.stopPropagation();
      dragging = { sliceId: i, which: "start" };
      bar.setPointerCapture(e.pointerId);
    });
    bar.appendChild(h1);

    // end handle
    const h2 = document.createElement("div");
    h2.className = "handle";
    h2.style.left = (right - 5) + "px";
    h2.title = "Drag to change end";
    h2.addEventListener("pointerdown", (e) => {
      e.preventDefault(); e.stopPropagation();
      dragging = { sliceId: i, which: "end" };
      bar.setPointerCapture(e.pointerId);
    });
    bar.appendChild(h2);
  }

  playheadEl.style.left = pxFromSec(playheadSec) + "px";
}

/* ========= Timeline interactions ========= */
bar.addEventListener("pointermove", (e) => {
  if (!dragging || !durationSec) return;
  const rect = bar.getBoundingClientRect();
  const x = clamp(e.clientX - rect.left, 0, rect.width);
  const sec = secFromPx(x);

  const s = slices[dragging.sliceId];
  if (dragging.which === "start") {
    s.start = clamp(sec, 0, s.end - 0.02);
  } else {
    s.end = clamp(sec, s.start + 0.02, durationSec);
  }
  saveSlices();

  // If this pad is currently ON looping, restart its loop with new duration
  if (padOn[dragging.sliceId]) {
    clearInterval(padLoopTimers[dragging.sliceId]);
    padLoopTimers[dragging.sliceId] = null;
    startPadLoop(dragging.sliceId);
  }

  setSelected(dragging.sliceId, false);
  renderPads(); renderToggles(); renderTimeline();
});

bar.addEventListener("pointerup", (e) => {
  if (dragging) {
    dragging = null;
    try { bar.releasePointerCapture(e.pointerId); } catch {}
    msg("Slice updated ‚úÖ");
  }
});

bar.addEventListener("click", (e) => {
  if (!durationSec) return;
  const rect = bar.getBoundingClientRect();
  const x = clamp(e.clientX - rect.left, 0, rect.width);
  playheadSec = secFromPx(x);
  playheadEl.style.left = x + "px";
  msg(`Playhead: ${fmt(playheadSec)}s`);
});

window.addEventListener("resize", () => renderTimeline());

/* ========= 16-step loop transport ========= */
function stepMs() {
  const bpm = clamp(Number($("bpm").value || 120), 40, 240);
  return (60000 / bpm) / 4; // 16th
}
function stepLoopStart() {
  if (!audioCtx || !buffer) { msg("Decode first."); return; }
  if (stepLooping) return;
  stepLooping = true;
  stepIndex = 0;
  stepNextAt = performance.now() + 20;
  msg("‚ñ∂ 16-step loop running. (This triggers ON pads on their step index.)");

  const tick = () => {
    if (!stepLooping) return;
    const i = stepIndex % N;
    if (padOn[i]) playOnce(i);
    stepIndex++;
    stepNextAt += stepMs();
    const wait = Math.max(0, stepNextAt - performance.now());
    stepTimer = setTimeout(tick, wait);
  };
  tick();
}
function stepLoopStop() {
  stepLooping = false;
  if (stepTimer) { clearTimeout(stepTimer); stepTimer = null; }
  msg("16-step loop stopped.");
}

/* ========= Decode flow ========= */
async function enableAndDecode() {
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state !== "running") await audioCtx.resume();

    const url = mp3UrlFromHtml();
    msg(`Fetching MP3‚Ä¶\n${url}`);

    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} fetching MP3`);
    const arr = await res.arrayBuffer();

    msg("Decoding MP3‚Ä¶");
    buffer = await audioCtx.decodeAudioData(arr);
    durationSec = buffer.duration;

    const loaded = loadSlices();
    slices = loaded ? loaded : defaultSlicesEqual(durationSec);

    // clamp
    for (const s of slices) {
      s.start = clamp(s.start, 0, durationSec);
      s.end = clamp(s.end, 0, durationSec);
      if (s.end <= s.start) s.end = clamp(s.start + (durationSec/N), 0, durationSec);
    }
    saveSlices();

    msg(`Decoded ‚úÖ duration=${durationSec.toFixed(2)}s\nClick pads to toggle loop ON/OFF.`);
    setSelected(0);
    renderPads(); renderToggles(); renderTimeline();
  } catch (err) {
    console.error(err);
    msg("Decode failed ‚ùå\nOpen DevTools Console for details.");
  }
}

/* ========= Buttons ========= */
$("enable").addEventListener("click", enableAndDecode);
$("auditionSel").addEventListener("click", () => {
  if (!buffer) return msg("Decode first.");
  playOnce(selected);
});
$("stopAll").addEventListener("click", () => {
  // stop pad loops
  for (let i=0;i<N;i++){
    if (padLoopTimers[i]) { clearInterval(padLoopTimers[i]); padLoopTimers[i]=null; }
    padOn[i]=false;
    setPadPlaying(i, false);
  }
  stepLoopStop();
  stopSources();
  renderPads(); renderToggles(); renderTimeline();
  msg("Stopped all audio + cleared pad ON states.");
});
$("reset").addEventListener("click", () => {
  if (!durationSec) return msg("Decode first.");
  // stop loops before resetting
  for (let i=0;i<N;i++){
    if (padLoopTimers[i]) { clearInterval(padLoopTimers[i]); padLoopTimers[i]=null; }
    padOn[i]=false;
    setPadPlaying(i, false);
  }
  slices = defaultSlicesEqual(durationSec);
  saveSlices();
  setSelected(0);
  renderPads(); renderToggles(); renderTimeline();
  msg("Reset to equal 16 slices ‚úÖ");
});
$("loopPlay").addEventListener("click", stepLoopStart);
$("loopStop").addEventListener("click", stepLoopStop);

/* ========= Shortcuts ========= */
window.addEventListener("keydown", (e) => {
  if (e.code === "Space") { e.preventDefault(); stepLooping ? stepLoopStop() : stepLoopStart(); }
  const n = Number(e.key);
  if (n >= 1 && n <= 9) {
    const i = n - 1;
    // toggle ON/OFF
    if (i < N) togglePad(i);
  }
});

/* ========= Bootstrap placeholder UI ========= */
slices = Array.from({length:N}, (_, i)=>({id:i,name:`Pad ${i+1}`,note:"decode first",start:0,end:0}));
renderPads();
renderToggles();
msg("Ready. Click ‚ÄúEnable Audio + Decode MP3‚Äù.");
</script>
</body>
</html>
