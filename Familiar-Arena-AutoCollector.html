<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>FAMILIAR ARENA ‚Äî Auto Collector</title>
<style>
:root{
  --bg:#050814;--panel:rgba(10,16,32,.78);--panel2:rgba(16,24,48,.84);--line:rgba(255,255,255,.10);
  --text:#eef4ff;--muted:#9db0cf;--mint:#33ffbb;--cyan:#44ddff;--violet:#c79dff;--rose:#ff6f91;--gold:#ffd35e;--amber:#ffad63;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;overflow:hidden;background:radial-gradient(circle at top,#152347 0%,#08101f 40%,#04070f 100%);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
body{display:grid;grid-template-rows:auto 1fr auto}
button{font:inherit}
#topbar,#footer{padding:10px 14px;background:rgba(255,255,255,.03);border-bottom:1px solid var(--line)}
#footer{border-top:1px solid var(--line);border-bottom:0;display:flex;justify-content:space-between;gap:12px;color:var(--muted);font-size:.78rem}
#topbar{display:flex;justify-content:space-between;align-items:center;gap:12px}
.title{font-family:Orbitron,system-ui,sans-serif;font-weight:900;letter-spacing:.12em;font-size:1rem;background:linear-gradient(135deg,var(--mint),var(--cyan),var(--violet));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.subtitle{font-size:.74rem;color:var(--muted);margin-top:2px}
#app{display:grid;grid-template-columns:280px 1fr 300px;gap:12px;padding:12px;height:100%}
.panel{background:var(--panel);border:1px solid var(--line);border-radius:18px;backdrop-filter:blur(12px);box-shadow:0 16px 40px rgba(0,0,0,.28)}
.left,.right{padding:12px;overflow:auto}
.center{display:grid;grid-template-rows:auto 1fr auto;gap:10px;padding:12px;overflow:hidden}
.banner{display:flex;justify-content:space-between;gap:10px;padding:12px;border:1px solid var(--line);border-radius:16px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03))}
.bannerTitle{font-family:Orbitron,system-ui,sans-serif;font-size:.82rem;letter-spacing:.12em;color:var(--gold)}
.bannerText{font-size:.78rem;color:var(--muted);line-height:1.45;margin-top:4px}
.livePill{align-self:flex-start;padding:6px 10px;border-radius:999px;border:1px solid rgba(51,255,187,.35);background:rgba(51,255,187,.08);color:var(--mint);font-size:.72rem;font-family:JetBrains Mono,monospace}
#arenaWrap{position:relative;overflow:hidden;border:1px solid var(--line);border-radius:18px;background:radial-gradient(circle at 50% 20%,rgba(68,221,255,.08),rgba(0,0,0,0) 35%),linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02))}
canvas{display:block;width:100%;height:100%}
#hud{display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center;padding:10px 12px;border:1px solid var(--line);border-radius:16px;background:var(--panel2)}
.hudBox{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.badge{padding:6px 9px;border-radius:999px;background:rgba(255,255,255,.05);border:1px solid var(--line);font-size:.72rem;color:var(--muted)}
.badge strong{color:var(--text)}
.turn{justify-self:center;padding:8px 12px;border-radius:999px;border:1px solid rgba(255,211,94,.38);background:rgba(255,211,94,.08);font-family:Orbitron,system-ui,sans-serif;font-size:.76rem;letter-spacing:.1em;color:var(--gold)}
.controls{display:flex;gap:8px;align-items:center;justify-content:space-between;padding:10px 12px;border:1px solid var(--line);border-radius:16px;background:var(--panel2)}
.btn{padding:10px 12px;border-radius:12px;border:1px solid var(--line);background:rgba(255,255,255,.05);color:var(--text);font-weight:800;cursor:pointer;transition:.16s transform,.16s border-color,.16s background}
.btn:hover{transform:translateY(-1px)}
.btn.primary{border-color:rgba(51,255,187,.42);background:rgba(51,255,187,.10);color:var(--mint)}
.btn.gold{border-color:rgba(255,211,94,.42);background:rgba(255,211,94,.10);color:var(--gold)}
.btn.rose{border-color:rgba(255,111,145,.42);background:rgba(255,111,145,.10);color:var(--rose)}
.btn:disabled{opacity:.38;cursor:not-allowed;transform:none}
.sectionTitle{margin:0 0 10px;font-family:Orbitron,system-ui,sans-serif;font-size:.82rem;letter-spacing:.1em;color:var(--gold)}
.tip,.cardItem,.logLine{padding:10px;border-radius:12px;border:1px solid var(--line);background:rgba(255,255,255,.04);font-size:.76rem;color:var(--muted);line-height:1.45}
.tipList,.cardList{display:grid;gap:8px}
.cardItem{cursor:pointer;transition:.16s transform,.16s border-color,.16s box-shadow}
.cardItem:hover{transform:translateY(-1px)}
.cardItem.ready{border-color:rgba(68,221,255,.42);box-shadow:0 0 0 1px rgba(68,221,255,.16)}
.cardItem.used{opacity:.42;filter:grayscale(.8);pointer-events:none}
.cardHead{display:flex;justify-content:space-between;gap:8px;margin-bottom:6px}
.cardName{font-weight:900;color:var(--text);font-size:.84rem}
.cardType{font-family:JetBrains Mono,monospace;font-size:.68rem}
.type-burst{color:var(--gold)}.type-magnet{color:var(--mint)}.type-sweep{color:var(--rose)}.type-freeze{color:var(--cyan)}.type-halo{color:var(--violet)}
.log{display:grid;gap:8px;max-height:320px;overflow:auto}
.small{font-size:.74rem;color:var(--muted)}
.spot{padding:12px;border-radius:16px;border:1px solid var(--line);background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));margin-bottom:12px}
.spotLabel{font-family:Orbitron,system-ui,sans-serif;font-size:.68rem;letter-spacing:.12em;color:var(--cyan);margin-bottom:6px}
.spotName{font-size:.96rem;font-weight:900;margin-bottom:6px}
.spotText{font-size:.78rem;color:var(--muted);line-height:1.45}
@media (max-width:1100px){#app{grid-template-columns:1fr;grid-template-rows:auto 1fr auto;height:auto;overflow:auto}body{overflow:auto}.center{min-height:70vh}}
</style>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800;900&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet">
</head>
<body>
  <div id="topbar">
    <div>
      <div class="title">FAMILIAR ARENA ‚Äî AUTO COLLECTOR</div>
      <div class="subtitle">AI flies the ship, gathers cards, levels up, and now battles Zaxxon-style robot waves while you trigger specials and weapon patterns.</div>
    </div>
    <div class="livePill" id="modePill">AUTO-PILOT ACTIVE</div>
  </div>

  <div id="app">
    <aside class="panel left">
      <h3 class="sectionTitle">üß† What Changed</h3>
      <div class="tipList">
        <div class="tip"><strong>AI handles navigation.</strong> The ship constantly steers, boosts, and collects cards for you.</div>
        <div class="tip"><strong>Cards chase the ship.</strong> Nearby pickups drift inward, then snap into a readable halo once collected.</div>
        <div class="tip"><strong>You click powers, not movement.</strong> Collected cards become special actions like magnet pulse, sweep, freeze, and burst collect.</div>
        <div class="tip"><strong>Collect-All effects</strong> let you vacuum huge parts of the field without manually piloting through them.</div>
      </div>
      <div class="spot" style="margin-top:14px">
        <div class="spotLabel">SPECIAL ACTIONS</div>
        <div class="spotName">Clickable Power Cards</div>
        <div class="spotText">As the auto-pilot collects cards, they populate the action list below. Click any ready card for its special effect.</div>
      </div>
      <h3 class="sectionTitle">‚ö° Collected Powers</h3>
      <div class="cardList" id="powerList"></div>
    </aside>

    <main class="panel center">
      <div class="banner">
        <div>
          <div class="bannerTitle">SELF-FLYING COLLECTION MODE</div>
          <div class="bannerText">The ship hunts pickups automatically. Your job is timing special powers: burst nearby cards, magnetize the field, freeze card motion, or sweep the whole arena.</div>
        </div>
        <div class="livePill" id="activityPill">HUNTING</div>
      </div>

      <div id="arenaWrap"><canvas id="game" width="1200" height="760"></canvas></div>

      <div id="hud">
        <div class="hudBox">
          <div class="badge"><strong>Collected</strong> <span id="collectedCount">0</span></div>
          <div class="badge"><strong>Level</strong> <span id="levelCount">1</span></div>
          <div class="badge"><strong>Wave</strong> <span id="waveCount">1</span></div>
          <div class="badge"><strong>Loose Cards</strong> <span id="looseCount">0</span></div>
          <div class="badge"><strong>Halo</strong> <span id="haloCount">0</span></div>
        </div>
        <div class="turn" id="statusText">AUTO GATHERING</div>
        <div class="hudBox" style="justify-content:flex-end">
          <div class="badge"><strong>Combo</strong> <span id="comboCount">0</span></div>
          <div class="badge"><strong>Weapon</strong> <span id="weaponName">FAN</span></div>
          <div class="badge"><strong>Boss</strong> <span id="bossHp">‚Äî</span></div>
          <div class="badge"><strong>Field Sweep</strong> <span id="sweepCharge">0%</span></div>
        </div>
      </div>

      <div class="controls">
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button class="btn primary" id="burstBtn">üåü Burst Nearby</button>
          <button class="btn gold" id="collectAllBtn">üß≤ Collect Visible</button>
          <button class="btn primary" id="weaponBtn">üó°Ô∏è Cycle Weapon</button>
          <button class="btn gold" id="bombBtn">üí£ Card Bomb</button>
          <button class="btn rose" id="restartBtn">‚Üª Restart Field</button>
        </div>
        <div class="small" id="hint">Tip: Click the collected power cards on the left for stronger special effects.</div>
      </div>
    </main>

    <aside class="panel right">
      <div class="spot">
        <div class="spotLabel">LIVE ACTION</div>
        <div class="spotName" id="actionTitle">Auto-pilot engaged</div>
        <div class="spotText" id="actionText">The ship is steering itself toward the best cluster of cards.</div>
      </div>
      <h3 class="sectionTitle">üìú Event Log</h3>
      <div class="log" id="log"></div>
    </aside>
  </div>

  <div id="footer">
    <div>Readable orbiting halo ¬∑ auto chase ¬∑ click-to-trigger power cards</div>
    <div>Built for low-friction gathering instead of manual piloting</div>
  </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

const ui = {
  collectedCount: document.getElementById('collectedCount'),
  looseCount: document.getElementById('looseCount'),
  haloCount: document.getElementById('haloCount'),
  comboCount: document.getElementById('comboCount'),
  sweepCharge: document.getElementById('sweepCharge'),
  statusText: document.getElementById('statusText'),
  hint: document.getElementById('hint'),
  powerList: document.getElementById('powerList'),
  log: document.getElementById('log'),
  actionTitle: document.getElementById('actionTitle'),
  actionText: document.getElementById('actionText'),
  activityPill: document.getElementById('activityPill'),
  levelCount: document.getElementById('levelCount'),
  waveCount: document.getElementById('waveCount'),
  weaponName: document.getElementById('weaponName'),
  bossHp: document.getElementById('bossHp')
};

const CARD_TYPES = [
  { type:'Burst', color:'#ffd35e', css:'type-burst', desc:'Instantly collects all cards in a large nearby radius.', effect:'burst' },
  { type:'Magnet', color:'#33ffbb', css:'type-magnet', desc:'Pulls all loose cards toward the ship for several seconds.', effect:'magnet' },
  { type:'Sweep', color:'#ff6f91', css:'type-sweep', desc:'Collects every visible loose card in the arena.', effect:'sweep' },
  { type:'Freeze', color:'#44ddff', css:'type-freeze', desc:'Freezes card drift so the halo can absorb them cleanly.', effect:'freeze' },
  { type:'Halo', color:'#c79dff', css:'type-halo', desc:'Expands the readable orbit ring and vacuum radius.', effect:'halo' }
];

const WEAPONS = [
  { name:'FAN', color:'#ffd35e', cooldown:0.22, fire:fanShot },
  { name:'SPIRAL', color:'#c79dff', cooldown:0.14, fire:spiralShot },
  { name:'LANCE', color:'#44ddff', cooldown:0.3, fire:lanceShot },
  { name:'CROSS', color:'#33ffbb', cooldown:0.2, fire:crossShot }
];

const state = {
  time: 0,
  combo: 0,
  totalCollected: 0,
  sweepCharge: 0,
  autopilot: true,
  cards: [],
  haloCards: [],
  powers: [],
  particles: [],
  enemies: [],
  playerProjectiles: [],
  enemyProjectiles: [],
  xp: 0,
  level: 1,
  nextLevelXp: 20,
  wave: 1,
  kills: 0,
  boss: null,
  weaponIndex: 0,
  fireCooldown: 0,
  spiralAngle: 0,
  effects: { magnetUntil: 0, freezeUntil: 0, haloUntil: 0, bombFlashUntil: 0 },
  ship: { x: W * 0.5, y: H * 0.55, vx: 0, vy: 0, angle: 0, targetX: W * 0.5, targetY: H * 0.55, baseOrbit: 92, hp: 100, maxHp: 100 }
};

function rand(min,max){ return Math.random() * (max - min) + min; }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function dist(ax,ay,bx,by){ return Math.hypot(bx-ax, by-ay); }
function lerp(a,b,t){ return a + (b-a)*t; }
function angleTo(ax,ay,bx,by){ return Math.atan2(by-ay,bx-ax); }

function log(msg){
  const line = document.createElement('div');
  line.className = 'logLine';
  line.innerHTML = msg;
  ui.log.prepend(line);
  while (ui.log.children.length > 28) ui.log.removeChild(ui.log.lastChild);
}
function setAction(title,text){ ui.actionTitle.textContent = title; ui.actionText.textContent = text; }

function spawnCard(edgeBias = false){
  const meta = CARD_TYPES[Math.floor(Math.random() * CARD_TYPES.length)];
  let x, y;
  if (edgeBias || Math.random() < 0.6) {
    const side = Math.floor(Math.random() * 4);
    if (side === 0) { x = rand(30, W-30); y = rand(20, 90); }
    if (side === 1) { x = W - rand(20, 90); y = rand(30, H-30); }
    if (side === 2) { x = rand(30, W-30); y = H - rand(20, 90); }
    if (side === 3) { x = rand(20, 90); y = rand(30, H-30); }
  } else { x = rand(40, W-40); y = rand(40, H-40); }
  const angle = rand(0, Math.PI * 2);
  state.cards.push({ id: crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2), x, y, vx: Math.cos(angle) * rand(.3,1.0), vy: Math.sin(angle) * rand(.3,1.0), r: 18, type: meta.type, css: meta.css, effect: meta.effect, color: meta.color, desc: meta.desc, collected:false, phase:rand(0,Math.PI*2) });
}

function spawnEnemy(boss = false){
  const lane = Math.floor(rand(0, 5));
  const x = 170 + lane * 180 + rand(-28,28);
  const y = rand(60, 180);
  const hp = boss ? 50 + state.wave * 8 : 6 + state.wave + Math.floor(state.level * 0.7);
  const enemy = { id:(crypto.randomUUID?crypto.randomUUID():Math.random().toString(36).slice(2)), x, y, vx: boss ? -22 : -34 - state.wave*1.5, vy: boss ? 14 : 18 + rand(-4,6), hp, maxHp: hp, boss, cooldown: rand(1.2,2.4), shotTimer: rand(.4,1.1), phase: rand(0,Math.PI*2), r: boss ? 34 : 18, exploded:false };
  state.enemies.push(enemy);
  if (boss) {
    state.boss = enemy;
    log(`ü§ñ <strong>Boss inbound.</strong> Zaxxon war robot entered wave ${state.wave}.`);
    setAction('Boss Alert', 'A heavy robot boss is entering from the upper lanes.');
  }
}

function seedField(){
  state.cards = []; state.haloCards = []; state.powers = []; state.particles = []; state.enemies = []; state.playerProjectiles = []; state.enemyProjectiles = [];
  state.combo = 0; state.totalCollected = 0; state.sweepCharge = 0; state.xp = 0; state.level = 1; state.nextLevelXp = 20; state.wave = 1; state.kills = 0; state.weaponIndex = 0; state.fireCooldown = 0; state.spiralAngle = 0; state.boss = null;
  state.effects.magnetUntil = 0; state.effects.freezeUntil = 0; state.effects.haloUntil = 0; state.effects.bombFlashUntil = 0;
  state.ship.x = W * 0.5; state.ship.y = H * 0.55; state.ship.vx = 0; state.ship.vy = 0; state.ship.hp = 100; state.ship.maxHp = 100; state.ship.baseOrbit = 92;
  for (let i = 0; i < 34; i++) spawnCard(true);
  for (let i = 0; i < 6; i++) spawnEnemy(false);
  renderPowerList(); updateUi(); setAction('Auto-pilot engaged', 'The ship is steering itself toward the best cluster of cards while card-weapons target incoming robots.');
  log('üöÄ <strong>Field reset.</strong> Auto-pilot is gathering cards while battling robot squadrons.');
}

function bestClusterTarget(){
  const loose = state.cards.filter(c => !c.collected);
  if (!loose.length) return { x: W * 0.5, y: H * 0.5, activity:'IDLE' };
  let best = null;
  for (const card of loose) {
    let score = 0;
    for (const other of loose) {
      const d = dist(card.x, card.y, other.x, other.y);
      if (d < 170) score += 1 - d / 170;
    }
    const shipD = dist(state.ship.x, state.ship.y, card.x, card.y);
    score += clamp(1 - shipD / 700, 0, 1) * 2.2;
    if (state.enemies.length) {
      const enemyNear = state.enemies.reduce((acc,e)=>Math.min(acc, dist(card.x,card.y,e.x,e.y)), 9999);
      score += clamp(1 - enemyNear / 260, 0, 1) * 0.9;
    }
    if (!best || score > best.score) best = { x: card.x, y: card.y, score, card };
  }
  return { x: best.x, y: best.y, activity: best.score > 3.2 ? 'CLUSTER LOCK' : 'HUNTING', card: best.card };
}

function collectCard(card, source='auto'){
  if (card.collected) return;
  card.collected = true;
  state.totalCollected += 1;
  state.combo += 1;
  state.sweepCharge = clamp(state.sweepCharge + 6, 0, 100);
  state.powers.unshift({ id: card.id, name: `${card.type} Card`, css: card.css, color: card.color, effect: card.effect, desc: card.desc, used: false });
  state.haloCards.push({ id: card.id, type: card.type, color: card.color, t: 0, slot: state.haloCards.length, phase: rand(0, Math.PI * 2) });
  for (let i = 0; i < 10; i++) state.particles.push({ x: card.x, y: card.y, vx: rand(-2.5,2.5), vy: rand(-2.5,2.5), life: rand(18,36), color: card.color, size: rand(1.5,3.2) });
  renderPowerList(); updateUi();
  if (source === 'auto') log(`‚ú® <strong>${card.type}</strong> card auto-collected into your halo.`);
  if (source === 'special') log(`‚ö° <strong>${card.type}</strong> card was captured by a special effect.`);
}

function addXp(amount){
  state.xp += amount;
  while (state.xp >= state.nextLevelXp) {
    state.xp -= state.nextLevelXp;
    state.level += 1;
    state.nextLevelXp = Math.round(state.nextLevelXp * 1.34);
    state.ship.baseOrbit += 6;
    state.ship.maxHp += 5;
    state.ship.hp = Math.min(state.ship.maxHp, state.ship.hp + 10);
    setAction('Level Up', `Level ${state.level} reached. Orbit widened, hull strengthened, and card-weapon cadence improved.`);
    log(`üÜô <strong>Level ${state.level}</strong> reached. Weapon cooldowns improve and ship survivability rises.`);
  }
}

function renderPowerList(){
  ui.powerList.innerHTML = '';
  if (!state.powers.length) {
    const empty = document.createElement('div'); empty.className = 'tip'; empty.textContent = 'No collected power cards yet. Auto-pilot will fill this panel as it gathers cards.'; ui.powerList.appendChild(empty); return;
  }
  state.powers.slice(0, 14).forEach(power => {
    const el = document.createElement('div');
    el.className = `cardItem ${power.used ? 'used' : 'ready'}`;
    el.innerHTML = `<div class="cardHead"><div class="cardName">${power.name}</div><div class="cardType ${power.css}">${power.effect.toUpperCase()}</div></div><div>${power.desc}</div>`;
    if (!power.used) el.addEventListener('click', () => triggerPower(power.id));
    ui.powerList.appendChild(el);
  });
}

function triggerPower(id){
  const power = state.powers.find(p => p.id === id && !p.used);
  if (!power) return;
  power.used = true;
  if (power.effect === 'burst') applyBurst();
  if (power.effect === 'magnet') applyMagnet();
  if (power.effect === 'sweep') applySweep();
  if (power.effect === 'freeze') applyFreeze();
  if (power.effect === 'halo') applyHaloBoost();
  renderPowerList(); updateUi();
}

function applyBurst(){
  let hits = 0, enemyHits = 0;
  for (const card of state.cards) if (!card.collected && dist(card.x, card.y, state.ship.x, state.ship.y) < 240) { collectCard(card, 'special'); hits += 1; }
  for (const enemy of state.enemies) if (dist(enemy.x, enemy.y, state.ship.x, state.ship.y) < 260) { enemy.hp -= 8 + state.level; enemyHits += 1; }
  setAction('Burst Nearby', `Burst vacuumed ${hits} cards and blasted ${enemyHits} robots.`);
  log(`üåü <strong>Burst Nearby</strong> collected ${hits} cards and hit ${enemyHits} enemies.`);
}
function applyMagnet(){ state.effects.magnetUntil = state.time + 6.0; setAction('Magnet Pulse', 'Loose cards are being pulled aggressively toward the ship for 6 seconds.'); log('üß≤ <strong>Magnet Pulse</strong> activated. All loose cards are drifting inward.'); }
function applySweep(){
  let hits = 0; for (const card of state.cards) if (!card.collected) { collectCard(card, 'special'); hits += 1; }
  state.sweepCharge = 0; if (state.boss) state.boss.hp -= 12 + state.level * 2;
  setAction('Field Sweep', `A full-arena sweep captured ${hits} visible cards and slashed the battle line.`);
  log(`üí• <strong>Field Sweep</strong> captured ${hits} visible cards and damaged active enemies.`);
}
function applyFreeze(){ state.effects.freezeUntil = state.time + 5.0; setAction('Freeze Field', 'Card drift and enemy fire cadence are slowed for 5 seconds.'); log('‚ùÑÔ∏è <strong>Freeze Field</strong> activated. Loose card motion is paused.'); }
function applyHaloBoost(){ state.effects.haloUntil = state.time + 8.0; setAction('Halo Expansion', 'The readable orbit ring, vacuum radius, and fire spread are expanded for 8 seconds.'); log('üü£ <strong>Halo Expansion</strong> activated. Orbit ring and pull radius increased.'); }
function applyBomb(){
  if (state.haloCards.length < 3) { log('‚ö†Ô∏è <strong>Card Bomb</strong> needs at least 3 halo cards.'); return; }
  state.effects.bombFlashUntil = state.time + 0.35;
  const consumed = Math.min(5, state.haloCards.length);
  state.haloCards.splice(0, consumed);
  for (const enemy of state.enemies) enemy.hp -= 10 + consumed * 3 + state.level;
  setAction('Card Bomb', `Detonated ${consumed} halo cards into a screen-wide blast.`);
  log(`üí£ <strong>Card Bomb</strong> detonated ${consumed} halo cards into all enemies.`);
}
function cycleWeapon(){ state.weaponIndex = (state.weaponIndex + 1) % WEAPONS.length; setAction('Weapon Cycled', `Switched to ${WEAPONS[state.weaponIndex].name}.`); updateUi(); }

function fanShot(target){
  const base = angleTo(state.ship.x, state.ship.y, target.x, target.y);
  [-0.22, 0, 0.22].forEach((off, idx)=>spawnProjectile(base + off, 360 + state.level*18, 5 + state.level*0.7, idx===1 ? '#ffd35e' : '#ffef9d', 'fan'));
}
function spiralShot(target){
  state.spiralAngle += 0.45;
  for (let i = 0; i < 2; i++) spawnProjectile(state.spiralAngle + i * Math.PI, 320 + state.level*14, 4.5 + state.level*0.55, '#c79dff', 'spiral');
}
function lanceShot(target){ const a = angleTo(state.ship.x, state.ship.y, target.x, target.y); spawnProjectile(a, 520, 10 + state.level*0.9, '#44ddff', 'lance', 7); }
function crossShot(target){ [0, Math.PI/2, Math.PI, Math.PI*1.5].forEach(a=>spawnProjectile(a, 280 + state.level*12, 4 + state.level*0.5, '#33ffbb', 'cross')); }
function spawnProjectile(angle, speed, damage, color, kind, width = 4){ state.playerProjectiles.push({ x: state.ship.x, y: state.ship.y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, damage, color, kind, life: 1.6, width }); }
function spawnEnemyProjectile(enemy, angle, speed, damage){ state.enemyProjectiles.push({ x: enemy.x, y: enemy.y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, damage, color:'#ff6f91', life: 2.6, width: 4 }); }

function fireWeapons(dt){
  if (!state.enemies.length) return;
  state.fireCooldown -= dt;
  const weapon = WEAPONS[state.weaponIndex];
  const cooldown = Math.max(0.06, weapon.cooldown - state.level * 0.006);
  if (state.fireCooldown > 0) return;
  const target = state.enemies.reduce((best,e)=>!best||dist(state.ship.x,state.ship.y,e.x,e.y) < dist(state.ship.x,state.ship.y,best.x,best.y) ? e : best, null);
  if (!target) return;
  weapon.fire(target);
  state.fireCooldown = cooldown;
}

function killEnemy(enemy){
  if (enemy.exploded) return;
  enemy.exploded = true;
  const xpGain = enemy.boss ? 18 + state.wave * 2 : 4 + Math.floor(state.wave * 0.6);
  addXp(xpGain);
  state.kills += 1;
  for (let i = 0; i < (enemy.boss ? 26 : 12); i++) state.particles.push({ x: enemy.x, y: enemy.y, vx: rand(-4.6,4.6), vy: rand(-4.6,4.6), life: rand(22,46), color: enemy.boss ? '#ffad63' : '#ff6f91', size: rand(1.8,4.0) });
  for (let i = 0; i < (enemy.boss ? 3 : 1); i++) spawnCard(false);
  log(`${enemy.boss ? 'üëπ <strong>Boss destroyed.</strong>' : 'üí• <strong>Robot destroyed.</strong>'} +${xpGain} XP.`);
  if (enemy.boss) { state.boss = null; state.wave += 1; setAction('Boss Down', 'The boss exploded and dropped extra cards into the field.'); }
}

function advanceWaveIfNeeded(){
  if (state.enemies.length > 0) return;
  state.wave += 1;
  const count = 5 + Math.min(6, state.wave);
  for (let i = 0; i < count; i++) spawnEnemy(false);
  if (state.wave % 3 === 0) spawnEnemy(true);
  log(`üõ∏ <strong>Wave ${state.wave}</strong> entering with ${count}${state.wave % 3 === 0 ? ' + boss' : ''} enemies.`);
  setAction(`Wave ${state.wave}`, state.wave % 3 === 0 ? 'Boss support detected. Prepare card bombs and sweeps.' : 'Robot squadrons are crossing the arena lanes.');
}

function updateEnemies(dt){
  const freezeOn = state.time < state.effects.freezeUntil;
  for (let i = state.enemies.length - 1; i >= 0; i--) {
    const e = state.enemies[i];
    e.phase += dt * (e.boss ? 1.2 : 2.0);
    e.x += e.vx * dt;
    e.y += (e.vy + Math.sin(e.phase) * (e.boss ? 8 : 18)) * dt;
    if (e.y < 60 || e.y > H - 120) e.vy *= -1;
    if (!freezeOn) e.shotTimer -= dt * (e.boss ? 0.85 : 1);
    if (e.shotTimer <= 0) {
      const angle = angleTo(e.x, e.y, state.ship.x, state.ship.y);
      if (e.boss) {
        [-0.18, 0, 0.18].forEach(off=>spawnEnemyProjectile(e, angle + off, 180, 7));
        e.shotTimer = 1.0;
      } else {
        spawnEnemyProjectile(e, angle, 210, 5);
        e.shotTimer = rand(1.1, 2.2);
      }
    }
    if (e.x < -120 || e.hp <= 0) {
      if (e.hp <= 0) killEnemy(e); else state.ship.hp = Math.max(0, state.ship.hp - (e.boss ? 14 : 7));
      state.enemies.splice(i,1);
    }
  }
  advanceWaveIfNeeded();
}

function updateProjectiles(dt){
  for (let i = state.playerProjectiles.length - 1; i >= 0; i--) {
    const p = state.playerProjectiles[i];
    p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
    let hit = false;
    for (const e of state.enemies) {
      if (dist(p.x,p.y,e.x,e.y) < e.r + 8) {
        e.hp -= p.damage;
        for (let j = 0; j < 5; j++) state.particles.push({ x:p.x,y:p.y,vx:rand(-2,2),vy:rand(-2,2),life:rand(10,24),color:p.color,size:rand(1.2,2.8)});
        hit = true; break;
      }
    }
    if (hit || p.life <= 0 || p.x < -40 || p.x > W+40 || p.y < -40 || p.y > H+40) state.playerProjectiles.splice(i,1);
  }
  for (let i = state.enemyProjectiles.length - 1; i >= 0; i--) {
    const p = state.enemyProjectiles[i];
    p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
    if (dist(p.x,p.y,state.ship.x,state.ship.y) < 22) {
      state.ship.hp = Math.max(0, state.ship.hp - p.damage);
      state.enemyProjectiles.splice(i,1);
      log(`‚ö†Ô∏è <strong>Ship hit.</strong> Took ${p.damage} damage from enemy fire.`);
      continue;
    }
    if (p.life <= 0 || p.x < -40 || p.x > W+40 || p.y < -40 || p.y > H+40) state.enemyProjectiles.splice(i,1);
  }
  if (state.ship.hp <= 0) {
    log('üõ†Ô∏è <strong>Hull failure.</strong> Rebuilding ship and dropping a recovery field.');
    state.ship.hp = state.ship.maxHp;
    state.ship.x = W * 0.5; state.ship.y = H * 0.55; state.enemyProjectiles.length = 0;
    for (let i = 0; i < 6; i++) spawnCard(false);
  }
}

function updateUi(){
  const loose = state.cards.filter(c => !c.collected).length;
  ui.collectedCount.textContent = state.totalCollected;
  ui.looseCount.textContent = loose;
  ui.haloCount.textContent = state.haloCards.length;
  ui.comboCount.textContent = state.combo;
  ui.sweepCharge.textContent = `${Math.round(state.sweepCharge)}%`;
  ui.levelCount.textContent = state.level;
  ui.waveCount.textContent = state.wave;
  ui.weaponName.textContent = WEAPONS[state.weaponIndex].name;
  ui.bossHp.textContent = state.boss ? `${Math.max(0, Math.round(state.boss.hp))}` : '‚Äî';
}

function autopilot(dt){
  const target = bestClusterTarget();
  ui.activityPill.textContent = target.activity;
  ui.statusText.textContent = state.boss ? 'BOSS ENGAGED' : (target.activity === 'IDLE' ? 'FIELD CLEAR' : 'AUTO GATHERING');
  const ship = state.ship;
  ship.targetX = target.x; ship.targetY = target.y;
  if (state.boss) { ship.targetY = lerp(ship.targetY, H * 0.68, 0.45); }
  const dx = ship.targetX - ship.x, dy = ship.targetY - ship.y;
  const d = Math.hypot(dx, dy) || 1;
  const desiredSpeed = clamp(d * 0.7, 70, 230 + state.level * 3);
  ship.vx = lerp(ship.vx, dx / d * desiredSpeed, 0.035);
  ship.vy = lerp(ship.vy, dy / d * desiredSpeed, 0.035);
  ship.x += ship.vx * dt; ship.y += ship.vy * dt;
  ship.x = clamp(ship.x, 60, W - 60); ship.y = clamp(ship.y, 70, H - 70); ship.angle = Math.atan2(ship.vy, ship.vx);
  const magnetOn = state.time < state.effects.magnetUntil;
  const freezeOn = state.time < state.effects.freezeUntil;
  const haloBoost = state.time < state.effects.haloUntil;
  const collectRadius = haloBoost ? 160 : 118;
  const magnetRadius = magnetOn ? 420 : 220;
  for (const card of state.cards) {
    if (card.collected) continue;
    card.phase += dt * 2.2;
    if (!freezeOn) {
      card.x += card.vx; card.y += card.vy;
      if (card.x < 22 || card.x > W - 22) card.vx *= -1;
      if (card.y < 22 || card.y > H - 22) card.vy *= -1;
    }
    const cd = dist(card.x, card.y, ship.x, ship.y);
    if (cd < magnetRadius) {
      const pull = clamp(1 - cd / magnetRadius, 0.04, magnetOn ? 0.24 : 0.11);
      card.vx += (ship.x - card.x) * pull * 0.006;
      card.vy += (ship.y - card.y) * pull * 0.006;
    }
    card.vx *= 0.991; card.vy *= 0.991;
    if (cd < collectRadius) collectCard(card, 'auto');
  }
  if (state.cards.filter(c => !c.collected).length < 18) for (let i = 0; i < 2; i++) spawnCard(true);
  fireWeapons(dt);
  ui.hint.textContent = state.sweepCharge >= 100 ? 'Sweep fully charged. Click ‚ÄúCollect Visible‚Äù, trigger a Sweep card, or drop a bomb.' : 'Auto-pilot gathers while your current weapon throws card patterns at robots.';
}

function updateHalo(dt){
  const haloBoost = state.time < state.effects.haloUntil;
  const orbitR = state.ship.baseOrbit + (haloBoost ? 30 : 0);
  const speed = haloBoost ? 1.6 : 1.05;
  for (let i = 0; i < state.haloCards.length; i++) {
    const hc = state.haloCards[i];
    hc.t += dt; hc.slot = i; hc.phase += dt * speed;
    hc.x = state.ship.x + Math.cos(hc.phase + i * 0.46) * (orbitR + (i % 3) * 12);
    hc.y = state.ship.y + Math.sin(hc.phase + i * 0.46) * (orbitR * 0.48 + (i % 2) * 10);
  }
}

function updateParticles(dt){
  for (let i = state.particles.length - 1; i >= 0; i--) {
    const p = state.particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 1; if (p.life <= 0) state.particles.splice(i,1);
  }
}

function drawBackground(){
  ctx.clearRect(0,0,W,H);
  const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#0a1326'); g.addColorStop(1,'#050913'); ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle = 'rgba(68,221,255,0.08)'; ctx.lineWidth = 1;
  for (let x = 0; x < W; x += 60) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for (let y = 0; y < H; y += 60) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  for (let i = 0; i < 70; i++) { const sx = (i * 173) % W, sy = (i * 97) % H; ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(sx, sy, 2, 2); }
  if (state.effects.bombFlashUntil > state.time) { ctx.fillStyle = 'rgba(255,211,94,0.16)'; ctx.fillRect(0,0,W,H); }
}

function drawCard(card, alpha = 1){
  ctx.save(); ctx.translate(card.x, card.y); const angle = Math.atan2(card.vy || 0, card.vx || 0) * 0.15; ctx.rotate(angle); ctx.globalAlpha = alpha;
  ctx.fillStyle = 'rgba(12,18,36,0.95)'; ctx.strokeStyle = card.color; ctx.lineWidth = 2;
  const w = 26, h = 34; ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, 7); ctx.fill(); ctx.stroke();
  ctx.fillStyle = card.color; ctx.fillRect(-w/2 + 3, -h/2 + 3, w - 6, 4); ctx.beginPath(); ctx.arc(0, 0, 6 + Math.sin(card.phase) * 1.2, 0, Math.PI * 2); ctx.fill(); ctx.restore();
}

function drawShip(){
  const s = state.ship; const haloBoost = state.time < state.effects.haloUntil; const orbitR = s.baseOrbit + (haloBoost ? 30 : 0);
  ctx.save(); ctx.translate(s.x, s.y); ctx.strokeStyle = haloBoost ? 'rgba(199,157,255,0.42)' : 'rgba(68,221,255,0.24)'; ctx.lineWidth = haloBoost ? 3 : 2; ctx.beginPath(); ctx.ellipse(0,0,orbitR,orbitR*0.48,0,0,Math.PI*2); ctx.stroke(); ctx.restore();
  ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(s.angle); ctx.fillStyle = '#dff9ff'; ctx.strokeStyle = '#44ddff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(20,0); ctx.lineTo(-16,-11); ctx.lineTo(-10,0); ctx.lineTo(-16,11); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'rgba(51,255,187,0.8)'; ctx.fillRect(-20,-4,10,8); ctx.restore();
  ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.fillRect(s.x-40, s.y+28, 80, 6); ctx.fillStyle = '#33ffbb'; ctx.fillRect(s.x-40, s.y+28, 80 * (s.hp / s.maxHp), 6); ctx.restore();
}

function drawEnemies(){
  for (const e of state.enemies) {
    ctx.save(); ctx.translate(e.x, e.y);
    if (e.boss) {
      ctx.fillStyle = 'rgba(255,173,99,0.16)'; ctx.beginPath(); ctx.ellipse(0,0,e.r+20,e.r*0.7,0,0,Math.PI*2); ctx.fill();
    }
    ctx.strokeStyle = e.boss ? '#ffad63' : '#ff6f91'; ctx.fillStyle = 'rgba(22,14,20,0.95)'; ctx.lineWidth = e.boss ? 3 : 2;
    ctx.beginPath(); ctx.moveTo(0,-e.r); ctx.lineTo(e.r*1.1,0); ctx.lineTo(0,e.r); ctx.lineTo(-e.r*1.1,0); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = e.boss ? '#ffd35e' : '#ff6f91'; ctx.fillRect(-8,-4,16,8); ctx.beginPath(); ctx.arc(0,0,e.boss?7:5,0,Math.PI*2); ctx.fill();
    ctx.restore();
    ctx.fillStyle = 'rgba(255,255,255,0.28)'; ctx.fillRect(e.x - e.r, e.y + e.r + 8, e.r*2, 5); ctx.fillStyle = e.boss ? '#ffad63' : '#ff6f91'; ctx.fillRect(e.x - e.r, e.y + e.r + 8, e.r*2 * (e.hp / e.maxHp), 5);
  }
}

function drawProjectiles(){
  for (const p of state.playerProjectiles) {
    ctx.strokeStyle = p.color; ctx.lineWidth = p.width; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - p.vx * 0.02, p.y - p.vy * 0.02); ctx.stroke();
  }
  for (const p of state.enemyProjectiles) {
    ctx.strokeStyle = p.color; ctx.lineWidth = p.width; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - p.vx * 0.02, p.y - p.vy * 0.02); ctx.stroke();
  }
}

function drawParticles(){
  for (const p of state.particles) {
    ctx.globalAlpha = p.life / 36; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size || 2.2, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawLabels(){
  ctx.save(); ctx.fillStyle = 'rgba(255,255,255,0.72)'; ctx.font = '12px JetBrains Mono, monospace'; const target = bestClusterTarget(); if (target.card) ctx.fillText(`TRACKING ${target.card.type.toUpperCase()}`, state.ship.x + 32, state.ship.y - 24); if (state.boss) ctx.fillText(`BOSS LOCK ${Math.max(0, Math.round(state.boss.hp))} HP`, state.ship.x + 32, state.ship.y - 8); ctx.restore();
}

function render(){
  drawBackground();
  for (const card of state.cards) if (!card.collected) drawCard(card, 0.95);
  for (const hc of state.haloCards) drawCard({ x: hc.x, y: hc.y, vx: 0, vy: 0, phase: hc.phase, color: hc.color }, 0.92);
  drawEnemies(); drawProjectiles(); drawShip(); drawParticles(); drawLabels();
}

let last = performance.now();
function frame(now){
  const dt = Math.min((now - last) / 1000, 0.033); last = now; state.time += dt;
  autopilot(dt); updateEnemies(dt); updateProjectiles(dt); updateHalo(dt); updateParticles(dt); render(); updateUi(); requestAnimationFrame(frame);
}

function assert(name, cond){ if (!cond) console.error('[self-test failed]', name); }
function selfTest(){
  assert('seedField function exists', typeof seedField === 'function');
  assert('triggerPower function exists', typeof triggerPower === 'function');
  assert('canvas exists', !!canvas && !!ctx);
  seedField();
  assert('field seeded with cards', state.cards.length > 0);
  assert('enemies seeded', state.enemies.length > 0);
  applyMagnet();
  assert('magnet effect armed', state.effects.magnetUntil > state.time);
  cycleWeapon();
  assert('weapon cycles', WEAPONS[state.weaponIndex].name !== 'FAN');
}

document.getElementById('restartBtn').addEventListener('click', seedField);
document.getElementById('burstBtn').addEventListener('click', applyBurst);
document.getElementById('collectAllBtn').addEventListener('click', () => { if (state.sweepCharge >= 100) applySweep(); else applyMagnet(); });
document.getElementById('weaponBtn').addEventListener('click', cycleWeapon);
document.getElementById('bombBtn').addEventListener('click', applyBomb);

selfTest();
seedField();
requestAnimationFrame(frame);
</script>
</body>
</html>
