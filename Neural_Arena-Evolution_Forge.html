<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neural Arena: Evolution Forge</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600;800;900&family=JetBrains+Mono:wght@500;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #050814;
      --mint: #33ffbb;
      --cyan: #44ddff;
      --violet: #c79dff;
      --rose: #ff6f91;
      --gold: #ffd35e;
      --bio: #91ff6b;
      --bone: #f6e7d2;
      --muscle: #ff7b95;
    }
    body {
      margin: 0;
      overflow: hidden;
      background-color: var(--bg);
      font-family: 'Inter', sans-serif;
      color: #eef4ff;
      user-select: none;
    }
    #three-container { position: absolute; inset: 0; z-index: 0; }
    .ui-layer { position: relative; z-index: 10; pointer-events: none; }
    .interactive { pointer-events: auto; }
    .glass-panel {
      background: rgba(10, 16, 32, 0.75);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 16px 40px rgba(0,0,0,0.5);
    }
    .font-orbitron { font-family: 'Orbitron', sans-serif; }
    .font-mono { font-family: 'JetBrains Mono', monospace; }
    .text-mint { color: var(--mint); }
    .text-cyan { color: var(--cyan); }
    .text-violet { color: var(--violet); }
    .text-rose { color: var(--rose); }
    .text-gold { color: var(--gold); }
    .text-bio { color: var(--bio); }

    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }

    .log-entry { animation: slideIn 0.28s ease-out forwards; }
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .card-item { transition: all 0.2s; cursor: pointer; }
    .card-item:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(255,255,255,0.1); }
    .type-burst { color: var(--gold); border-color: rgba(255,211,94,0.4); }
    .type-magnet { color: var(--mint); border-color: rgba(51,255,187,0.4); }
    .type-sweep { color: var(--rose); border-color: rgba(255,111,145,0.4); }
    .type-freeze { color: var(--cyan); border-color: rgba(68,221,255,0.4); }
    .type-halo { color: var(--violet); border-color: rgba(199,157,255,0.4); }
    .type-splice { color: var(--bio); border-color: rgba(145,255,107,0.4); }

    .recording-pulse {
      animation: pulse 1.5s infinite;
      background-color: var(--rose) !important;
      color: #fff !important;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(255,111,145,0.7); }
      70% { box-shadow: 0 0 0 10px rgba(255,111,145,0); }
      100% { box-shadow: 0 0 0 0 rgba(255,111,145,0); }
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/"
      }
    }
  </script>
</head>
<body class="flex h-screen w-full">
  <div id="three-container"></div>

  <div class="ui-layer flex flex-col w-full h-full justify-between p-4 gap-4">
    <header class="flex justify-between items-start gap-4">
      <div class="glass-panel p-4 rounded-xl interactive w-80">
        <h1 class="font-orbitron text-lg font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-violet-500 tracking-widest uppercase">All.AI Bio Forge</h1>
        <p class="text-xs text-slate-400 mt-1">Autonomous evolution active. Species drift, mutate, compete, and become reusable anatomy for the central organism.</p>
        <div class="mt-3 flex items-center justify-between text-[10px] font-mono border-t border-slate-700 pt-2">
          <span id="status-text" class="text-mint">STATUS: EVOLVING</span>
          <div class="flex items-center gap-2 text-slate-300">
            TTS
            <button id="tts-btn" class="w-8 h-4 bg-indigo-600 rounded-full relative transition-colors">
              <span class="absolute right-1 top-0.5 w-3 h-3 bg-white rounded-full transition-all"></span>
            </button>
          </div>
        </div>
      </div>

      <div class="glass-panel px-6 py-3 rounded-xl flex gap-5 text-center font-mono text-sm interactive">
        <div><div class="text-slate-400 text-[10px]">COLLECTED</div><div id="ui-collected" class="text-white font-bold text-lg">0</div></div>
        <div><div class="text-slate-400 text-[10px]">LOOSE</div><div id="ui-loose" class="text-cyan-400 font-bold text-lg">0</div></div>
        <div><div class="text-slate-400 text-[10px]">MASS</div><div id="ui-mass" class="text-bio font-bold text-lg">1.0</div></div>
        <div><div class="text-slate-400 text-[10px]">GENE</div><div id="ui-gene" class="text-violet-400 font-bold text-lg">1</div></div>
        <div><div class="text-slate-400 text-[10px]">SWEEP %</div><div id="ui-sweep" class="text-rose-400 font-bold text-lg">0%</div></div>
      </div>
    </header>

    <main class="flex-1 flex justify-between items-end gap-4 pb-4">
      <div class="glass-panel w-80 h-96 rounded-xl flex flex-col interactive overflow-hidden">
        <div class="p-3 border-b border-slate-700 bg-slate-900/50 flex justify-between items-center">
          <span class="font-orbitron text-xs text-cyan-400 tracking-widest">COMMS LOG</span>
          <button id="mic-btn" class="p-2 bg-slate-800 rounded-full hover:bg-slate-700 transition-colors" title="Toggle Voice Recognition">
            <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path></svg>
          </button>
        </div>
        <div id="chat-log" class="flex-1 overflow-y-auto p-3 flex flex-col gap-2 text-xs"></div>
        <div class="p-2 border-t border-slate-700 bg-slate-900/80">
          <input type="text" id="chat-input" class="w-full bg-slate-950 text-slate-200 text-xs px-3 py-2 rounded border border-slate-700 focus:outline-none focus:border-cyan-500" placeholder="Try: splice, burst, magnet, halo, freeze, sweep" />
        </div>
      </div>

      <div class="glass-panel w-80 h-96 rounded-xl flex flex-col interactive overflow-hidden">
        <div class="p-3 border-b border-slate-700 bg-slate-900/50">
          <span class="font-orbitron text-xs text-gold tracking-widest">TACTICAL POWERS</span>
        </div>
        <div id="powers-list" class="flex-1 overflow-y-auto p-3 flex flex-col gap-2">
          <div class="text-[10px] text-slate-500 text-center mt-10">Power organs and protocols will appear here.</div>
        </div>
      </div>

      <div class="glass-panel w-80 h-96 rounded-xl flex flex-col interactive overflow-hidden">
        <div class="p-3 border-b border-slate-700 bg-slate-900/50">
          <span class="font-orbitron text-xs text-bio tracking-widest">SPECIES LAB</span>
        </div>
        <div id="species-list" class="flex-1 overflow-y-auto p-3 flex flex-col gap-2 text-xs"></div>
      </div>
    </main>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    const BOUNDS = 220;
    const MAX_PARTICLES = 1200;
    const MAX_ENTITIES = 90;
    const MAX_POWER_HISTORY = 36;
    const SPECIES_SEEDS = [
      { name: 'Tubulon', color: 0x33ffbb, body: 'tube', speed: 22, drift: 0.35, fertility: 0.22, aggression: 0.10, rarity: 1 },
      { name: 'Ossifin', color: 0xf6e7d2, body: 'bone', speed: 18, drift: 0.18, fertility: 0.14, aggression: 0.28, rarity: 1 },
      { name: 'Myocel', color: 0xff7b95, body: 'muscle', speed: 24, drift: 0.25, fertility: 0.18, aggression: 0.34, rarity: 1 },
      { name: 'Spirax', color: 0x44ddff, body: 'spiral', speed: 28, drift: 0.45, fertility: 0.16, aggression: 0.22, rarity: 1 },
      { name: 'Calyx', color: 0xc79dff, body: 'petal', speed: 20, drift: 0.30, fertility: 0.20, aggression: 0.15, rarity: 1 },
      { name: 'Hexapod', color: 0xffd35e, body: 'limb', speed: 26, drift: 0.22, fertility: 0.17, aggression: 0.26, rarity: 1 }
    ];

    const CARD_TYPES = [
      { type: 'Burst', color: 0xffd35e, css: 'type-burst', effect: 'burst', desc: 'Instant harvest in radius.' },
      { type: 'Magnet', color: 0x33ffbb, css: 'type-magnet', effect: 'magnet', desc: 'Pull biomass to core.' },
      { type: 'Sweep', color: 0xff6f91, css: 'type-sweep', effect: 'sweep', desc: 'Collect all visible organisms.' },
      { type: 'Freeze', color: 0x44ddff, css: 'type-freeze', effect: 'freeze', desc: 'Stall species movement.' },
      { type: 'Halo', color: 0xc79dff, css: 'type-halo', effect: 'halo', desc: 'Widen predation ring.' },
      { type: 'Splice', color: 0x91ff6b, css: 'type-splice', effect: 'splice', desc: 'Force rapid evolution and extra growth.' }
    ];

    const state = {
      time: 0,
      collected: 0,
      combo: 0,
      sweepCharge: 0,
      powers: [],
      effects: { magnetUntil: 0, freezeUntil: 0, haloUntil: 0, spliceUntil: 0 },
      ttsEnabled: true,
      isListening: false,
      nextSpawnAt: 0,
      nextMutateAt: 6,
      nextSpeciationAt: 18,
      entities: [],
      speciesCatalog: [],
      speciesCounter: 0,
      growthMass: 1,
      geneLevel: 1,
      harvestedParts: [],
      haloNodes: []
    };

    const container = document.getElementById('three-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050814, 0.003);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1400);
    camera.position.set(0, 210, 260);
    camera.lookAt(0, 20, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    container.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.1;
    bloomPass.strength = 1.25;
    bloomPass.radius = 0.55;
    composer.addPass(bloomPass);
    composer.addPass(new OutputPass());

    const gridHelper = new THREE.GridHelper(BOUNDS * 2, 48, 0x44ddff, 0x112244);
    gridHelper.position.y = -8;
    gridHelper.material.transparent = true;
    gridHelper.material.opacity = 0.22;
    scene.add(gridHelper);

    scene.add(new THREE.AmbientLight(0x283040, 1.0));
    const pointLight = new THREE.PointLight(0xaaffee, 2.8, 400);
    scene.add(pointLight);

    const bioCore = new THREE.Group();
    scene.add(bioCore);

    const shipData = {
      pos: new THREE.Vector3(0, 0, 0),
      vel: new THREE.Vector3(0, 0, 0),
      target: new THREE.Vector3(0, 0, 0),
      baseOrbit: 24,
      collectRadius: 18,
      magnetRadius: 70,
      rootAssembly: null,
      partGroups: []
    };

    const particles = [];
    const dummy = new THREE.Object3D();
    const particleMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(0.55, 0.55, 0.55), new THREE.MeshBasicMaterial({ color: 0xffffff }), MAX_PARTICLES);
    particleMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    scene.add(particleMesh);

    const synth = window.speechSynthesis;
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;

    function rand(min, max) { return Math.random() * (max - min) + min; }
    function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function setStatus(text, cssClass = 'text-mint') {
      const el = document.getElementById('status-text');
      el.textContent = text;
      el.className = cssClass;
    }

    function logComms(speaker, msg, isHighlight = false) {
      const logBox = document.getElementById('chat-log');
      const entry = document.createElement('div');
      entry.className = 'log-entry mb-2';
      const color = speaker === 'System' ? 'text-rose' : (speaker === 'Link' ? 'text-cyan' : 'text-mint');
      const textClass = isHighlight ? 'text-white font-semibold' : 'text-slate-300';
      entry.innerHTML = `<span class="font-bold ${color} text-[10px] uppercase tracking-wider">${speaker}:</span> <span class="${textClass}">${msg}</span>`;
      logBox.appendChild(entry);
      logBox.scrollTop = logBox.scrollHeight;
      while (logBox.children.length > 80) logBox.removeChild(logBox.firstChild);
    }

    function speak(text) {
      if (!state.ttsEnabled || !synth) return;
      const u = new SpeechSynthesisUtterance(text);
      u.pitch = 0.88;
      u.rate = 1.05;
      synth.speak(u);
    }

    function seededSpecies(seed) {
      state.speciesCounter += 1;
      return {
        id: `sp-${state.speciesCounter}`,
        name: `${seed.name}-${state.speciesCounter}`,
        color: seed.color,
        body: seed.body,
        speed: seed.speed,
        drift: seed.drift,
        fertility: seed.fertility,
        aggression: seed.aggression,
        rarity: seed.rarity,
        generation: 1,
        births: 0,
        harvested: 0,
        mutations: 0
      };
    }

    function mutateSpecies(base) {
      state.speciesCounter += 1;
      const hue = new THREE.Color(base.color);
      hue.offsetHSL(rand(-0.08, 0.08), rand(-0.08, 0.08), rand(-0.08, 0.08));
      const bodies = ['tube', 'bone', 'muscle', 'spiral', 'petal', 'limb', 'spine'];
      return {
        ...base,
        id: `sp-${state.speciesCounter}`,
        name: `${base.name.split('-')[0]}′${state.speciesCounter}`,
        color: hue.getHex(),
        body: Math.random() < 0.35 ? pick(bodies) : base.body,
        speed: clamp(base.speed + rand(-4, 4), 12, 38),
        drift: clamp(base.drift + rand(-0.12, 0.12), 0.08, 0.65),
        fertility: clamp(base.fertility + rand(-0.05, 0.06), 0.08, 0.34),
        aggression: clamp(base.aggression + rand(-0.08, 0.10), 0.05, 0.55),
        generation: base.generation + 1,
        births: 0,
        harvested: 0,
        mutations: (base.mutations || 0) + 1
      };
    }

    function createBodyGeometry(kind, scale = 1) {
      if (kind === 'tube') return new THREE.CylinderGeometry(1.2 * scale, 1.8 * scale, 8 * scale, 10, 1, true);
      if (kind === 'bone') return new THREE.CapsuleGeometry(1.4 * scale, 6 * scale, 4, 10);
      if (kind === 'muscle') return new THREE.SphereGeometry(2.6 * scale, 10, 8);
      if (kind === 'spiral') return new THREE.TorusKnotGeometry(1.6 * scale, 0.45 * scale, 48, 8, 2, 3);
      if (kind === 'petal') return new THREE.OctahedronGeometry(3.1 * scale, 0);
      if (kind === 'limb') return new THREE.CylinderGeometry(0.7 * scale, 1.3 * scale, 10 * scale, 7);
      if (kind === 'spine') return new THREE.ConeGeometry(2.3 * scale, 8 * scale, 7);
      return new THREE.IcosahedronGeometry(2.4 * scale, 0);
    }

    function createBioMaterial(color) {
      return new THREE.MeshStandardMaterial({
        color,
        emissive: color,
        emissiveIntensity: 0.25,
        roughness: 0.45,
        metalness: 0.12,
        flatShading: false
      });
    }

    function buildCreatureMesh(species, mass = 1) {
      const g = new THREE.Group();
      const baseColor = species.color;
      const main = new THREE.Mesh(createBodyGeometry(species.body, 0.8 + mass * 0.25), createBioMaterial(baseColor));
      main.castShadow = false;
      main.receiveShadow = false;
      main.rotation.z = rand(-0.4, 0.4);
      g.add(main);

      const appendages = Math.floor(2 + mass * 2 + species.generation * 0.4);
      for (let i = 0; i < appendages; i++) {
        const limbKind = Math.random() < 0.5 ? pick(['tube', 'bone', 'limb', 'spine']) : species.body;
        const limb = new THREE.Mesh(createBodyGeometry(limbKind, rand(0.25, 0.55)), createBioMaterial(baseColor));
        const a = (Math.PI * 2 * i) / appendages;
        limb.position.set(Math.cos(a) * rand(1.5, 4.5), rand(-1.2, 1.2), Math.sin(a) * rand(1.5, 4.5));
        limb.rotation.set(rand(-1.5, 1.5), rand(-1.5, 1.5), rand(-1.5, 1.5));
        g.add(limb);
      }

      const nucleus = new THREE.Mesh(new THREE.SphereGeometry(0.7 + mass * 0.18, 8, 8), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: baseColor, emissiveIntensity: 0.6 }));
      g.add(nucleus);
      return g;
    }

    function createSpeciesEntity(species, inherited = false) {
      const mass = rand(0.6, 1.6) + species.generation * 0.08;
      const mesh = buildCreatureMesh(species, mass);
      mesh.position.set(rand(-BOUNDS, BOUNDS), rand(0, 12), rand(-BOUNDS, BOUNDS));
      scene.add(mesh);
      const dir = new THREE.Vector3(rand(-1, 1), 0, rand(-1, 1)).normalize();
      const entity = {
        id: Math.random().toString(36).slice(2),
        kind: 'organism',
        speciesId: species.id,
        speciesName: species.name,
        species,
        mesh,
        pos: mesh.position,
        vel: dir.multiplyScalar(species.speed * 0.18),
        energy: rand(40, 90),
        age: 0,
        mass,
        phase: rand(0, Math.PI * 2),
        collected: false,
        visualRemoved: false,
        power: pick(CARD_TYPES),
        partKind: species.body
      };
      state.entities.push(entity);
      if (!inherited) species.births += 1;
      return entity;
    }

    function createShipAssembly() {
      bioCore.clear();
      shipData.partGroups = [];

      const spineMat = new THREE.MeshStandardMaterial({ color: 0x33ffbb, emissive: 0x115544, emissiveIntensity: 0.7, roughness: 0.35, metalness: 0.15 });
      const root = new THREE.Group();
      const torso = new THREE.Mesh(new THREE.CapsuleGeometry(4, 14, 6, 12), spineMat);
      torso.rotation.z = Math.PI / 2;
      root.add(torso);

      const head = new THREE.Mesh(new THREE.SphereGeometry(3.4, 10, 10), new THREE.MeshStandardMaterial({ color: 0xaaffee, emissive: 0x44ddff, emissiveIntensity: 0.9 }));
      head.position.set(7.5, 0.5, 0);
      root.add(head);

      const tail = new THREE.Mesh(new THREE.ConeGeometry(2.8, 8, 8), spineMat);
      tail.position.set(-10, 0, 0);
      tail.rotation.z = -Math.PI / 2;
      root.add(tail);

      bioCore.add(root);
      shipData.rootAssembly = root;
    }

    function addHarvestedPart(partKind, color, powerEffect) {
      if (!shipData.rootAssembly) return;
      const part = new THREE.Mesh(createBodyGeometry(partKind, rand(0.22, 0.48)), createBioMaterial(color));
      const slot = shipData.partGroups.length;
      const ring = 6 + Math.floor(slot / 5) * 3.8;
      const a = slot * 0.86;
      part.position.set(Math.cos(a) * ring, rand(-3.5, 3.5), Math.sin(a) * ring);
      part.rotation.set(rand(-1.5, 1.5), rand(-1.5, 1.5), rand(-1.5, 1.5));
      part.userData = { slot, pulse: rand(0, Math.PI * 2), effect: powerEffect };
      shipData.rootAssembly.add(part);
      shipData.partGroups.push(part);
      state.harvestedParts.push({ partKind, color, powerEffect });

      const growthFactor = 1 + shipData.partGroups.length * 0.012;
      shipData.rootAssembly.scale.setScalar(growthFactor);
      shipData.collectRadius = 18 + Math.min(18, shipData.partGroups.length * 0.18);
      shipData.magnetRadius = 70 + Math.min(90, shipData.partGroups.length * 1.1);
      shipData.baseOrbit = 24 + Math.min(20, shipData.partGroups.length * 0.25);
      state.growthMass = (1 + shipData.partGroups.length * 0.06).toFixed(1);
      state.geneLevel = 1 + Math.floor(shipData.partGroups.length / 6);
    }

    function emitParticles(pos, colorValue, count = 10) {
      const color = new THREE.Color(colorValue);
      for (let i = 0; i < count; i++) {
        if (particles.length >= MAX_PARTICLES) break;
        particles.push({
          pos: pos.clone(),
          vel: new THREE.Vector3(rand(-1.6, 1.6), rand(-0.4, 2.4), rand(-1.6, 1.6)),
          life: 1,
          color
        });
      }
    }

    function updateParticles(dt) {
      let activeCount = 0;
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= dt * 1.45;
        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }
        p.pos.addScaledVector(p.vel, dt * 60);
        p.vel.y -= dt * 2;
        dummy.position.copy(p.pos);
        dummy.scale.setScalar(Math.max(0.12, p.life));
        dummy.updateMatrix();
        particleMesh.setMatrixAt(activeCount, dummy.matrix);
        particleMesh.setColorAt(activeCount, p.color);
        activeCount++;
      }
      particleMesh.count = activeCount;
      particleMesh.instanceMatrix.needsUpdate = true;
      if (particleMesh.instanceColor) particleMesh.instanceColor.needsUpdate = true;
    }

    function collectEntity(entity, source = 'auto') {
      if (entity.collected) return;
      entity.collected = true;
      state.collected++;
      state.combo++;
      state.sweepCharge = Math.min(100, state.sweepCharge + 4 + entity.mass * 2);
      emitParticles(entity.mesh.position, entity.species.color, 20);

      state.powers.unshift({
        id: entity.id,
        name: `${entity.power.type} Protocol`,
        effect: entity.power.effect,
        css: entity.power.css,
        desc: `${entity.power.desc} Harvested from ${entity.speciesName}.`,
        used: false
      });
      state.powers = state.powers.slice(0, MAX_POWER_HISTORY);

      entity.species.harvested += 1;
      addHarvestedPart(entity.partKind, entity.species.color, entity.power.effect);
      state.haloNodes.push({ entity, phase: rand(0, Math.PI * 2) });
      if (state.haloNodes.length > 22) {
        const removed = state.haloNodes.shift();
        if (removed && removed.entity && !removed.entity.visualRemoved) {
          removed.entity.visualRemoved = true;
          scene.remove(removed.entity.mesh);
        }
      }

      renderPowers();
      renderSpecies();
      updateUI();
      if (source !== 'auto') logComms('Link', `Biomass ${entity.speciesName} acquired via ${source}.`);
    }

    function bestTarget() {
      const loose = state.entities.filter(e => !e.collected);
      if (!loose.length) return new THREE.Vector3(0, 0, 0);
      let best = null;
      let bestScore = -Infinity;
      for (const e of loose) {
        let score = e.energy * 0.01 + e.mass * 0.6 + e.species.generation * 0.5;
        for (const other of loose) {
          const d = e.pos.distanceTo(other.pos);
          if (d < 48) score += 1 - d / 48;
        }
        const distToShip = shipData.pos.distanceTo(e.pos);
        score += Math.max(0, 1 - distToShip / 160) * 2;
        if (score > bestScore) {
          bestScore = score;
          best = e.pos.clone();
        }
      }
      return best || new THREE.Vector3(0, 0, 0);
    }

    function evolveWorld(dt) {
      if (state.time >= state.nextMutateAt) {
        state.nextMutateAt = state.time + rand(6, 10);
        const base = pick(state.speciesCatalog);
        const mutant = mutateSpecies(base);
        state.speciesCatalog.push(mutant);
        logComms('System', `Mutation event: ${mutant.name} emerges with ${mutant.body} architecture.`);
        for (let i = 0; i < 2 + Math.floor(mutant.generation / 2); i++) createSpeciesEntity(mutant, true);
        renderSpecies();
      }

      if (state.time >= state.nextSpeciationAt && state.speciesCatalog.length < 14) {
        state.nextSpeciationAt = state.time + rand(15, 24);
        const seed = mutateSpecies(pick(state.speciesCatalog));
        state.speciesCatalog.push(seed);
        logComms('System', `Speciation burst: ${seed.name} becomes a stable lineage.`);
        renderSpecies();
      }

      const freezeOn = state.time < state.effects.freezeUntil;
      const spliceOn = state.time < state.effects.spliceUntil;

      for (const e of state.entities) {
        if (e.collected) continue;
        e.age += dt;
        e.energy -= dt * (0.5 + e.species.speed * 0.012);
        e.phase += dt * (0.8 + e.species.drift * 2.0);
        e.mesh.rotation.x += dt * 0.7;
        e.mesh.rotation.y += dt * (0.8 + e.species.drift);
        e.mesh.position.y = 3 + Math.sin(state.time * 2 + e.phase) * (2 + e.mass);

        if (!freezeOn) {
          const noise = new THREE.Vector3(Math.sin(e.phase) * e.species.drift, 0, Math.cos(e.phase * 1.2) * e.species.drift);
          e.vel.addScaledVector(noise, dt * 7);
          e.vel.clampLength(0, e.species.speed * 0.35);
          e.pos.addScaledVector(e.vel, dt);
        }

        if (Math.abs(e.pos.x) > BOUNDS) e.vel.x *= -1;
        if (Math.abs(e.pos.z) > BOUNDS) e.vel.z *= -1;
        e.pos.x = clamp(e.pos.x, -BOUNDS, BOUNDS);
        e.pos.z = clamp(e.pos.z, -BOUNDS, BOUNDS);

        if (Math.random() < (e.species.fertility + (spliceOn ? 0.06 : 0)) * dt * 0.15 && state.entities.filter(x => !x.collected).length < MAX_ENTITIES) {
          const childSpecies = Math.random() < 0.16 ? mutateSpecies(e.species) : e.species;
          if (!state.speciesCatalog.find(s => s.id === childSpecies.id)) state.speciesCatalog.push(childSpecies);
          const child = createSpeciesEntity(childSpecies);
          child.pos.copy(e.pos.clone().add(new THREE.Vector3(rand(-5,5), 0, rand(-5,5))));
        }
      }

      const live = state.entities.filter(e => !e.collected);
      for (let i = 0; i < live.length; i++) {
        for (let j = i + 1; j < live.length; j++) {
          const a = live[i], b = live[j];
          const d = a.pos.distanceTo(b.pos);
          if (d > 0 && d < 10) {
            const push = a.pos.clone().sub(b.pos).normalize().multiplyScalar(0.03);
            a.vel.add(push);
            b.vel.sub(push);
          }
          if (d < 12 && Math.random() < (a.species.aggression + b.species.aggression) * 0.004) {
            if (a.mass > b.mass) b.energy -= 1.4;
            else a.energy -= 1.4;
          }
        }
      }

      for (const e of live) {
        if (e.energy <= 0) collectEntity(e, 'ecosystem');
      }
    }

    function autopilot(dt) {
      shipData.target = bestTarget();
      const dir = shipData.target.clone().sub(shipData.pos);
      const dist = dir.length();
      if (dist > 0.1) {
        const speed = clamp(18 + state.geneLevel * 2 + dist * 0.12, 18, 95);
        dir.normalize().multiplyScalar(speed);
        shipData.vel.lerp(dir, 0.045);
      }

      shipData.pos.addScaledVector(shipData.vel, dt);
      shipData.pos.x = clamp(shipData.pos.x, -BOUNDS, BOUNDS);
      shipData.pos.z = clamp(shipData.pos.z, -BOUNDS, BOUNDS);

      bioCore.position.copy(shipData.pos);
      bioCore.position.y = 7 + Math.sin(state.time * 2.6) * 2.5;
      if (shipData.vel.lengthSq() > 0.1) {
        const angle = Math.atan2(shipData.vel.x, shipData.vel.z);
        bioCore.rotation.y = angle;
      }

      pointLight.position.copy(bioCore.position);
      pointLight.position.y += 16;

      const magnetOn = state.time < state.effects.magnetUntil;
      const haloOn = state.time < state.effects.haloUntil;
      const collectRadius = shipData.collectRadius + (haloOn ? 16 : 0);
      const magnetRadius = shipData.magnetRadius + (magnetOn ? 110 : 0);

      for (const e of state.entities) {
        if (e.collected) continue;
        const d = e.pos.distanceTo(shipData.pos);
        if (d < magnetRadius) {
          const pull = shipData.pos.clone().sub(e.pos).normalize().multiplyScalar((magnetOn ? 0.85 : 0.08) * Math.max(0.2, 1 - d / magnetRadius));
          e.vel.add(pull);
        }
        if (d < collectRadius) collectEntity(e);
      }

      for (const part of shipData.partGroups) {
        const u = part.userData;
        u.pulse += dt * 2.2;
        const slot = u.slot;
        const ring = 6 + Math.floor(slot / 5) * 3.8;
        const a = slot * 0.86 + state.time * 0.2;
        part.position.x = Math.cos(a) * ring;
        part.position.z = Math.sin(a) * ring;
        part.position.y += Math.sin(u.pulse) * 0.03;
        part.rotation.x += dt * 0.7;
        part.rotation.y += dt * 0.9;
      }
    }

    function updateHalo(dt) {
      const orbitR = shipData.baseOrbit + (state.time < state.effects.haloUntil ? 15 : 0);
      state.haloNodes.forEach((hn, i) => {
        if (hn.entity.visualRemoved) return;
        hn.phase += dt * 1.5;
        const r = orbitR + (i % 3) * 4;
        hn.entity.mesh.position.x = shipData.pos.x + Math.cos(hn.phase + i * 0.6) * r;
        hn.entity.mesh.position.z = shipData.pos.z + Math.sin(hn.phase + i * 0.6) * r;
        hn.entity.mesh.position.y = bioCore.position.y + Math.sin(state.time * 2 + i) * 3.2;
      });
    }

    function executePower(effectType, source = 'manual') {
      const powerIdx = state.powers.findIndex(p => p.effect === effectType && !p.used);
      if (powerIdx === -1 && effectType !== 'sweep') {
        logComms('System', `No ${effectType.toUpperCase()} organ available.`);
        return false;
      }
      if (effectType === 'sweep' && powerIdx === -1 && state.sweepCharge < 100) {
        logComms('System', 'Sweep charge insufficient.');
        return false;
      }
      if (powerIdx !== -1) state.powers[powerIdx].used = true;

      let successMsg = '';
      if (effectType === 'burst') {
        let hits = 0;
        state.entities.forEach(e => {
          if (!e.collected && e.pos.distanceTo(shipData.pos) < 96) {
            collectEntity(e, source);
            hits++;
          }
        });
        emitParticles(shipData.pos, 0xffd35e, 55);
        successMsg = `Burst harvested ${hits} organisms.`;
      } else if (effectType === 'magnet') {
        state.effects.magnetUntil = state.time + 7;
        successMsg = 'Magnetic metabolism amplified.';
      } else if (effectType === 'sweep') {
        state.entities.forEach(e => { if (!e.collected) collectEntity(e, source); });
        state.sweepCharge = 0;
        successMsg = 'Arena sweep executed.';
      } else if (effectType === 'freeze') {
        state.effects.freezeUntil = state.time + 5.5;
        successMsg = 'Cryostasis web deployed.';
      } else if (effectType === 'halo') {
        state.effects.haloUntil = state.time + 9;
        successMsg = 'Predation halo expanded.';
      } else if (effectType === 'splice') {
        state.effects.spliceUntil = state.time + 10;
        for (let i = 0; i < 4; i++) {
          const base = pick(state.speciesCatalog);
          const mutant = mutateSpecies(base);
          state.speciesCatalog.push(mutant);
          createSpeciesEntity(mutant, true);
        }
        addHarvestedPart(pick(['tube','bone','muscle','spiral','limb','spine']), 0x91ff6b, 'splice');
        successMsg = 'Genome splice pulse triggered rapid evolution.';
      }

      logComms('Operator', successMsg, true);
      speak(successMsg);
      renderPowers();
      renderSpecies();
      updateUI();
      return true;
    }

    function parseCommand(raw, source = 'manual') {
      const lower = raw.toLowerCase();
      if (lower.includes('burst')) return executePower('burst', source);
      if (lower.includes('magnet') || lower.includes('pull')) return executePower('magnet', source);
      if (lower.includes('sweep') || lower.includes('collect all')) return executePower('sweep', source);
      if (lower.includes('freeze') || lower.includes('stop')) return executePower('freeze', source);
      if (lower.includes('halo') || lower.includes('expand')) return executePower('halo', source);
      if (lower.includes('splice') || lower.includes('evolve') || lower.includes('mutate')) return executePower('splice', source);
      logComms('System', 'Command not recognized. Try splice, burst, magnet, freeze, halo, or sweep.');
      return false;
    }

    function updateUI() {
      const loose = state.entities.reduce((acc, e) => acc + (e.collected ? 0 : 1), 0);
      document.getElementById('ui-collected').textContent = String(state.collected);
      document.getElementById('ui-loose').textContent = String(loose);
      document.getElementById('ui-mass').textContent = String(state.growthMass);
      document.getElementById('ui-gene').textContent = String(state.geneLevel);
      document.getElementById('ui-sweep').textContent = `${Math.floor(state.sweepCharge)}%`;
    }

    function renderPowers() {
      const list = document.getElementById('powers-list');
      list.innerHTML = '';
      const activePowers = state.powers.filter(p => !p.used).slice(0, 12);
      if (!activePowers.length) {
        list.innerHTML = '<div class="text-[10px] text-slate-500 text-center mt-10">Awaiting harvested organs...</div>';
        return;
      }
      activePowers.forEach(power => {
        const el = document.createElement('div');
        el.className = `card-item p-2 rounded-lg border bg-slate-800/80 text-xs ${power.css}`;
        el.innerHTML = `
          <div class="flex justify-between font-bold">
            <span>${power.name}</span>
            <span class="font-mono text-[9px] text-slate-400">READY</span>
          </div>
          <div class="text-[10px] text-slate-400 mt-1">${power.desc}</div>
        `;
        el.onclick = () => executePower(power.effect, 'manual');
        list.appendChild(el);
      });
    }

    function renderSpecies() {
      const lab = document.getElementById('species-list');
      lab.innerHTML = '';
      const lines = [...state.speciesCatalog]
        .sort((a, b) => (b.generation + b.births * 0.1) - (a.generation + a.births * 0.1))
        .slice(0, 14);

      if (!lines.length) {
        lab.innerHTML = '<div class="text-[10px] text-slate-500 text-center mt-10">Species data pending...</div>';
        return;
      }

      lines.forEach(sp => {
        const live = state.entities.filter(e => !e.collected && e.speciesId === sp.id).length;
        const row = document.createElement('div');
        row.className = 'p-2 rounded-lg border border-slate-700 bg-slate-900/70';
        row.innerHTML = `
          <div class="flex justify-between items-center">
            <span class="font-semibold" style="color:#${sp.color.toString(16).padStart(6,'0')}">${sp.name}</span>
            <span class="text-[10px] text-slate-400">GEN ${sp.generation}</span>
          </div>
          <div class="mt-1 text-[10px] text-slate-400">${sp.body} • live ${live} • births ${sp.births} • harvested ${sp.harvested}</div>
          <div class="text-[10px] text-slate-500">spd ${sp.speed.toFixed(1)} • fert ${sp.fertility.toFixed(2)} • agg ${sp.aggression.toFixed(2)}</div>
        `;
        lab.appendChild(row);
      });
    }

    function initField() {
      createShipAssembly();
      state.speciesCatalog = SPECIES_SEEDS.map(seededSpecies);
      state.speciesCatalog.forEach(sp => {
        const n = 6 + Math.floor(rand(0, 5));
        for (let i = 0; i < n; i++) createSpeciesEntity(sp);
      });
      addHarvestedPart('tube', 0x33ffbb, 'magnet');
      addHarvestedPart('bone', 0xf6e7d2, 'halo');
      logComms('System', 'Evolution forge initialized. Species seeded across arena.');
      renderPowers();
      renderSpecies();
      updateUI();
    }

    if (SpeechRecognition) {
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = false;
      recognition.onstart = () => {
        state.isListening = true;
        document.getElementById('mic-btn').classList.add('recording-pulse');
        setStatus('LISTENING...', 'text-rose');
      };
      recognition.onend = () => {
        state.isListening = false;
        document.getElementById('mic-btn').classList.remove('recording-pulse');
        setStatus('STATUS: EVOLVING', 'text-mint');
      };
      recognition.onerror = event => {
        logComms('System', `Voice interface error: ${event.error}`);
        setStatus('VOICE ERROR', 'text-rose');
      };
      recognition.onresult = event => {
        const transcript = event.results[event.results.length - 1][0].transcript.trim();
        logComms('Operator (Voice)', `"${transcript}"`);
        parseCommand(transcript, 'voice');
      };
    }

    document.getElementById('mic-btn').addEventListener('click', () => {
      if (!recognition) return logComms('System', 'Speech API not supported in this browser.');
      if (state.isListening) recognition.stop();
      else recognition.start();
    });

    document.getElementById('tts-btn').addEventListener('click', e => {
      state.ttsEnabled = !state.ttsEnabled;
      const btn = e.currentTarget;
      const knob = btn.children[0];
      if (state.ttsEnabled) {
        btn.classList.replace('bg-slate-600', 'bg-indigo-600');
        knob.classList.replace('right-5', 'right-1');
        speak('Audio interface active.');
      } else {
        btn.classList.replace('bg-indigo-600', 'bg-slate-600');
        knob.classList.replace('right-1', 'right-5');
        if (synth) synth.cancel();
      }
    });

    document.getElementById('chat-input').addEventListener('keypress', e => {
      if (e.key !== 'Enter') return;
      const val = e.target.value.trim();
      if (!val) return;
      logComms('Operator (Text)', val);
      e.target.value = '';
      parseCommand(val, 'text');
    });

    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.1);
      state.time += dt;

      evolveWorld(dt);
      autopilot(dt);
      updateHalo(dt);
      updateParticles(dt);

      if (state.entities.filter(e => !e.collected).length < 24 && state.time >= state.nextSpawnAt) {
        createSpeciesEntity(pick(state.speciesCatalog));
        state.nextSpawnAt = state.time + 0.3;
      }

      composer.render();
      updateUI();
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    initField();
    speak('Bio forge online. Evolutionary harvest engaged.');
    animate();
  </script>
</body>
</html>
