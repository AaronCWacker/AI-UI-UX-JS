<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Enhanced AI Traffic Evolution Simulator</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #000; }
    #ui {
      position: absolute; top: 10px; left: 10px; color: white;
      background-color: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px;
      z-index: 100; font-size: 14px; min-width: 220px;
    }
    #controls {
      position: absolute; top: 10px; right: 10px; color: white;
      background-color: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px; z-index: 100;
    }
    button {
      background-color: #4CAF50; border: none; color: white;
      padding: 8px 16px; margin: 5px; cursor: pointer;
      border-radius: 4px; font-size: 12px;
    }
    button:hover { background-color: #45a049; }
    #stats {
      position: absolute; bottom: 10px; left: 10px; color: white;
      background-color: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px;
      z-index: 100; font-size: 12px; min-width: 200px;
    }
    #flockingStats {
      position: absolute; bottom: 10px; right: 10px; color: white;
      background-color: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px;
      z-index: 100; font-size: 12px; min-width: 180px;
    }
    #trafficStats {
      position: absolute; top: 50%; right: 10px; transform: translateY(-50%);
      color: white; background-color: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px;
      z-index: 100; font-size: 12px; min-width: 180px;
    }
    .highlight { color: #ffcc00; font-weight: bold; }
    .success { color: #00ff00; font-weight: bold; }
    .flocking { color: #00aaff; }
    .solo { color: #ff8800; }
    .leader { color: #ff00ff; font-weight: bold; }
    .convoy { color: #00ffff; }
    .parked { color: #88ff88; }
    .species-0 { color: #ff6b6b; }
    .species-1 { color: #4ecdc4; }
    .species-2 { color: #45b7d1; }
    .species-3 { color: #96ceb4; }
    .species-4 { color: #ffd93d; }
    .progress-bar {
      width: 100%; height: 10px; background-color: #333;
      border-radius: 5px; overflow: hidden; margin: 5px 0;
    }
    .progress-fill {
      height: 100%; background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1);
      transition: width 0.3s ease;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div class="highlight">AI Traffic Evolution Simulator</div>
    <div>Epoch: <span id="epoch">1</span></div>
    <div>Time: <span id="epochTime">60</span>s</div>
    <div class="progress-bar"><div class="progress-fill" id="timeProgress"></div></div>
    <div>Population: <span id="population">100</span></div>
    <div>Species: <span id="speciesCount">1</span></div>
    <div>Best Fitness: <span id="bestFitness">0</span></div>
    <div>Traffic IQ: <span id="trafficIQ">50</span></div>
    <div>Road Mastery: <span id="roadMastery">0</span>%</div>
    <div style="margin-top:8px;">Brain: <span id="brainLabel" class="highlight">V2 (GRU)</span></div>
  </div>

  <div id="controls">
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
    <button id="speedBtn">Speed: 1x</button>
    <button id="viewBtn">View: Overview</button>
    <button id="flockBtn">Networks: ON</button>
    <button id="trafficBtn">Traffic Rules: ON</button>
    <!-- ✅ minimal add: swap brains (resets sim to keep features + avoid incompatible genomes) -->
    <button id="brainBtn">Brain: V2</button>
  </div>

  <div id="stats">
    <div><span class="highlight">Top Performers:</span></div>
    <div id="topPerformers"></div>
    <div style="margin-top: 10px;"><span class="highlight">Generation Stats:</span></div>
    <div>Crashes: <span id="crashCount">0</span></div>
    <div>Total Distance: <span id="totalDistance">0</span></div>
    <div>Parking Visits: <span id="parkingEvents">0</span></div>
    <div>Lane Violations: <span id="laneViolations">0</span></div>
    <div>Convoy Length: <span id="convoyLength">0</span></div>
  </div>

  <div id="flockingStats">
    <div><span class="highlight">Convoy Behavior:</span></div>
    <div><span class="leader">Leaders:</span> <span id="leaderCount">0</span></div>
    <div><span class="convoy">In Convoy:</span> <span id="convoyCount">0</span></div>
    <div><span class="parked">Parked:</span> <span id="parkedCount">0</span></div>
    <div><span class="solo">Solo:</span> <span id="soloCount">0</span></div>
    <div>Largest Convoy: <span id="largestConvoy">0</span></div>
    <div>Formation Quality: <span id="formationQuality">0</span>%</div>
    <div>Parking Efficiency: <span id="parkingEfficiency">0</span>%</div>
  </div>

  <div id="trafficStats">
    <div><span class="highlight">Traffic Intelligence:</span></div>
    <div>Lane Discipline: <span id="laneDiscipline">0</span>%</div>
    <div>Following Distance: <span id="followingDistance">0</span>m</div>
    <div>Road Adherence: <span id="roadAdherence">0</span>%</div>
    <div>Turn Signals: <span id="turnSignals">0</span>%</div>
    <div style="margin-top: 10px;"><span class="highlight">Parking:</span></div>
    <div>Spots Occupied: <span id="spotsOccupied">0</span></div>
    <div>Parking Success: <span id="parkingSuccess">0</span>%</div>
    <div>Queue Efficiency: <span id="queueEfficiency">0</span>%</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Global variables
    let scene, camera, renderer, clock;
    let world = {
      roads: [],
      intersections: [],
      buildings: [], // { mesh, parkingLot, visitorCount, barGraphMesh, height }
      parkingLots: [], // { center, spots, queue, approachLanes, exitLanes, accessPoints, building }
      flockLines: []
    };

    // Enhanced evolution system
    let epoch = 1;
    let epochTime = 60;
    let timeLeft = 60;
    let population = [];
    let species = [];
    let populationSize = 100;
    let bestFitness = 0;
    let crashCount = 0;
    let paused = false;
    let speedMultiplier = 1;
    let cameraMode = 'overview'; // 'overview', 'follow_best', 'follow_convoy'
    let showFlockLines = true;
    let trafficRules = true;
    let parkingEvents = 0;
    let laneViolations = 0;

    // ✅ Brain swap state (minimal integration)
    let AI_MODE = 'v2'; // 'v1' or 'v2'

    // Traffic and road parameters
    const ROAD_WIDTH_UNIT = 6;
    const ROAD_SPACING = 150;
    const FOLLOW_DISTANCE = 8;
    const CONVOY_MAX_DISTANCE = 12;
    const PARKING_SPOT_SIZE = { width: 4, length: 8 };
    const GRASS_THRESHOLD = 0.15;

    // Manual control state for "Follow Best"
    let manuallyControlledCar = null;
    const manualControls = { W: false, A: false, S: false, D: false };

    // -------------------------------
    // TrafficAI V1 (your original)
    // -------------------------------
    class TrafficAI_v1 {
      constructor() {
        this.inputSize = 28;
        this.hiddenLayers = [36, 28, 20];
        this.outputSize = 10;
        this.memorySize = 8;

        this.weights = [];
        this.biases = [];
        this.memory = new Array(this.memorySize).fill(0);
        this.memoryPointer = 0;

        let prevSize = this.inputSize + this.memorySize;
        for (let i = 0; i < this.hiddenLayers.length; i++) {
          this.weights.push(this.randomMatrix(prevSize, this.hiddenLayers[i]));
          this.biases.push(this.randomArray(this.hiddenLayers[i]));
          prevSize = this.hiddenLayers[i];
        }
        this.weights.push(this.randomMatrix(prevSize, this.outputSize));
        this.biases.push(this.randomArray(this.outputSize));

        this.trafficTraits = {
          laneKeeping: Math.random(),
          followingBehavior: Math.random(),
          parkingSkill: Math.random(),
          convoyDiscipline: Math.random(),
          roadPriority: Math.random()
        };
      }

      randomMatrix(rows, cols) {
        let matrix = [];
        for (let i = 0; i < rows; i++) {
          matrix[i] = [];
          for (let j = 0; j < cols; j++) matrix[i][j] = (Math.random() - 0.5) * 2;
        }
        return matrix;
      }
      randomArray(size) { return Array(size).fill().map(() => (Math.random() - 0.5) * 2); }

      activate(inputs) {
        let currentInput = [...inputs, ...this.memory];
        for (let layer = 0; layer < this.hiddenLayers.length; layer++) {
          currentInput = this.forwardLayer(currentInput, this.weights[layer], this.biases[layer]);
        }
        const outputs = this.forwardLayer(
          currentInput,
          this.weights[this.weights.length - 1],
          this.biases[this.biases.length - 1]
        );
        this.updateMemory(inputs, outputs);
        return outputs;
      }

      forwardLayer(inputs, weights, biases) {
        const outputs = new Array(weights[0].length).fill(0);
        for (let i = 0; i < outputs.length; i++) {
          for (let j = 0; j < inputs.length; j++) outputs[i] += inputs[j] * weights[j][i];
          outputs[i] += biases[i];
          outputs[i] = this.sigmoid(outputs[i]);
        }
        return outputs;
      }

      sigmoid(x) {
        const clampedX = Math.max(-10, Math.min(10, x));
        return 1 / (1 + Math.exp(-clampedX));
      }

      updateMemory(inputs, outputs) {
        const roadInfo = inputs.slice(20, 24).reduce((a, b) => a + b, 0) / 4;
        this.memory[this.memoryPointer] = roadInfo;
        this.memoryPointer = (this.memoryPointer + 1) % this.memorySize;
      }

      mutate(rate = 0.1) {
        this.weights.forEach(w => this.mutateMatrix(w, rate));
        this.biases.forEach(b => this.mutateArray(b, rate));
        Object.keys(this.trafficTraits).forEach(trait => {
          if (Math.random() < rate) {
            this.trafficTraits[trait] += (Math.random() - 0.5) * 0.2;
            this.trafficTraits[trait] = Math.max(0, Math.min(1, this.trafficTraits[trait]));
          }
        });
      }

      mutateMatrix(matrix, rate) {
        for (let i = 0; i < matrix.length; i++) {
          for (let j = 0; j < matrix[i].length; j++) {
            if (Math.random() < rate) {
              matrix[i][j] += (Math.random() - 0.5) * 0.5;
              matrix[i][j] = Math.max(-3, Math.min(3, matrix[i][j]));
            }
          }
        }
      }

      mutateArray(array, rate) {
        for (let i = 0; i < array.length; i++) {
          if (Math.random() < rate) {
            array[i] += (Math.random() - 0.5) * 0.5;
            array[i] = Math.max(-3, Math.min(3, array[i]));
          }
        }
      }

      copy() {
        const n = new TrafficAI_v1();
        n.weights = this.weights.map(m => m.map(row => [...row]));
        n.biases = this.biases.map(b => [...b]);
        n.memory = [...this.memory];
        n.memoryPointer = this.memoryPointer;
        n.trafficTraits = { ...this.trafficTraits };
        return n;
      }
    }

    // --------------------------------
    // TrafficAI V2 (GRU + residual MLP)
    // --------------------------------
    class TrafficAI_v2 {
      constructor() {
        this.inputSize = 28;
        this.stateSize = 18;
        this.hiddenSize = 36;
        this.outputSize = 10;

        this.state = new Array(this.stateSize).fill(0);
        this.actionEMA = new Array(this.outputSize).fill(0);
        this.emaAlpha = 0.35;

        this.trafficTraits = {
          laneKeeping: Math.random(),
          followingBehavior: Math.random(),
          parkingSkill: Math.random(),
          convoyDiscipline: Math.random(),
          roadPriority: Math.random()
        };

        this.Wz = this.xavierMatrix(this.inputSize, this.stateSize);
        this.Uz = this.xavierMatrix(this.stateSize, this.stateSize);
        this.bz = this.zeros(this.stateSize);

        this.Wr = this.xavierMatrix(this.inputSize, this.stateSize);
        this.Ur = this.xavierMatrix(this.stateSize, this.stateSize);
        this.br = this.zeros(this.stateSize);

        this.Wh = this.xavierMatrix(this.inputSize, this.stateSize);
        this.Uh = this.xavierMatrix(this.stateSize, this.stateSize);
        this.bh = this.zeros(this.stateSize);

        this.W1 = this.xavierMatrix(this.stateSize, this.hiddenSize);
        this.b1 = this.zeros(this.hiddenSize);

        this.W2 = this.xavierMatrix(this.hiddenSize, this.hiddenSize);
        this.b2 = this.zeros(this.hiddenSize);

        this.W_throttle = this.xavierMatrix(this.hiddenSize, 1);
        this.b_throttle = [0];

        this.W_steer = this.xavierMatrix(this.hiddenSize, 1);
        this.b_steer = [0];

        this.W_lane = this.xavierMatrix(this.hiddenSize, 3);
        this.b_lane = this.zeros(3);

        this.W_other = this.xavierMatrix(this.hiddenSize, 5);
        this.b_other = this.zeros(5);
      }

      activate(inputs) {
        const x = this.normalizeInputs(inputs);

        this.state = this.gruStep(x, this.state);

        const h1 = this.tanhVec(this.addVec(this.matVec(this.W1, this.state), this.b1));
        const h2pre = this.addVec(this.matVec(this.W2, h1), this.b2);
        const h2 = this.tanhVec(this.addVec(h2pre, h1)); // residual

        const throttleLogit = this.dotCol(this.W_throttle, h2, 0) + this.b_throttle[0];
        const steerLogit = this.dotCol(this.W_steer, h2, 0) + this.b_steer[0];

        const laneLogits = this.addVec(this.matVec(this.W_lane, h2), this.b_lane);
        const otherLogits = this.addVec(this.matVec(this.W_other, h2), this.b_other);

        const t = this.sigmoid(throttleLogit);
        const accel = this.clamp01((t * 1.15) - 0.05);
        const brake = this.clamp01(((1 - t) * 1.15) - 0.05);

        const s = this.tanh(steerLogit);
        const steerLeft = this.clamp01(Math.max(0, -s));
        const steerRight = this.clamp01(Math.max(0, s));

        const laneP = this.softmax(laneLogits);
        const laneChangeIntent = this.clamp01(laneP[0] * 0.15 + laneP[1] * 0.50 + laneP[2] * 0.85);

        const convoy = this.sigmoid(otherLogits[0]);
        const park = this.sigmoid(otherLogits[1]);
        const sigL = this.sigmoid(otherLogits[2]);
        const sigR = this.sigmoid(otherLogits[3]);
        const stop = this.sigmoid(otherLogits[4]);

        let out = [accel, brake, steerLeft, steerRight, laneChangeIntent, convoy, park, sigL, sigR, stop];

        for (let i = 0; i < out.length; i++) {
          this.actionEMA[i] = this.actionEMA[i] * this.emaAlpha + out[i] * (1 - this.emaAlpha);
          out[i] = this.actionEMA[i];
        }
        return out;
      }

      mutate(rate = 0.07) {
        const wRate = rate, bRate = rate;

        const mutateMat = (M, sigma) => {
          for (let i = 0; i < M.length; i++) for (let j = 0; j < M[i].length; j++) {
            if (Math.random() < wRate) {
              M[i][j] += this.randn() * sigma;
              M[i][j] = Math.max(-4, Math.min(4, M[i][j]));
            }
          }
        };
        const mutateArr = (A, sigma) => {
          for (let i = 0; i < A.length; i++) {
            if (Math.random() < bRate) {
              A[i] += this.randn() * sigma;
              A[i] = Math.max(-4, Math.min(4, A[i]));
            }
          }
        };

        mutateMat(this.Wz, 0.12); mutateMat(this.Uz, 0.08); mutateArr(this.bz, 0.06);
        mutateMat(this.Wr, 0.12); mutateMat(this.Ur, 0.08); mutateArr(this.br, 0.06);
        mutateMat(this.Wh, 0.12); mutateMat(this.Uh, 0.08); mutateArr(this.bh, 0.06);

        mutateMat(this.W1, 0.10); mutateArr(this.b1, 0.05);
        mutateMat(this.W2, 0.10); mutateArr(this.b2, 0.05);

        mutateMat(this.W_throttle, 0.08); mutateArr(this.b_throttle, 0.04);
        mutateMat(this.W_steer, 0.08); mutateArr(this.b_steer, 0.04);
        mutateMat(this.W_lane, 0.08); mutateArr(this.b_lane, 0.04);
        mutateMat(this.W_other, 0.08); mutateArr(this.b_other, 0.04);

        Object.keys(this.trafficTraits).forEach(trait => {
          if (Math.random() < rate) {
            this.trafficTraits[trait] = this.clamp01(this.trafficTraits[trait] + (Math.random() - 0.5) * 0.18);
          }
        });

        if (Math.random() < 0.02) {
          this.state.fill(0);
          this.actionEMA.fill(0);
        }
      }

      copy() {
        const n = new TrafficAI_v2();
        const cloneM = (M) => M.map(row => row.slice());
        const cloneA = (A) => A.slice();

        n.Wz = cloneM(this.Wz); n.Uz = cloneM(this.Uz); n.bz = cloneA(this.bz);
        n.Wr = cloneM(this.Wr); n.Ur = cloneM(this.Ur); n.br = cloneA(this.br);
        n.Wh = cloneM(this.Wh); n.Uh = cloneM(this.Uh); n.bh = cloneA(this.bh);

        n.W1 = cloneM(this.W1); n.b1 = cloneA(this.b1);
        n.W2 = cloneM(this.W2); n.b2 = cloneA(this.b2);

        n.W_throttle = cloneM(this.W_throttle); n.b_throttle = cloneA(this.b_throttle);
        n.W_steer = cloneM(this.W_steer); n.b_steer = cloneA(this.b_steer);
        n.W_lane = cloneM(this.W_lane); n.b_lane = cloneA(this.b_lane);
        n.W_other = cloneM(this.W_other); n.b_other = cloneA(this.b_other);

        n.trafficTraits = { ...this.trafficTraits };

        // fresh life state
        n.state = new Array(n.stateSize).fill(0);
        n.actionEMA = new Array(n.outputSize).fill(0);
        return n;
      }

      gruStep(x, h) {
        const z = this.sigmoidVec(this.addVec(this.addVec(this.matVec(this.Wz, x), this.matVec(this.Uz, h)), this.bz));
        const r = this.sigmoidVec(this.addVec(this.addVec(this.matVec(this.Wr, x), this.matVec(this.Ur, h)), this.br));

        const rh = new Array(h.length);
        for (let i = 0; i < h.length; i++) rh[i] = r[i] * h[i];

        const hHat = this.tanhVec(this.addVec(this.addVec(this.matVec(this.Wh, x), this.matVec(this.Uh, rh)), this.bh));

        const hNew = new Array(h.length);
        for (let i = 0; i < h.length; i++) hNew[i] = (1 - z[i]) * h[i] + z[i] * hHat[i];
        return hNew;
      }

      xavierMatrix(rows, cols) {
        const scale = Math.sqrt(2 / (rows + cols));
        const M = new Array(rows);
        for (let i = 0; i < rows; i++) {
          M[i] = new Array(cols);
          for (let j = 0; j < cols; j++) M[i][j] = (Math.random() * 2 - 1) * scale;
        }
        return M;
      }
      zeros(n) { return new Array(n).fill(0); }

      matVec(W, v) {
        const cols = W[0].length;
        const out = new Array(cols).fill(0);
        for (let i = 0; i < W.length; i++) {
          const wi = W[i];
          const vi = v[i];
          for (let j = 0; j < cols; j++) out[j] += vi * wi[j];
        }
        return out;
      }
      dotCol(W, v, col) { let s = 0; for (let i = 0; i < W.length; i++) s += v[i] * W[i][col]; return s; }
      addVec(a, b) { const o = new Array(a.length); for (let i = 0; i < a.length; i++) o[i] = a[i] + b[i]; return o; }

      sigmoid(x) { const cx = Math.max(-10, Math.min(10, x)); return 1 / (1 + Math.exp(-cx)); }
      tanh(x) {
        const cx = Math.max(-10, Math.min(10, x));
        const e2 = Math.exp(2 * cx);
        return (e2 - 1) / (e2 + 1);
      }
      sigmoidVec(v) { return v.map(x => this.sigmoid(x)); }
      tanhVec(v) { return v.map(x => this.tanh(x)); }

      softmax(logits) {
        const m = Math.max(...logits);
        const exps = logits.map(x => Math.exp(Math.max(-10, Math.min(10, x - m))));
        const sum = exps.reduce((a, b) => a + b, 0) || 1;
        return exps.map(e => e / sum);
      }

      clamp01(x) { return Math.max(0, Math.min(1, x)); }

      normalizeInputs(inputs) {
        const x = new Array(inputs.length);
        for (let i = 0; i < inputs.length; i++) {
          const v = inputs[i];
          const vv = (v * 2 - 1);
          x[i] = Math.max(-1.25, Math.min(1.25, vv));
        }
        return x;
      }

      randn() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
      }
    }

    // ✅ Factory used by TrafficCar to pick the active brain with minimal changes
    function createBrain() {
      return (AI_MODE === 'v2') ? new TrafficAI_v2() : new TrafficAI_v1();
    }
    function updateBrainUI() {
      const brainLabel = document.getElementById('brainLabel');
      const brainBtn = document.getElementById('brainBtn');
      if (AI_MODE === 'v2') {
        brainLabel.textContent = 'V2 (GRU)';
        brainBtn.textContent = 'Brain: V2';
      } else {
        brainLabel.textContent = 'V1 (MLP+Memory)';
        brainBtn.textContent = 'Brain: V1';
      }
    }

    // Enhanced AI Car with traffic behavior
    class TrafficCar {
      constructor(x = 0, z = 0) {
        this.brain = createBrain(); // ✅ swapped brain creation, everything else unchanged
        this.mesh = this.createCarMesh();
        this.mesh.position.set(x, 1, z);

        this.velocity = new THREE.Vector3();
        this.acceleration = new THREE.Vector3();
        this.maxSpeed = 20;
        this.minSpeed = 2;
        this.currentLane = null;
        this.targetLane = null;
        this.lanePosition = 0;

        this.lastRoadPositionScore = 0;
        this.isReturningToRoad = false;
        this.turnAngleGoal = 0;
        this.turnProgress = 0;
        this.initialOrientationY = 0;

        this.flockId = -1;
        this.convoyPosition = -1;
        this.convoyLeader = null;
        this.convoyFollowers = [];
        this.followTarget = null;
        this.role = 'driver';

        this.isParked = false;
        this.parkingSpot = null;
        this.targetParkingLot = null;
        this.parkingQueuePosition = -1;
        this.isParkingApproach = false;
        this.isInApproachLane = false;
        this.isInExitLane = false;
        this.approachTargetPosition = null;
        this.exitTargetPosition = null;
        this.selectedApproachLaneIndex = -1;
        this.selectedExitLaneIndex = -1;
        this.parkingAttempts = 0;
        this.maxParkingAttempts = 3;
        this.departureTime = 0;
        this.isExitingParking = false;

        this.turnSignal = 'none';
        this.laneDiscipline = 0;
        this.followingDistance = FOLLOW_DISTANCE;

        this.fitness = 0;
        this.roadTime = 0;
        this.convoyTime = 0;
        this.parkingScore = 0;
        this.trafficViolations = 0;
        this.distanceTraveled = 0;
        this.crashed = false;
        this.timeAlive = epochTime * 0.8 + Math.random() * epochTime * 0.4;

        this.sensors = Array(16).fill(0);
        this.roadSensors = Array(8).fill(0);
        this.trafficSensors = Array(4).fill(0);
        this.sensorRays = [];
        this.flockLines = [];
        this.neighbors = [];

        this.lastPosition = new THREE.Vector3(x, 1, z);
        this.createSensorRays();
        this.createFlockVisualization();
        this.initializeMovement();

        this.manualAcceleration = 0;
        this.manualBraking = 0;
        this.manualSteer = 0;
      }

      createCarMesh() {
        const group = new THREE.Group();

        const bodyGeometry = new THREE.BoxGeometry(1.5, 0.8, 3.5);
        this.bodyMaterial = new THREE.MeshLambertMaterial({
          color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6)
        });
        const body = new THREE.Mesh(bodyGeometry, this.bodyMaterial);
        body.position.y = 0.4;
        body.castShadow = true;
        group.add(body);

        const signalGeometry = new THREE.SphereGeometry(0.15, 6, 4);
        this.leftSignal = new THREE.Mesh(signalGeometry,
          new THREE.MeshLambertMaterial({ color: 0xff8800, transparent: true, opacity: 0.5 }));
        this.leftSignal.position.set(-0.8, 0.8, 1.2);
        group.add(this.leftSignal);

        this.rightSignal = new THREE.Mesh(signalGeometry,
          new THREE.MeshLambertMaterial({ color: 0xff8800, transparent: true, opacity: 0.5 }));
        this.rightSignal.position.set(0.8, 0.8, 1.2);
        group.add(this.rightSignal);

        const indicatorGeometry = new THREE.ConeGeometry(0.2, 0.8, 6);
        this.roleIndicator = new THREE.Mesh(indicatorGeometry,
          new THREE.MeshLambertMaterial({ color: 0xffffff }));
        this.roleIndicator.position.set(0, 1.5, 0);
        group.add(this.roleIndicator);

        const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
        const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });

        this.wheels = [];
        const wheelPositions = [
          [-0.7, 0, 1.4], [0.7, 0, 1.4],
          [-0.7, 0, -1.4], [0.7, 0, -1.4]
        ];

        wheelPositions.forEach((pos) => {
          const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
          wheel.position.set(...pos);
          wheel.rotation.z = Math.PI / 2;
          this.wheels.push(wheel);
          group.add(wheel);
        });

        return group;
      }

      createSensorRays() {
        const sensorMaterial = new THREE.LineBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.2
        });

        for (let i = 0; i < 16; i++) {
          const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 10)
          ]);
          const ray = new THREE.Line(geometry, sensorMaterial);
          this.sensorRays.push(ray);
          this.mesh.add(ray);
        }
      }

      createFlockVisualization() {
        const flockMaterial = new THREE.LineBasicMaterial({
          color: 0x00ff00,
          transparent: true,
          opacity: 0.6,
          linewidth: 2
        });

        for (let i = 0; i < 10; i++) {
          const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 2, 0),
            new THREE.Vector3(0, 2, 0)
          ]);
          const line = new THREE.Line(geometry, flockMaterial);
          this.flockLines.push(line);
          if (showFlockLines) scene.add(line);
        }
      }

      initializeMovement() {
        const nearestRoad = this.findNearestRoad();
        if (nearestRoad) {
          this.currentLane = nearestRoad.lane;
          this.mesh.rotation.y = nearestRoad.direction;
          this.velocity.set(Math.sin(nearestRoad.direction) * 8, 0, Math.cos(nearestRoad.direction) * 8);
        } else {
          this.mesh.rotation.y = Math.random() * Math.PI * 2;
          this.velocity.set(Math.sin(this.mesh.rotation.y) * 6, 0, Math.cos(this.mesh.rotation.y) * 6);
        }
      }

      findNearestRoad() {
        const pos = this.mesh.position;
        let nearestRoadInfo = null;
        let minDistance = Infinity;

        world.roads.forEach(road => {
          let distanceToRoadCenterLine;
          let roadCenterCoord;
          let carRelevantCoord;
          let roadWidth = road.width;

          if (road.direction === 'horizontal') {
            roadCenterCoord = road.z;
            carRelevantCoord = pos.z;
            if (pos.x < road.start || pos.x > road.end) return;
          } else {
            roadCenterCoord = road.x;
            carRelevantCoord = pos.x;
            if (pos.z < road.start || pos.z > road.end) return;
          }

          distanceToRoadCenterLine = Math.abs(carRelevantCoord - roadCenterCoord);

          if (distanceToRoadCenterLine < roadWidth / 2 + 5) {
            if (distanceToRoadCenterLine < minDistance) {
              minDistance = distanceToRoadCenterLine;
              nearestRoadInfo = {
                lane: `${road.type}_${road.direction}`,
                center: roadCenterCoord,
                direction: road.orientationAngle,
                width: roadWidth,
                roadObject: road
              };
            }
          }
        });
        return nearestRoadInfo;
      }

      getRoadPositionScore() {
        const pos = this.mesh.position;
        let maxRoadScore = 0;

        world.roads.forEach(road => {
          let distanceToRoadCenterLine;
          let carRelevantCoord;

          if (road.direction === 'horizontal') {
            if (pos.x < road.start || pos.x > road.end) return;
            carRelevantCoord = pos.z;
            distanceToRoadCenterLine = Math.abs(carRelevantCoord - road.z);
          } else {
            if (pos.z < road.start || pos.z > road.end) return;
            carRelevantCoord = pos.x;
            distanceToRoadCenterLine = Math.abs(carRelevantCoord - road.x);
          }

          if (distanceToRoadCenterLine <= road.width / 2) {
            maxRoadScore = Math.max(maxRoadScore, 1 - (distanceToRoadCenterLine / (road.width / 2)));
          }
        });
        return maxRoadScore;
      }

      updateSensors() {
        const maxDistance = 10;
        const raycaster = new THREE.Raycaster();

        for (let i = 0; i < 16; i++) {
          const angle = (i * Math.PI * 2) / 16;
          const direction = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
          direction.applyQuaternion(this.mesh.quaternion);

          raycaster.set(this.mesh.position, direction);
          const intersects = raycaster.intersectObjects(this.getObstacles(), true);

          if (intersects.length > 0 && intersects[0].distance <= maxDistance) {
            this.sensors[i] = 1 - (intersects[0].distance / maxDistance);
          } else {
            this.sensors[i] = 0;
          }

          const endDistance = intersects.length > 0 ? Math.min(intersects[0].distance, maxDistance) : maxDistance;
          const rayEnd = direction.clone().multiplyScalar(endDistance);
          this.sensorRays[i].geometry.setFromPoints([new THREE.Vector3(0, 0, 0), rayEnd]);
        }

        this.updateRoadSensors();
        this.updateTrafficSensors();
      }

      updateRoadSensors() {
        this.roadSensors[0] = this.getRoadPositionScore();
        this.roadSensors[1] = this.getLanePosition();
        this.roadSensors[2] = this.getRoadDirectionAlignment();
        this.roadSensors[3] = this.getDistanceToIntersection();
        this.roadSensors[4] = this.getNearestParkingLotProximity();
        this.roadSensors[5] = this.getParkingAvailability();
        this.roadSensors[6] = this.getTrafficDensity();
        this.roadSensors[7] = this.getOptimalSpeedFactor();
      }

      getLanePosition() {
        const roadInfo = this.findNearestRoad();
        if (!roadInfo || !roadInfo.roadObject) return 0.5;

        const pos = this.mesh.position;
        let laneOffset;
        if (roadInfo.roadObject.direction === 'horizontal') laneOffset = pos.z - roadInfo.center;
        else laneOffset = pos.x - roadInfo.center;

        let normalizedPosition = (laneOffset / (roadInfo.width / 2));
        return Math.max(0, Math.min(1, (normalizedPosition + 1) / 2));
      }

      getRoadDirectionAlignment() {
        const roadInfo = this.findNearestRoad();
        if (!roadInfo) return 0.5;

        const carDirectionVector = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);
        const roadDirectionVector = new THREE.Vector3(Math.sin(roadInfo.direction), 0, Math.cos(roadInfo.direction));
        const dotProduct = carDirectionVector.dot(roadDirectionVector);
        return (dotProduct + 1) / 2;
      }

      // Placeholder functions
      getDistanceToIntersection() { return Math.random(); }
      getNearestParkingLotProximity() {
        if (!this.targetParkingLot) return 0;
        const dist = this.mesh.position.distanceTo(this.targetParkingLot.center);
        return Math.max(0, 1 - dist / 100);
      }
      getParkingAvailability() {
        if (!this.targetParkingLot) return 0;
        const availableSpots = this.targetParkingLot.spots.filter(spot => !spot.occupied).length;
        return this.targetParkingLot.spots.length > 0 ? availableSpots / this.targetParkingLot.spots.length : 0;
      }
      getTrafficDensity() { return Math.random() * 0.5; }
      getOptimalSpeedFactor() { return 0.8 + Math.random() * 0.2; }

      updateTrafficSensors() {
        this.trafficSensors[0] = this.convoyPosition >= 0 ? 1 : 0;
        this.trafficSensors[1] = this.followTarget ? Math.min(this.mesh.position.distanceTo(this.followTarget.mesh.position) / 20, 1) : 1;
        this.trafficSensors[2] = this.convoyLeader ? Math.max(0, 1 - this.mesh.position.distanceTo(this.convoyLeader.mesh.position) / 50) : 0;
        this.trafficSensors[3] = (this.timeAlive < epochTime * 0.3 && !this.isParked) ? 1 : 0;
      }

      updateConvoyBehavior() {
        this.neighbors = [];
        population.forEach(other => {
          if (other !== this && !other.crashed && !other.isParked) {
            const distance = this.mesh.position.distanceTo(other.mesh.position);
            if (distance < 25) this.neighbors.push(other);
          }
        });
        this.updateRole();
        this.updateConvoyFormation();
      }

      updateRole() {
        const roadPosScore = this.getRoadPositionScore();
        if (this.isParked || this.isParkingApproach || this.isInApproachLane || this.isInExitLane) {
          this.role = 'parker';
        } else if (roadPosScore > 0.8 && this.neighbors.length > 1 && this.brain.trafficTraits.convoyDiscipline > 0.6) {
          this.role = 'leader';
        } else {
          this.role = 'driver';
        }

        if (this.role === 'leader') this.roleIndicator.material.color.setHex(0xff00ff);
        else if (this.role === 'parker') this.roleIndicator.material.color.setHex(0x00ff00);
        else this.roleIndicator.material.color.setHex(0xffffff);
      }

      updateConvoyFormation() {
        if (this.role === 'leader') {
          this.convoyFollowers = this.neighbors
            .filter(car => car.role === 'driver' && !car.convoyLeader && car.brain.trafficTraits.convoyDiscipline > 0.5)
            .sort((a, b) => this.mesh.position.distanceTo(a.mesh.position) - this.mesh.position.distanceTo(b.mesh.position))
            .slice(0, 5);
          this.convoyFollowers.forEach((follower, index) => {
            follower.convoyLeader = this;
            follower.convoyPosition = index + 1;
            follower.followTarget = index === 0 ? this : this.convoyFollowers[index - 1];
          });
        } else if (this.convoyLeader && (this.convoyLeader.crashed || !this.convoyLeader.convoyFollowers.includes(this))) {
          this.convoyLeader = null;
          this.followTarget = null;
          this.convoyPosition = -1;
        }
      }

      getEnhancedInputs() {
        return [...this.sensors, ...this.roadSensors, ...this.trafficSensors];
      }

      update(deltaTime) {
        if (this.crashed) return;

        if (this === manuallyControlledCar && cameraMode === 'follow_best') {
          this.applyManualControls(deltaTime);
          this.updateVisuals();
          this.checkCollisions();
          this.keepInBounds();
          this.lastPosition.copy(this.mesh.position);
          return;
        }

        if (this.isParked) {
          this.handleParkedBehavior(deltaTime);
          this.updateVisuals();
          return;
        }

        this.timeAlive -= deltaTime;
        if (this.timeAlive <= 0 && !this.isParkingApproach && this.parkingAttempts < this.maxParkingAttempts) {
          this.attemptParking();
        }

        this.updateSensors();
        this.updateConvoyBehavior();
        this.updateVisuals();

        const inputs = this.getEnhancedInputs();
        const outputs = this.brain.activate(inputs);

        this.applyTrafficMovement(outputs, deltaTime);
        this.updateFitness(deltaTime);

        this.lastPosition.copy(this.mesh.position);
        this.checkCollisions();
        this.keepInBounds();

        const currentRoadPosScore = this.getRoadPositionScore();
        if (currentRoadPosScore < GRASS_THRESHOLD && !this.isReturningToRoad && !this.isParkingApproach && !this.isInApproachLane && !this.isInExitLane) {
          this.isReturningToRoad = true;
          this.turnAngleGoal = Math.PI;
          this.turnProgress = 0;
          this.initialOrientationY = this.mesh.rotation.y;
        }
        this.lastRoadPositionScore = currentRoadPosScore;
      }

      applyManualControls(deltaTime) {
        const moveSpeed = 20.0;
        const turnSpeed = 1.5;

        if (manualControls.W) this.velocity.add(new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion).multiplyScalar(moveSpeed * deltaTime));
        if (manualControls.S) this.velocity.sub(new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion).multiplyScalar(moveSpeed * 0.7 * deltaTime));
        if (!manualControls.W && !manualControls.S) this.velocity.multiplyScalar(0.95);

        if (manualControls.A) this.mesh.rotation.y += turnSpeed * deltaTime;
        if (manualControls.D) this.mesh.rotation.y -= turnSpeed * deltaTime;

        const currentSpeed = this.velocity.length();
        if (currentSpeed > this.maxSpeed) this.velocity.normalize().multiplyScalar(this.maxSpeed);

        this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
        this.wheels.forEach(wheel => wheel.rotation.x += currentSpeed * deltaTime * 0.1);
      }

      handleParkedBehavior(deltaTime) {
        this.velocity.set(0, 0, 0);
        this.departureTime -= deltaTime;

        if (this.departureTime <= 0 && !this.isExitingParking) {
          this.isExitingParking = true;
          if (this.targetParkingLot && this.targetParkingLot.building) {
            this.targetParkingLot.building.visitorCount = Math.max(0, (this.targetParkingLot.building.visitorCount || 0) - 1);
          }
          this.turnAngleGoal = Math.PI;
          this.turnProgress = 0;
          this.initialOrientationY = this.mesh.rotation.y;
        }

        if (this.isExitingParking) {
          const turnSpeedForExit = Math.PI / 2;
          this.mesh.rotation.y += turnSpeedForExit * deltaTime;
          this.turnProgress += turnSpeedForExit * deltaTime;

          if (this.turnProgress >= this.turnAngleGoal) {
            this.mesh.rotation.y = this.initialOrientationY + Math.PI;
            this.isExitingParking = false;
            this.leaveParking();
          }
        }
      }

      applyTrafficMovement(outputs, deltaTime) {
        const [
          acceleration, braking, steerLeft, steerRight,
          laneChangeIntent, followConvoySignal, parkingManeuverSignal,
          turnSignalLeftOutput, turnSignalRightOutput, emergencyStopSignal
        ] = outputs;

        this.turnSignal = 'none';
        if (turnSignalLeftOutput > 0.7) this.turnSignal = 'left';
        if (turnSignalRightOutput > 0.7) this.turnSignal = 'right';
        this.leftSignal.material.opacity = this.turnSignal === 'left' ? (Math.sin(Date.now() * 0.01) * 0.4 + 0.6) : 0.3;
        this.rightSignal.material.opacity = this.turnSignal === 'right' ? (Math.sin(Date.now() * 0.01) * 0.4 + 0.6) : 0.3;

        if (this.isReturningToRoad) {
          const turnSpeedReturn = Math.PI / 1.5;
          this.mesh.rotation.y += turnSpeedReturn * deltaTime;
          this.turnProgress += turnSpeedReturn * deltaTime;
          this.velocity.copy(new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion).multiplyScalar(this.minSpeed * 0.8));
          if (this.turnProgress >= this.turnAngleGoal) {
            this.mesh.rotation.y = this.initialOrientationY + Math.PI;
            this.isReturningToRoad = false;
          }
          this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
          return;
        }

        if (emergencyStopSignal > 0.8) { this.velocity.multiplyScalar(0.7); return; }
        if (parkingManeuverSignal > 0.7 && !this.isParked && !this.isParkingApproach) { this.attemptParking(); return; }
        if (this.isParkingApproach || this.isInApproachLane || this.isInExitLane) { this.executeParkingLogic(deltaTime); return; }

        this.followRoad(deltaTime, laneChangeIntent);

        if (followConvoySignal > 0.6 && this.followTarget) this.followConvoyTarget(deltaTime);

        const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);
        if (acceleration > 0.3) this.velocity.add(forward.multiplyScalar(acceleration * 10 * deltaTime));
        if (braking > 0.5) this.velocity.multiplyScalar(1 - braking * deltaTime * 4);

        const steering = (steerRight - steerLeft) * 0.10 * deltaTime * (this.velocity.length() / this.maxSpeed + 0.2);
        this.mesh.rotation.y += steering;

        const currentSpeed = this.velocity.length();
        if (currentSpeed > this.maxSpeed) this.velocity.normalize().multiplyScalar(this.maxSpeed);
        else if (currentSpeed < this.minSpeed && currentSpeed > 0.1) this.velocity.normalize().multiplyScalar(this.minSpeed);
        else if (currentSpeed < 0.1) this.velocity.set(0, 0, 0);
        this.velocity.multiplyScalar(0.99);

        this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
        this.wheels.forEach(wheel => wheel.rotation.x += currentSpeed * deltaTime * 0.1);
      }

      followRoad(deltaTime, laneChangeIntent) {
        const roadInfo = this.findNearestRoad();
        if (!roadInfo || !roadInfo.roadObject) {
          this.fitness -= 2 * deltaTime;
          return;
        }

        const road = roadInfo.roadObject;
        const targetRoadAngle = road.orientationAngle;
        let carAngle = this.mesh.rotation.y;

        while (carAngle - targetRoadAngle > Math.PI) carAngle -= 2 * Math.PI;
        while (targetRoadAngle - carAngle > Math.PI) carAngle += 2 * Math.PI;

        let angleDiff = targetRoadAngle - carAngle;
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        this.mesh.rotation.y += angleDiff * 0.1 * this.brain.trafficTraits.laneKeeping;

        const numLanes = Math.max(1, Math.floor(road.width / ROAD_WIDTH_UNIT));
        let targetLaneIndex = Math.floor(numLanes / 2);

        if (numLanes > 1) {
          if (laneChangeIntent < 0.33) targetLaneIndex = Math.max(0, targetLaneIndex - 1);
          else if (laneChangeIntent > 0.66) targetLaneIndex = Math.min(numLanes - 1, targetLaneIndex + 1);
        }

        let targetLaneCenterCoord;
        const laneCenterOffsetFromRoadEdge = (targetLaneIndex + 0.5) * ROAD_WIDTH_UNIT;

        if (road.direction === 'horizontal') {
          targetLaneCenterCoord = (road.z - road.width / 2) + laneCenterOffsetFromRoadEdge;
          const offsetFromTargetLane = this.mesh.position.z - targetLaneCenterCoord;
          this.velocity.z -= offsetFromTargetLane * 0.2 * this.brain.trafficTraits.laneKeeping * deltaTime;
          if (Math.abs(offsetFromTargetLane) > ROAD_WIDTH_UNIT / 2) { this.trafficViolations++; laneViolations++; }
        } else {
          targetLaneCenterCoord = (road.x - road.width / 2) + laneCenterOffsetFromRoadEdge;
          const offsetFromTargetLane = this.mesh.position.x - targetLaneCenterCoord;
          this.velocity.x -= offsetFromTargetLane * 0.2 * this.brain.trafficTraits.laneKeeping * deltaTime;
          if (Math.abs(offsetFromTargetLane) > ROAD_WIDTH_UNIT / 2) { this.trafficViolations++; laneViolations++; }
        }

        this.roadTime += deltaTime;
        this.laneDiscipline = Math.max(0, 1 - (this.trafficViolations / (this.roadTime + 1)) * 0.1);
      }

      followConvoyTarget(deltaTime) {
        if (!this.followTarget || this.followTarget.crashed) {
          this.convoyLeader = null; this.followTarget = null; this.convoyPosition = -1; return;
        }

        const targetPos = this.followTarget.mesh.position;
        const distance = this.mesh.position.distanceTo(targetPos);
        const idealDistance = FOLLOW_DISTANCE + (this.convoyPosition * 2.5);

        const directionToTarget = targetPos.clone().sub(this.mesh.position).normalize();

        if (distance > idealDistance + 2) {
          this.velocity.add(directionToTarget.multiplyScalar(this.brain.trafficTraits.followingBehavior * 5 * deltaTime));
        } else if (distance < idealDistance - 1) {
          this.velocity.multiplyScalar(1 - (1 - this.brain.trafficTraits.followingBehavior) * 0.5 * deltaTime);
        }

        const targetAngle = Math.atan2(directionToTarget.x, directionToTarget.z);
        let carAngle = this.mesh.rotation.y;
        while (carAngle - targetAngle > Math.PI) carAngle -= 2 * Math.PI;
        while (targetAngle - carAngle > Math.PI) carAngle += 2 * Math.PI;
        this.mesh.rotation.y += (targetAngle - carAngle) * 0.05;

        this.convoyTime += deltaTime;
        this.followingDistance = distance;
      }

      executeParkingLogic(deltaTime) {
        if (!this.targetParkingLot) { this.isParkingApproach = false; return; }
        if (this.isInExitLane) this.handleExitLane(deltaTime);
        else if (this.isInApproachLane) this.handleApproachLaneMovement(deltaTime);
        else if (this.isParkingApproach) this.moveTowardsParkingEntry(deltaTime);
      }

      moveTowardsParkingEntry(deltaTime) {
        if (!this.targetParkingLot.approachLanes || this.targetParkingLot.approachLanes.length === 0) {
          this.isParkingApproach = false; return;
        }

        let bestLaneEntry = null;
        let selectedLaneIdx = -1;

        this.targetParkingLot.approachLanes.forEach((laneQueuePositions, idx) => {
          if (laneQueuePositions.length > 0) {
            const entryPoint = laneQueuePositions[0];
            const occupied = population.some(car => car !== this && car.isInApproachLane && car.selectedApproachLaneIndex === idx && car.mesh.position.distanceTo(entryPoint) < 5);
            if (!occupied && !bestLaneEntry) {
              bestLaneEntry = entryPoint;
              selectedLaneIdx = idx;
            }
          }
        });

        if (bestLaneEntry) {
          this.approachTargetPosition = bestLaneEntry;
          this.selectedApproachLaneIndex = selectedLaneIdx;
          this.moveToPosition(this.approachTargetPosition, deltaTime, 3);
          if (this.mesh.position.distanceTo(this.approachTargetPosition) < 2) {
            this.isInApproachLane = true;
            this.isParkingApproach = false;
          }
        } else {
          this.velocity.multiplyScalar(0.9);
          this.parkingAttempts++;
          if (this.parkingAttempts >= this.maxParkingAttempts) this.isParkingApproach = false;
        }
      }

      handleApproachLaneMovement(deltaTime) {
        if (!this.targetParkingLot || !this.targetParkingLot.spots) { this.isInApproachLane = false; return; }
        const availableSpot = this.targetParkingLot.spots.find(spot => !spot.occupied);
        if (availableSpot) {
          this.moveToPosition(availableSpot.position, deltaTime, 2);
          if (this.mesh.position.distanceTo(availableSpot.position) < 1.5) this.completeParkingProcess(availableSpot);
        } else {
          this.velocity.multiplyScalar(0.95);
        }
      }

      completeParkingProcess(spot) {
        this.isParked = true;
        this.parkingSpot = spot;
        spot.occupied = true;
        spot.car = this;
        this.mesh.position.copy(spot.position);
        this.mesh.rotation.y = spot.orientation !== undefined ? spot.orientation : this.mesh.rotation.y;
        this.velocity.set(0, 0, 0);
        this.parkingScore += 100;
        parkingEvents++;
        this.isInApproachLane = false;
        this.isParkingApproach = false;
        this.departureTime = 15 + Math.random() * 5;
        if (this.targetParkingLot && this.targetParkingLot.building) {
          this.targetParkingLot.building.visitorCount = (this.targetParkingLot.building.visitorCount || 0) + 1;
        }
        this.updateCarColor();
      }

      handleExitLane(deltaTime) {
        if (!this.exitTargetPosition) {
          this.isInExitLane = false;
          this.role = 'driver';
          this.timeAlive = epochTime * 0.5;
          return;
        }
        this.moveToPosition(this.exitTargetPosition, deltaTime, 4);
        if (this.mesh.position.distanceTo(this.exitTargetPosition) < 2) {
          this.isInExitLane = false;
          this.role = 'driver';
          this.timeAlive = epochTime * 0.7;
          this.initializeMovement();
          this.updateCarColor();
        }
      }

      leaveParking() {
        if (!this.isParked && !this.isInExitLane) return;

        if (this.parkingSpot) {
          this.parkingSpot.occupied = false;
          this.parkingSpot.car = null;
          this.parkingSpot = null;
        }
        this.isParked = false;

        if (this.targetParkingLot && this.targetParkingLot.exitLanes && this.targetParkingLot.exitLanes.length > 0) {
          this.selectedExitLaneIndex = 0;
          const exitLanePoints = this.targetParkingLot.exitLanes[this.selectedExitLaneIndex];
          if (exitLanePoints && exitLanePoints.length > 0) {
            this.exitTargetPosition = exitLanePoints[exitLanePoints.length - 1];
            this.isInExitLane = true;
            this.isExitingParking = false;
          } else {
            this.role = 'driver';
            this.initializeMovement();
          }
        } else {
          this.role = 'driver';
          this.initializeMovement();
        }
        this.updateCarColor();
      }

      attemptParking() {
        if (this.isParked || this.isParkingApproach) return;
        this.role = 'parker';
        this.updateRole();
        this.findNearestParkingLotForAI();
        if (!this.targetParkingLot) {
          this.parkingAttempts++;
          this.role = 'driver'; this.updateRole();
          this.timeAlive = epochTime * 0.2;
          return;
        }
        this.isParkingApproach = true;
        this.parkingAttempts = 0;
      }

      findNearestParkingLotForAI() {
        let closestLot = null;
        let minDist = Infinity;
        world.parkingLots.forEach(lot => {
          const dist = this.mesh.position.distanceTo(lot.center);
          if (dist < minDist) { minDist = dist; closestLot = lot; }
        });
        this.targetParkingLot = closestLot;
      }

      moveToPosition(targetPos, deltaTime, speed) {
        const direction = targetPos.clone().sub(this.mesh.position);
        const distance = direction.length();

        if (distance > 0.5) {
          direction.normalize();
          this.velocity.copy(direction.multiplyScalar(speed));
          const targetAngle = Math.atan2(direction.x, direction.z);
          let currentAngle = this.mesh.rotation.y;
          while (targetAngle - currentAngle > Math.PI) currentAngle += 2 * Math.PI;
          while (currentAngle - targetAngle > Math.PI) currentAngle -= 2 * Math.PI;
          this.mesh.rotation.y += (targetAngle - currentAngle) * 0.2;
          this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
        } else {
          this.velocity.set(0, 0, 0);
        }
      }

      updateFitness(deltaTime) {
        const distance = this.mesh.position.distanceTo(this.lastPosition);
        this.distanceTraveled += distance;

        let fitnessScore = this.distanceTraveled * 0.5;
        fitnessScore += this.roadTime * 1.5;
        fitnessScore += this.convoyTime * 1.0;
        fitnessScore += this.parkingScore * 0.5;
        fitnessScore -= this.trafficViolations * 5;

        if (this.getRoadPositionScore() < GRASS_THRESHOLD && !this.isReturningToRoad) fitnessScore -= 10 * deltaTime;
        if (this.crashed) fitnessScore -= 500;

        this.fitness = fitnessScore;
      }

      updateVisuals() {
        this.updateCarColor();
        this.updateFlockVisualization();
        this.updateRole();
      }

      updateCarColor() {
        let hue = 0.6, saturation = 0.7, lightness = 0.5;
        if (this.isParked) { hue = 0.33; lightness = 0.7; }
        else if (this.role === 'leader') { hue = 0.83; saturation = 1.0; lightness = 0.6; }
        else if (this.convoyPosition > 0) { hue = 0.5; saturation = 0.8; lightness = 0.6; }
        else if (this.getRoadPositionScore() < GRASS_THRESHOLD) { hue = 0.1; saturation = 1.0; }

        const performanceBonus = Math.min(Math.max(0, this.fitness) / 1000, 0.2);
        lightness = Math.min(1, lightness + performanceBonus);
        this.bodyMaterial.color.setHSL(hue, saturation, lightness);
      }

      updateFlockVisualization() {
        let lineIdx = 0;
        if (showFlockLines) {
          if (this.role === 'leader' && this.convoyFollowers) {
            this.convoyFollowers.forEach(follower => {
              if (lineIdx < this.flockLines.length && follower) {
                this.flockLines[lineIdx].geometry.setFromPoints([this.mesh.position, follower.mesh.position]);
                this.flockLines[lineIdx].material.color.setHex(0xff00ff);
                this.flockLines[lineIdx].visible = true;
                lineIdx++;
              }
            });
          } else if (this.followTarget) {
            if (lineIdx < this.flockLines.length) {
              this.flockLines[lineIdx].geometry.setFromPoints([this.mesh.position, this.followTarget.mesh.position]);
              this.flockLines[lineIdx].material.color.setHex(0x00ffff);
              this.flockLines[lineIdx].visible = true;
              lineIdx++;
            }
          }
        }
        for (let i = lineIdx; i < this.flockLines.length; i++) this.flockLines[i].visible = false;
      }

      getObstacles() {
        let obstacles = [];
        population.forEach(car => { if (car !== this && !car.crashed) obstacles.push(car.mesh); });
        world.buildings.forEach(buildingData => obstacles.push(buildingData.mesh));
        return obstacles;
      }

      checkCollisions() {
        if (this.crashed) return;
        const carBox = new THREE.Box3().setFromObject(this.mesh);

        population.forEach(otherCar => {
          if (otherCar !== this && !otherCar.crashed) {
            const otherBox = new THREE.Box3().setFromObject(otherCar.mesh);
            if (carBox.intersectsBox(otherBox)) {
              const separationVector = this.mesh.position.clone().sub(otherCar.mesh.position).normalize().multiplyScalar(0.2);
              this.mesh.position.add(separationVector);
              otherCar.mesh.position.sub(separationVector);
              this.velocity.multiplyScalar(0.8); otherCar.velocity.multiplyScalar(0.8);
              this.fitness -= 5; otherCar.fitness -= 5;
              this.trafficViolations++; otherCar.trafficViolations++;
              if (Math.random() < 0.01 && !this.isParkingRelatedState() && !otherCar.isParkingRelatedState()) {
                this.crashed = true; crashCount++;
              }
            }
          }
        });

        world.buildings.forEach(buildingData => {
          const buildingBox = new THREE.Box3().setFromObject(buildingData.mesh);
          if (carBox.intersectsBox(buildingBox)) { this.crashed = true; crashCount++; }
        });
      }

      isParkingRelatedState() {
        return this.isParked || this.isParkingApproach || this.isInApproachLane || this.isInExitLane;
      }

      keepInBounds() {
        const bounds = 400;
        if (Math.abs(this.mesh.position.x) > bounds || Math.abs(this.mesh.position.z) > bounds) {
          this.mesh.position.x = Math.max(-bounds, Math.min(bounds, this.mesh.position.x));
          this.mesh.position.z = Math.max(-bounds, Math.min(bounds, this.mesh.position.z));
          this.velocity.multiplyScalar(-0.5);
          this.fitness -= 20;
        }
      }

      destroy() {
        if (this.parkingSpot) { this.parkingSpot.occupied = false; this.parkingSpot.car = null; }
        if (this.targetParkingLot && this.targetParkingLot.building && this.isParked) {
          this.targetParkingLot.building.visitorCount = Math.max(0, (this.targetParkingLot.building.visitorCount || 0) - 1);
        }
        this.flockLines.forEach(line => { if (line.parent) scene.remove(line); });
        if (this.mesh.parent) scene.remove(this.mesh);
      }
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 300, 1000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(0, 150, 150);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x606060);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 150, 75);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 50;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.left = -200;
      directionalLight.shadow.camera.right = 200;
      directionalLight.shadow.camera.top = 200;
      directionalLight.shadow.camera.bottom = -200;
      scene.add(directionalLight);

      createTrafficWorld();
      createInitialPopulation();

      clock = new THREE.Clock();

      window.addEventListener('resize', onWindowResize);
      setupEventListeners();

      updateBrainUI();
      animate();
    }

    function createTrafficWorld() {
      const groundGeometry = new THREE.PlaneGeometry(1200, 1200);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3c763d });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);

      createRoadNetwork();
      createBuildingsWithParkingLots();
    }

    function createRoad(x, z, width, length, type, orientationAngle, isHorizontal) {
      const roadHeight = 0.1;
      const roadMaterial = new THREE.MeshLambertMaterial({ color: type === 'highway' ? 0x333333 : 0x444444 });
      const roadGeometry = new THREE.PlaneGeometry(isHorizontal ? length : width, isHorizontal ? width : length);
      const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
      roadMesh.rotation.x = -Math.PI / 2;
      roadMesh.position.set(x, roadHeight, z);
      roadMesh.receiveShadow = true;
      scene.add(roadMesh);

      const roadData = {
        mesh: roadMesh,
        x: x, z: z,
        width: width, length: length,
        type: type,
        direction: isHorizontal ? 'horizontal' : 'vertical',
        orientationAngle: orientationAngle,
        start: isHorizontal ? x - length / 2 : z - length / 2,
        end: isHorizontal ? x + length / 2 : z + length / 2,
        lanes: []
      };
      world.roads.push(roadData);

      const numLanes = Math.max(1, Math.floor(width / ROAD_WIDTH_UNIT));
      const actualLaneWidth = width / numLanes;
      const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const yellowLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });

      for (let i = 0; i < numLanes; i++) {
        const laneCenterOffset = (i - (numLanes - 1) / 2) * actualLaneWidth;

        if (i < numLanes - 1) {
          let linePosX, linePosZ, lineWidth, lineHeight;
          const lineOffsetFromLaneCenter = actualLaneWidth / 2;

          if (isHorizontal) {
            linePosX = x;
            linePosZ = z + laneCenterOffset + lineOffsetFromLaneCenter;
            lineWidth = length;
            lineHeight = 0.2;
          } else {
            linePosX = x + laneCenterOffset + lineOffsetFromLaneCenter;
            linePosZ = z;
            lineWidth = 0.2;
            lineHeight = length;
          }
          const isCenterDivider = numLanes > 1 && Math.abs(laneCenterOffset + lineOffsetFromLaneCenter) < actualLaneWidth * 0.6;
          createDashedLineWorld(linePosX, linePosZ, lineWidth, lineHeight, isHorizontal, isCenterDivider ? yellowLineMaterial : lineMaterial, roadHeight + 0.01);
        }
      }
    }

    function createDashedLineWorld(centerX, centerZ, totalLength, totalWidth, isHorizontal, material, yPos) {
      const dashLength = 5;
      const gapLength = 3;
      const numDashes = Math.floor(totalLength / (dashLength + gapLength));

      for (let j = 0; j < numDashes; j++) {
        const dashGeometry = new THREE.PlaneGeometry(
          isHorizontal ? dashLength : totalWidth,
          isHorizontal ? totalWidth : dashLength
        );
        const dash = new THREE.Mesh(dashGeometry, material);
        dash.rotation.x = -Math.PI / 2;

        const dashOffset = j * (dashLength + gapLength) - totalLength / 2 + dashLength / 2;
        if (isHorizontal) dash.position.set(centerX + dashOffset, yPos, centerZ);
        else dash.position.set(centerX, yPos, centerZ + dashOffset);
        scene.add(dash);
      }
    }

    function createRoadNetwork() {
      world.roads = [];
      createRoad(0, 0, ROAD_WIDTH_UNIT * 4, 800, 'highway', 0, true);
      createRoad(0, 0, ROAD_WIDTH_UNIT * 4, 800, 'highway', Math.PI / 2, false);

      createRoad(0, ROAD_SPACING, ROAD_WIDTH_UNIT * 2, 800, 'secondary', 0, true);
      createRoad(0, -ROAD_SPACING, ROAD_WIDTH_UNIT * 2, 800, 'secondary', 0, true);
      createRoad(ROAD_SPACING, 0, ROAD_WIDTH_UNIT * 2, 800, 'secondary', Math.PI / 2, false);
      createRoad(-ROAD_SPACING, 0, ROAD_WIDTH_UNIT * 2, 800, 'secondary', Math.PI / 2, false);

      createRoad(0, ROAD_SPACING * 2, ROAD_WIDTH_UNIT * 2, 800, 'local', 0, true);
      createRoad(0, -ROAD_SPACING * 2, ROAD_WIDTH_UNIT * 2, 800, 'local', 0, true);
      createRoad(ROAD_SPACING * 2, 0, ROAD_WIDTH_UNIT * 2, 800, 'local', Math.PI / 2, false);
      createRoad(-ROAD_SPACING * 2, 0, ROAD_WIDTH_UNIT * 2, 800, 'local', Math.PI / 2, false);
    }

    function createBuildingsWithParkingLots() {
      world.buildings = []; world.parkingLots = [];
      const buildingBaseMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
      const parkingMaterial = new THREE.MeshLambertMaterial({ color: 0x383838 });
      const spotMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
      const barGraphMaterial = new THREE.MeshLambertMaterial({ color: 0x007bff });

      const buildingLocations = [
        { x: -100, z: -100 }, { x: 100, z: -100 },
        { x: -100, z: 100 }, { x: 100, z: 100 },
        { x: -250, z: -50 }, { x: 250, z: 50 },
        { x: -50, z: -250 }, { x: 50, z: 250 },
      ];

      buildingLocations.forEach((loc) => {
        const bWidth = 20 + Math.random() * 15;
        const bHeight = 15 + Math.random() * 25;
        const bDepth = 20 + Math.random() * 15;

        const buildingGeometry = new THREE.BoxGeometry(bWidth, bHeight, bDepth);
        const buildingMesh = new THREE.Mesh(buildingGeometry, buildingBaseMaterial.clone());
        buildingMesh.material.color.setHSL(Math.random(), 0.5, 0.6);
        buildingMesh.position.set(loc.x, bHeight / 2 + 0.1, loc.z);
        buildingMesh.castShadow = true;
        scene.add(buildingMesh);

        const barGeometry = new THREE.BoxGeometry(5, 1, 5);
        const barGraphMesh = new THREE.Mesh(barGeometry, barGraphMaterial.clone());
        barGraphMesh.position.set(loc.x, bHeight + 0.1 + 3, loc.z);
        barGraphMesh.scale.y = 0.1;
        barGraphMesh.visible = true;
        scene.add(barGraphMesh);

        const buildingData = { mesh: buildingMesh, parkingLot: null, visitorCount: 0, barGraphMesh: barGraphMesh, height: bHeight };
        world.buildings.push(buildingData);

        const lotWidth = 40, lotDepth = 30;
        const lotCenterX = loc.x + bWidth / 2 + lotWidth / 2 + 5;
        const lotCenterZ = loc.z;

        const lotGeometry = new THREE.PlaneGeometry(lotWidth, lotDepth);
        const lotMesh = new THREE.Mesh(lotGeometry, parkingMaterial);
        lotMesh.rotation.x = -Math.PI / 2;
        lotMesh.position.set(lotCenterX, 0.05, lotCenterZ);
        scene.add(lotMesh);

        const parkingLot = {
          center: new THREE.Vector3(lotCenterX, 0.1, lotCenterZ),
          spots: [],
          approachLanes: [], exitLanes: [], accessPoints: [],
          building: buildingData
        };
        buildingData.parkingLot = parkingLot;

        const numRows = 2, spotsPerRow = 5;
        for (let r = 0; r < numRows; r++) {
          for (let s = 0; s < spotsPerRow; s++) {
            const spotX = lotCenterX + (s - (spotsPerRow - 1) / 2) * (PARKING_SPOT_SIZE.width + 2);
            const spotZ = lotCenterZ + (r - (numRows - 1) / 2) * (PARKING_SPOT_SIZE.length + 3);
            const spotOrientation = Math.PI / 2;

            const spotPlaneGeom = new THREE.PlaneGeometry(PARKING_SPOT_SIZE.width, PARKING_SPOT_SIZE.length);
            const spotPlaneMesh = new THREE.Mesh(spotPlaneGeom, spotMaterial);
            spotPlaneMesh.rotation.x = -Math.PI / 2;
            spotPlaneMesh.rotation.z = spotOrientation;
            spotPlaneMesh.position.set(spotX, 0.06, spotZ);
            scene.add(spotPlaneMesh);

            parkingLot.spots.push({
              position: new THREE.Vector3(spotX, 1, spotZ),
              orientation: spotOrientation,
              occupied: false, car: null, mesh: spotPlaneMesh
            });
          }
        }

        parkingLot.approachLanes.push([new THREE.Vector3(lotCenterX - lotWidth / 2 - 5, 1, lotCenterZ)]);
        parkingLot.exitLanes.push([new THREE.Vector3(lotCenterX - lotWidth / 2 - 10, 1, lotCenterZ + 5)]);

        world.parkingLots.push(parkingLot);
      });
    }

    function createInitialPopulation() {
      population = [];
      const startPositions = [
        { x: -50, z: 0 }, { x: 50, z: 0 }, { x: 0, z: -50 }, { x: 0, z: 50 },
        { x: -ROAD_SPACING, z: 0 }, { x: ROAD_SPACING, z: 0 },
        { x: 0, z: -ROAD_SPACING }, { x: 0, z: ROAD_SPACING },
      ];
      for (let i = 0; i < populationSize; i++) {
        const pos = startPositions[i % startPositions.length];
        const car = new TrafficCar(pos.x + Math.random() * 10 - 5, pos.z + Math.random() * 10 - 5);
        population.push(car);
        scene.add(car.mesh);
      }
    }

    function evolvePopulation() {
      population.sort((a, b) => (b.fitness || 0) - (a.fitness || 0));
      bestFitness = population[0] ? population[0].fitness : 0;

      const eliteCount = Math.floor(populationSize * 0.1);
      const survivors = population.slice(0, eliteCount);

      const newPopulation = [];

      survivors.forEach(parent => {
        const offspring = new TrafficCar(parent.mesh.position.x, parent.mesh.position.z);
        offspring.brain = parent.brain.copy();
        newPopulation.push(offspring);
      });

      while (newPopulation.length < populationSize) {
        const parent = survivors[Math.floor(Math.random() * survivors.length)];
        const offspring = new TrafficCar(parent.mesh.position.x, parent.mesh.position.z);
        offspring.brain = parent.brain.copy();
        offspring.brain.mutate(AI_MODE === 'v2' ? 0.06 : 0.1); // ✅ slightly gentler for v2
        newPopulation.push(offspring);
      }

      population.forEach(car => car.destroy());
      population = newPopulation;
      population.forEach(car => scene.add(car.mesh));

      epoch++;
      timeLeft = epochTime;
      crashCount = 0; parkingEvents = 0; laneViolations = 0;
      world.parkingLots.forEach(lot => {
        if (lot.building) lot.building.visitorCount = 0;
        lot.spots.forEach(spot => { spot.occupied = false; spot.car = null; });
      });
      console.log(`Epoch ${epoch}: Best Fitness: ${bestFitness.toFixed(1)} | Brain=${AI_MODE}`);
    }

    function animate() {
      requestAnimationFrame(animate);
      const deltaTime = Math.min(clock.getDelta() * speedMultiplier, 0.1);
      if (!paused) {
        timeLeft -= deltaTime;
        if (timeLeft <= 0) evolvePopulation();
        updatePopulation(deltaTime);
        updateCamera();
        updateUI();
      }
      renderer.render(scene, camera);
    }

    function updatePopulation(deltaTime) {
      let currentStats = {
        alive: 0, leaders: 0, convoy: 0, parked: 0, solo: 0,
        maxConvoySize: 0, totalRoadTime: 0, totalViolations: 0,
        totalFollowingDistance: 0, followingCount: 0, approaching: 0
      };
      population.forEach(car => {
        if (!car.crashed) {
          car.update(deltaTime);
          currentStats.alive++;
          if (car.isParked) currentStats.parked++;
          else if (car.isParkingApproach || car.isInApproachLane) currentStats.approaching++;
          else if (car.role === 'leader') currentStats.leaders++;
          else if (car.convoyPosition > 0) {
            currentStats.convoy++;
            if (car.followTarget) {
              currentStats.totalFollowingDistance += car.mesh.position.distanceTo(car.followTarget.mesh.position);
              currentStats.followingCount++;
            }
          } else currentStats.solo++;

          if (car.role === 'leader' && car.convoyFollowers)
            currentStats.maxConvoySize = Math.max(currentStats.maxConvoySize, car.convoyFollowers.length + 1);

          currentStats.totalRoadTime += car.roadTime;
          currentStats.totalViolations += car.trafficViolations;
        }
      });
      window.populationStats = currentStats;
    }

    function updateCamera() {
      let targetCar = null;
      if (cameraMode === 'follow_best') {
        targetCar = population.filter(c => !c.crashed && !c.isParked).sort((a, b) => b.fitness - a.fitness)[0];
        manuallyControlledCar = targetCar;
      } else if (cameraMode === 'follow_convoy') {
        targetCar = population.filter(c => c.role === 'leader' && c.convoyFollowers.length > 0)
          .sort((a, b) => b.convoyFollowers.length - a.convoyFollowers.length)[0];
        manuallyControlledCar = null;
      } else {
        manuallyControlledCar = null;
      }

      if (targetCar) {
        const offset = new THREE.Vector3(0, 30, -25);
        const targetPosition = targetCar.mesh.position.clone().add(offset.applyQuaternion(targetCar.mesh.quaternion));
        camera.position.lerp(targetPosition, 0.05);
        camera.lookAt(targetCar.mesh.position);
      } else {
        camera.position.lerp(new THREE.Vector3(0, 200, 200), 0.02);
        camera.lookAt(0, 0, 0);
      }
    }

    function updateUI() {
      const stats = window.populationStats || {};
      document.getElementById('epoch').textContent = epoch;
      document.getElementById('epochTime').textContent = Math.ceil(timeLeft);
      document.getElementById('timeProgress').style.width = `${((epochTime - timeLeft) / epochTime) * 100}%`;
      document.getElementById('population').textContent = stats.alive || 0;
      document.getElementById('bestFitness').textContent = Math.round(bestFitness);
      document.getElementById('trafficIQ').textContent = Math.round(50 + (bestFitness / 50));
      document.getElementById('roadMastery').textContent = stats.alive > 0 ? Math.round((stats.totalRoadTime / stats.alive) / epochTime * 100) : 0;

      document.getElementById('crashCount').textContent = crashCount;
      document.getElementById('parkingEvents').textContent = parkingEvents;
      document.getElementById('laneViolations').textContent = laneViolations;

      document.getElementById('leaderCount').textContent = stats.leaders || 0;
      document.getElementById('convoyCount').textContent = stats.convoy || 0;
      document.getElementById('parkedCount').textContent = stats.parked || 0;
      document.getElementById('soloCount').textContent = stats.solo || 0;
      document.getElementById('largestConvoy').textContent = stats.maxConvoySize || 0;

      world.buildings.forEach(buildingData => {
        if (buildingData.barGraphMesh) {
          const scaleY = Math.max(0.1, buildingData.visitorCount * 2);
          buildingData.barGraphMesh.scale.y = scaleY;
          buildingData.barGraphMesh.position.y = buildingData.height + 0.1 + 3 + (scaleY / 2) * buildingData.barGraphMesh.geometry.parameters.height;
        }
      });

      updateTopPerformersDisplay();
    }

    function updateTopPerformersDisplay() {
      const sorted = [...population].filter(car => !car.crashed).sort((a, b) => b.fitness - a.fitness).slice(0, 5);
      const topPerformersDiv = document.getElementById('topPerformers');
      topPerformersDiv.innerHTML = '';
      sorted.forEach((car, i) => {
        const div = document.createElement('div');
        div.innerHTML = `${i + 1}. F:${Math.round(car.fitness)} Role:${car.role}`;
        topPerformersDiv.appendChild(div);
      });
    }

    function setupEventListeners() {
      document.getElementById('pauseBtn').addEventListener('click', () => {
        paused = !paused;
        document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
      });

      document.getElementById('resetBtn').addEventListener('click', resetSimulation);

      document.getElementById('speedBtn').addEventListener('click', () => {
        speedMultiplier = speedMultiplier === 1 ? 2 : speedMultiplier === 2 ? 5 : 1;
        document.getElementById('speedBtn').textContent = `Speed: ${speedMultiplier}x`;
      });

      document.getElementById('viewBtn').addEventListener('click', () => {
        const modes = ['overview', 'follow_best', 'follow_convoy'];
        cameraMode = modes[(modes.indexOf(cameraMode) + 1) % modes.length];
        document.getElementById('viewBtn').textContent = `View: ${cameraMode.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
      });

      document.getElementById('flockBtn').addEventListener('click', () => {
        showFlockLines = !showFlockLines;
        document.getElementById('flockBtn').textContent = `Networks: ${showFlockLines ? 'ON' : 'OFF'}`;
        world.flockLines.forEach(line => line.visible = showFlockLines);
        population.forEach(car => car.flockLines.forEach(line => line.visible = showFlockLines && (line.parent === scene)));
      });

      document.getElementById('trafficBtn').addEventListener('click', () => {
        trafficRules = !trafficRules;
        document.getElementById('trafficBtn').textContent = `Traffic Rules: ${trafficRules ? 'ON' : 'OFF'}`;
      });

      // ✅ minimal add: brain swap button (resets to keep all sim features and avoid mixing architectures)
      document.getElementById('brainBtn').addEventListener('click', () => {
        AI_MODE = (AI_MODE === 'v2') ? 'v1' : 'v2';
        updateBrainUI();
        resetSimulation(); // safest: keep camera modes, controls, visuals, but restart population with new brain
      });

      document.addEventListener('keydown', (event) => {
        if (manuallyControlledCar && cameraMode === 'follow_best') {
          if (event.key === 'w' || event.key === 'W') manualControls.W = true;
          if (event.key === 's' || event.key === 'S') manualControls.S = true;
          if (event.key === 'a' || event.key === 'A') manualControls.A = true;
          if (event.key === 'd' || event.key === 'D') manualControls.D = true;
        }
      });
      document.addEventListener('keyup', (event) => {
        if (manuallyControlledCar && cameraMode === 'follow_best') {
          if (event.key === 'w' || event.key === 'W') manualControls.W = false;
          if (event.key === 's' || event.key === 'S') manualControls.S = false;
          if (event.key === 'a' || event.key === 'A') manualControls.A = false;
          if (event.key === 'd' || event.key === 'D') manualControls.D = false;
        }
      });
    }

    function resetSimulation() {
      epoch = 1; timeLeft = epochTime; bestFitness = 0; crashCount = 0; parkingEvents = 0; laneViolations = 0;
      population.forEach(car => car.destroy());
      world.buildings.forEach(buildingData => {
        buildingData.visitorCount = 0;
        if (buildingData.barGraphMesh) {
          buildingData.barGraphMesh.scale.y = 0.1;
          buildingData.barGraphMesh.position.y = buildingData.height + 0.1 + 3 + (0.1 / 2) * buildingData.barGraphMesh.geometry.parameters.height;
        }
      });
      world.parkingLots.forEach(lot => { lot.spots.forEach(spot => { spot.occupied = false; spot.car = null; }); });
      createInitialPopulation();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
