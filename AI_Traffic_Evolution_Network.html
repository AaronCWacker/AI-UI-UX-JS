<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Enhanced AI Traffic Evolution Simulator</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #000; }
    #ui {
      position: absolute; top: 10px; left: 10px; color: white;
      background-color: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px;
      z-index: 100; font-size: 14px; min-width: 220px;
    }
    #controls {
      position: absolute; top: 10px; right: 10px; color: white;
      background-color: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px;
      z-index: 100;
    }
    button {
      background-color: #4CAF50; border: none; color: white; padding: 8px 16px;
      margin: 5px; cursor: pointer; border-radius: 4px; font-size: 12px;
    }
    button:hover { background-color: #45a049; }
    #stats {
      position: absolute; bottom: 10px; left: 10px; color: white;
      background-color: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px;
      z-index: 100; font-size: 12px; min-width: 200px;
    }
    #flockingStats {
      position: absolute; bottom: 10px; right: 10px; color: white;
      background-color: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px;
      z-index: 100; font-size: 12px; min-width: 180px;
    }
    #trafficStats {
      position: absolute; top: 50%; right: 10px; transform: translateY(-50%);
      color: white; background-color: rgba(0,0,0,0.9); padding: 15px;
      border-radius: 8px; z-index: 100; font-size: 12px; min-width: 180px;
    }
    .highlight { color: #ffcc00; font-weight: bold; }
    .success { color: #00ff00; font-weight: bold; }
    .flocking { color: #00aaff; }
    .solo { color: #ff8800; }
    .leader { color: #ff00ff; font-weight: bold; }
    .convoy { color: #00ffff; }
    .parked { color: #88ff88; }
    .species-0 { color: #ff6b6b; }
    .species-1 { color: #4ecdc4; }
    .species-2 { color: #45b7d1; }
    .species-3 { color: #96ceb4; }
    .species-4 { color: #ffd93d; }
    .progress-bar {
      width: 100%; height: 10px; background-color: #333; border-radius: 5px;
      overflow: hidden; margin: 5px 0;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1);
      transition: width 0.3s ease;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div class="highlight">AI Traffic Evolution Simulator</div>
    <div>Epoch: <span id="epoch">1</span></div>
    <div>Time: <span id="epochTime">60</span>s</div>
    <div class="progress-bar"><div class="progress-fill" id="timeProgress"></div></div>
    <div>Population: <span id="population">100</span></div>
    <div>Species: <span id="speciesCount">1</span></div>
    <div>Best Fitness: <span id="bestFitness">0</span></div>
    <div>Traffic IQ: <span id="trafficIQ">50</span></div>
    <div>Road Mastery: <span id="roadMastery">0</span>%</div>
    <div>Brain: <span id="brainModeLabel">V2</span></div>
  </div>

  <div id="controls">
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
    <button id="speedBtn">Speed: 1x</button>
    <button id="viewBtn">View: Overview</button>
    <button id="brainBtn">Brain: V2</button>
    <button id="flockBtn">Networks: ON</button>
    <button id="trafficBtn">Traffic Rules: ON</button>
  </div>

  <div id="stats">
    <div><span class="highlight">Top Performers:</span></div>
    <div id="topPerformers"></div>
    <div style="margin-top: 10px;"><span class="highlight">Generation Stats:</span></div>
    <div>Crashes: <span id="crashCount">0</span></div>
    <div>Total Distance: <span id="totalDistance">0</span></div>
    <div>Parking Visits: <span id="parkingEvents">0</span></div>
    <div>Lane Violations: <span id="laneViolations">0</span></div>
    <div>Convoy Length: <span id="convoyLength">0</span></div>
  </div>

  <div id="flockingStats">
    <div><span class="highlight">Convoy Behavior:</span></div>
    <div><span class="leader">Leaders:</span> <span id="leaderCount">0</span></div>
    <div><span class="convoy">In Convoy:</span> <span id="convoyCount">0</span></div>
    <div><span class="parked">Parked:</span> <span id="parkedCount">0</span></div>
    <div><span class="solo">Solo:</span> <span id="soloCount">0</span></div>
    <div>Largest Convoy: <span id="largestConvoy">0</span></div>
    <div>Formation Quality: <span id="formationQuality">0</span>%</div>
    <div>Parking Efficiency: <span id="parkingEfficiency">0</span>%</div>
  </div>

  <div id="trafficStats">
    <div><span class="highlight">Traffic Intelligence:</span></div>
    <div>Lane Discipline: <span id="laneDiscipline">0</span>%</div>
    <div>Following Distance: <span id="followingDistance">0</span>m</div>
    <div>Road Adherence: <span id="roadAdherence">0</span>%</div>
    <div>Turn Signals: <span id="turnSignals">0</span>%</div>
    <div style="margin-top: 10px;"><span class="highlight">Parking:</span></div>
    <div>Spots Occupied: <span id="spotsOccupied">0</span></div>
    <div>Parking Success: <span id="parkingSuccess">0</span>%</div>
    <div>Queue Efficiency: <span id="queueEfficiency">0</span>%</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // =========================================================
    // Global variables
    // =========================================================
    let scene, camera, renderer, clock;

    let world = {
      roads: [],
      intersections: [],
      buildings: [],     // { mesh, parkingLot, visitorCount, barGraphMesh, height }
      parkingLots: [],   // { center, spots, approachLanes, exitLanes, accessPoints, building }
      flockLines: []
    };

    // Evolution system
    let epoch = 1;
    let epochTime = 60;
    let timeLeft = 60;
    let population = [];
    let species = [];
    let populationSize = 100;
    let bestFitness = 0;
    let crashCount = 0;
    let paused = false;
    let speedMultiplier = 1;
    let cameraMode = 'overview';
    let showFlockLines = true;
    let trafficRules = true;
    let parkingEvents = 0;
    let laneViolations = 0;

    // Manual control state
    let manuallyControlledCar = null;
    const manualControls = { W: false, A: false, S: false, D: false };

    // Parameters
    const ROAD_WIDTH_UNIT = 6;
    const ROAD_SPACING = 150;
    const FOLLOW_DISTANCE = 8;
    const CONVOY_MAX_DISTANCE = 12;
    const PARKING_SPOT_SIZE = { width: 4, length: 8 };
    const GRASS_THRESHOLD = 0.15;

    // =========================================================
    // Brain swap (V1: original MLP+memory, V2: GRU-ish + heads)
    // =========================================================
    let AI_MODE = 'v2'; // 'v1' or 'v2'

    function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }
    function clamp01(x) { return clamp(x, 0, 1); }
    function randn() {
      // Box-Muller
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function createBrain() {
      return (AI_MODE === 'v2') ? new TrafficAI_v2() : new TrafficAI_v1();
    }

    // =========================================================
    // Brain V1 (your original MLP + memory) + imprintFrom()
    // =========================================================
    class TrafficAI_v1 {
      constructor() {
        this.inputSize = 28;
        this.hiddenLayers = [36, 28, 20];
        this.outputSize = 10;
        this.memorySize = 8;

        this.weights = [];
        this.biases = [];
        this.memory = new Array(this.memorySize).fill(0);
        this.memoryPointer = 0;

        let prevSize = this.inputSize + this.memorySize;
        for (let i = 0; i < this.hiddenLayers.length; i++) {
          this.weights.push(this.randomMatrix(prevSize, this.hiddenLayers[i]));
          this.biases.push(this.randomArray(this.hiddenLayers[i]));
          prevSize = this.hiddenLayers[i];
        }
        this.weights.push(this.randomMatrix(prevSize, this.outputSize));
        this.biases.push(this.randomArray(this.outputSize));

        this.trafficTraits = {
          laneKeeping: Math.random(),
          followingBehavior: Math.random(),
          parkingSkill: Math.random(),
          convoyDiscipline: Math.random(),
          roadPriority: Math.random()
        };
      }

      randomMatrix(rows, cols) {
        let matrix = [];
        for (let i = 0; i < rows; i++) {
          matrix[i] = [];
          for (let j = 0; j < cols; j++) matrix[i][j] = (Math.random() - 0.5) * 2;
        }
        return matrix;
      }

      randomArray(size) {
        return Array(size).fill().map(() => (Math.random() - 0.5) * 2);
      }

      sigmoid(x) {
        const clampedX = Math.max(-10, Math.min(10, x));
        return 1 / (1 + Math.exp(-clampedX));
      }

      forwardLayer(inputs, weights, biases) {
        const outputs = new Array(weights[0].length).fill(0);
        for (let i = 0; i < outputs.length; i++) {
          for (let j = 0; j < inputs.length; j++) outputs[i] += inputs[j] * weights[j][i];
          outputs[i] += biases[i];
          outputs[i] = this.sigmoid(outputs[i]);
        }
        return outputs;
      }

      updateMemory(inputs, outputs) {
        const roadInfo = inputs.slice(20, 24).reduce((a, b) => a + b, 0) / 4;
        this.memory[this.memoryPointer] = roadInfo;
        this.memoryPointer = (this.memoryPointer + 1) % this.memorySize;
      }

      activate(inputs) {
        let currentInput = [...inputs, ...this.memory];
        for (let layer = 0; layer < this.hiddenLayers.length; layer++) {
          currentInput = this.forwardLayer(currentInput, this.weights[layer], this.biases[layer]);
        }
        const outputs = this.forwardLayer(
          currentInput,
          this.weights[this.weights.length - 1],
          this.biases[this.biases.length - 1]
        );
        this.updateMemory(inputs, outputs);
        return outputs;
      }

      mutate(rate = 0.1) {
        this.weights.forEach(m => this.mutateMatrix(m, rate));
        this.biases.forEach(a => this.mutateArray(a, rate));

        Object.keys(this.trafficTraits).forEach(trait => {
          if (Math.random() < rate) {
            this.trafficTraits[trait] += (Math.random() - 0.5) * 0.2;
            this.trafficTraits[trait] = clamp01(this.trafficTraits[trait]);
          }
        });
      }

      mutateMatrix(matrix, rate) {
        for (let i = 0; i < matrix.length; i++) {
          for (let j = 0; j < matrix[i].length; j++) {
            if (Math.random() < rate) {
              matrix[i][j] += (Math.random() - 0.5) * 0.5;
              matrix[i][j] = clamp(matrix[i][j], -3, 3);
            }
          }
        }
      }

      mutateArray(array, rate) {
        for (let i = 0; i < array.length; i++) {
          if (Math.random() < rate) {
            array[i] += (Math.random() - 0.5) * 0.5;
            array[i] = clamp(array[i], -3, 3);
          }
        }
      }

      copy() {
        const n = new TrafficAI_v1();
        n.weights = this.weights.map(m => m.map(r => [...r]));
        n.biases = this.biases.map(b => [...b]);
        n.memory = [...this.memory];
        n.memoryPointer = this.memoryPointer;
        n.trafficTraits = { ...this.trafficTraits };
        return n;
      }

      // ✅ NEW: soft copy from mentor
      imprintFrom(src, alpha = 0.15) {
        if (!src || !src.weights || !src.biases) return;

        for (let l = 0; l < this.weights.length; l++) {
          for (let i = 0; i < this.weights[l].length; i++) {
            for (let j = 0; j < this.weights[l][i].length; j++) {
              this.weights[l][i][j] = (1 - alpha) * this.weights[l][i][j] + alpha * src.weights[l][i][j];
              this.weights[l][i][j] = clamp(this.weights[l][i][j], -3, 3);
            }
          }
        }
        for (let l = 0; l < this.biases.length; l++) {
          for (let i = 0; i < this.biases[l].length; i++) {
            this.biases[l][i] = (1 - alpha) * this.biases[l][i] + alpha * src.biases[l][i];
            this.biases[l][i] = clamp(this.biases[l][i], -3, 3);
          }
        }
        if (src.trafficTraits) {
          Object.keys(this.trafficTraits).forEach(k => {
            this.trafficTraits[k] = clamp01((1 - alpha) * this.trafficTraits[k] + alpha * src.trafficTraits[k]);
          });
        }
      }
    }

    // =========================================================
    // Brain V2 (small GRU + MLP + multi-head outputs) + imprintFrom()
    // =========================================================
    class TrafficAI_v2 {
      constructor() {
        this.inputSize = 28;

        // GRU state size
        this.hSize = 24;
        this.h = new Array(this.hSize).fill(0);

        // MLP sizes
        this.m1 = 32;
        this.m2 = 24;

        // Output is still 10 (same contract)
        this.outputSize = 10;

        // Action smoothing
        this.actionEMA = new Array(this.outputSize).fill(0.5);

        // Traits (kept)
        this.trafficTraits = {
          laneKeeping: Math.random(),
          followingBehavior: Math.random(),
          parkingSkill: Math.random(),
          convoyDiscipline: Math.random(),
          roadPriority: Math.random()
        };

        // Xavier-ish init helpers
        const mat = (r, c, scale) => Array.from({ length: r }, () =>
          Array.from({ length: c }, () => (Math.random() * 2 - 1) * scale)
        );
        const arr = (n, scale) => Array.from({ length: n }, () => (Math.random() * 2 - 1) * scale);

        // GRU params
        const sIn = Math.sqrt(1 / this.inputSize);
        const sH  = Math.sqrt(1 / this.hSize);

        this.Wz = mat(this.inputSize, this.hSize, sIn);
        this.Uz = mat(this.hSize, this.hSize, sH);
        this.bz = arr(this.hSize, 0.1);

        this.Wr = mat(this.inputSize, this.hSize, sIn);
        this.Ur = mat(this.hSize, this.hSize, sH);
        this.br = arr(this.hSize, 0.1);

        this.Wh = mat(this.inputSize, this.hSize, sIn);
        this.Uh = mat(this.hSize, this.hSize, sH);
        this.bh = arr(this.hSize, 0.1);

        // MLP on [h, inputs]
        const fSize = this.hSize + this.inputSize;
        const sF = Math.sqrt(1 / fSize);

        this.W1 = mat(fSize, this.m1, sF);
        this.b1 = arr(this.m1, 0.1);

        this.W2 = mat(this.m1, this.m2, Math.sqrt(1 / this.m1));
        this.b2 = arr(this.m2, 0.1);

        // Heads:
        // throttle: 1 (tanh)
        this.W_throttle = mat(this.m2, 1, Math.sqrt(1 / this.m2));
        this.b_throttle = arr(1, 0.1);

        // steer: 1 (tanh)
        this.W_steer = mat(this.m2, 1, Math.sqrt(1 / this.m2));
        this.b_steer = arr(1, 0.1);

        // lane: 3 (softmax)
        this.W_lane = mat(this.m2, 3, Math.sqrt(1 / this.m2));
        this.b_lane = arr(3, 0.1);

        // other: 6 (sigmoid) -> convoy, park, signalL, signalR, stop, emergencyStop
        this.W_other = mat(this.m2, 6, Math.sqrt(1 / this.m2));
        this.b_other = arr(6, 0.1);
      }

      sigmoid(x) { x = clamp(x, -10, 10); return 1 / (1 + Math.exp(-x)); }
      tanh(x) { x = clamp(x, -10, 10); return Math.tanh(x); }
      relu(x) { return Math.max(0, x); }

      dotVecMat(v, W) {
        const out = new Array(W[0].length).fill(0);
        for (let j = 0; j < out.length; j++) {
          let s = 0;
          for (let i = 0; i < v.length; i++) s += v[i] * W[i][j];
          out[j] = s;
        }
        return out;
      }

      add(a, b) { return a.map((x, i) => x + b[i]); }
      mul(a, b) { return a.map((x, i) => x * b[i]); }

      softmax(logits) {
        const m = Math.max(...logits);
        const exps = logits.map(v => Math.exp(clamp(v - m, -10, 10)));
        const sum = exps.reduce((a, b) => a + b, 0) || 1;
        return exps.map(v => v / sum);
      }

      layerTanh(v, W, b) {
        const z = this.add(this.dotVecMat(v, W), b);
        return z.map(x => this.tanh(x));
      }

      layerSigmoid(v, W, b) {
        const z = this.add(this.dotVecMat(v, W), b);
        return z.map(x => this.sigmoid(x));
      }

      activate(inputs) {
        // -------- GRU update --------
        const x = inputs;

        const z = this.add(this.dotVecMat(x, this.Wz), this.add(this.dotVecMat(this.h, this.Uz), this.bz)).map(v => this.sigmoid(v));
        const r = this.add(this.dotVecMat(x, this.Wr), this.add(this.dotVecMat(this.h, this.Ur), this.br)).map(v => this.sigmoid(v));

        const rh = this.mul(r, this.h);
        const hTilde = this.add(this.dotVecMat(x, this.Wh), this.add(this.dotVecMat(rh, this.Uh), this.bh)).map(v => this.tanh(v));

        // h = (1 - z) * h + z * hTilde
        this.h = this.h.map((hv, i) => (1 - z[i]) * hv + z[i] * hTilde[i]);

        // -------- MLP features --------
        const feat = [...this.h, ...x]; // size fSize
        const y1 = this.layerTanh(feat, this.W1, this.b1);
        const y2 = this.layerTanh(y1, this.W2, this.b2);

        // -------- heads --------
        const throttle = this.tanh(this.dotVecMat(y2, this.W_throttle)[0] + this.b_throttle[0]); // [-1..1]
        const steer = this.tanh(this.dotVecMat(y2, this.W_steer)[0] + this.b_steer[0]);         // [-1..1]

        const laneLogits = this.add(this.dotVecMat(y2, this.W_lane), this.b_lane);
        const laneP = this.softmax(laneLogits); // 3 probs
        const laneScalar = laneP[0] * 0.0 + laneP[1] * 0.5 + laneP[2] * 1.0;

        const other = this.layerSigmoid(y2, this.W_other, this.b_other); // 6

        // Map to the original 10 outputs contract:
        const accel = clamp01(this.relu(throttle));     // 0..1
        const brake = clamp01(this.relu(-throttle));    // 0..1
        const steerL = clamp01(this.relu(-steer));      // 0..1
        const steerR = clamp01(this.relu(steer));       // 0..1

        const laneChangeIntent = laneScalar;            // 0..1
        const followConvoy = other[0];
        const park = other[1];
        const sigL = other[2];
        const sigR = other[3];
        const stop = other[4];
        const eStop = other[5];

        let out = [accel, brake, steerL, steerR, laneChangeIntent, followConvoy, park, sigL, sigR, Math.max(stop, eStop)];

        // Action smoothing (helps stability)
        const emaA = 0.85;
        for (let i = 0; i < out.length; i++) {
          this.actionEMA[i] = emaA * this.actionEMA[i] + (1 - emaA) * out[i];
        }
        return this.actionEMA.map(v => clamp01(v));
      }

      mutate(rate = 0.10) {
        const mutMat = (M, scale=0.20, lo=-4, hi=4) => {
          for (let i = 0; i < M.length; i++) {
            for (let j = 0; j < M[i].length; j++) {
              if (Math.random() < rate) M[i][j] = clamp(M[i][j] + randn() * scale, lo, hi);
            }
          }
        };
        const mutArr = (A, scale=0.20, lo=-4, hi=4) => {
          for (let i = 0; i < A.length; i++) {
            if (Math.random() < rate) A[i] = clamp(A[i] + randn() * scale, lo, hi);
          }
        };

        // GRU
        mutMat(this.Wz); mutMat(this.Uz); mutArr(this.bz);
        mutMat(this.Wr); mutMat(this.Ur); mutArr(this.br);
        mutMat(this.Wh); mutMat(this.Uh); mutArr(this.bh);

        // MLP + heads
        mutMat(this.W1); mutArr(this.b1);
        mutMat(this.W2); mutArr(this.b2);

        mutMat(this.W_throttle); mutArr(this.b_throttle);
        mutMat(this.W_steer); mutArr(this.b_steer);
        mutMat(this.W_lane); mutArr(this.b_lane);
        mutMat(this.W_other); mutArr(this.b_other);

        Object.keys(this.trafficTraits).forEach(trait => {
          if (Math.random() < rate) {
            this.trafficTraits[trait] = clamp01(this.trafficTraits[trait] + (Math.random() - 0.5) * 0.15);
          }
        });
      }

      copy() {
        const n = new TrafficAI_v2();
        const cMat = (M) => M.map(r => [...r]);
        const cArr = (A) => [...A];

        n.h = [...this.h];
        n.actionEMA = [...this.actionEMA];
        n.trafficTraits = { ...this.trafficTraits };

        n.Wz = cMat(this.Wz); n.Uz = cMat(this.Uz); n.bz = cArr(this.bz);
        n.Wr = cMat(this.Wr); n.Ur = cMat(this.Ur); n.br = cArr(this.br);
        n.Wh = cMat(this.Wh); n.Uh = cMat(this.Uh); n.bh = cArr(this.bh);

        n.W1 = cMat(this.W1); n.b1 = cArr(this.b1);
        n.W2 = cMat(this.W2); n.b2 = cArr(this.b2);

        n.W_throttle = cMat(this.W_throttle); n.b_throttle = cArr(this.b_throttle);
        n.W_steer = cMat(this.W_steer); n.b_steer = cArr(this.b_steer);
        n.W_lane = cMat(this.W_lane); n.b_lane = cArr(this.b_lane);
        n.W_other = cMat(this.W_other); n.b_other = cArr(this.b_other);

        return n;
      }

      // ✅ NEW: soft copy from mentor
      imprintFrom(src, alpha = 0.12) {
        if (!src) return;

        const blendMat = (A, B, lo=-4, hi=4) => {
          for (let i = 0; i < A.length; i++) {
            for (let j = 0; j < A[i].length; j++) {
              A[i][j] = clamp((1 - alpha) * A[i][j] + alpha * B[i][j], lo, hi);
            }
          }
        };
        const blendArr = (A, B, lo=-4, hi=4) => {
          for (let i = 0; i < A.length; i++) A[i] = clamp((1 - alpha) * A[i] + alpha * B[i], lo, hi);
        };

        blendMat(this.Wz, src.Wz); blendMat(this.Uz, src.Uz); blendArr(this.bz, src.bz);
        blendMat(this.Wr, src.Wr); blendMat(this.Ur, src.Ur); blendArr(this.br, src.br);
        blendMat(this.Wh, src.Wh); blendMat(this.Uh, src.Uh); blendArr(this.bh, src.bh);

        blendMat(this.W1, src.W1); blendArr(this.b1, src.b1);
        blendMat(this.W2, src.W2); blendArr(this.b2, src.b2);

        blendMat(this.W_throttle, src.W_throttle); blendArr(this.b_throttle, src.b_throttle);
        blendMat(this.W_steer, src.W_steer); blendArr(this.b_steer, src.b_steer);
        blendMat(this.W_lane, src.W_lane); blendArr(this.b_lane, src.b_lane);
        blendMat(this.W_other, src.W_other); blendArr(this.b_other, src.b_other);

        if (src.trafficTraits) {
          Object.keys(this.trafficTraits).forEach(k => {
            this.trafficTraits[k] = clamp01((1 - alpha) * this.trafficTraits[k] + alpha * src.trafficTraits[k]);
          });
        }

        if (src.actionEMA && this.actionEMA) {
          for (let i = 0; i < this.actionEMA.length; i++) {
            this.actionEMA[i] = (1 - alpha) * this.actionEMA[i] + alpha * src.actionEMA[i];
          }
        }
      }
    }

    // =========================================================
    // TrafficCar
    // =========================================================
    class TrafficCar {
      constructor(x = 0, z = 0) {
        this.brain = createBrain();

        this.mesh = this.createCarMesh();
        this.mesh.position.set(x, 1, z);

        this.velocity = new THREE.Vector3();
        this.acceleration = new THREE.Vector3();
        this.maxSpeed = 20;
        this.minSpeed = 2;

        this.currentLane = null;
        this.targetLane = null;
        this.lanePosition = 0;

        this.lastRoadPositionScore = 0;
        this.isReturningToRoad = false;
        this.turnAngleGoal = 0;
        this.turnProgress = 0;
        this.initialOrientationY = 0;

        this.flockId = -1;
        this.convoyPosition = -1;
        this.convoyLeader = null;
        this.convoyFollowers = [];
        this.followTarget = null;
        this.role = 'driver';

        // Parking system
        this.isParked = false;
        this.parkingSpot = null;
        this.targetParkingLot = null;
        this.parkingQueuePosition = -1;
        this.isParkingApproach = false;
        this.isInApproachLane = false;
        this.isInExitLane = false;
        this.approachTargetPosition = null;
        this.exitTargetPosition = null;
        this.selectedApproachLaneIndex = -1;
        this.selectedExitLaneIndex = -1;
        this.parkingAttempts = 0;
        this.maxParkingAttempts = 3;
        this.departureTime = 0;
        this.isExitingParking = false;

        this.turnSignal = 'none';
        this.laneDiscipline = 0;
        this.followingDistance = FOLLOW_DISTANCE;

        // Fitness & metrics
        this.fitness = 0;
        this.roadTime = 0;
        this.convoyTime = 0;
        this.parkingScore = 0;
        this.trafficViolations = 0;
        this.distanceTraveled = 0;
        this.crashed = false;
        this.timeAlive = epochTime * 0.8 + Math.random() * epochTime * 0.4;

        // Sensors
        this.sensors = Array(16).fill(0);
        this.roadSensors = Array(8).fill(0);
        this.trafficSensors = Array(4).fill(0);
        this.sensorRays = [];
        this.flockLines = [];
        this.neighbors = [];

        this.lastPosition = new THREE.Vector3(x, 1, z);
        this.createSensorRays();
        this.createFlockVisualization();
        this.initializeMovement();

        // Manual control
        this.manualAcceleration = 0;
        this.manualBraking = 0;
        this.manualSteer = 0;

        // ✅ NEW: rescue tether (off-road -> follow on-road mentor)
        this.rescueLeader = null;
        this.rescueTimer = 0;
        this.lastImprintAt = 0;
        this.rescueCooldown = 0;
      }

      createCarMesh() {
        const group = new THREE.Group();

        const bodyGeometry = new THREE.BoxGeometry(1.5, 0.8, 3.5);
        this.bodyMaterial = new THREE.MeshLambertMaterial({
          color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6)
        });
        const body = new THREE.Mesh(bodyGeometry, this.bodyMaterial);
        body.position.y = 0.4;
        body.castShadow = true;
        group.add(body);

        const signalGeometry = new THREE.SphereGeometry(0.15, 6, 4);
        this.leftSignal = new THREE.Mesh(signalGeometry,
          new THREE.MeshLambertMaterial({ color: 0xff8800, transparent: true, opacity: 0.5 }));
        this.leftSignal.position.set(-0.8, 0.8, 1.2);
        group.add(this.leftSignal);

        this.rightSignal = new THREE.Mesh(signalGeometry,
          new THREE.MeshLambertMaterial({ color: 0xff8800, transparent: true, opacity: 0.5 }));
        this.rightSignal.position.set(0.8, 0.8, 1.2);
        group.add(this.rightSignal);

        const indicatorGeometry = new THREE.ConeGeometry(0.2, 0.8, 6);
        this.roleIndicator = new THREE.Mesh(indicatorGeometry,
          new THREE.MeshLambertMaterial({ color: 0xffffff }));
        this.roleIndicator.position.set(0, 1.5, 0);
        group.add(this.roleIndicator);

        const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
        const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });

        this.wheels = [];
        const wheelPositions = [
          [-0.7, 0, 1.4], [0.7, 0, 1.4],
          [-0.7, 0, -1.4], [0.7, 0, -1.4]
        ];

        wheelPositions.forEach((pos) => {
          const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
          wheel.position.set(...pos);
          wheel.rotation.z = Math.PI / 2;
          this.wheels.push(wheel);
          group.add(wheel);
        });

        return group;
      }

      createSensorRays() {
        const sensorMaterial = new THREE.LineBasicMaterial({
          color: 0xff0000, transparent: true, opacity: 0.2
        });

        for (let i = 0; i < 16; i++) {
          const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, 10)
          ]);
          const ray = new THREE.Line(geometry, sensorMaterial);
          this.sensorRays.push(ray);
          this.mesh.add(ray);
        }
      }

      createFlockVisualization() {
        const flockMaterial = new THREE.LineBasicMaterial({
          color: 0x00ff00, transparent: true, opacity: 0.6
        });

        for (let i = 0; i < 10; i++) {
          const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 2, 0),
            new THREE.Vector3(0, 2, 0)
          ]);
          const line = new THREE.Line(geometry, flockMaterial);
          this.flockLines.push(line);
          if (showFlockLines) scene.add(line);
        }
      }

      initializeMovement() {
        const nearestRoad = this.findNearestRoad();
        if (nearestRoad) {
          this.currentLane = nearestRoad.lane;
          this.mesh.rotation.y = nearestRoad.direction;
          this.velocity.set(
            Math.sin(nearestRoad.direction) * 8, 0, Math.cos(nearestRoad.direction) * 8
          );
        } else {
          this.mesh.rotation.y = Math.random() * Math.PI * 2;
          this.velocity.set(
            Math.sin(this.mesh.rotation.y) * 6, 0, Math.cos(this.mesh.rotation.y) * 6
          );
        }
      }

      findNearestRoad() {
        const pos = this.mesh.position;
        let nearestRoadInfo = null;
        let minDistance = Infinity;

        world.roads.forEach(road => {
          let distanceToRoadCenterLine;
          let roadCenterCoord;
          let carRelevantCoord;
          let roadWidth = road.width;

          if (road.direction === 'horizontal') {
            roadCenterCoord = road.z;
            carRelevantCoord = pos.z;
            if (pos.x < road.start || pos.x > road.end) return;
          } else {
            roadCenterCoord = road.x;
            carRelevantCoord = pos.x;
            if (pos.z < road.start || pos.z > road.end) return;
          }

          distanceToRoadCenterLine = Math.abs(carRelevantCoord - roadCenterCoord);

          if (distanceToRoadCenterLine < roadWidth / 2 + 5) {
            if (distanceToRoadCenterLine < minDistance) {
              minDistance = distanceToRoadCenterLine;
              nearestRoadInfo = {
                lane: `${road.type}_${road.direction}`,
                center: roadCenterCoord,
                direction: road.orientationAngle,
                width: roadWidth,
                roadObject: road
              };
            }
          }
        });

        return nearestRoadInfo;
      }

      getRoadPositionScore() {
        const pos = this.mesh.position;
        let maxRoadScore = 0;

        world.roads.forEach(road => {
          let distanceToRoadCenterLine;
          let carRelevantCoord;

          if (road.direction === 'horizontal') {
            if (pos.x < road.start || pos.x > road.end) return;
            carRelevantCoord = pos.z;
            distanceToRoadCenterLine = Math.abs(carRelevantCoord - road.z);
          } else {
            if (pos.z < road.start || pos.z > road.end) return;
            carRelevantCoord = pos.x;
            distanceToRoadCenterLine = Math.abs(carRelevantCoord - road.x);
          }

          if (distanceToRoadCenterLine <= road.width / 2) {
            maxRoadScore = Math.max(maxRoadScore, 1 - (distanceToRoadCenterLine / (road.width / 2)));
          }
        });

        return maxRoadScore;
      }

      updateSensors() {
        const maxDistance = 10;
        const raycaster = new THREE.Raycaster();

        for (let i = 0; i < 16; i++) {
          const angle = (i * Math.PI * 2) / 16;
          const direction = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
          direction.applyQuaternion(this.mesh.quaternion);

          raycaster.set(this.mesh.position, direction);
          const intersects = raycaster.intersectObjects(this.getObstacles(), true);

          if (intersects.length > 0 && intersects[0].distance <= maxDistance) {
            this.sensors[i] = 1 - (intersects[0].distance / maxDistance);
          } else {
            this.sensors[i] = 0;
          }

          const endDistance = intersects.length > 0 ?
            Math.min(intersects[0].distance, maxDistance) : maxDistance;
          const rayEnd = direction.clone().multiplyScalar(endDistance);
          this.sensorRays[i].geometry.setFromPoints([new THREE.Vector3(0, 0, 0), rayEnd]);
        }

        this.updateRoadSensors();
        this.updateTrafficSensors();
      }

      updateRoadSensors() {
        this.roadSensors[0] = this.getRoadPositionScore();
        this.roadSensors[1] = this.getLanePosition();
        this.roadSensors[2] = this.getRoadDirectionAlignment();
        this.roadSensors[3] = this.getDistanceToIntersection();
        this.roadSensors[4] = this.getNearestParkingLotProximity();
        this.roadSensors[5] = this.getParkingAvailability();
        this.roadSensors[6] = this.getTrafficDensity();
        this.roadSensors[7] = this.getOptimalSpeedFactor();
      }

      getLanePosition() {
        const roadInfo = this.findNearestRoad();
        if (!roadInfo || !roadInfo.roadObject) return 0.5;

        const pos = this.mesh.position;
        let laneOffset;
        if (roadInfo.roadObject.direction === 'horizontal') laneOffset = pos.z - roadInfo.center;
        else laneOffset = pos.x - roadInfo.center;

        let normalizedPosition = (laneOffset / (roadInfo.width / 2));
        return clamp01((normalizedPosition + 1) / 2);
      }

      getRoadDirectionAlignment() {
        const roadInfo = this.findNearestRoad();
        if (!roadInfo) return 0.5;

        const carDirectionVector = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);
        const roadDirectionVector = new THREE.Vector3(Math.sin(roadInfo.direction), 0, Math.cos(roadInfo.direction));
        const dotProduct = carDirectionVector.dot(roadDirectionVector);
        return (dotProduct + 1) / 2;
      }

      // placeholders (kept from your original for fun/chaos)
      getDistanceToIntersection() { return Math.random(); }
      getTrafficDensity() { return Math.random() * 0.5; }
      getOptimalSpeedFactor() { return 0.8 + Math.random() * 0.2; }

      getNearestParkingLotProximity() {
        if (!this.targetParkingLot) return 0;
        const dist = this.mesh.position.distanceTo(this.targetParkingLot.center);
        return Math.max(0, 1 - dist / 100);
      }

      getParkingAvailability() {
        if (!this.targetParkingLot) return 0;
        const availableSpots = this.targetParkingLot.spots.filter(spot => !spot.occupied).length;
        return this.targetParkingLot.spots.length > 0 ? availableSpots / this.targetParkingLot.spots.length : 0;
      }

      updateTrafficSensors() {
        this.trafficSensors[0] = this.convoyPosition >= 0 ? 1 : 0;
        this.trafficSensors[1] = this.followTarget ? Math.min(this.mesh.position.distanceTo(this.followTarget.mesh.position) / 20, 1) : 1;
        this.trafficSensors[2] = this.convoyLeader ? Math.max(0, 1 - this.mesh.position.distanceTo(this.convoyLeader.mesh.position) / 50) : 0;
        this.trafficSensors[3] = (this.timeAlive < epochTime * 0.3 && !this.isParked) ? 1 : 0;
      }

      updateConvoyBehavior() {
        this.neighbors = [];
        population.forEach(other => {
          if (other !== this && !other.crashed && !other.isParked) {
            const distance = this.mesh.position.distanceTo(other.mesh.position);
            if (distance < 25) this.neighbors.push(other);
          }
        });
        this.updateRole();
        this.updateConvoyFormation();
      }

      updateRole() {
        const roadPosScore = this.getRoadPositionScore();
        if (this.isParked || this.isParkingApproach || this.isInApproachLane || this.isInExitLane) {
          this.role = 'parker';
        } else if (roadPosScore > 0.8 && this.neighbors.length > 1 && this.brain.trafficTraits.convoyDiscipline > 0.6) {
          this.role = 'leader';
        } else {
          this.role = 'driver';
        }

        if (this.role === 'leader') this.roleIndicator.material.color.setHex(0xff00ff);
        else if (this.role === 'parker') this.roleIndicator.material.color.setHex(0x00ff00);
        else this.roleIndicator.material.color.setHex(0xffffff);
      }

      updateConvoyFormation() {
        if (this.role === 'leader') {
          this.convoyFollowers = this.neighbors
            .filter(car => car.role === 'driver' && !car.convoyLeader && car.brain.trafficTraits.convoyDiscipline > 0.5)
            .sort((a, b) => this.mesh.position.distanceTo(a.mesh.position) - this.mesh.position.distanceTo(b.mesh.position))
            .slice(0, 5);
          this.convoyFollowers.forEach((follower, index) => {
            follower.convoyLeader = this;
            follower.convoyPosition = index + 1;
            follower.followTarget = index === 0 ? this : this.convoyFollowers[index - 1];
          });
        } else if (this.convoyLeader && (this.convoyLeader.crashed || !this.convoyLeader.convoyFollowers.includes(this))) {
          this.convoyLeader = null;
          this.followTarget = null;
          this.convoyPosition = -1;
        }
      }

      getEnhancedInputs() {
        return [
          ...this.sensors,
          ...this.roadSensors,
          ...this.trafficSensors
        ];
      }

      // =========================================================
      // ✅ NEW: rescue tether selection + follow + brain imprinting
      // =========================================================
      selectRescueLeader() {
        if (this.isParkingRelatedState()) return null;

        const myRoad = this.getRoadPositionScore();
        if (myRoad >= GRASS_THRESHOLD) return null;

        let best = null;
        let bestScore = -Infinity;

        for (const other of population) {
          if (other === this) continue;
          if (other.crashed || other.isParked) continue;

          const d = this.mesh.position.distanceTo(other.mesh.position);
          if (d > 35) continue;

          const roadOk = other.getRoadPositionScore();
          if (roadOk < 0.75) continue;

          const roleBonus = (other.role === 'leader') ? 50 : (other.convoyPosition > 0 ? 20 : 0);
          const score = (other.fitness || 0) * 0.15 + roadOk * 100 + roleBonus - d * 1.2;

          if (score > bestScore) {
            bestScore = score;
            best = other;
          }
        }
        return best;
      }

      followRescueLeader(deltaTime) {
        if (!this.rescueLeader || this.rescueLeader.crashed || this.rescueLeader.isParked) {
          this.rescueLeader = null;
          this.rescueTimer = 0;
          return false;
        }

        const leader = this.rescueLeader;
        const dist = this.mesh.position.distanceTo(leader.mesh.position);

        const leaderForward = new THREE.Vector3(0, 0, 1).applyQuaternion(leader.mesh.quaternion);
        const followPoint = leader.mesh.position.clone().sub(leaderForward.multiplyScalar(10));

        this.moveToPosition(followPoint, deltaTime, 6);

        const mySpeed = this.velocity.length();
        const leaderSpeed = leader.velocity.length();
        if (mySpeed < leaderSpeed * 0.7) this.velocity.multiplyScalar(1.05);
        if (mySpeed > leaderSpeed * 1.2) this.velocity.multiplyScalar(0.95);

        const now = performance.now();
        if (dist < 18 && now - this.lastImprintAt > 500) {
          if (this.brain && leader.brain && typeof this.brain.imprintFrom === 'function') {
            this.brain.imprintFrom(leader.brain, AI_MODE === 'v2' ? 0.10 : 0.14);
          }
          this.lastImprintAt = now;
        }

        return true;
      }

      // =========================================================
      // update()
      // =========================================================
      update(deltaTime) {
        if (this.crashed) return;

        // Manual control if follow_best
        if (this === manuallyControlledCar && cameraMode === 'follow_best') {
          this.applyManualControls(deltaTime);
          this.updateVisuals();
          this.checkCollisions();
          this.keepInBounds();
          this.lastPosition.copy(this.mesh.position);
          return;
        }

        // Parked cars
        if (this.isParked) {
          this.handleParkedBehavior(deltaTime);
          this.updateVisuals();
          return;
        }

        this.timeAlive -= deltaTime;
        if (this.timeAlive <= 0 && !this.isParkingApproach && this.parkingAttempts < this.maxParkingAttempts) {
          this.attemptParking();
        }

        this.updateSensors();
        this.updateConvoyBehavior();
        this.updateVisuals();

        // ✅ NEW: rescue tether
        this.rescueCooldown = Math.max(0, this.rescueCooldown - deltaTime);
        const roadScoreNow = this.getRoadPositionScore();

        if (!this.isParkingRelatedState() && roadScoreNow < GRASS_THRESHOLD) {
          if ((!this.rescueLeader || this.rescueLeader.crashed) && this.rescueCooldown <= 0) {
            const mentor = this.selectRescueLeader();
            if (mentor) {
              this.rescueLeader = mentor;
              this.rescueTimer = 5.0;
              this.rescueCooldown = 2.0;
              // also tie visuals / “network” feel
              this.followTarget = mentor;
            }
          }
        }

        // Decide movement
        if (this.rescueLeader && this.rescueTimer > 0) {
          this.rescueTimer -= deltaTime;
          const usedRescue = this.followRescueLeader(deltaTime);

          const backOnRoad = this.getRoadPositionScore() >= 0.55;
          if (!usedRescue || backOnRoad || this.rescueTimer <= 0) {
            this.rescueLeader = null;
            this.rescueTimer = 0;
          }
        } else {
          const inputs = this.getEnhancedInputs();
          const outputs = this.brain.activate(inputs);
          this.applyTrafficMovement(outputs, deltaTime);
        }

        // Fitness/collisions/bounds remain consistent
        this.updateFitness(deltaTime);
        this.lastPosition.copy(this.mesh.position);
        this.checkCollisions();
        this.keepInBounds();

        // Grass behavior (kept)
        const currentRoadPosScore = this.getRoadPositionScore();
        if (currentRoadPosScore < GRASS_THRESHOLD && !this.isReturningToRoad &&
            !this.isParkingApproach && !this.isInApproachLane && !this.isInExitLane &&
            !(this.rescueLeader && this.rescueTimer > 0)) {
          this.isReturningToRoad = true;
          this.turnAngleGoal = Math.PI;
          this.turnProgress = 0;
          this.initialOrientationY = this.mesh.rotation.y;
        }
        this.lastRoadPositionScore = currentRoadPosScore;
      }

      applyManualControls(deltaTime) {
        const moveSpeed = 20.0;
        const turnSpeed = 1.5;

        if (manualControls.W) {
          this.velocity.add(new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion).multiplyScalar(moveSpeed * deltaTime));
        }
        if (manualControls.S) {
          this.velocity.sub(new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion).multiplyScalar(moveSpeed * 0.7 * deltaTime));
        }
        if (!manualControls.W && !manualControls.S) {
          this.velocity.multiplyScalar(0.95);
        }

        if (manualControls.A) this.mesh.rotation.y += turnSpeed * deltaTime;
        if (manualControls.D) this.mesh.rotation.y -= turnSpeed * deltaTime;

        const currentSpeed = this.velocity.length();
        if (currentSpeed > this.maxSpeed) this.velocity.normalize().multiplyScalar(this.maxSpeed);

        this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
        this.wheels.forEach(wheel => wheel.rotation.x += currentSpeed * deltaTime * 0.1);
      }

      handleParkedBehavior(deltaTime) {
        this.velocity.set(0, 0, 0);
        this.departureTime -= deltaTime;

        if (this.departureTime <= 0 && !this.isExitingParking) {
          this.isExitingParking = true;
          if (this.targetParkingLot && this.targetParkingLot.building) {
            this.targetParkingLot.building.visitorCount = Math.max(0, (this.targetParkingLot.building.visitorCount || 0) - 1);
          }
          this.turnAngleGoal = Math.PI;
          this.turnProgress = 0;
          this.initialOrientationY = this.mesh.rotation.y;
        }

        if (this.isExitingParking) {
          const turnSpeedForExit = Math.PI / 2;
          this.mesh.rotation.y += turnSpeedForExit * deltaTime;
          this.turnProgress += turnSpeedForExit * deltaTime;

          if (this.turnProgress >= this.turnAngleGoal) {
            this.mesh.rotation.y = this.initialOrientationY + Math.PI;
            this.isExitingParking = false;
            this.leaveParking();
          }
        }
      }

      applyTrafficMovement(outputs, deltaTime) {
        const [
          acceleration, braking, steerLeft, steerRight,
          laneChangeIntent, followConvoySignal, parkingManeuverSignal,
          turnSignalLeftOutput, turnSignalRightOutput, emergencyStopSignal
        ] = outputs;

        this.turnSignal = 'none';
        if (turnSignalLeftOutput > 0.7) this.turnSignal = 'left';
        if (turnSignalRightOutput > 0.7) this.turnSignal = 'right';

        this.leftSignal.material.opacity = this.turnSignal === 'left' ? (Math.sin(Date.now() * 0.01) * 0.4 + 0.6) : 0.3;
        this.rightSignal.material.opacity = this.turnSignal === 'right' ? (Math.sin(Date.now() * 0.01) * 0.4 + 0.6) : 0.3;

        if (this.isReturningToRoad) {
          const turnSpeedReturn = Math.PI / 1.5;
          this.mesh.rotation.y += turnSpeedReturn * deltaTime;
          this.turnProgress += turnSpeedReturn * deltaTime;
          this.velocity.copy(new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion).multiplyScalar(this.minSpeed * 0.8));
          if (this.turnProgress >= this.turnAngleGoal) {
            this.mesh.rotation.y = this.initialOrientationY + Math.PI;
            this.isReturningToRoad = false;
          }
          this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
          return;
        }

        if (emergencyStopSignal > 0.8) {
          this.velocity.multiplyScalar(0.7);
          return;
        }
        if (parkingManeuverSignal > 0.7 && !this.isParked && !this.isParkingApproach) {
          this.attemptParking();
          return;
        }
        if (this.isParkingApproach || this.isInApproachLane || this.isInExitLane) {
          this.executeParkingLogic(deltaTime);
          return;
        }

        this.followRoad(deltaTime, laneChangeIntent);

        if (followConvoySignal > 0.6 && this.followTarget) {
          this.followConvoyTarget(deltaTime);
        }

        const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);
        if (acceleration > 0.3) this.velocity.add(forward.multiplyScalar(acceleration * 10 * deltaTime));
        if (braking > 0.5) this.velocity.multiplyScalar(1 - braking * deltaTime * 4);

        const steering = (steerRight - steerLeft) * 0.10 * deltaTime * (this.velocity.length() / this.maxSpeed + 0.2);
        this.mesh.rotation.y += steering;

        const currentSpeed = this.velocity.length();
        if (currentSpeed > this.maxSpeed) this.velocity.normalize().multiplyScalar(this.maxSpeed);
        else if (currentSpeed < this.minSpeed && currentSpeed > 0.1) this.velocity.normalize().multiplyScalar(this.minSpeed);
        else if (currentSpeed < 0.1) this.velocity.set(0, 0, 0);

        this.velocity.multiplyScalar(0.99);
        this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
        this.wheels.forEach(wheel => wheel.rotation.x += currentSpeed * deltaTime * 0.1);
      }

      followRoad(deltaTime, laneChangeIntent) {
        const roadInfo = this.findNearestRoad();
        if (!roadInfo || !roadInfo.roadObject) {
          this.fitness -= 2 * deltaTime;
          return;
        }

        const road = roadInfo.roadObject;
        const targetRoadAngle = road.orientationAngle;
        let carAngle = this.mesh.rotation.y;

        while (carAngle - targetRoadAngle > Math.PI) carAngle -= 2 * Math.PI;
        while (targetRoadAngle - carAngle > Math.PI) carAngle += 2 * Math.PI;

        let angleDiff = targetRoadAngle - carAngle;
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        this.mesh.rotation.y += angleDiff * 0.1 * this.brain.trafficTraits.laneKeeping;

        const numLanes = Math.max(1, Math.floor(road.width / ROAD_WIDTH_UNIT));
        let targetLaneIndex = Math.floor(numLanes / 2);

        if (numLanes > 1) {
          if (laneChangeIntent < 0.33) targetLaneIndex = Math.max(0, targetLaneIndex - 1);
          else if (laneChangeIntent > 0.66) targetLaneIndex = Math.min(numLanes - 1, targetLaneIndex + 1);
        }

        const laneCenterOffsetFromRoadEdge = (targetLaneIndex + 0.5) * ROAD_WIDTH_UNIT;

        if (road.direction === 'horizontal') {
          const targetLaneCenterCoord = (road.z - road.width / 2) + laneCenterOffsetFromRoadEdge;
          const offsetFromTargetLane = this.mesh.position.z - targetLaneCenterCoord;
          this.velocity.z -= offsetFromTargetLane * 0.2 * this.brain.trafficTraits.laneKeeping * deltaTime;
          if (Math.abs(offsetFromTargetLane) > ROAD_WIDTH_UNIT / 2) {
            this.trafficViolations++; laneViolations++;
          }
        } else {
          const targetLaneCenterCoord = (road.x - road.width / 2) + laneCenterOffsetFromRoadEdge;
          const offsetFromTargetLane = this.mesh.position.x - targetLaneCenterCoord;
          this.velocity.x -= offsetFromTargetLane * 0.2 * this.brain.trafficTraits.laneKeeping * deltaTime;
          if (Math.abs(offsetFromTargetLane) > ROAD_WIDTH_UNIT / 2) {
            this.trafficViolations++; laneViolations++;
          }
        }

        this.roadTime += deltaTime;
        this.laneDiscipline = Math.max(0, 1 - (this.trafficViolations / (this.roadTime + 1)) * 0.1);
      }

      followConvoyTarget(deltaTime) {
        if (!this.followTarget || this.followTarget.crashed) {
          this.convoyLeader = null; this.followTarget = null; this.convoyPosition = -1;
          return;
        }

        const targetPos = this.followTarget.mesh.position;
        const distance = this.mesh.position.distanceTo(targetPos);
        const idealDistance = FOLLOW_DISTANCE + (this.convoyPosition * 2.5);

        const directionToTarget = targetPos.clone().sub(this.mesh.position).normalize();

        if (distance > idealDistance + 2) {
          this.velocity.add(directionToTarget.multiplyScalar(this.brain.trafficTraits.followingBehavior * 5 * deltaTime));
        } else if (distance < idealDistance - 1) {
          this.velocity.multiplyScalar(1 - (1 - this.brain.trafficTraits.followingBehavior) * 0.5 * deltaTime);
        }

        const targetAngle = Math.atan2(directionToTarget.x, directionToTarget.z);
        let carAngle = this.mesh.rotation.y;
        while (carAngle - targetAngle > Math.PI) carAngle -= 2 * Math.PI;
        while (targetAngle - carAngle > Math.PI) carAngle += 2 * Math.PI;
        this.mesh.rotation.y += (targetAngle - carAngle) * 0.05;

        this.convoyTime += deltaTime;
        this.followingDistance = distance;
      }

      executeParkingLogic(deltaTime) {
        if (!this.targetParkingLot) { this.isParkingApproach = false; return; }

        if (this.isInExitLane) this.handleExitLane(deltaTime);
        else if (this.isInApproachLane) this.handleApproachLaneMovement(deltaTime);
        else if (this.isParkingApproach) this.moveTowardsParkingEntry(deltaTime);
      }

      moveTowardsParkingEntry(deltaTime) {
        if (!this.targetParkingLot.approachLanes || this.targetParkingLot.approachLanes.length === 0) {
          this.isParkingApproach = false; return;
        }

        let bestLaneEntry = null;
        let selectedLaneIdx = -1;

        this.targetParkingLot.approachLanes.forEach((laneQueuePositions, idx) => {
          if (laneQueuePositions.length > 0) {
            const entryPoint = laneQueuePositions[0];
            const occupied = population.some(car =>
              car !== this &&
              car.isInApproachLane &&
              car.selectedApproachLaneIndex === idx &&
              car.mesh.position.distanceTo(entryPoint) < 5
            );
            if (!occupied && !bestLaneEntry) {
              bestLaneEntry = entryPoint;
              selectedLaneIdx = idx;
            }
          }
        });

        if (bestLaneEntry) {
          this.approachTargetPosition = bestLaneEntry;
          this.selectedApproachLaneIndex = selectedLaneIdx;
          this.moveToPosition(this.approachTargetPosition, deltaTime, 3);
          if (this.mesh.position.distanceTo(this.approachTargetPosition) < 2) {
            this.isInApproachLane = true;
            this.isParkingApproach = false;
          }
        } else {
          this.velocity.multiplyScalar(0.9);
          this.parkingAttempts++;
          if (this.parkingAttempts >= this.maxParkingAttempts) this.isParkingApproach = false;
        }
      }

      handleApproachLaneMovement(deltaTime) {
        if (!this.targetParkingLot || !this.targetParkingLot.spots) {
          this.isInApproachLane = false; return;
        }
        const availableSpot = this.targetParkingLot.spots.find(spot => !spot.occupied);
        if (availableSpot) {
          this.moveToPosition(availableSpot.position, deltaTime, 2);
          if (this.mesh.position.distanceTo(availableSpot.position) < 1.5) {
            this.completeParkingProcess(availableSpot);
          }
        } else {
          this.velocity.multiplyScalar(0.95);
        }
      }

      completeParkingProcess(spot) {
        this.isParked = true;
        this.parkingSpot = spot;
        spot.occupied = true;
        spot.car = this;
        this.mesh.position.copy(spot.position);
        this.mesh.rotation.y = spot.orientation !== undefined ? spot.orientation : this.mesh.rotation.y;
        this.velocity.set(0, 0, 0);
        this.parkingScore += 100;
        parkingEvents++;
        this.isInApproachLane = false;
        this.isParkingApproach = false;
        this.departureTime = 15 + Math.random() * 5;
        if (this.targetParkingLot && this.targetParkingLot.building) {
          this.targetParkingLot.building.visitorCount = (this.targetParkingLot.building.visitorCount || 0) + 1;
        }
        this.updateCarColor();
      }

      handleExitLane(deltaTime) {
        if (!this.exitTargetPosition) {
          this.isInExitLane = false;
          this.role = 'driver';
          this.timeAlive = epochTime * 0.5;
          return;
        }
        this.moveToPosition(this.exitTargetPosition, deltaTime, 4);
        if (this.mesh.position.distanceTo(this.exitTargetPosition) < 2) {
          this.isInExitLane = false;
          this.role = 'driver';
          this.timeAlive = epochTime * 0.7;
          this.initializeMovement();
          this.updateCarColor();
        }
      }

      leaveParking() {
        if (!this.isParked && !this.isInExitLane) return;

        if (this.parkingSpot) {
          this.parkingSpot.occupied = false;
          this.parkingSpot.car = null;
          this.parkingSpot = null;
        }
        this.isParked = false;

        if (this.targetParkingLot && this.targetParkingLot.exitLanes && this.targetParkingLot.exitLanes.length > 0) {
          this.selectedExitLaneIndex = 0;
          const exitLanePoints = this.targetParkingLot.exitLanes[this.selectedExitLaneIndex];
          if (exitLanePoints && exitLanePoints.length > 0) {
            this.exitTargetPosition = exitLanePoints[exitLanePoints.length - 1];
            this.isInExitLane = true;
            this.isExitingParking = false;
          } else {
            this.role = 'driver';
            this.initializeMovement();
          }
        } else {
          this.role = 'driver';
          this.initializeMovement();
        }
        this.updateCarColor();
      }

      attemptParking() {
        if (this.isParked || this.isParkingApproach) return;
        this.role = 'parker';
        this.updateRole();
        this.findNearestParkingLotForAI();

        if (!this.targetParkingLot) {
          this.parkingAttempts++;
          this.role = 'driver'; this.updateRole();
          this.timeAlive = epochTime * 0.2;
          return;
        }
        this.isParkingApproach = true;
        this.parkingAttempts = 0;
      }

      findNearestParkingLotForAI() {
        let closestLot = null;
        let minDist = Infinity;
        world.parkingLots.forEach(lot => {
          const dist = this.mesh.position.distanceTo(lot.center);
          if (dist < minDist) {
            minDist = dist;
            closestLot = lot;
          }
        });
        this.targetParkingLot = closestLot;
      }

      moveToPosition(targetPos, deltaTime, speed) {
        const direction = targetPos.clone().sub(this.mesh.position);
        const distance = direction.length();

        if (distance > 0.5) {
          direction.normalize();
          this.velocity.copy(direction.multiplyScalar(speed));

          const targetAngle = Math.atan2(direction.x, direction.z);
          let currentAngle = this.mesh.rotation.y;
          while (targetAngle - currentAngle > Math.PI) currentAngle += 2 * Math.PI;
          while (currentAngle - targetAngle > Math.PI) currentAngle -= 2 * Math.PI;
          this.mesh.rotation.y += (targetAngle - currentAngle) * 0.2;

          this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
        } else {
          this.velocity.set(0, 0, 0);
        }
      }

      updateFitness(deltaTime) {
        const distance = this.mesh.position.distanceTo(this.lastPosition);
        this.distanceTraveled += distance;

        let fitnessScore = this.distanceTraveled * 0.5;
        fitnessScore += this.roadTime * 1.5;
        fitnessScore += this.convoyTime * 1.0;
        fitnessScore += this.parkingScore * 0.5;
        fitnessScore -= this.trafficViolations * 5;

        if (this.getRoadPositionScore() < GRASS_THRESHOLD && !this.isReturningToRoad && !(this.rescueLeader && this.rescueTimer > 0)) {
          fitnessScore -= 10 * deltaTime;
        }
        if (this.crashed) fitnessScore -= 500;

        this.fitness = fitnessScore;
      }

      updateVisuals() {
        this.updateCarColor();
        this.updateFlockVisualization();
        this.updateRole();
      }

      updateCarColor() {
        let hue = 0.6, saturation = 0.7, lightness = 0.5;
        if (this.isParked) { hue = 0.33; lightness = 0.7; }
        else if (this.role === 'leader') { hue = 0.83; saturation = 1.0; lightness = 0.6; }
        else if (this.convoyPosition > 0) { hue = 0.5; saturation = 0.8; lightness = 0.6; }
        else if (this.getRoadPositionScore() < GRASS_THRESHOLD) { hue = 0.1; saturation = 1.0; }

        const performanceBonus = Math.min(Math.max(0, this.fitness) / 1000, 0.2);
        lightness = Math.min(1, lightness + performanceBonus);
        this.bodyMaterial.color.setHSL(hue, saturation, lightness);
      }

      updateFlockVisualization() {
        let lineIdx = 0;

        if (showFlockLines) {
          if (this.role === 'leader' && this.convoyFollowers) {
            this.convoyFollowers.forEach(follower => {
              if (lineIdx < this.flockLines.length && follower) {
                this.flockLines[lineIdx].geometry.setFromPoints([this.mesh.position, follower.mesh.position]);
                this.flockLines[lineIdx].material.color.setHex(0xff00ff);
                this.flockLines[lineIdx].visible = true;
                lineIdx++;
              }
            });
          } else if (this.followTarget) {
            if (lineIdx < this.flockLines.length) {
              this.flockLines[lineIdx].geometry.setFromPoints([this.mesh.position, this.followTarget.mesh.position]);
              // rescue tether is yellow-ish, convoy tether is cyan-ish
              const isRescue = (this.rescueLeader && this.followTarget === this.rescueLeader && this.rescueTimer > 0);
              this.flockLines[lineIdx].material.color.setHex(isRescue ? 0xffdd33 : 0x00ffff);
              this.flockLines[lineIdx].visible = true;
              lineIdx++;
            }
          }
        }

        for (let i = lineIdx; i < this.flockLines.length; i++) this.flockLines[i].visible = false;
      }

      getObstacles() {
        let obstacles = [];
        population.forEach(car => { if (car !== this && !car.crashed) obstacles.push(car.mesh); });
        world.buildings.forEach(b => obstacles.push(b.mesh));
        return obstacles;
      }

      checkCollisions() {
        if (this.crashed) return;
        const carBox = new THREE.Box3().setFromObject(this.mesh);

        population.forEach(otherCar => {
          if (otherCar !== this && !otherCar.crashed) {
            const otherBox = new THREE.Box3().setFromObject(otherCar.mesh);
            if (carBox.intersectsBox(otherBox)) {
              const separationVector = this.mesh.position.clone().sub(otherCar.mesh.position).normalize().multiplyScalar(0.2);
              this.mesh.position.add(separationVector);
              otherCar.mesh.position.sub(separationVector);
              this.velocity.multiplyScalar(0.8); otherCar.velocity.multiplyScalar(0.8);
              this.fitness -= 5; otherCar.fitness -= 5;
              this.trafficViolations++; otherCar.trafficViolations++;

              if (Math.random() < 0.01 && !this.isParkingRelatedState() && !otherCar.isParkingRelatedState()) {
                this.crashed = true; crashCount++;
              }
            }
          }
        });

        world.buildings.forEach(buildingData => {
          const buildingBox = new THREE.Box3().setFromObject(buildingData.mesh);
          if (carBox.intersectsBox(buildingBox)) {
            this.crashed = true; crashCount++;
          }
        });
      }

      isParkingRelatedState() {
        return this.isParked || this.isParkingApproach || this.isInApproachLane || this.isInExitLane;
      }

      keepInBounds() {
        const bounds = 400;
        if (Math.abs(this.mesh.position.x) > bounds || Math.abs(this.mesh.position.z) > bounds) {
          this.mesh.position.x = clamp(this.mesh.position.x, -bounds, bounds);
          this.mesh.position.z = clamp(this.mesh.position.z, -bounds, bounds);
          this.velocity.multiplyScalar(-0.5);
          this.fitness -= 20;
        }
      }

      destroy() {
        if (this.parkingSpot) {
          this.parkingSpot.occupied = false; this.parkingSpot.car = null;
        }
        if (this.targetParkingLot && this.targetParkingLot.building && this.isParked) {
          this.targetParkingLot.building.visitorCount = Math.max(0, (this.targetParkingLot.building.visitorCount || 0) - 1);
        }

        this.flockLines.forEach(line => { if (line.parent) scene.remove(line); });
        if (this.mesh.parent) scene.remove(this.mesh);
      }
    }

    // =========================================================
    // Three.js setup
    // =========================================================
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 300, 1000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(0, 150, 150);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x606060);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 150, 75);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 50;
      directionalLight.shadow.camera.far = 500;
      directionalLight.shadow.camera.left = -200;
      directionalLight.shadow.camera.right = 200;
      directionalLight.shadow.camera.top = 200;
      directionalLight.shadow.camera.bottom = -200;
      scene.add(directionalLight);

      createTrafficWorld();
      createInitialPopulation();

      clock = new THREE.Clock();

      window.addEventListener('resize', onWindowResize);
      setupEventListeners();

      updateBrainUILabel();
      animate();
    }

    function createTrafficWorld() {
      const groundGeometry = new THREE.PlaneGeometry(1200, 1200);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3c763d });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);

      createRoadNetwork();
      createBuildingsWithParkingLots();
    }

    function createRoad(x, z, width, length, type, orientationAngle, isHorizontal) {
      const roadHeight = 0.1;
      const roadMaterial = new THREE.MeshLambertMaterial({ color: type === 'highway' ? 0x333333 : 0x444444 });
      const roadGeometry = new THREE.PlaneGeometry(isHorizontal ? length : width, isHorizontal ? width : length);
      const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
      roadMesh.rotation.x = -Math.PI / 2;
      roadMesh.position.set(x, roadHeight, z);
      roadMesh.receiveShadow = true;
      scene.add(roadMesh);

      const roadData = {
        mesh: roadMesh,
        x, z,
        width, length,
        type,
        direction: isHorizontal ? 'horizontal' : 'vertical',
        orientationAngle,
        start: isHorizontal ? x - length / 2 : z - length / 2,
        end: isHorizontal ? x + length / 2 : z + length / 2,
        lanes: []
      };
      world.roads.push(roadData);

      const numLanes = Math.max(1, Math.floor(width / ROAD_WIDTH_UNIT));
      const actualLaneWidth = width / numLanes;
      const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const yellowLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });

      for (let i = 0; i < numLanes; i++) {
        const laneCenterOffset = (i - (numLanes - 1) / 2) * actualLaneWidth;
        if (i < numLanes - 1) {
          let linePosX, linePosZ, lineWidth, lineHeight;
          const lineOffsetFromLaneCenter = actualLaneWidth / 2;

          if (isHorizontal) {
            linePosX = x;
            linePosZ = z + laneCenterOffset + lineOffsetFromLaneCenter;
            lineWidth = length;
            lineHeight = 0.2;
          } else {
            linePosX = x + laneCenterOffset + lineOffsetFromLaneCenter;
            linePosZ = z;
            lineWidth = 0.2;
            lineHeight = length;
          }

          const isCenterDivider = numLanes > 1 && Math.abs(laneCenterOffset + lineOffsetFromLaneCenter) < actualLaneWidth * 0.6;
          createDashedLineWorld(linePosX, linePosZ, lineWidth, lineHeight, isHorizontal, isCenterDivider ? yellowLineMaterial : lineMaterial, roadHeight + 0.01);
        }
      }
    }

    function createDashedLineWorld(centerX, centerZ, totalLength, totalWidth, isHorizontal, material, yPos) {
      const dashLength = 5;
      const gapLength = 3;
      const numDashes = Math.floor(totalLength / (dashLength + gapLength));

      for (let j = 0; j < numDashes; j++) {
        const dashGeometry = new THREE.PlaneGeometry(
          isHorizontal ? dashLength : totalWidth,
          isHorizontal ? totalWidth : dashLength
        );
        const dash = new THREE.Mesh(dashGeometry, material);
        dash.rotation.x = -Math.PI / 2;

        const dashOffset = j * (dashLength + gapLength) - totalLength / 2 + dashLength / 2;
        if (isHorizontal) dash.position.set(centerX + dashOffset, yPos, centerZ);
        else dash.position.set(centerX, yPos, centerZ + dashOffset);

        scene.add(dash);
      }
    }

    function createRoadNetwork() {
      world.roads = [];
      createRoad(0, 0, ROAD_WIDTH_UNIT * 4, 800, 'highway', 0, true);
      createRoad(0, 0, ROAD_WIDTH_UNIT * 4, 800, 'highway', Math.PI / 2, false);

      createRoad(0, ROAD_SPACING, ROAD_WIDTH_UNIT * 2, 800, 'secondary', 0, true);
      createRoad(0, -ROAD_SPACING, ROAD_WIDTH_UNIT * 2, 800, 'secondary', 0, true);
      createRoad(ROAD_SPACING, 0, ROAD_WIDTH_UNIT * 2, 800, 'secondary', Math.PI / 2, false);
      createRoad(-ROAD_SPACING, 0, ROAD_WIDTH_UNIT * 2, 800, 'secondary', Math.PI / 2, false);

      createRoad(0, ROAD_SPACING * 2, ROAD_WIDTH_UNIT * 2, 800, 'local', 0, true);
      createRoad(0, -ROAD_SPACING * 2, ROAD_WIDTH_UNIT * 2, 800, 'local', 0, true);
      createRoad(ROAD_SPACING * 2, 0, ROAD_WIDTH_UNIT * 2, 800, 'local', Math.PI / 2, false);
      createRoad(-ROAD_SPACING * 2, 0, ROAD_WIDTH_UNIT * 2, 800, 'local', Math.PI / 2, false);
    }

    function createBuildingsWithParkingLots() {
      world.buildings = [];
      world.parkingLots = [];

      const buildingBaseMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
      const parkingMaterial = new THREE.MeshLambertMaterial({ color: 0x383838 });
      const spotMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
      const barGraphMaterial = new THREE.MeshLambertMaterial({ color: 0x007bff });

      const buildingLocations = [
        { x: -100, z: -100 }, { x: 100, z: -100 },
        { x: -100, z: 100 }, { x: 100, z: 100 },
        { x: -250, z: -50 }, { x: 250, z: 50 },
        { x: -50, z: -250 }, { x: 50, z: 250 },
      ];

      buildingLocations.forEach((loc) => {
        const bWidth = 20 + Math.random() * 15;
        const bHeight = 15 + Math.random() * 25;
        const bDepth = 20 + Math.random() * 15;

        const buildingGeometry = new THREE.BoxGeometry(bWidth, bHeight, bDepth);
        const buildingMesh = new THREE.Mesh(buildingGeometry, buildingBaseMaterial.clone());
        buildingMesh.material.color.setHSL(Math.random(), 0.5, 0.6);
        buildingMesh.position.set(loc.x, bHeight / 2 + 0.1, loc.z);
        buildingMesh.castShadow = true;
        scene.add(buildingMesh);

        const barGeometry = new THREE.BoxGeometry(5, 1, 5);
        const barGraphMesh = new THREE.Mesh(barGeometry, barGraphMaterial.clone());
        barGraphMesh.position.set(loc.x, bHeight + 0.1 + 3, loc.z);
        barGraphMesh.scale.y = 0.1;
        barGraphMesh.visible = true;
        scene.add(barGraphMesh);

        const buildingData = { mesh: buildingMesh, parkingLot: null, visitorCount: 0, barGraphMesh, height: bHeight };
        world.buildings.push(buildingData);

        const lotWidth = 40, lotDepth = 30;
        const lotCenterX = loc.x + bWidth / 2 + lotWidth / 2 + 5;
        const lotCenterZ = loc.z;

        const lotGeometry = new THREE.PlaneGeometry(lotWidth, lotDepth);
        const lotMesh = new THREE.Mesh(lotGeometry, parkingMaterial);
        lotMesh.rotation.x = -Math.PI / 2;
        lotMesh.position.set(lotCenterX, 0.05, lotCenterZ);
        scene.add(lotMesh);

        const parkingLot = {
          center: new THREE.Vector3(lotCenterX, 0.1, lotCenterZ),
          spots: [],
          approachLanes: [], exitLanes: [], accessPoints: [],
          building: buildingData
        };
        buildingData.parkingLot = parkingLot;

        const numRows = 2, spotsPerRow = 5;
        for (let r = 0; r < numRows; r++) {
          for (let s = 0; s < spotsPerRow; s++) {
            const spotX = lotCenterX + (s - (spotsPerRow - 1) / 2) * (PARKING_SPOT_SIZE.width + 2);
            const spotZ = lotCenterZ + (r - (numRows - 1) / 2) * (PARKING_SPOT_SIZE.length + 3);
            const spotOrientation = Math.PI / 2;

            const spotPlaneGeom = new THREE.PlaneGeometry(PARKING_SPOT_SIZE.width, PARKING_SPOT_SIZE.length);
            const spotPlaneMesh = new THREE.Mesh(spotPlaneGeom, spotMaterial);
            spotPlaneMesh.rotation.x = -Math.PI / 2;
            spotPlaneMesh.rotation.z = spotOrientation;
            spotPlaneMesh.position.set(spotX, 0.06, spotZ);
            scene.add(spotPlaneMesh);

            parkingLot.spots.push({
              position: new THREE.Vector3(spotX, 1, spotZ),
              orientation: spotOrientation,
              occupied: false, car: null, mesh: spotPlaneMesh
            });
          }
        }

        parkingLot.approachLanes.push([new THREE.Vector3(lotCenterX - lotWidth / 2 - 5, 1, lotCenterZ)]);
        parkingLot.exitLanes.push([new THREE.Vector3(lotCenterX - lotWidth / 2 - 10, 1, lotCenterZ + 5)]);

        world.parkingLots.push(parkingLot);
      });
    }

    function createInitialPopulation() {
      population = [];
      const startPositions = [
        { x: -50, z: 0 }, { x: 50, z: 0 }, { x: 0, z: -50 }, { x: 0, z: 50 },
        { x: -ROAD_SPACING, z: 0 }, { x: ROAD_SPACING, z: 0 },
        { x: 0, z: -ROAD_SPACING }, { x: 0, z: ROAD_SPACING },
      ];
      for (let i = 0; i < populationSize; i++) {
        const pos = startPositions[i % startPositions.length];
        const car = new TrafficCar(pos.x + Math.random() * 10 - 5, pos.z + Math.random() * 10 - 5);
        population.push(car);
        scene.add(car.mesh);
      }
    }

    function evolvePopulation() {
      population.sort((a, b) => (b.fitness || 0) - (a.fitness || 0));
      bestFitness = population[0] ? population[0].fitness : 0;

      const eliteCount = Math.floor(populationSize * 0.1);
      const survivors = population.slice(0, eliteCount);

      const newPopulation = [];

      survivors.forEach(parent => {
        const offspring = new TrafficCar(parent.mesh.position.x, parent.mesh.position.z);
        offspring.brain = parent.brain.copy();
        newPopulation.push(offspring);
      });

      while (newPopulation.length < populationSize) {
        const parent = survivors[Math.floor(Math.random() * survivors.length)];
        const offspring = new TrafficCar(parent.mesh.position.x, parent.mesh.position.z);
        offspring.brain = parent.brain.copy();
        offspring.brain.mutate(0.1);
        newPopulation.push(offspring);
      }

      population.forEach(car => car.destroy());
      population = newPopulation;
      population.forEach(car => scene.add(car.mesh));

      epoch++;
      timeLeft = epochTime;
      crashCount = 0; parkingEvents = 0; laneViolations = 0;

      world.parkingLots.forEach(lot => {
        if (lot.building) lot.building.visitorCount = 0;
        lot.spots.forEach(spot => { spot.occupied = false; spot.car = null; });
      });

      console.log(`Epoch ${epoch}: Best Fitness: ${bestFitness.toFixed(1)} | Brain: ${AI_MODE.toUpperCase()}`);
    }

    function animate() {
      requestAnimationFrame(animate);
      const deltaTime = Math.min(clock.getDelta() * speedMultiplier, 0.1);

      if (!paused) {
        timeLeft -= deltaTime;
        if (timeLeft <= 0) evolvePopulation();

        updatePopulation(deltaTime);
        updateCamera();
        updateUI();
      }
      renderer.render(scene, camera);
    }

    function updatePopulation(deltaTime) {
      let currentStats = {
        alive: 0, leaders: 0, convoy: 0, parked: 0, solo: 0,
        maxConvoySize: 0, totalRoadTime: 0, totalViolations: 0,
        totalFollowingDistance: 0, followingCount: 0, approaching: 0
      };

      population.forEach(car => {
        if (!car.crashed) {
          car.update(deltaTime);
          currentStats.alive++;

          if (car.isParked) currentStats.parked++;
          else if (car.isParkingApproach || car.isInApproachLane) currentStats.approaching++;
          else if (car.role === 'leader') currentStats.leaders++;
          else if (car.convoyPosition > 0) {
            currentStats.convoy++;
            if (car.followTarget) {
              currentStats.totalFollowingDistance += car.mesh.position.distanceTo(car.followTarget.mesh.position);
              currentStats.followingCount++;
            }
          } else currentStats.solo++;

          if (car.role === 'leader' && car.convoyFollowers)
            currentStats.maxConvoySize = Math.max(currentStats.maxConvoySize, car.convoyFollowers.length + 1);

          currentStats.totalRoadTime += car.roadTime;
          currentStats.totalViolations += car.trafficViolations;
        }
      });

      window.populationStats = currentStats;
    }

    function updateCamera() {
      let targetCar = null;

      if (cameraMode === 'follow_best') {
        targetCar = population.filter(c => !c.crashed && !c.isParked).sort((a, b) => b.fitness - a.fitness)[0];
        manuallyControlledCar = targetCar;
      } else if (cameraMode === 'follow_convoy') {
        targetCar = population.filter(c => c.role === 'leader' && c.convoyFollowers.length > 0)
          .sort((a, b) => b.convoyFollowers.length - a.convoyFollowers.length)[0];
        manuallyControlledCar = null;
      } else {
        manuallyControlledCar = null;
      }

      if (targetCar) {
        const offset = new THREE.Vector3(0, 30, -25);
        const targetPosition = targetCar.mesh.position.clone().add(offset.applyQuaternion(targetCar.mesh.quaternion));
        camera.position.lerp(targetPosition, 0.05);
        camera.lookAt(targetCar.mesh.position);
      } else {
        camera.position.lerp(new THREE.Vector3(0, 200, 200), 0.02);
        camera.lookAt(0, 0, 0);
      }
    }

    function updateUI() {
      const stats = window.populationStats || {};

      document.getElementById('epoch').textContent = epoch;
      document.getElementById('epochTime').textContent = Math.ceil(timeLeft);
      document.getElementById('timeProgress').style.width = `${((epochTime - timeLeft) / epochTime) * 100}%`;

      document.getElementById('population').textContent = stats.alive || 0;
      document.getElementById('bestFitness').textContent = Math.round(bestFitness);
      document.getElementById('trafficIQ').textContent = Math.round(50 + (bestFitness / 50));
      document.getElementById('roadMastery').textContent =
        stats.alive > 0 ? Math.round((stats.totalRoadTime / stats.alive) / epochTime * 100) : 0;

      document.getElementById('crashCount').textContent = crashCount;
      document.getElementById('parkingEvents').textContent = parkingEvents;
      document.getElementById('laneViolations').textContent = laneViolations;

      document.getElementById('leaderCount').textContent = stats.leaders || 0;
      document.getElementById('convoyCount').textContent = stats.convoy || 0;
      document.getElementById('parkedCount').textContent = stats.parked || 0;
      document.getElementById('soloCount').textContent = stats.solo || 0;
      document.getElementById('largestConvoy').textContent = stats.maxConvoySize || 0;

      // some extra “fun” stats shown in right panels (kept lightweight)
      const laneDisc = stats.alive ? clamp01(1 - (stats.totalViolations / (stats.alive * 50))) : 0;
      document.getElementById('laneDiscipline').textContent = Math.round(laneDisc * 100);
      const avgFollow = stats.followingCount ? (stats.totalFollowingDistance / stats.followingCount) : 0;
      document.getElementById('followingDistance').textContent = avgFollow.toFixed(1);
      const roadAdh = stats.alive ? Math.round((stats.totalRoadTime / (stats.alive * epochTime)) * 100) : 0;
      document.getElementById('roadAdherence').textContent = roadAdh;
      document.getElementById('turnSignals').textContent = Math.round((Math.random() * 30 + 40)); // playful placeholder

      const spotsTotal = world.parkingLots.reduce((a, lot) => a + lot.spots.length, 0);
      const spotsUsed = world.parkingLots.reduce((a, lot) => a + lot.spots.filter(s => s.occupied).length, 0);
      document.getElementById('spotsOccupied').textContent = `${spotsUsed}/${spotsTotal}`;
      document.getElementById('parkingSuccess').textContent = spotsTotal ? Math.round((spotsUsed / spotsTotal) * 100) : 0;
      document.getElementById('queueEfficiency').textContent = Math.round(60 + Math.random() * 30);

      // Update building bar graphs
      world.buildings.forEach(buildingData => {
        if (buildingData.barGraphMesh) {
          const scaleY = Math.max(0.1, buildingData.visitorCount * 2);
          buildingData.barGraphMesh.scale.y = scaleY;
          buildingData.barGraphMesh.position.y = buildingData.height + 0.1 + 3 + (scaleY / 2) * buildingData.barGraphMesh.geometry.parameters.height;
        }
      });

      updateTopPerformersDisplay();
      document.getElementById('brainModeLabel').textContent = (AI_MODE === 'v2') ? 'V2' : 'V1';
    }

    function updateTopPerformersDisplay() {
      const sorted = [...population].filter(car => !car.crashed).sort((a, b) => b.fitness - a.fitness).slice(0, 5);
      const topPerformersDiv = document.getElementById('topPerformers');
      topPerformersDiv.innerHTML = '';
      sorted.forEach((car, i) => {
        const div = document.createElement('div');
        div.innerHTML = `${i + 1}. F:${Math.round(car.fitness)} Role:${car.role}${car.rescueLeader ? ' 🧲' : ''}`;
        topPerformersDiv.appendChild(div);
      });
    }

    function updateBrainUILabel() {
      const btn = document.getElementById('brainBtn');
      btn.textContent = `Brain: ${AI_MODE === 'v2' ? 'V2' : 'V1'}`;
      document.getElementById('brainModeLabel').textContent = (AI_MODE === 'v2') ? 'V2' : 'V1';
    }

    function setupEventListeners() {
      document.getElementById('pauseBtn').addEventListener('click', () => {
        paused = !paused;
        document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
      });

      document.getElementById('resetBtn').addEventListener('click', resetSimulation);

      document.getElementById('speedBtn').addEventListener('click', () => {
        speedMultiplier = speedMultiplier === 1 ? 2 : speedMultiplier === 2 ? 5 : 1;
        document.getElementById('speedBtn').textContent = `Speed: ${speedMultiplier}x`;
      });

      document.getElementById('viewBtn').addEventListener('click', () => {
        const modes = ['overview', 'follow_best', 'follow_convoy'];
        cameraMode = modes[(modes.indexOf(cameraMode) + 1) % modes.length];
        document.getElementById('viewBtn').textContent =
          `View: ${cameraMode.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}`;
      });

      document.getElementById('brainBtn').addEventListener('click', () => {
        AI_MODE = (AI_MODE === 'v2') ? 'v1' : 'v2';
        updateBrainUILabel();
        // Minimal swap behavior: affects NEW offspring + new resets.
        // (You can reset to see immediate effect.)
      });

      document.getElementById('flockBtn').addEventListener('click', () => {
        showFlockLines = !showFlockLines;
        document.getElementById('flockBtn').textContent = `Networks: ${showFlockLines ? 'ON' : 'OFF'}`;
        population.forEach(car => car.flockLines.forEach(line => line.visible = showFlockLines && (line.parent === scene)));
      });

      document.getElementById('trafficBtn').addEventListener('click', () => {
        trafficRules = !trafficRules;
        document.getElementById('trafficBtn').textContent = `Traffic Rules: ${trafficRules ? 'ON' : 'OFF'}`;
      });

      document.addEventListener('keydown', (event) => {
        if (manuallyControlledCar && cameraMode === 'follow_best') {
          if (event.key === 'w' || event.key === 'W') manualControls.W = true;
          if (event.key === 's' || event.key === 'S') manualControls.S = true;
          if (event.key === 'a' || event.key === 'A') manualControls.A = true;
          if (event.key === 'd' || event.key === 'D') manualControls.D = true;
        }
      });

      document.addEventListener('keyup', (event) => {
        if (manuallyControlledCar && cameraMode === 'follow_best') {
          if (event.key === 'w' || event.key === 'W') manualControls.W = false;
          if (event.key === 's' || event.key === 'S') manualControls.S = false;
          if (event.key === 'a' || event.key === 'A') manualControls.A = false;
          if (event.key === 'd' || event.key === 'D') manualControls.D = false;
        }
      });
    }

    function resetSimulation() {
      epoch = 1; timeLeft = epochTime; bestFitness = 0; crashCount = 0; parkingEvents = 0; laneViolations = 0;

      population.forEach(car => car.destroy());

      world.buildings.forEach(buildingData => {
        buildingData.visitorCount = 0;
        if (buildingData.barGraphMesh) {
          buildingData.barGraphMesh.scale.y = 0.1;
          buildingData.barGraphMesh.position.y = buildingData.height + 0.1 + 3 + (0.1 / 2) * buildingData.barGraphMesh.geometry.parameters.height;
        }
      });

      world.parkingLots.forEach(lot => lot.spots.forEach(spot => { spot.occupied = false; spot.car = null; }));

      createInitialPopulation();
      updateBrainUILabel();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
