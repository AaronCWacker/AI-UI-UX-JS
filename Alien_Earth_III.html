<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alien: Earth - 3D Arcade Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=stylesheet" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #0c0a1e;
            color: #e0e0e0;
            margin: 0;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #game-container {
            border: 4px solid #4f4f4f;
            box-shadow: 0 0 20px #ff00ff, 0 0 30px #00ffff, inset 0 0 15px #000000;
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        .text-glow {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #ff00ff, 0 0 20px #ff00ff;
        }
        .btn-glow {
            box-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
            transition: all 0.3s ease;
        }
        .btn-glow:hover {
            box-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            transform: translateY(-2px);
        }
        .modal {
            background-color: rgba(12, 10, 30, 0.95);
            border: 2px solid #ff00ff;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
        }
        canvas {
            background-image: url('https://www.transparenttextures.com/patterns/stardust.png');
            background-color: #1a1a2e;
            cursor: crosshair;
            display: block;
            width: 100%;
            height: 100%;
        }
        .character-card {
            border: 2px solid #4f4f4f;
            transition: all 0.3s ease;
            padding: 1rem;
            border-radius: 0.5rem;
            background-color: rgba(0, 0, 0, 0.4);
            cursor: pointer;
        }
        .character-card.selected {
            border-color: #ff00ff;
            box-shadow: 0 0 15px #ff00ff;
        }
        .powerup-toast {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s, bottom 0.5s;
        }
        /* IMPROVED TOUCH CONTROLS */
        .touch-controls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            z-index: 100;
            padding: 0 10px;
            pointer-events: none;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
        }
        .control-group.left {
            justify-self: start;
            align-items: center;
        }
        .control-group.center {
            justify-self: center;
            align-items: center;
        }
        .control-group.right {
            justify-self: end;
            align-items: center;
        }
        .direction-pad {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 4px;
            width: fit-content;
        }
        .touch-button {
            width: 70px;
            height: 70px;
            border: 3px solid #00ffff;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #00ffff;
            font-size: 2.5rem;
            user-select: none;
            box-shadow: 0 0 15px #00ffff, inset 0 0 10px rgba(0, 255, 255, 0.2);
            background: rgba(0, 255, 255, 0.1);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .touch-button.active {
            background: rgba(0, 255, 255, 0.3);
            transform: scale(0.95);
        }
        .touch-button.fire {
            width: 90px;
            height: 90px;
            border-color: #ff00ff;
            color: #ff00ff;
            box-shadow: 0 0 20px #ff00ff, inset 0 0 10px rgba(255, 0, 255, 0.2);
            background: rgba(255, 0, 255, 0.1);
            font-size: 3rem;
            border-width: 4px;
        }
        .touch-button.ability {
            width: 70px;
            height: 70px;
            border-color: #fbbf24;
            color: #fbbf24;
            box-shadow: 0 0 15px #fbbf24, inset 0 0 10px rgba(251, 191, 36, 0.2);
            background: rgba(251, 191, 36, 0.1);
        }
        /* RESPONSIVE FIXES FOR FOLD7 AND IPAD */
        #start-screen {
            text-align: center;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 2rem 1rem;
            padding-top: 10vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        #start-screen h1 {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            font-weight: bold;
            color: #e0e0e0;
            margin: 0.5rem 0;
        }
        #start-screen h2 {
            font-size: clamp(1rem, 3vw, 1.25rem);
            color: #22d3ee;
            margin-bottom: 1rem;
        }
        #start-screen p {
            margin-bottom: 1.5rem;
            max-width: 32rem;
            font-size: clamp(0.875rem, 2.5vw, 1rem);
        }
        #start-screen .button-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
            max-width: 300px;
        }
        #start-screen button {
            background-color: #06b6d4;
            color: #000;
            font-weight: bold;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            font-size: clamp(1rem, 3vw, 1.25rem);
            border: none;
            cursor: pointer;
            margin: 0;
            width: 100%;
        }
        #start-screen button:last-child {
            background-color: #d946ef;
        }
        #character-selection-screen {
            display: none;
            text-align: center;
            width: 100%;
            height: 100%;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            overflow-y: auto;
            justify-content: flex-start;
            padding-top: 2rem;
        }
        #character-selection-screen h2 {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 0.5rem;
        }
        #character-selection-screen p {
            margin-bottom: 1rem;
            color: #9ca3af;
            font-size: clamp(0.875rem, 2.5vw, 1rem);
        }
        #character-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            max-width: 64rem;
        }
        #character-details {
            padding: 1rem;
            border-radius: 0.5rem;
            background-color: rgba(0, 0, 0, 0.5);
            min-height: 120px;
            width: 100%;
            max-width: 64rem;
            margin-bottom: 1rem;
        }
        #char-name {
            font-size: clamp(1.125rem, 4vw, 1.5rem);
            font-weight: bold;
            color: #22d3ee;
        }
        #char-faction {
            font-size: clamp(1rem, 3vw, 1.125rem);
            color: #d946ef;
        }
        #char-passive {
            margin-top: 0.5rem;
            color: #eab308;
            font-size: clamp(0.875rem, 2.5vw, 1rem);
        }
        #play-game-btn {
            display: none;
            background-color: #d946ef;
            color: #000;
            font-weight: bold;
            padding: 0.75rem 2rem;
            border-radius: 0.5rem;
            font-size: clamp(1rem, 3vw, 1.25rem);
            border: none;
            cursor: pointer;
            margin-bottom: 2rem;
        }
        #game-screen {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
        }
        #game-over-modal, #pause-modal, #high-score-modal {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.8);
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 50;
            font-size: clamp(0.875rem, 2.5vw, 1rem);
        }
        #hud > div {
            margin-bottom: 8px;
        }
        #health-bar-container, #ability-cooldown-container {
            width: 150px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #4f4f4f;
            border-radius: 4px;
            overflow: hidden;
        }
        #health-bar {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #22c55e);
            transition: width 0.3s ease;
        }
        #ability-cooldown-bar {
            height: 100%;
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
            transition: width 0.1s linear;
        }
        ul {
            list-style: none;
            padding: 0;
        }
        ul li {
            padding: 0.5rem;
            margin: 0.25rem 0;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 0.25rem;
            display: flex;
            justify-content: space-between;
        }
        /* IMPROVED HIGH SCORE MODAL */
        #high-score-list {
            max-width: 400px;
            margin: 1rem auto;
        }
        #high-score-list li {
            font-size: clamp(1rem, 3vw, 1.25rem);
            padding: 0.75rem;
        }
        /* Media queries for better device support */
        @media (max-width: 768px) and (max-height: 900px) {
            #start-screen {
                padding-top: 5vh;
            }
            #character-selection-screen {
                padding-top: 1rem;
            }
        }
        @media (max-width: 768px) {
            .touch-button {
                width: 65px;
                height: 65px;
                font-size: 2rem;
            }
            .touch-button.fire {
                width: 80px;
                height: 80px;
                font-size: 2.5rem;
            }
            .touch-button.ability {
                width: 65px;
                height: 65px;
            }
        }
        @media (max-width: 480px) {
            .touch-button {
                width: 55px;
                height: 55px;
                font-size: 1.75rem;
            }
            .touch-button.fire {
                width: 70px;
                height: 70px;
                font-size: 2.25rem;
            }
            .touch-button.ability {
                width: 55px;
                height: 55px;
            }
            #start-screen {
                padding-top: 3vh;
            }
        }
        @media (min-width: 1024px) {
            .touch-controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="start-screen">
            <h1 class="text-glow">ALIEN: EARTH</h1>
            <h2>3D Arcade Defense</h2>
            <p>The year is 2157. Earth has been invaded by hostile alien forces. As humanity's last line of defense, you must hold the line and eliminate the alien threat. Choose your hero and defend our world!</p>
            <div class="button-container">
                <button id="start-game-btn" class="btn-glow">START GAME</button>
                <button id="high-score-btn" class="btn-glow">HIGH SCORES</button>
            </div>
        </div>
        <div id="character-selection-screen">
            <h2 class="text-glow">SELECT YOUR HERO</h2>
            <p>Choose a character to defend Earth</p>
            <div id="character-grid"></div>
            <div id="character-details">
                <div id="char-name"></div>
                <div id="char-faction"></div>
                <div id="char-ability"></div>
                <div id="char-passive"></div>
            </div>
            <button id="play-game-btn" class="btn-glow">DEPLOY TO BATTLEFIELD</button>
        </div>
        <div id="game-screen">
            <canvas id="game-canvas"></canvas>
            <div id="hud">
                <div><strong>SCORE:</strong> <span id="score">0</span></div>
                <div><strong>WAVE:</strong> <span id="wave">1</span></div>
                <div><strong>PILOT:</strong> <span id="player-name"></span></div>
                <div id="health-bar-container"><div id="health-bar" style="width: 100%;"></div></div>
                <div id="ability-cooldown-container"><div id="ability-cooldown-bar" style="width: 100%;"></div></div>
            </div>
            <div class="touch-controls">
                <div class="control-group left">
                    <div class="direction-pad">
                        <div></div>
                        <div id="up-touch" class="touch-button">⬆️</div>
                        <div></div>
                        <div id="left-touch" class="touch-button">⬅️</div>
                        <div></div>
                        <div id="right-touch" class="touch-button">➡️</div>
                        <div></div>
                        <div id="down-touch" class="touch-button">⬇️</div>
                        <div></div>
                    </div>
                </div>
                <div class="control-group center">
                    <div id="fire-touch" class="touch-button fire">🎯</div>
                </div>
                <div class="control-group right">
                    <div id="ability-touch" class="touch-button ability">⚡</div>
                </div>
            </div>
            <div class="powerup-toast" id="powerup-toast"></div>
        </div>
        <div id="game-over-modal" class="modal">
            <h2 class="text-glow">MISSION FAILED</h2>
            <p>Earth's defenses have been breached...</p>
            <div id="final-stats">
                <p><strong>Final Score:</strong> <span id="final-score">0</span></p>
                <p><strong>Waves Survived:</strong> <span id="final-wave">0</span></p>
            </div>
            <div id="new-high-score-input" style="display: none;">
                <p style="color: #fbbf24; font-weight: bold;">🏆 NEW HIGH SCORE! 🏆</p>
                <input type="text" id="player-initials" maxlength="3" placeholder="AAA" style="padding: 0.5rem; margin: 0.5rem; font-size: 1.5rem; text-align: center; text-transform: uppercase; background-color: rgba(0,0,0,0.5); border: 2px solid #ff00ff; color: #e0e0e0; border-radius: 0.25rem;">
                <button id="submit-score-btn" class="btn-glow" style="background-color: #fbbf24; color: #000; padding: 0.5rem 1rem; border: none; border-radius: 0.25rem; cursor: pointer; font-weight: bold;">SUBMIT</button>
            </div>
            <button id="restart-game-btn" class="btn-glow" style="background-color: #06b6d4; color: #000; padding: 0.75rem 2rem; border: none; border-radius: 0.5rem; cursor: pointer; font-weight: bold; margin-top: 1rem;">TRY AGAIN</button>
        </div>
        <div id="pause-modal" class="modal">
            <h2 class="text-glow">PAUSED</h2>
            <p>Press 'P' or click Resume to continue</p>
            <button id="resume-btn" class="btn-glow" style="background-color: #10b981; color: #000; padding: 0.75rem 2rem; border: none; border-radius: 0.5rem; cursor: pointer; font-weight: bold;">RESUME</button>
        </div>
        <div id="high-score-modal" class="modal">
            <h2 class="text-glow">🏆 HIGH SCORES 🏆</h2>
            <ul id="high-score-list"></ul>
            <button id="close-hs-btn" class="btn-glow" style="background-color: #06b6d4; color: #000; padding: 0.75rem 2rem; border: none; border-radius: 0.5rem; cursor: pointer; font-weight: bold; margin-top: 1rem;">CLOSE</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('game-canvas');
        const startGameBtn = document.getElementById('start-game-btn');
        const playGameBtn = document.getElementById('play-game-btn');
        const restartGameBtn = document.getElementById('restart-game-btn');
        const highScoreBtn = document.getElementById('high-score-btn');
        const closeHsBtn = document.getElementById('close-hs-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const submitScoreBtn = document.getElementById('submit-score-btn');
        const playerInitialsInput = document.getElementById('player-initials');
        const scoreEl = document.getElementById('score');
        const waveEl = document.getElementById('wave');
        const playerNameDisplay = document.getElementById('player-name');
        const healthBar = document.getElementById('health-bar');
        const abilityCooldownBar = document.getElementById('ability-cooldown-bar');
        const gameOverModal = document.getElementById('game-over-modal');
        const pauseModal = document.getElementById('pause-modal');
        const highScoreModal = document.getElementById('high-score-modal');
        const finalScoreEl = document.getElementById('final-score');
        const finalWaveEl = document.getElementById('final-wave');
        const finalStats = document.getElementById('final-stats');
        const newHighScoreInput = document.getElementById('new-high-score-input');
        const highScoreList = document.getElementById('high-score-list');
        const characterGrid = document.getElementById('character-grid');
        const charName = document.getElementById('char-name');
        const charFaction = document.getElementById('char-faction');
        const charAbility = document.getElementById('char-ability');
        const charPassive = document.getElementById('char-passive');
        const leftTouch = document.getElementById('left-touch');
        const rightTouch = document.getElementById('right-touch');
        const upTouch = document.getElementById('up-touch');
        const downTouch = document.getElementById('down-touch');
        const fireTouch = document.getElementById('fire-touch');
        const abilityTouch = document.getElementById('ability-touch');
        const powerupToast = document.getElementById('powerup-toast');
        let scene, camera, renderer, raycaster, mouse, gamePlane;
        let GAME_WIDTH = 60, GAME_HEIGHT = 40;
        let gameActive = false, isPaused = false;
        let score = 0, wave = 1;
        let projectiles = [], enemies = [], explosions = [], powerups = [];
        let player;
        let keys = { a: { pressed: false }, d: { pressed: false }, w: { pressed: false }, s: { pressed: false } };
        let abilityReady = true, abilityCooldownTimer = 0;
        let selectedCharacter = null;
        let activePowerups = {};
        let gameLoopId;
        const CHARACTERS = [
            { name: 'Kirsh', faction: 'United Earth Defense', ability: 'Energy Shield', abilityDesc: 'Deploys a protective barrier', abilityCooldown: 15000, emoji: '🛡️', color: 0x00ffff, passive: 'Auto-shield at 30% health', passiveDesc: 'When health drops below 30%, automatically deploys a one-time shield.' },
            { name: 'Ravage', faction: 'Guerilla Resistance', ability: 'Missile Barrage', abilityDesc: 'Launches multiple homing missiles', abilityCooldown: 12000, emoji: '🚀', color: 0xff0000, passive: 'Explosive rounds', passiveDesc: 'All shots have a small explosion radius for area damage.' },
            { name: 'Sif', faction: 'Royal Guard', ability: 'Time Slow', abilityDesc: 'Slows all enemies for 5 seconds', abilityCooldown: 20000, emoji: '⏱️', color: 0xfbbf24, passive: 'Speed boost', passiveDesc: 'Moves 50% faster than other pilots.' },
            { name: 'Nexus', faction: 'AI Collective', ability: 'Orbital Strike', abilityDesc: 'Calls down devastating beam from orbit', abilityCooldown: 18000, emoji: '🛸', color: 0x8b5cf6, passive: 'Shield regeneration', passiveDesc: 'Slowly regenerates health over time.' }
        ];
        function initCharacterSelection() {
            characterGrid.innerHTML = '';
            CHARACTERS.forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.innerHTML = `<div style="font-size: 3rem;">${char.emoji}</div><div style="font-size: 1.25rem; font-weight: bold; color: #22d3ee;">${char.name}</div><div style="color: #d946ef;">${char.faction}</div>`;
                card.addEventListener('click', () => {
                    document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    selectedCharacter = char;
                    charName.textContent = char.name;
                    charFaction.textContent = char.faction;
                    charAbility.textContent = `⚡ ABILITY: ${char.ability} - ${char.abilityDesc} (Cooldown: ${char.abilityCooldown / 1000}s)`;
                    charPassive.textContent = `🔰 PASSIVE: ${char.passive} - ${char.passiveDesc}`;
                    playGameBtn.style.display = 'block';
                });
                characterGrid.appendChild(card);
            });
        }
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, canvas.offsetWidth / canvas.offsetHeight, 0.1, 1000);
            camera.position.set(0, 0, 35);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 10, 10);
            scene.add(dirLight);
            const planeGeo = new THREE.PlaneGeometry(GAME_WIDTH, GAME_HEIGHT);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0x1a1a2e, transparent: true, opacity: 0 });
            gamePlane = new THREE.Mesh(planeGeo, planeMat);
            scene.add(gamePlane);
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }
        class Player {
            constructor(character) {
                this.character = character;
                this.health = 100;
                this.maxHealth = 100;
                this.speed = character.name === 'Sif' ? 0.45 : 0.3;
                this.fireRate = 150;
                this.lastShot = 0;
                this.passiveShieldUsed = false;
                this.passiveShieldReady = character.name === 'Kirsh';
                this.healthRegenTimer = 0;
                const bodyGeo = new THREE.BoxGeometry(2, 1.5, 2);
                const bodyMat = new THREE.MeshPhongMaterial({ color: character.color, emissive: character.color, emissiveIntensity: 0.3 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                const cockpitGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const cockpitMat = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.5, transparent: true, opacity: 0.8 });
                const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
                cockpit.position.set(0, 0.8, 0.5);
                const wingGeo = new THREE.BoxGeometry(4, 0.2, 1);
                const wingMat = new THREE.MeshPhongMaterial({ color: character.color });
                const wing = new THREE.Mesh(wingGeo, wingMat);
                wing.position.set(0, 0, -0.5);
                this.model = new THREE.Group();
                this.model.add(body);
                this.model.add(cockpit);
                this.model.add(wing);
                this.model.position.set(0, -15, 0);
                scene.add(this.model);
            }
            update() {
                if (keys.a.pressed && this.model.position.x > -GAME_WIDTH / 2 + 2) this.model.position.x -= this.speed;
                if (keys.d.pressed && this.model.position.x < GAME_WIDTH / 2 - 2) this.model.position.x += this.speed;
                if (keys.w.pressed && this.model.position.y < GAME_HEIGHT / 2 - 2) this.model.position.y += this.speed;
                if (keys.s.pressed && this.model.position.y > -GAME_HEIGHT / 2 + 2) this.model.position.y -= this.speed;
                if (this.character.name === 'Nexus') {
                    this.healthRegenTimer++;
                    if (this.healthRegenTimer >= 120) {
                        this.health = Math.min(this.health + 1, this.maxHealth);
                        updateHealthBar();
                        this.healthRegenTimer = 0;
                    }
                }
                if (this.passiveShieldReady && !this.passiveShieldUsed && this.health <= 30) {
                    this.addShieldVisual(0x00ffff, 3.5);
                    this.passiveShieldUsed = true;
                }
            }
            shoot(target) {
                const now = Date.now();
                if (now - this.lastShot < this.fireRate) return;
                this.lastShot = now;
                const direction = new THREE.Vector3().subVectors(target, this.model.position).normalize();
                projectiles.push(new Projectile(this.model.position.clone(), direction, this.character.name === 'Ravage'));
            }
            takeDamage(amount) {
                if (this.model.userData.shielded) {
                    if (this.model.userData.shieldHealth) {
                        this.model.userData.shieldHealth -= amount;
                        if (this.model.userData.shieldHealth <= 0) {
                            this.removeShield();
                        }
                    }
                    return;
                }
                this.health = Math.max(0, this.health - amount);
                updateHealthBar();
                if (this.health <= 0) endGame();
            }
            addShieldVisual(color, duration) {
                const shieldGeo = new THREE.SphereGeometry(3, 16, 16);
                const shieldMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
                const shield = new THREE.Mesh(shieldGeo, shieldMat);
                this.model.add(shield);
                this.model.userData.shielded = true;
                this.model.userData.shield = shield;
                this.model.userData.shieldHealth = 50;
                if (duration) {
                    setTimeout(() => { this.removeShield(); }, duration * 1000);
                }
            }
            removeShield() {
                if (this.model.userData.shield) {
                    this.model.remove(this.model.userData.shield);
                    this.model.userData.shielded = false;
                    this.model.userData.shield = null;
                    this.model.userData.shieldHealth = 0;
                }
            }
        }
        class Projectile {
            constructor(position, direction, isExplosive = false) {
                this.speed = 0.8;
                this.direction = direction;
                this.isExplosive = isExplosive;
                const geo = new THREE.SphereGeometry(0.3, 8, 8);
                const mat = new THREE.MeshPhongMaterial({ color: isExplosive ? 0xff0000 : 0x00ff00, emissive: isExplosive ? 0xff0000 : 0x00ff00, emissiveIntensity: 0.8 });
                this.model = new THREE.Mesh(geo, mat);
                this.model.position.copy(position);
                scene.add(this.model);
            }
            update() {
                this.model.position.add(this.direction.clone().multiplyScalar(this.speed));
            }
        }
        class Enemy {
            constructor(type) {
                this.type = type;
                this.health = type === 'WALKING' ? 30 : 50;
                this.speed = type === 'WALKING' ? 0.15 : 0.08;
                this.state = type;
                this.shootTimer = 0;
                this.shootCooldown = type === 'FLYING' ? 120 : 180;
                const bodyGeo = type === 'WALKING' ? new THREE.BoxGeometry(1.5, 2, 1.5) : new THREE.ConeGeometry(1, 2, 6);
                const bodyMat = new THREE.MeshPhongMaterial({ color: type === 'WALKING' ? 0x00ff00 : 0xff00ff, emissive: type === 'WALKING' ? 0x00ff00 : 0xff00ff, emissiveIntensity: 0.4 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                if (type === 'FLYING') body.rotation.x = Math.PI;
                const eyeGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const eyeMat = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1.0 });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.4, type === 'WALKING' ? 0.6 : -0.3, type === 'WALKING' ? 0.6 : 0);
                rightEye.position.set(0.4, type === 'WALKING' ? 0.6 : -0.3, type === 'WALKING' ? 0.6 : 0);
                this.model = new THREE.Group();
                this.model.add(body);
                this.model.add(leftEye);
                this.model.add(rightEye);
                this.model.position.set(Math.random() * GAME_WIDTH - GAME_WIDTH / 2, GAME_HEIGHT / 2 + 5, 0);
                scene.add(this.model);
            }
            update() {
                const dirToPlayer = new THREE.Vector3().subVectors(player.model.position, this.model.position).normalize();
                this.model.position.add(dirToPlayer.multiplyScalar(this.speed));
                if (this.state === 'FLYING') {
                    this.shootTimer++;
                    if (this.shootTimer >= this.shootCooldown) {
                        this.shoot();
                        this.shootTimer = 0;
                    }
                }
            }
            shoot() {
                const direction = new THREE.Vector3().subVectors(player.model.position, this.model.position).normalize();
                projectiles.push(new EnemyProjectile(this.model.position.clone(), direction));
            }
            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    score += this.type === 'WALKING' ? 100 : 200;
                    scoreEl.textContent = score;
                    explosions.push(new Explosion(this.model.position, 0x00ff00, true, player.character.name, false));
                    if (Math.random() < 0.15) {
                        powerups.push(new Powerup(this.model.position.clone()));
                    }
                    return true;
                }
                return false;
            }
        }
        class EnemyProjectile {
            constructor(position, direction) {
                this.speed = 0.5;
                this.direction = direction;
                const geo = new THREE.SphereGeometry(0.25, 8, 8);
                const mat = new THREE.MeshPhongMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0.8 });
                this.model = new THREE.Mesh(geo, mat);
                this.model.position.copy(position);
                scene.add(this.model);
            }
            update() {
                this.model.position.add(this.direction.clone().multiplyScalar(this.speed));
            }
        }
        class Explosion {
            constructor(position, color, isPlayerExplosion, charName, isEnemyExplosion) {
                this.life = 30;
                this.maxRadius = isPlayerExplosion ? (charName === 'Ravage' ? 4 : 2.5) : 3;
                this.isPlayerExplosion = isPlayerExplosion;
                this.isEnemyExplosion = isEnemyExplosion;
                this.damagedEnemies = new Set(); // Track which enemies have been damaged
                
                // Main explosion sphere
                const geo = new THREE.SphereGeometry(1, 16, 16);
                const mat = new THREE.MeshPhongMaterial({ 
                    color: color, 
                    emissive: color,
                    emissiveIntensity: 0.8,
                    transparent: true, 
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                this.model = new THREE.Mesh(geo, mat);
                this.model.position.copy(position);
                
                // Add visible ring to show damage radius
                const ringGeo = new THREE.RingGeometry(0.8, 1, 32);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                this.ring = new THREE.Mesh(ringGeo, ringMat);
                this.ring.rotation.x = -Math.PI / 2;
                this.model.add(this.ring);
                
                // Add particle effects
                this.particles = [];
                for (let i = 0; i < 8; i++) {
                    const particleGeo = new THREE.SphereGeometry(0.3, 8, 8);
                    const particleMat = new THREE.MeshPhongMaterial({ 
                        color: color, 
                        emissive: color,
                        emissiveIntensity: 1,
                        transparent: true, 
                        opacity: 0.8
                    });
                    const particle = new THREE.Mesh(particleGeo, particleMat);
                    const angle = (i / 8) * Math.PI * 2;
                    particle.userData.velocity = new THREE.Vector3(
                        Math.cos(angle) * 0.2,
                        Math.sin(angle) * 0.2,
                        0
                    );
                    this.model.add(particle);
                    this.particles.push(particle);
                }
                
                scene.add(this.model);
            }
            update() {
                this.life--;
                const scale = (30 - this.life) / 30 * this.maxRadius * 2;
                this.model.scale.set(scale, scale, scale);
                this.model.material.opacity = this.life / 30 * 0.9;
                if (this.ring) {
                    this.ring.material.opacity = this.life / 30 * 0.6;
                }
                
                // Update particles
                this.particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = this.life / 30 * 0.8;
                });
            }
        }
        class Powerup {
            constructor(position) {
                this.isTractored = false;
                this.types = ['HEALTH', 'SHIELD', 'SPEED', 'FIRERATE'];
                this.type = this.types[Math.floor(Math.random() * this.types.length)];
                const colors = { HEALTH: 0x10b981, SHIELD: 0x06b6d4, SPEED: 0xfbbf24, FIRERATE: 0xf97316 };
                const geo = new THREE.OctahedronGeometry(0.8, 0);
                const mat = new THREE.MeshPhongMaterial({ color: colors[this.type], emissive: colors[this.type], emissiveIntensity: 0.5 });
                this.model = new THREE.Mesh(geo, mat);
                this.model.position.copy(position);
                scene.add(this.model);
            }
            update() {
                this.model.rotation.x += 0.02;
                this.model.rotation.y += 0.02;
                if (this.isTractored) {
                    const dirToPlayer = new THREE.Vector3().subVectors(player.model.position, this.model.position);
                    this.model.position.add(dirToPlayer.multiplyScalar(0.1));
                } else {
                    this.model.position.y -= 0.05;
                }
            }
            startTractorBeam() {
                this.isTractored = true;
                const beamGeo = new THREE.CylinderGeometry(0.1, 0.5, 10, 8);
                const beamMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
                this.tractorBeam = new THREE.Mesh(beamGeo, beamMat);
                this.tractorBeam.position.set(0, 5, 0);
                this.tractorBeam.rotation.x = Math.PI / 2;
                this.model.add(this.tractorBeam);
            }
        }
        function spawnEnemies() {
            const count = Math.min(3 + wave, 12);
            for (let i = 0; i < count; i++) {
                const type = Math.random() < 0.6 ? 'WALKING' : 'FLYING';
                enemies.push(new Enemy(type));
            }
        }
        function activatePowerup(powerup) {
            showPowerupToast(powerup.type);
            if (powerup.type === 'HEALTH') {
                player.health = Math.min(player.health + 30, player.maxHealth);
                updateHealthBar();
            } else if (powerup.type === 'SHIELD') {
                player.addShieldVisual(0x06b6d4, 8);
            } else if (powerup.type === 'SPEED') {
                activePowerups.SPEED = { duration: 10000, startTime: Date.now() };
                player.speed *= 2;
            } else if (powerup.type === 'FIRERATE') {
                activePowerups.FIRERATE = { duration: 8000, startTime: Date.now() };
                player.fireRate /= 2;
            }
        }
        function showPowerupToast(type) {
            const messages = { HEALTH: '💚 Health Restored!', SHIELD: '🛡️ Shield Active!', SPEED: '⚡ Speed Boost!', FIRERATE: '🔥 Rapid Fire!' };
            const colors = { HEALTH: '#10b981', SHIELD: '#06b6d4', SPEED: '#fbbf24', FIRERATE: '#f97316' };
            powerupToast.textContent = messages[type];
            powerupToast.style.backgroundColor = colors[type];
            powerupToast.style.opacity = '1';
            powerupToast.style.bottom = '140px';
            setTimeout(() => {
                powerupToast.style.opacity = '0';
                powerupToast.style.bottom = '20px';
            }, 2000);
        }
        function updateHealthBar() {
            const percent = (player.health / player.maxHealth) * 100;
            healthBar.style.width = `${percent}%`;
            if (percent > 60) healthBar.style.background = 'linear-gradient(90deg, #10b981, #22c55e)';
            else if (percent > 30) healthBar.style.background = 'linear-gradient(90deg, #fbbf24, #f59e0b)';
            else healthBar.style.background = 'linear-gradient(90deg, #ef4444, #dc2626)';
        }
        function useAbility() {
            if (!abilityReady || !gameActive || isPaused) return;
            abilityReady = false;
            abilityCooldownTimer = selectedCharacter.abilityCooldown;
            if (selectedCharacter.name === 'Kirsh') {
                player.addShieldVisual(0x00ffff, 6);
            } else if (selectedCharacter.name === 'Ravage') {
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        if (enemies.length > 0) {
                            const target = enemies[Math.floor(Math.random() * enemies.length)];
                            const direction = new THREE.Vector3().subVectors(target.model.position, player.model.position).normalize();
                            projectiles.push(new Projectile(player.model.position.clone(), direction, true));
                        }
                    }, i * 100);
                }
            } else if (selectedCharacter.name === 'Sif') {
                activePowerups.TIMESLOW = { duration: 5000, startTime: Date.now() };
            } else if (selectedCharacter.name === 'Nexus') {
                const beamGeo = new THREE.CylinderGeometry(2, 2, 50, 16);
                const beamMat = new THREE.MeshBasicMaterial({ color: 0x8b5cf6, transparent: true, opacity: 0.6 });
                const beam = new THREE.Mesh(beamGeo, beamMat);
                beam.position.set(player.model.position.x, 0, 0);
                beam.rotation.x = Math.PI / 2;
                scene.add(beam);
                enemies.forEach((enemy, i) => {
                    if (Math.abs(enemy.model.position.x - player.model.position.x) < 3) {
                        explosions.push(new Explosion(enemy.model.position, 0x8b5cf6, true, player.character.name, false));
                        score += 150;
                        scene.remove(enemy.model);
                        enemies.splice(i, 1);
                    }
                });
                setTimeout(() => scene.remove(beam), 500);
            }
        }
        function togglePause() {
            if (!gameActive) return;
            isPaused = !isPaused;
            pauseModal.style.display = isPaused ? 'flex' : 'none';
        }
        function gameLoop() {
            if (!gameActive) return;
            gameLoopId = requestAnimationFrame(gameLoop);
            if (isPaused) return;
            Object.keys(activePowerups).forEach(key => {
                const powerup = activePowerups[key];
                if (Date.now() - powerup.startTime >= powerup.duration) {
                    if (key === 'SPEED') player.speed /= 2;
                    if (key === 'FIRERATE') player.fireRate *= 2;
                    delete activePowerups[key];
                }
            });
            player.update();
            const timeSlowActive = activePowerups.TIMESLOW !== undefined;
            const speedMultiplier = timeSlowActive ? 0.3 : 1;
            projectiles.forEach((proj, i) => {
                proj.update();
                if (proj.model.position.y > GAME_HEIGHT / 2 || proj.model.position.y < -GAME_HEIGHT / 2 || Math.abs(proj.model.position.x) > GAME_WIDTH / 2) {
                    scene.remove(proj.model);
                    projectiles.splice(i, 1);
                } else if (proj.direction.y < 0) {
                    if (proj.model.position.distanceTo(player.model.position) < 2) {
                        player.takeDamage(10);
                        scene.remove(proj.model);
                        projectiles.splice(i, 1);
                    }
                } else {
                    let hitEnemy = false;
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        const distance = proj.model.position.distanceTo(enemy.model.position);
                        // Increased hit radius for better detection
                        if (distance < 3) {
                            // Create explosion on hit
                            const explosionColor = proj.isExplosive ? 0xff6600 : 0x00ff00;
                            explosions.push(new Explosion(proj.model.position.clone(), explosionColor, true, player.character.name, false));
                            
                            if (enemy.takeDamage(10)) {
                                scene.remove(enemy.model);
                                enemies.splice(j, 1);
                            }
                            scene.remove(proj.model);
                            projectiles.splice(i, 1);
                            hitEnemy = true;
                            break;
                        }
                    }
                }
            });
            explosions.forEach((exp, i) => {
                exp.update();
                if (exp.isPlayerExplosion) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        // Check if this enemy hasn't been damaged by this explosion yet
                        const enemyId = enemy.model.uuid;
                        if (!exp.damagedEnemies.has(enemyId)) {
                            const distance = exp.model.position.distanceTo(enemy.model.position);
                            // Use the actual visual scale of the explosion for collision
                            const effectiveRadius = exp.model.scale.x;
                            if (distance < effectiveRadius * 1.3) {
                                exp.damagedEnemies.add(enemyId);
                                if (enemy.takeDamage(25)) {
                                    scene.remove(enemy.model);
                                    enemies.splice(j, 1);
                                }
                            }
                        }
                    }
                }
                for (let j = powerups.length - 1; j >= 0; j--) {
                    const powerup = powerups[j];
                    if (!powerup.isTractored && exp.model.position.distanceTo(powerup.model.position) < exp.model.scale.x) {
                        powerup.startTractorBeam();
                    }
                }
                if (exp.isEnemyExplosion) {
                    const distToPlayer = exp.model.position.distanceTo(player.model.position);
                    const effectiveRadius = exp.model.scale.x;
                    if (distToPlayer < effectiveRadius * 1.2) {
                        const damage = Math.max(0, 20 * (1 - distToPlayer / (effectiveRadius * 1.2)));
                        if (damage > 0) player.takeDamage(damage * 0.1); // Reduce per-frame damage
                    }
                }
                if (exp.life <= 0) {
                    scene.remove(exp.model);
                    explosions.splice(i, 1);
                }
            });
            enemies.forEach((enemy, i) => {
                if (timeSlowActive) {
                    const originalSpeed = enemy.speed;
                    enemy.speed *= speedMultiplier;
                    enemy.update();
                    enemy.speed = originalSpeed;
                } else {
                    enemy.update();
                }
                if (enemy.state === 'WALKING' && enemy.model.position.distanceTo(player.model.position) < 4) {
                    explosions.push(new Explosion(enemy.model.position, 0xff0000, false, player.character.name, true));
                    scene.remove(enemy.model);
                    enemies.splice(i, 1);
                } else if (enemy.state === 'FLYING' && enemy.model.position.distanceTo(player.model.position) < 4) {
                    explosions.push(new Explosion(enemy.model.position, 0xff0000, false, player.character.name, true));
                    scene.remove(enemy.model);
                    enemies.splice(i, 1);
                }
            });
            powerups.forEach((p, i) => {
                p.update();
                if (!p.isTractored && p.model.position.distanceTo(player.model.position) < 4) {
                    activatePowerup(p);
                    scene.remove(p.model);
                    if (p.tractorBeam) p.model.remove(p.tractorBeam);
                    powerups.splice(i, 1);
                } else if (p.model.position.y < -GAME_HEIGHT / 2) {
                    scene.remove(p.model);
                    if (p.tractorBeam) p.model.remove(p.tractorBeam);
                    powerups.splice(i, 1);
                }
            });
            if (enemies.length === 0) { wave++; waveEl.textContent = wave; spawnEnemies(); }
            if (!abilityReady) {
                abilityCooldownTimer -= 1000 / 60;
                abilityCooldownBar.style.width = `${100 - (abilityCooldownTimer / selectedCharacter.abilityCooldown) * 100}%`;
                if (abilityCooldownTimer <= 0) { abilityReady = true; abilityCooldownBar.style.width = '100%'; }
            }
            renderer.render(scene, camera);
        }
        // --- IMPROVED High Score Logic ---
        function getHighScores() {
            try {
                const scores = localStorage.getItem('alienEarthHighScores');
                return scores ? JSON.parse(scores) : [];
            } catch (e) {
                console.error('Error loading high scores:', e);
                return [];
            }
        }
        function saveHighScore(score, initials) {
            try {
                const scores = getHighScores();
                scores.push({ score, initials: initials.toUpperCase() });
                scores.sort((a, b) => b.score - a.score);
                scores.splice(10); // Keep top 10
                localStorage.setItem('alienEarthHighScores', JSON.stringify(scores));
                return true;
            } catch (e) {
                console.error('Error saving high score:', e);
                return false;
            }
        }
        function displayHighScores() {
            highScoreList.innerHTML = '';
            const scores = getHighScores();
            if (scores.length === 0) {
                highScoreList.innerHTML = '<li style="text-align: center; font-size: 1.25rem;">🎮 No scores yet. Be the first! 🎮</li>';
            } else {
                scores.forEach((s, index) => {
                    const li = document.createElement('li');
                    const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
                    li.innerHTML = `<span style="font-weight: bold;">${medal} ${s.initials}</span> <span style="color: #fbbf24;">${s.score.toLocaleString()}</span>`;
                    li.style.textAlign = 'center';
                    li.style.fontSize = index < 3 ? '1.5rem' : '1.25rem';
                    highScoreList.appendChild(li);
                });
            }
        }
        // --- Game State Management ---
        function showScreen(screenId) {
            ['start-screen', 'character-selection-screen', 'game-screen'].forEach(id => document.getElementById(id).style.display = 'none');
            document.getElementById(screenId).style.display = 'flex';
        }
        function playGame() {
            if (!selectedCharacter) return;
            score = 0; wave = 1; gameActive = true; isPaused = false;
            projectiles = []; enemies = []; explosions = []; powerups = [];
            activePowerups = {};
            scoreEl.textContent = score; waveEl.textContent = wave;
            showScreen('game-screen');
            initThreeJS();
            player = new Player(selectedCharacter);
            if (player.character.name === 'Kirsh' && player.passiveShieldReady) {
                player.addShieldVisual(0x00ffff, 3.5);
            }
            playerNameDisplay.textContent = player.character.name;
            updateHealthBar();
            abilityCooldownBar.style.width = '100%';
            spawnEnemies();
            gameLoop();
        }
        function endGame() {
            gameActive = false;
            cancelAnimationFrame(gameLoopId);
            finalScoreEl.textContent = score.toLocaleString();
            finalWaveEl.textContent = wave;
            const highScores = getHighScores();
            if (score > 0 && (highScores.length < 10 || score > highScores[highScores.length - 1].score)) {
                finalStats.style.display = 'none';
                newHighScoreInput.style.display = 'block';
                playerInitialsInput.value = '';
                playerInitialsInput.focus();
            } else {
                finalStats.style.display = 'block';
                newHighScoreInput.style.display = 'none';
            }
            gameOverModal.style.display = 'flex';
            if (scene) { while(scene.children.length > 0){ scene.remove(scene.children[0]); } }
        }
        function restartGame() {
            gameOverModal.style.display = 'none';
            selectedCharacter = null;
            playGameBtn.style.display = 'none';
            charName.textContent = ''; charFaction.textContent = ''; charAbility.textContent = ''; charPassive.textContent = '';
            showScreen('character-selection-screen');
            initCharacterSelection();
        }
        // --- Event Listeners ---
        startGameBtn.addEventListener('click', () => { showScreen('character-selection-screen'); initCharacterSelection(); });
        playGameBtn.addEventListener('click', playGame);
        restartGameBtn.addEventListener('click', restartGame);
        highScoreBtn.addEventListener('click', () => { displayHighScores(); highScoreModal.style.display = 'flex'; });
        closeHsBtn.addEventListener('click', () => highScoreModal.style.display = 'none');
        resumeBtn.addEventListener('click', togglePause);
        submitScoreBtn.addEventListener('click', () => {
            const initials = playerInitialsInput.value.trim();
            if (initials.length > 0) {
                if (saveHighScore(score, initials)) {
                    newHighScoreInput.style.display = 'none';
                    finalStats.style.display = 'block';
                    displayHighScores();
                }
            }
        });
        playerInitialsInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitScoreBtn.click();
            }
        });
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / canvas.offsetWidth) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / canvas.offsetHeight) * 2 + 1;
            if (gameActive && raycaster) raycaster.setFromCamera(mouse, camera);
        });
        canvas.addEventListener('mousedown', () => {
            if (gameActive && raycaster && !isPaused) {
                const intersects = raycaster.intersectObject(gamePlane);
                if (intersects.length > 0) player.shoot(intersects[0].point);
            }
        });
        window.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') keys.a.pressed = true;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') keys.d.pressed = true;
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') keys.w.pressed = true;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') keys.s.pressed = true;
            if (e.key === 'q' || e.key === 'Q') useAbility();
            if (e.key === 'p' || e.key === 'P') togglePause();
        });
        window.addEventListener('keyup', (e) => {
            if (!gameActive) return;
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') keys.a.pressed = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') keys.d.pressed = false;
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') keys.w.pressed = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') keys.s.pressed = false;
        });
        // IMPROVED TOUCH CONTROLS WITH UP/DOWN
        function handleTouchButton(button, key, addClass = true) {
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameActive) {
                    keys[key].pressed = true;
                    if (addClass) button.classList.add('active');
                }
            });
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key].pressed = false;
                if (addClass) button.classList.remove('active');
            });
            button.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                keys[key].pressed = false;
                if (addClass) button.classList.remove('active');
            });
        }
        handleTouchButton(leftTouch, 'a');
        handleTouchButton(rightTouch, 'd');
        handleTouchButton(upTouch, 'w');
        handleTouchButton(downTouch, 's');
        fireTouch.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameActive && !isPaused && raycaster) {
                fireTouch.classList.add('active');
                const intersects = raycaster.intersectObject(gamePlane);
                if (intersects.length > 0) player.shoot(intersects[0].point);
            }
        });
        fireTouch.addEventListener('touchend', (e) => {
            e.preventDefault();
            fireTouch.classList.remove('active');
        });
        abilityTouch.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameActive && !isPaused) {
                abilityTouch.classList.add('active');
                useAbility();
            }
        });
        abilityTouch.addEventListener('touchend', (e) => {
            e.preventDefault();
            abilityTouch.classList.remove('active');
        });
        window.addEventListener('resize', () => {
            if (!gameActive) return;
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            GAME_HEIGHT = (GAME_WIDTH * canvas.offsetHeight) / canvas.offsetWidth;
            scene.remove(gamePlane);
            const planeGeo = new THREE.PlaneGeometry(GAME_WIDTH, GAME_HEIGHT);
            gamePlane.geometry.dispose();
            gamePlane.geometry = planeGeo;
            scene.add(gamePlane);
        }, false);
    </script>
</body>
</html>
