<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alien: Earth - 3D Arcade Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #0c0a1e;
            color: #e0e0e0;
            margin: 0;
            overflow: hidden;
        }
        .game-container {
            border: 4px solid #4f4f4f;
            box-shadow: 0 0 20px #ff00ff, 0 0 30px #00ffff, inset 0 0 15px #000000;
        }
        .text-glow {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #ff00ff, 0 0 20px #ff00ff;
        }
        .btn-glow {
            box-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
            transition: all 0.3s ease;
        }
        .btn-glow:hover {
            box-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            transform: translateY(-2px);
        }
        .modal {
            background-color: rgba(12, 10, 30, 0.95);
            border: 2px solid #ff00ff;
        }
        canvas {
            background-image: url('https://www.transparenttextures.com/patterns/stardust.png');
            background-color: #1a1a2e;
            cursor: crosshair;
            display: block;
        }
        .character-card {
            border: 2px solid #4f4f4f;
            transition: all 0.3s ease;
        }
        .character-card.selected {
            border-color: #ff00ff;
            box-shadow: 0 0 15px #ff00ff;
        }
        .powerup-toast {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            border-radius: 8px;
            color: black;
            font-weight: bold;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s, bottom 0.5s;
        }
        .touch-controls {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 120px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            padding: 0 20px;
        }
        .touch-button {
            width: 80px;
            height: 80px;
            border: 2px solid #00ffff;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #00ffff;
            font-size: 2rem;
            user-select: none;
            box-shadow: 0 0 10px #00ffff;
        }
        .touch-button.fire {
            width: 100px;
            height: 100px;
            border-color: #ff00ff;
            color: #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
        }
    </style>
</head>
<body>
    <div id="game-container" class="w-screen h-screen relative">
        <div id="start-screen" class="text-center w-full h-full flex flex-col items-center justify-center p-4">
            <h1 class="text-4xl md:text-6xl font-bold text-glow mb-4">ALIEN: EARTH 3D</h1>
            <h2 class="text-xl md:text-2xl text-cyan-300 mb-8">ARCADE BATTLE</h2>
            <p class="mb-8 max-w-2xl mx-auto">The USCSS Maginot has crashed. Xenomorphs swarm New Siam. Choose your faction and fight for the future of humanity... or something beyond it.</p>
            <div>
                <button id="start-game-btn" class="bg-cyan-500 text-black font-bold py-3 px-8 rounded-lg text-xl btn-glow">Start Game</button>
                <button id="high-score-btn" class="bg-fuchsia-500 text-black font-bold py-3 px-8 rounded-lg text-xl btn-glow ml-4">High Scores</button>
            </div>
        </div>
        <div id="character-selection-screen" class="hidden text-center w-full h-full flex flex-col items-center justify-center p-4">
            <h2 class="text-4xl font-bold text-glow mb-2">CHOOSE YOUR CHAMPION</h2>
            <p class="mb-4 text-gray-400">Each faction has a unique passive ability.</p>
            <div id="character-grid" class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6 w-full max-w-4xl"></div>
            <div id="character-details" class="p-4 rounded-lg bg-black bg-opacity-50 min-h-[150px] w-full max-w-4xl">
                <h3 id="char-name" class="text-2xl font-bold text-cyan-300"></h3>
                <p id="char-faction" class="text-lg text-fuchsia-400"></p>
                <p id="char-passive" class="mt-2 text-yellow-300"></p>
                <p id="char-ability" class="mt-2"></p>
            </div>
            <button id="play-game-btn" class="bg-fuchsia-500 text-black font-bold py-3 px-8 rounded-lg text-xl btn-glow mt-6 hidden">Engage!</button>
        </div>
        <div id="game-screen" class="hidden w-full h-full flex flex-col">
            <div class="flex justify-between items-center p-2 bg-black bg-opacity-50">
                <div>
                    <h3 id="player-name-display" class="text-lg md:text-xl font-bold text-cyan-400"></h3>
                    <div class="w-32 md:w-64 h-6 bg-gray-700 rounded-full overflow-hidden border-2 border-gray-500">
                        <div id="player-health-bar" class="bg-green-500 h-full" style="width: 100%;"></div>
                    </div>
                </div>
                <div class="text-center">
                    <p class="text-sm md:text-lg">Score: <span id="score" class="font-bold text-yellow-400">0</span></p>
                    <p class="text-sm md:text-lg">Wave: <span id="wave" class="font-bold text-red-400">1</span></p>
                </div>
                <div class="text-right">
                    <h3 class="text-lg md:text-xl font-bold text-fuchsia-400">Ability</h3>
                    <div class="w-32 md:w-64 h-6 bg-gray-700 rounded-full overflow-hidden border-2 border-gray-500">
                        <div id="ability-cooldown-bar" class="bg-cyan-500 h-full" style="width: 100%;"></div>
                    </div>
                </div>
            </div>
            <div class="flex-grow w-full relative">
                <canvas id="game-canvas" class="absolute top-0 left-0 w-full h-full"></canvas>
                <div id="pause-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
                    <div class="modal p-8 rounded-lg text-center">
                        <h2 class="text-5xl font-bold text-glow text-cyan-300 mb-4">PAUSED</h2>
                        <button id="resume-btn" class="bg-cyan-500 text-black font-bold py-3 px-8 rounded-lg text-xl btn-glow">Resume</button>
                    </div>
                </div>
                <div class="touch-controls">
                    <div id="left-touch" class="touch-button"><span>&#x2190;</span></div>
                    <div id="fire-touch" class="touch-button fire"><span>&#x25CE;</span></div>
                    <div id="right-touch" class="touch-button"><span>&#x2192;</span></div>
                </div>
            </div>
        </div>
        <div id="game-over-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="modal p-8 rounded-lg text-center">
                <h2 id="game-over-title" class="text-5xl font-bold text-glow text-red-500 mb-4">GAME OVER</h2>
                <div id="new-high-score-input" class="hidden">
                    <p class="text-2xl text-yellow-300 mb-2">New High Score!</p>
                    <input type="text" id="player-initials" placeholder="Enter Your Initials (3)" maxlength="3" class="bg-gray-800 border-2 border-fuchsia-500 text-center text-2xl p-2 rounded w-48 mx-auto block mb-4">
                    <button id="submit-score-btn" class="bg-yellow-500 text-black font-bold py-2 px-6 rounded-lg text-lg btn-glow">Submit</button>
                </div>
                <div id="final-stats">
                    <p class="text-2xl mb-2">Final Score: <span id="final-score" class="text-yellow-300"></span></p>
                    <p class="text-2xl mb-6">Wave Reached: <span id="final-wave" class="text-red-400"></span></p>
                    <button id="restart-game-btn" class="bg-cyan-500 text-black font-bold py-3 px-8 rounded-lg text-xl btn-glow">Play Again</button>
                </div>
            </div>
        </div>
        <div id="high-score-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="modal p-8 rounded-lg text-center w-full max-w-md">
                <h2 class="text-5xl font-bold text-glow text-yellow-400 mb-6">HIGH SCORES</h2>
                <ol id="high-score-list" class="text-2xl text-left list-decimal list-inside mb-6"></ol>
                <button id="close-hs-btn" class="bg-cyan-500 text-black font-bold py-3 px-8 rounded-lg text-xl btn-glow">Back</button>
            </div>
        </div>
        <div id="powerup-toast-container"></div>
    </div>
    <script>
        // --- DOM Elements ---
        const startScreen = document.getElementById('start-screen');
        const characterSelectionScreen = document.getElementById('character-selection-screen');
        const gameScreen = document.getElementById('game-screen');
        const gameOverModal = document.getElementById('game-over-modal');
        const highScoreModal = document.getElementById('high-score-modal');
        const pauseModal = document.getElementById('pause-modal');
        const startGameBtn = document.getElementById('start-game-btn');
        const playGameBtn = document.getElementById('play-game-btn');
        const restartGameBtn = document.getElementById('restart-game-btn');
        const highScoreBtn = document.getElementById('high-score-btn');
        const closeHsBtn = document.getElementById('close-hs-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const characterGrid = document.getElementById('character-grid');
        const charName = document.getElementById('char-name');
        const charFaction = document.getElementById('char-faction');
        const charPassive = document.getElementById('char-passive');
        const charAbility = document.getElementById('char-ability');
        const canvas = document.getElementById('game-canvas');
        const scoreEl = document.getElementById('score');
        const waveEl = document.getElementById('wave');
        const playerNameDisplay = document.getElementById('player-name-display');
        const playerHealthBar = document.getElementById('player-health-bar');
        const abilityCooldownBar = document.getElementById('ability-cooldown-bar');
        const finalScoreEl = document.getElementById('final-score');
        const finalWaveEl = document.getElementById('final-wave');
        const highScoreList = document.getElementById('high-score-list');
        const newHighScoreInput = document.getElementById('new-high-score-input');
        const finalStats = document.getElementById('final-stats');
        const playerInitialsInput = document.getElementById('player-initials');
        const submitScoreBtn = document.getElementById('submit-score-btn');
        const powerupToastContainer = document.getElementById('powerup-toast-container');
        const leftTouch = document.getElementById('left-touch');
        const rightTouch = document.getElementById('right-touch');
        const fireTouch = document.getElementById('fire-touch');
        // --- Game Configuration ---
        let selectedCharacter = null;
        let gameLoopId;
        let player, projectiles, enemies, explosions, powerups;
        let score, wave, gameActive;
        let abilityReady = true;
        let abilityCooldownTimer = 0;
        let activePowerups = {};
        let isPaused = false;
        let scene, camera, renderer, raycaster, gamePlane;
        let GAME_HEIGHT;
        const mouse = new THREE.Vector2();
        const GAME_WIDTH = 100;
        const keys = { a: { pressed: false }, d: { pressed: false } };
        const CHARACTERS = [
            { name: 'Wendy', faction: 'Hybrid', color: 0xff00ff, passive: 'Passive: Health Regeneration.', ability: 'Ability: Xeno-Pulse stuns all enemies.', abilityCooldown: 15000, abilityDuration: 2000, health: 100, speed: 0.5, projectileColor: 0xff00ff, projectileSpeed: 1.2 },
            { name: 'Morrow', faction: 'Cyborg', color: 0x00ffff, passive: 'Passive: Larger explosion radius.', ability: 'Ability: Overcharge fires 3 missiles.', abilityCooldown: 20000, abilityDuration: 1000, health: 150, speed: 0.3, projectileColor: 0x00ffff, projectileSpeed: 1.0 },
            { name: 'Kirsh', faction: 'Synth', color: 0xffff00, passive: 'Passive: Recharging energy shield.', ability: 'Ability: Shield Matrix for invulnerability.', abilityCooldown: 25000, abilityDuration: 4000, health: 120, speed: 0.4, projectileColor: 0xffff00, projectileSpeed: 1.1 },
        ];
        const POWERUP_TYPES = [
            { type: 'rapidFire', color: 0xffa500, duration: 5000, name: 'Rapid Fire' },
            { type: 'megaBomb', color: 0xff4500, duration: 0, name: 'Mega Bomb' },
            { type: 'shield', color: 0xadd8e6, duration: 0, name: 'Shield' },
            { type: 'doubleShot', color: 0x00ff00, duration: 10000, name: 'Double Shot' },
            { type: 'tripleShot', color: 0x00fa9a, duration: 8000, name: 'Triple Shot' },
            { type: 'scoreMultiplier', color: 0xffff00, duration: 10000, name: '2x Score' },
            { type: 'enemySlow', color: 0x4682b4, duration: 7000, name: 'Enemy Slow' },
            { type: 'nuke', color: 0xffffff, duration: 0, name: 'Nuke' },
            { type: 'healthPack', color: 0xffc0cb, duration: 0, name: 'Health Pack' },
            { type: 'heatSeeking', color: 0xda70d6, duration: 10000, name: 'Homing Missiles' },
        ];
        // --- 3D Model Creation ---
        function createPlayerModel(character) {
            const group = new THREE.Group();
            const baseMaterial = new THREE.MeshStandardMaterial({ color: character.color, metalness: 0.7, roughness: 0.3 });
            const accentMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.2 });
            const visorMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6, emissive: 0x00ffff });
            if (character.name === 'Wendy') {
                // Sleek spacesuit with organic hybrid elements
                const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.6, 2, 16), baseMaterial);
                torso.position.y = 1;
                const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), baseMaterial);
                helmet.position.y = 2.5;
                const visor = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), visorMaterial);
                visor.position.set(0, 2.5, 0.2);
                const arms = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1.5, 12), baseMaterial);
                arms.position.set(0.8, 1.5, 0);
                const leftArm = arms.clone();
                leftArm.position.x = -0.8;
                const jetpack = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1, 0.4), accentMaterial);
                jetpack.position.set(0, 1, -0.5);
                const thruster = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.5, 12), accentMaterial);
                thruster.position.set(0, 0.3, -0.6);
                group.add(torso, helmet, visor, arms, leftArm, jetpack, thruster);
            } else if (character.name === 'Morrow') {
                // Bulky cyborg spacesuit
                const torso = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.5, 0.8), baseMaterial);
                torso.position.y = 1.25;
                const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), baseMaterial);
                helmet.position.y = 2.8;
                const visor = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.4, 0.1), visorMaterial);
                visor.position.set(0, 2.8, 0.4);
                const shoulderPad = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.6), accentMaterial);
                shoulderPad.position.set(1, 2, 0);
                const leftShoulder = shoulderPad.clone();
                leftShoulder.position.x = -1;
                const jetpack = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2, 12), accentMaterial);
                jetpack.position.set(0, 1.25, -0.5);
                group.add(torso, helmet, visor, shoulderPad, leftShoulder, jetpack);
            } else { // Kirsh
                // High-tech synth suit with floating panels
                const core = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 1), baseMaterial);
                core.position.y = 1.5;
                const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), baseMaterial);
                helmet.position.y = 3;
                const visor = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), visorMaterial);
                visor.position.set(0, 3, 0.2);
                const panel1 = new THREE.Mesh(new THREE.BoxGeometry(1, 0.1, 1), accentMaterial);
                panel1.position.set(1.5, 2, 0);
                const panel2 = panel1.clone();
                panel2.position.set(-1.5, 2, 0);
                group.add(core, helmet, visor, panel1, panel2);
                group.userData.rings = [panel1, panel2];
            }
            group.scale.set(1.2, 1.2, 1.2);
            return group;
        }
        function createEnemyModel(type) {
            const group = new THREE.Group();
            let material;
            if (type === 'warrior') {
                // Large xenomorph with sharp claws
                material = new THREE.MeshStandardMaterial({ color: 0xff4500, roughness: 0.8, metalness: 0.2 });
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), material);
                head.scale.z = 1.5;
                head.position.y = 2;
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.5, 2.5, 12), material);
                body.position.y = 0.5;
                const claw = new THREE.Mesh(new THREE.ConeGeometry(0.3, 1, 8), material);
                claw.position.set(0.8, 1, 0);
                claw.rotation.z = Math.PI / 4;
                const leftClaw = claw.clone();
                leftClaw.position.x = -0.8;
                leftClaw.rotation.z = -Math.PI / 4;
                const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.1, 2, 8), material);
                tail.position.set(0, 0, -1.5);
                tail.rotation.x = Math.PI / 3;
                group.add(head, body, claw, leftClaw, tail);
                group.scale.set(1.5, 1.5, 1.5);
            } else if (type === 'facehugger') {
                // Spider-like facehugger with articulated legs
                material = new THREE.MeshStandardMaterial({ color: 0xf5deb3, roughness: 0.9, metalness: 0.1 });
                const body = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 12), material);
                body.scale.y = 0.4;
                const legGeo = new THREE.CylinderGeometry(0.1, 0.05, 1.5, 8);
                for (let i = 0; i < 8; i++) {
                    const leg = new THREE.Mesh(legGeo, material);
                    const angle = (i / 8) * Math.PI * 2;
                    leg.position.set(Math.cos(angle) * 0.8, 0, Math.sin(angle) * 0.8);
                    leg.rotation.z = Math.PI / 4 * (i % 2 === 0 ? 1 : -1);
                    leg.rotation.y = -angle;
                    const joint = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), material);
                    joint.position.set(0, 0.75, 0);
                    leg.add(joint);
                    group.add(leg);
                }
                group.add(body);
            } else { // drone
                // Sleek alien with elongated head and tail
                material = new THREE.MeshStandardMaterial({ color: 0x7cfc00, roughness: 0.7, metalness: 0.3 });
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), material);
                head.scale.z = 2;
                head.position.y = 1.5;
                head.rotation.x = Math.PI / 6;
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.3, 2.5, 12), material);
                body.position.y = 0;
                const tail = new THREE.Mesh(new THREE.ConeGeometry(0.3, 1.5, 8), material);
                tail.position.set(0, -1, -1);
                tail.rotation.x = Math.PI / 3;
                group.add(head, body, tail);
            }
            group.position.y = 1.5;
            return group;
        }
        function createPowerupModel(powerupInfo) {
            const group = new THREE.Group();
            const core = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), new THREE.MeshStandardMaterial({ color: powerupInfo.color, metalness: 0.5, roughness: 0.3, emissive: powerupInfo.color, emissiveIntensity: 0.2 }));
            const ring = new THREE.Mesh(new THREE.TorusGeometry(1, 0.1, 8, 24), new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.2 }));
            ring.rotation.x = Math.PI / 2;
            const glow = new THREE.Mesh(new THREE.SphereGeometry(1, 16, 16), new THREE.MeshBasicMaterial({ color: powerupInfo.color, transparent: true, opacity: 0.3 }));
            group.add(core, ring, glow);
            return group;
        }
        // --- Game Classes ---
        class Player {
            constructor(character) {
                this.character = character;
                this.model = createPlayerModel(character);
                this.model.position.z = GAME_HEIGHT / 2 - 5;
                this.health = character.health;
                this.maxHealth = character.health;
                this.shootCooldown = 0;
                this.isShielded = false;
                this.shieldVisual = null;
                this.passiveShieldReady = true;
                this.passiveShieldCooldown = 5000;
                this.lastHitTime = 0;
                this.regenTimer = 0;
                scene.add(this.model);
            }
            update() {
                if (keys.a.pressed && this.model.position.x > -GAME_WIDTH / 2) this.model.position.x -= this.character.speed;
                if (keys.d.pressed && this.model.position.x < GAME_WIDTH / 2) this.model.position.x += this.character.speed;
                if (this.shootCooldown > 0) this.shootCooldown--;
                if (this.character.name === 'Kirsh') {
                    this.model.userData.rings.forEach((r, i) => r.rotation[i % 2 === 0 ? 'z' : 'x'] += 0.05);
                    if (!this.passiveShieldReady && Date.now() - this.lastHitTime > this.passiveShieldCooldown) {
                        this.passiveShieldReady = true;
                        this.addShieldVisual(0x00ffff, 3.5);
                    }
                }
                if (this.character.name === 'Wendy') {
                    this.regenTimer++;
                    if (this.regenTimer >= 120) {
                        this.heal(1);
                        this.regenTimer = 0;
                    }
                }
            }
            shoot(target) {
                const fireRate = activePowerups.rapidFire ? 5 : 20;
                if (this.shootCooldown > 0) return;
                const offsets = [0];
                if (activePowerups.tripleShot) offsets.push(-10, 10);
                else if (activePowerups.doubleShot) offsets.push(-5, 5);
                offsets.forEach(offset => {
                    const newTarget = target.clone();
                    const direction = new THREE.Vector3().subVectors(target, this.model.position).normalize();
                    const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x).multiplyScalar(offset);
                    newTarget.add(perpendicular);
                    projectiles.push(new Projectile(this.model.position, newTarget, this.character));
                });
                this.shootCooldown = fireRate;
            }
            takeDamage(amount) {
                if (this.isShielded) return;
                if (activePowerups.shield) {
                    delete activePowerups.shield;
                    this.model.remove(this.shieldVisual);
                    this.shieldVisual = null;
                    return;
                }
                if (this.character.name === 'Kirsh' && this.passiveShieldReady) {
                    this.passiveShieldReady = false;
                    this.lastHitTime = Date.now();
                    this.model.remove(this.shieldVisual);
                    this.shieldVisual = null;
                    return;
                }
                this.health -= amount;
                this.lastHitTime = Date.now();
                updateHealthBar();
                if (this.health <= 0) endGame();
            }
            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
                updateHealthBar();
            }
            addShieldVisual(color, size) {
                if (this.shieldVisual) this.model.remove(this.shieldVisual);
                const shieldGeo = new THREE.SphereGeometry(size, 16, 16);
                const shieldMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.4, wireframe: true });
                this.shieldVisual = new THREE.Mesh(shieldGeo, shieldMat);
                this.model.add(this.shieldVisual);
            }
        }
        class Projectile {
            constructor(startPos, targetPos, character) {
                const geometry = new THREE.SphereGeometry(0.5, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: character.projectileColor });
                this.model = new THREE.Mesh(geometry, material);
                this.model.position.copy(startPos);
                this.target = targetPos.clone();
                this.speed = character.projectileSpeed;
                this.isMega = !!activePowerups.megaBomb;
                if (this.isMega) delete activePowerups.megaBomb;
                this.isHoming = !!activePowerups.heatSeeking;
                this.homingTarget = null;
                if (this.isHoming && enemies.length > 0) {
                    let closestDist = Infinity;
                    enemies.forEach(enemy => {
                        const dist = this.model.position.distanceTo(enemy.model.position);
                        if (dist < closestDist) {
                            closestDist = dist;
                            this.homingTarget = enemy;
                        }
                    });
                }
                const direction = new THREE.Vector3().subVectors(this.target, this.model.position).normalize();
                this.velocity = direction.multiplyScalar(this.speed);
                scene.add(this.model);
            }
            update() {
                if (this.isHoming && this.homingTarget && this.homingTarget.model.parent === scene) {
                    const direction = new THREE.Vector3().subVectors(this.homingTarget.model.position, this.model.position).normalize();
                    this.velocity.lerp(direction.multiplyScalar(this.speed), 0.1);
                } else {
                    this.isHoming = false;
                }
                this.model.position.add(this.velocity);
            }
        }
        class Explosion {
            constructor(position, color, isMega, characterName) {
                const geometry = new THREE.SphereGeometry(1, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
                this.model = new THREE.Mesh(geometry, material);
                this.model.position.copy(position);
                this.maxRadius = 10;
                if (isMega) this.maxRadius = 30;
                if (characterName === 'Morrow') this.maxRadius *= 1.5;
                this.life = 1;
                this.triggeredChain = false;
                scene.add(this.model);
            }
            update() {
                const newScale = this.model.scale.x + (this.maxRadius - this.model.scale.x) * 0.1;
                this.model.scale.set(newScale, newScale, newScale);
                this.model.material.opacity = this.life;
                this.life -= 0.04;
            }
        }
        class Enemy {
            constructor(x, z, type) {
                this.type = type;
                this.model = createEnemyModel(type);
                this.model.position.set(x, 2, z);
                this.isStunned = false;
                let speed, score;
                if (type === 'warrior') { speed = 0.025 + (wave * 0.005); score = 50; }
                else if (type === 'facehugger') { speed = 0.1 + (wave * 0.015); score = 25; }
                else { speed = 0.05 + (wave * 0.008); score = 10; }
                this.speed = speed;
                this.scoreValue = score;
                scene.add(this.model);
            }
            update() {
                let currentSpeed = this.speed;
                if (activePowerups.enemySlow) currentSpeed *= 0.5;
                if (!this.isStunned) this.model.position.z += currentSpeed;
                this.model.rotation.y += 0.02;
            }
        }
        class Powerup {
            constructor(position) {
                this.info = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
                this.model = createPowerupModel(this.info);
                this.model.position.copy(position);
                this.model.position.y = 2;
                this.speed = 0.2;
                this.isTractored = false;
                this.tractorBeam = null;
                scene.add(this.model);
            }
            update() {
                if (this.isTractored) {
                    const direction = new THREE.Vector3().subVectors(player.model.position, this.model.position).normalize();
                    this.model.position.add(direction.multiplyScalar(0.5));
                    if (this.tractorBeam) {
                        this.tractorBeam.scale.y = player.model.position.distanceTo(this.model.position) / 5;
                        this.tractorBeam.position.y = -this.tractorBeam.scale.y * 2.5;
                    }
                    if (this.model.position.distanceTo(player.model.position) < 4) {
                        activatePowerup(this);
                        scene.remove(this.model);
                        if (this.tractorBeam) this.model.remove(this.tractorBeam);
                        powerups.splice(powerups.indexOf(this), 1);
                    }
                } else {
                    const direction = new THREE.Vector3().subVectors(player.model.position, this.model.position).normalize();
                    this.model.position.add(direction.multiplyScalar(this.speed));
                    this.model.rotation.y += 0.03;
                    this.model.rotation.x += 0.03;
                }
            }
            startTractorBeam() {
                this.isTractored = true;
                const beamGeo = new THREE.ConeGeometry(1, 5, 16, 1, true);
                const beamMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                this.tractorBeam = new THREE.Mesh(beamGeo, beamMat);
                this.tractorBeam.position.set(0, -2.5, 0);
                this.model.add(this.tractorBeam);
            }
        }
        // --- Game Logic ---
        function initThreeJS() {
            GAME_HEIGHT = (GAME_WIDTH * canvas.offsetHeight) / canvas.offsetWidth;
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, canvas.offsetWidth / canvas.offsetHeight, 0.1, 1000);
            camera.position.set(0, 50, GAME_HEIGHT / 2 + 10);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(10, 30, 20);
            scene.add(directionalLight);
            raycaster = new THREE.Raycaster();
            const planeGeo = new THREE.PlaneGeometry(GAME_WIDTH, GAME_HEIGHT);
            const planeMat = new THREE.MeshBasicMaterial({ visible: false });
            gamePlane = new THREE.Mesh(planeGeo, planeMat);
            gamePlane.rotation.x = -Math.PI / 2;
            scene.add(gamePlane);
        }
        function initCharacterSelection() {
            characterGrid.innerHTML = '';
            CHARACTERS.forEach(char => {
                const card = document.createElement('div');
                card.className = 'p-4 rounded-lg cursor-pointer character-card bg-black bg-opacity-40';
                card.style.borderColor = `#${new THREE.Color(char.color).getHexString()}`;
                card.dataset.name = char.name;
                card.innerHTML = `<h3 class="text-2xl font-bold" style="color: #${new THREE.Color(char.color).getHexString()}; text-shadow: 0 0 5px #${new THREE.Color(char.color).getHexString()};">${char.name}</h3><p class="text-lg">${char.faction}</p>`;
                card.addEventListener('click', () => selectCharacter(char, card));
                characterGrid.appendChild(card);
            });
        }
        function selectCharacter(char, card) {
            selectedCharacter = char;
            document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
            card.classList.add('selected');
            charName.textContent = char.name;
            charFaction.textContent = char.faction;
            charPassive.textContent = char.passive;
            charAbility.textContent = char.ability;
            playGameBtn.classList.remove('hidden');
        }
        function spawnEnemies() {
            const enemyCount = 5 + wave * 2;
            for (let i = 0; i < enemyCount; i++) {
                const x = (Math.random() - 0.5) * GAME_WIDTH;
                const z = -GAME_HEIGHT / 2 - Math.random() * GAME_HEIGHT;
                let type = 'drone';
                const rand = Math.random();
                if (wave > 2 && rand < 0.2) type = 'warrior';
                else if (wave > 1 && rand < 0.4) type = 'facehugger';
                enemies.push(new Enemy(x, z, type));
            }
        }
        function updateScore(amount) {
            const multiplier = activePowerups.scoreMultiplier ? 2 : 1;
            score += (amount * multiplier);
            scoreEl.textContent = score;
        }
        function updateHealthBar() {
            const percentage = (player.health / player.maxHealth) * 100;
            playerHealthBar.style.width = `${percentage}%`;
            playerHealthBar.className = 'h-full ';
            if (percentage < 25) playerHealthBar.classList.add('bg-red-500');
            else if (percentage < 60) playerHealthBar.classList.add('bg-yellow-500');
            else playerHealthBar.classList.add('bg-green-500');
        }
        function useAbility() {
            if (!abilityReady || isPaused) return;
            abilityReady = false;
            abilityCooldownTimer = selectedCharacter.abilityCooldown;
            switch(selectedCharacter.name) {
                case 'Wendy':
                    enemies.forEach(e => e.isStunned = true);
                    setTimeout(() => enemies.forEach(e => e.isStunned = false), selectedCharacter.abilityDuration);
                    break;
                case 'Morrow':
                    const intersects = raycaster.intersectObject(gamePlane);
                    if (intersects.length > 0) {
                        const target = intersects[0].point;
                        player.shoot(target);
                        setTimeout(() => player.shoot(target), 150);
                        setTimeout(() => player.shoot(target), 300);
                    }
                    break;
                case 'Kirsh':
                    player.isShielded = true;
                    player.addShieldVisual(0xffffff, 4);
                    setTimeout(() => {
                        player.isShielded = false;
                        player.model.remove(this.shieldVisual);
                        this.shieldVisual = null;
                        if (player.character.name === 'Kirsh' && player.passiveShieldReady) {
                            player.addShieldVisual(0x00ffff, 3.5);
                        }
                    }, selectedCharacter.abilityDuration);
                    break;
            }
        }
        function activatePowerup(powerup) {
            showToast(powerup.info.name, `#${new THREE.Color(powerup.info.color).getHexString()}`);
            if (powerup.info.duration > 0) {
                if (activePowerups[powerup.info.type]) clearTimeout(activePowerups[powerup.info.type].timer);
                const timer = setTimeout(() => {
                    delete activePowerups[powerup.info.type];
                }, powerup.info.duration);
                activePowerups[powerup.info.type] = { timer: timer };
            }
            switch(powerup.info.type) {
                case 'shield':
                    activePowerups.shield = true;
                    player.addShieldVisual(0xadd8e6, 3);
                    break;
                case 'megaBomb': activePowerups.megaBomb = true; break;
                case 'nuke':
                    enemies.forEach(enemy => {
                        updateScore(enemy.scoreValue);
                        scene.remove(enemy.model);
                    });
                    enemies = [];
                    break;
                case 'healthPack': player.heal(25); break;
            }
        }
        function showToast(message, bgColor) {
            const toast = document.createElement('div');
            toast.className = 'powerup-toast';
            toast.textContent = message;
            toast.style.backgroundColor = bgColor;
            powerupToastContainer.appendChild(toast);
            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.bottom = '40px';
            }, 10);
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.bottom = '20px';
                setTimeout(() => toast.remove(), 500);
            }, 2000);
        }
        function togglePause() {
            if (!gameActive) return;
            isPaused = !isPaused;
            pauseModal.classList.toggle('hidden', !isPaused);
            if (!isPaused) gameLoop();
        }
        function gameLoop() {
            if (!gameActive || isPaused) return;
            gameLoopId = requestAnimationFrame(gameLoop);
            player.update();
            projectiles.forEach((p, i) => {
                p.update();
                const dist = p.model.position.distanceTo(p.target);
                if (dist < p.speed || p.model.position.z < -GAME_HEIGHT/2 || p.model.position.z > GAME_HEIGHT/2) {
                    explosions.push(new Explosion(p.model.position, player.character.projectileColor, p.isMega, player.character.name));
                    scene.remove(p.model);
                    projectiles.splice(i, 1);
                }
            });
            explosions.forEach((exp, i) => {
                exp.update();
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (exp.model.position.distanceTo(enemy.model.position) < exp.model.scale.x) {
                        updateScore(enemy.scoreValue);
                        if (Math.random() < 0.15) {
                            const dropPosition = new THREE.Vector3(enemy.model.position.x, 2, enemy.model.position.z);
                            powerups.push(new Powerup(dropPosition));
                        }
                        scene.remove(enemy.model);
                        enemies.splice(j, 1);
                    }
                }
                for (let j = powerups.length - 1; j >= 0; j--) {
                    const powerup = powerups[j];
                    if (!powerup.isTractored && exp.model.position.distanceTo(powerup.model.position) < exp.model.scale.x) {
                        powerup.startTractorBeam();
                    }
                }
                if (exp.life <= 0) {
                    scene.remove(exp.model);
                    explosions.splice(i, 1);
                }
            });
            enemies.forEach((enemy, i) => {
                enemy.update();
                if (enemy.model.position.distanceTo(player.model.position) < 4) {
                    player.takeDamage(10);
                    scene.remove(enemy.model);
                    enemies.splice(i, 1);
                } else if (enemy.model.position.z > GAME_HEIGHT / 2) {
                    player.takeDamage(20);
                    scene.remove(enemy.model);
                    enemies.splice(i, 1);
                }
            });
            powerups.forEach((p, i) => {
                p.update();
                if (!p.isTractored && p.model.position.distanceTo(player.model.position) < 4) {
                    activatePowerup(p);
                    scene.remove(p.model);
                    if (p.tractorBeam) p.model.remove(p.tractorBeam);
                    powerups.splice(i, 1);
                } else if (p.model.position.z > GAME_HEIGHT / 2) {
                    scene.remove(p.model);
                    if (p.tractorBeam) p.model.remove(p.tractorBeam);
                    powerups.splice(i, 1);
                }
            });
            if (enemies.length === 0) { wave++; waveEl.textContent = wave; spawnEnemies(); }
            if (!abilityReady) {
                abilityCooldownTimer -= 1000 / 60;
                abilityCooldownBar.style.width = `${100 - (abilityCooldownTimer / selectedCharacter.abilityCooldown) * 100}%`;
                if (abilityCooldownTimer <= 0) { abilityReady = true; abilityCooldownBar.style.width = '100%'; }
            }
            renderer.render(scene, camera);
        }
        // --- High Score Logic ---
        function getHighScores() {
            const scores = localStorage.getItem('alienEarthHighScores');
            return scores ? JSON.parse(scores) : [];
        }
        function saveHighScore(score, initials) {
            const scores = getHighScores();
            scores.push({ score, initials });
            scores.sort((a, b) => b.score - a.score);
            scores.splice(5);
            localStorage.setItem('alienEarthHighScores', JSON.stringify(scores));
        }
        function displayHighScores() {
            highScoreList.innerHTML = '';
            const scores = getHighScores();
            if (scores.length === 0) {
                highScoreList.innerHTML = '<li class="text-gray-400">No scores yet. Be the first!</li>';
            } else {
                scores.forEach(s => {
                    const li = document.createElement('li');
                    li.innerHTML = `<span class="text-fuchsia-400">${s.initials.toUpperCase()}</span> - <span class="text-yellow-300">${s.score}</span>`;
                    highScoreList.appendChild(li);
                });
            }
        }
        // --- Game State Management ---
        function showScreen(screenId) {
            ['start-screen', 'character-selection-screen', 'game-screen'].forEach(id => document.getElementById(id).classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }
        function playGame() {
            if (!selectedCharacter) return;
            score = 0; wave = 1; gameActive = true; isPaused = false;
            projectiles = []; enemies = []; explosions = []; powerups = [];
            activePowerups = {};
            scoreEl.textContent = score; waveEl.textContent = wave;
            showScreen('game-screen');
            initThreeJS();
            player = new Player(selectedCharacter);
            if (player.character.name === 'Kirsh' && player.passiveShieldReady) {
                player.addShieldVisual(0x00ffff, 3.5);
            }
            playerNameDisplay.textContent = player.character.name;
            updateHealthBar();
            abilityCooldownBar.style.width = '100%';
            spawnEnemies();
            gameLoop();
        }
        function endGame() {
            gameActive = false;
            cancelAnimationFrame(gameLoopId);
            finalScoreEl.textContent = score;
            finalWaveEl.textContent = wave;
            const highScores = getHighScores();
            if (score > 0 && (highScores.length < 5 || score > highScores[highScores.length - 1].score)) {
                finalStats.classList.add('hidden');
                newHighScoreInput.classList.remove('hidden');
            } else {
                finalStats.classList.remove('hidden');
                newHighScoreInput.classList.add('hidden');
            }
            gameOverModal.classList.remove('hidden');
            if (scene) { while(scene.children.length > 0){ scene.remove(scene.children[0]); } }
        }
        function restartGame() {
            gameOverModal.classList.add('hidden');
            selectedCharacter = null;
            playGameBtn.classList.add('hidden');
            charName.textContent = ''; charFaction.textContent = ''; charAbility.textContent = '';
            showScreen('character-selection-screen');
        }
        // --- Event Listeners ---
        startGameBtn.addEventListener('click', () => { showScreen('character-selection-screen'); initCharacterSelection(); });
        playGameBtn.addEventListener('click', playGame);
        restartGameBtn.addEventListener('click', restartGame);
        highScoreBtn.addEventListener('click', () => { displayHighScores(); highScoreModal.classList.remove('hidden'); });
        closeHsBtn.addEventListener('click', () => highScoreModal.classList.add('hidden'));
        resumeBtn.addEventListener('click', togglePause);
        submitScoreBtn.addEventListener('click', () => {
            const initials = playerInitialsInput.value;
            if (initials.trim().length > 0) {
                saveHighScore(score, initials);
                newHighScoreInput.classList.add('hidden');
                finalStats.classList.remove('hidden');
            }
        });
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / canvas.offsetWidth) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / canvas.offsetHeight) * 2 + 1;
            if (gameActive && raycaster) raycaster.setFromCamera(mouse, camera);
        });
        canvas.addEventListener('mousedown', () => {
            if (gameActive && raycaster && !isPaused) {
                const intersects = raycaster.intersectObject(gamePlane);
                if (intersects.length > 0) player.shoot(intersects[0].point);
            }
        });
        window.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            if (e.key === 'a' || e.key === 'ArrowLeft') keys.a.pressed = true;
            if (e.key === 'd' || e.key === 'ArrowRight') keys.d.pressed = true;
            if (e.key === 'q') useAbility();
            if (e.key === 'p') togglePause();
        });
        window.addEventListener('keyup', (e) => {
            if (!gameActive) return;
            if (e.key === 'a' || e.key === 'ArrowLeft') keys.a.pressed = false;
            if (e.key === 'd' || e.key === 'ArrowRight') keys.d.pressed = false;
        });
        leftTouch.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameActive) keys.a.pressed = true; });
        leftTouch.addEventListener('touchend', (e) => { e.preventDefault(); keys.a.pressed = false; });
        rightTouch.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameActive) keys.d.pressed = true; });
        rightTouch.addEventListener('touchend', (e) => { e.preventDefault(); keys.d.pressed = false; });
        fireTouch.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameActive && !isPaused && raycaster) {
                const intersects = raycaster.intersectObject(gamePlane);
                if (intersects.length > 0) player.shoot(intersects[0].point);
            }
        });
        window.addEventListener('resize', () => {
            if (!gameActive) return;
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            GAME_HEIGHT = (GAME_WIDTH * canvas.offsetWidth) / canvas.offsetHeight;
            scene.remove(gamePlane);
            const planeGeo = new THREE.PlaneGeometry(GAME_WIDTH, GAME_HEIGHT);
            gamePlane.geometry.dispose();
            gamePlane.geometry = planeGeo;
        }, false);
    </script>
</body>
</html>
