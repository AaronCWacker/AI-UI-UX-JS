<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alien: Earth - Open Station Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=stylesheet" rel="stylesheet">
    <style>
        body { font-family: 'Orbitron', sans-serif; background-color: #05050a; color: #e0e0e0; margin: 0; overflow: hidden; position: fixed; width: 100%; height: 100%; }
        #game-container { border: 4px solid #333; box-shadow: 0 0 20px #00ffff; width: 100vw; height: 100vh; position: relative; }
        .text-glow { text-shadow: 0 0 10px #00ffff; }
        .btn-glow { box-shadow: 0 0 10px #00ffff; transition: all 0.3s ease; padding: 1rem 2rem; background: #00ffff; color: #000; border: none; cursor: pointer; font-weight: bold; border-radius: 4px; }
        canvas { background-color: #000; display: block; width: 100%; height: 100%; }
        #hud { position: absolute; top: 10px; left: 10px; z-index: 50; pointer-events: none; display: none; }
        #health-bar-container { width: 200px; height: 20px; background: rgba(0,0,0,0.7); border: 2px solid #00ffff; border-radius: 4px; overflow: hidden; margin-top: 5px; }
        #health-bar { height: 100%; background: #10b981; transition: width 0.3s ease; width: 100%; }
        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; justify-content: center; align-items: center; z-index: 1000; background: rgba(0,0,0,0.9); flex-direction: column; display: flex; }
        #character-selection-screen { display: none; }
        #character-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin: 20px; }
        .character-card { border: 2px solid #444; padding: 15px; cursor: pointer; border-radius: 8px; background: rgba(255,255,255,0.05); }
        .character-card.selected { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; background: rgba(0,255,255,0.1); }
        .powerup-toast { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); background: #10b981; color: #000; padding: 10px 20px; border-radius: 5px; opacity: 0; transition: opacity 0.5s; font-weight: bold; z-index: 200; }
        #game-over-modal { display: none; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="hud">
            <div class="text-glow">SCORE: <span id="score">0</span> | KILLS: <span id="kill-count">0</span></div>
            <div id="boss-hud" style="display:none; color: #ff0000; font-weight: bold;">BOSS DETECTED</div>
            <div id="health-bar-container"><div id="health-bar"></div></div>
        </div>

        <div id="start-screen" class="modal">
            <h1 class="text-glow">ALIEN: EARTH</h1>
            <h2>STATION INFILTRATION</h2>
            <button id="start-game-btn" class="btn-glow">INITIATE MISSION</button>
        </div>

        <div id="character-selection-screen" class="modal">
            <h2 class="text-glow">SELECT PILOT</h2>
            <div id="character-grid"></div>
            <button id="play-game-btn" class="btn-glow" style="display:none">LAUNCH</button>
        </div>

        <div id="game-over-modal" class="modal">
            <h1 id="win-loss-title" class="text-glow">MISSION FAILURE</h1>
            <p>Score: <span id="final-score">0</span></p>
            <button onclick="location.reload()" class="btn-glow">RESTART SYSTEM</button>
        </div>

        <div class="powerup-toast" id="toast">SYSTEM REPAIR +10%</div>
        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const scoreEl = document.getElementById('score');
        const killEl = document.getElementById('kill-count');
        const healthBar = document.getElementById('health-bar');
        const toast = document.getElementById('toast');

        let scene, camera, renderer, raycaster, mouse, gamePlane;
        let player, gameActive = false, score = 0, kills = 0, bossSpawned = false;
        let projectiles = [], enemies = [], structures = [], enemyProjectiles = [];
        let keys = { w: {pressed:false}, a: {pressed:false}, s: {pressed:false}, d: {pressed:false} };
        let selectedCharData = null;

        const STATION_BOUNDS = 200;
        const CHARACTERS = [
            { name: 'Kirsh', color: 0x00ffff, emoji: 'üõ°Ô∏è' },
            { name: 'Ravage', color: 0xff4444, emoji: 'üöÄ' },
            { name: 'Sif', color: 0xfbbf24, emoji: '‚è±Ô∏è' },
            { name: 'Nexus', color: 0x8b5cf6, emoji: 'üõ∏' }
        ];

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 40;
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            scene.add(new THREE.AmbientLight(0x404040, 2), new THREE.DirectionalLight(0xffffff, 1));

            const gridHelper = new THREE.GridHelper(STATION_BOUNDS * 2, 50, 0x00ffff, 0x111111);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);

            gamePlane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshBasicMaterial({ visible: false }));
            scene.add(gamePlane);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }

        class Player {
            constructor(char) {
                this.health = 100;
                this.targetRegen = 100;
                this.speed = 0.5;
                this.fireRate = 180;
                this.lastShot = 0;
                const geo = new THREE.BoxGeometry(2, 1, 2);
                const mat = new THREE.MeshPhongMaterial({ color: char.color, emissive: char.color, emissiveIntensity: 0.4 });
                this.model = new THREE.Mesh(geo, mat);
                this.model.position.set(0, 0, 0);
            }
            update() {
                if (keys.a.pressed) this.model.position.x -= this.speed;
                if (keys.d.pressed) this.model.position.x += this.speed;
                if (keys.w.pressed) this.model.position.y += this.speed;
                if (keys.s.pressed) this.model.position.y -= this.speed;

                camera.position.x = this.model.position.x;
                camera.position.y = this.model.position.y;

                if (this.health < this.targetRegen) {
                    this.health += 0.05;
                    const s = 1 + Math.sin(Date.now()*0.01)*0.1;
                    this.model.scale.set(s,s,s);
                    healthBar.style.width = `${this.health}%`;
                } else { this.model.scale.set(1,1,1); }
            }
            takeDamage(amt) {
                const prev = this.health;
                this.health = Math.max(0, this.health - amt);
                this.targetRegen = this.health + (prev - this.health) * 0.5;
                if (this.health <= 0) endGame("MISSION FAILURE");
            }
            shoot(target) {
                if (Date.now() - this.lastShot < this.fireRate) return;
                this.lastShot = Date.now();
                const dir = new THREE.Vector3().subVectors(target, this.model.position).normalize();
                projectiles.push(new Projectile(this.model.position.clone(), dir, true));
            }
        }

        class Projectile {
            constructor(pos, dir, isPlayer, isBoss = false) {
                this.isPlayer = isPlayer;
                this.dir = dir;
                this.speed = isPlayer ? 1.5 : (isBoss ? 0.3 : 0.2);
                const geo = new THREE.SphereGeometry(isBoss ? 1 : 0.4, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: isPlayer ? 0x00ffff : 0xff0000 });
                this.model = new THREE.Mesh(geo, mat);
                this.model.position.copy(pos);
                scene.add(this.model);
            }
            update() { this.model.position.add(this.dir.clone().multiplyScalar(this.speed)); }
        }

        class Structure {
            constructor(x, y) {
                this.group = new THREE.Group();
                this.health = 40;
                const frame = new THREE.Mesh(new THREE.BoxGeometry(10, 10, 4), new THREE.MeshPhongMaterial({ color: 0x444455 }));
                this.door = new THREE.Mesh(new THREE.BoxGeometry(4, 6, 0.5), new THREE.MeshPhongMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 }));
                this.door.position.z = 2.1;
                this.group.add(frame, this.door);
                this.group.position.set(x, y, 0);
                scene.add(this.group);
            }
            update() {
                const dist = player.model.position.distanceTo(this.group.position);
                if (this.door && dist < 12) {
                    this.door.position.y = THREE.MathUtils.lerp(this.door.position.y, 6, 0.1);
                } else if (this.door) {
                    this.door.position.y = THREE.MathUtils.lerp(this.door.position.y, 0, 0.1);
                }
            }
        }

        class Boss {
            constructor() {
                this.health = 500;
                this.model = new THREE.Mesh(new THREE.IcosahedronGeometry(6), new THREE.MeshPhongMaterial({ color: 0xff0000, wireframe: true }));
                this.model.position.set(0, 150, 0);
                this.shootTimer = 0;
                scene.add(this.model);
                document.getElementById('boss-hud').style.display = 'block';
            }
            update() {
                const dir = new THREE.Vector3().subVectors(player.model.position, this.model.position).normalize();
                this.model.position.add(dir.multiplyScalar(0.05));
                this.shootTimer++;
                if(this.shootTimer > 60) {
                    for(let i=0; i<8; i++) {
                        const angle = (i/8) * Math.PI * 2;
                        const bDir = new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0);
                        enemyProjectiles.push(new Projectile(this.model.position.clone(), bDir, false, true));
                    }
                    this.shootTimer = 0;
                }
            }
        }

        function gameLoop() {
            if (!gameActive) return;
            requestAnimationFrame(gameLoop);

            player.update();
            
            if (player.model.position.y > 120 && !bossSpawned) {
                bossSpawned = new Boss();
            }

            if (bossSpawned) bossSpawned.update();

            projectiles.forEach((p, pi) => {
                p.update();
                if (bossSpawned && p.model.position.distanceTo(bossSpawned.model.position) < 6) {
                    bossSpawned.health -= 5;
                    scene.remove(p.model); projectiles.splice(pi, 1);
                    if (bossSpawned.health <= 0) endGame("MISSION ACCOMPLISHED");
                }
                enemyProjectiles.forEach((ep, epi) => {
                    if (p.model.position.distanceTo(ep.model.position) < 2) {
                        player.fireRate = Math.max(50, player.fireRate - 5);
                        scene.remove(ep.model); enemyProjectiles.splice(epi, 1);
                        scene.remove(p.model); projectiles.splice(pi, 1);
                    }
                });
            });

            enemyProjectiles.forEach((ep, epi) => {
                ep.update();
                if (ep.model.position.distanceTo(player.model.position) < 2) {
                    player.takeDamage(10);
                    scene.remove(ep.model); enemyProjectiles.splice(epi, 1);
                }
            });

            structures.forEach(s => s.update());
            renderer.render(scene, camera);
        }

        function endGame(title) {
            gameActive = false;
            document.getElementById('win-loss-title').innerText = title;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-modal').style.display = 'flex';
        }

        document.getElementById('start-game-btn').onclick = () => {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('character-selection-screen').style.display = 'flex';
            const grid = document.getElementById('character-grid');
            CHARACTERS.forEach(c => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.innerHTML = `<div style="font-size:2rem">${c.emoji}</div><div>${c.name}</div>`;
                card.onclick = () => {
                    document.querySelectorAll('.character-card').forEach(el => el.classList.remove('selected'));
                    card.classList.add('selected');
                    selectedCharData = c;
                    document.getElementById('play-game-btn').style.display = 'block';
                };
                grid.appendChild(card);
            });
        };

        document.getElementById('play-game-btn').onclick = () => {
            document.getElementById('character-selection-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            initThreeJS();
            player = new Player(selectedCharData);
            scene.add(player.model);
            for(let i=0; i<15; i++) {
                structures.push(new Structure(Math.random()*80-40, i * 15 - 50));
            }
            gameActive = true;
            gameLoop();
        };

        window.addEventListener('keydown', e => { if(keys[e.key.toLowerCase()]) keys[e.key.toLowerCase()].pressed = true; });
        window.addEventListener('keyup', e => { if(keys[e.key.toLowerCase()]) keys[e.key.toLowerCase()].pressed = false; });
        canvas.addEventListener('mousedown', e => {
            if (!gameActive) return;
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / canvas.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / canvas.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObject(gamePlane);
            if (hits.length > 0) player.shoot(hits[0].point);
        });
    </script>
</body>
</html>
