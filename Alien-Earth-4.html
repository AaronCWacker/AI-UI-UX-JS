<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alien: Earth - Space Station Siege</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=stylesheet" rel="stylesheet">
    <style>
        body { font-family: 'Orbitron', sans-serif; background-color: #05050a; color: #e0e0e0; margin: 0; overflow: hidden; position: fixed; width: 100%; height: 100%; }
        #game-container { border: 4px solid #333; box-shadow: 0 0 20px #00ffff; width: 100vw; height: 100vh; position: relative; }
        .text-glow { text-shadow: 0 0 10px #00ffff; }
        .btn-glow { box-shadow: 0 0 10px #00ffff; transition: all 0.3s ease; padding: 1rem 2rem; background: #00ffff; color: #000; border: none; cursor: pointer; font-weight: bold; }
        canvas { background-color: #000; display: block; width: 100%; height: 100%; }
        #hud { position: absolute; top: 10px; left: 10px; z-index: 50; pointer-events: none; }
        #health-bar-container { width: 200px; height: 20px; background: rgba(0,0,0,0.7); border: 2px solid #00ffff; border-radius: 4px; overflow: hidden; margin-top: 5px; }
        #health-bar { height: 100%; background: #10b981; transition: width 0.3s ease; width: 100%; }
        .modal { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; justify-content: center; align-items: center; z-index: 1000; background: rgba(0,0,0,0.85); flex-direction: column; }
        #start-screen { display: flex; text-align: center; }
        #character-selection-screen { display: none; text-align: center; padding: 20px; }
        #character-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin: 20px; }
        .character-card { border: 2px solid #444; padding: 10px; cursor: pointer; border-radius: 8px; }
        .character-card.selected { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; }
        .powerup-toast { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); background: #10b981; color: #000; padding: 10px 20px; border-radius: 5px; opacity: 0; transition: opacity 0.5s; font-weight: bold; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="hud">
            <div class="text-glow">SCORE: <span id="score">0</span></div>
            <div class="text-glow">KILLS: <span id="kill-count">0</span></div>
            <div id="health-bar-container"><div id="health-bar"></div></div>
        </div>

        <div id="start-screen" class="modal">
            <h1 class="text-glow">ALIEN: EARTH</h1>
            <h2>SPACE STATION INFILTRATION</h2>
            <button id="start-game-btn" class="btn-glow">ENTER STATION</button>
        </div>

        <div id="character-selection-screen" class="modal">
            <h2 class="text-glow">CHOOSE YOUR PILOT</h2>
            <div id="character-grid"></div>
            <button id="play-game-btn" class="btn-glow" style="display:none">ENGAGE</button>
        </div>

        <div id="game-over-modal" class="modal">
            <h1 class="text-glow">PILOT DOWN</h1>
            <p>Score: <span id="final-score">0</span></p>
            <button onclick="location.reload()" class="btn-glow">REBOOT</button>
        </div>

        <div class="powerup-toast" id="toast">SYSTEM REPAIR +10%</div>
        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const scoreEl = document.getElementById('score');
        const killEl = document.getElementById('kill-count');
        const healthBar = document.getElementById('health-bar');
        const toast = document.getElementById('toast');

        let scene, camera, renderer, raycaster, mouse, gamePlane;
        let player, gameActive = false, score = 0, kills = 0;
        let projectiles = [], enemies = [], structures = [], enemyProjectiles = [];
        let keys = { w: {pressed:false}, a: {pressed:false}, s: {pressed:false}, d: {pressed:false} };
        let GAME_WIDTH = 60, GAME_HEIGHT = 80;

        const CHARACTERS = [
            { name: 'Kirsh', color: 0x00ffff, emoji: 'ðŸ›¡ï¸' },
            { name: 'Ravage', color: 0xff4444, emoji: 'ðŸš€' },
            { name: 'Sif', color: 0xfbbf24, emoji: 'â±ï¸' },
            { name: 'Nexus', color: 0x8b5cf6, emoji: 'ðŸ›¸' }
        ];

        class Player {
            constructor(char) {
                this.health = 100;
                this.targetRegen = 100;
                this.speed = 0.35;
                this.fireRate = 200;
                this.lastShot = 0;
                const geo = new THREE.BoxGeometry(2, 1, 2);
                const mat = new THREE.MeshPhongMaterial({ color: char.color, emissive: char.color, emissiveIntensity: 0.5 });
                this.model = new THREE.Mesh(geo, mat);
                this.model.position.set(0, -30, 0);
                scene.add(this.model);
            }
            update() {
                if (keys.a.pressed && this.model.position.x > -GAME_WIDTH/2) this.model.position.x -= this.speed;
                if (keys.d.pressed && this.model.position.x < GAME_WIDTH/2) this.model.position.x += this.speed;
                if (keys.w.pressed && this.model.position.y < GAME_HEIGHT/2) this.model.position.y += this.speed;
                if (keys.s.pressed && this.model.position.y > -GAME_HEIGHT/2) this.model.position.y -= this.speed;

                if (this.health < this.targetRegen) {
                    this.health += 0.05;
                    const s = 1 + Math.sin(Date.now()*0.01)*0.15;
                    this.model.scale.set(s,s,s);
                    this.updateUI();
                } else {
                    this.model.scale.set(1,1,1);
                }
            }
            takeDamage(amt) {
                const prev = this.health;
                this.health = Math.max(0, this.health - amt);
                this.targetRegen = this.health + (prev - this.health) * 0.5;
                this.updateUI();
                if (this.health <= 0) endGame();
            }
            updateUI() { healthBar.style.width = `${this.health}%`; }
            shoot(target) {
                if (Date.now() - this.lastShot < this.fireRate) return;
                this.lastShot = Date.now();
                const dir = new THREE.Vector3().subVectors(target, this.model.position).normalize();
                projectiles.push(new Projectile(this.model.position.clone(), dir, true));
            }
        }

        class Projectile {
            constructor(pos, dir, isPlayer) {
                this.isPlayer = isPlayer;
                this.dir = dir;
                this.speed = isPlayer ? 1.0 : 0.12;
                const geo = new THREE.SphereGeometry(isPlayer ? 0.3 : 0.6, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: isPlayer ? 0x00ffff : 0xff00ff });
                this.model = new THREE.Mesh(geo, mat);
                this.model.position.copy(pos);
                scene.add(this.model);
            }
            update() { this.model.position.add(this.dir.clone().multiplyScalar(this.speed)); }
        }

        class StationModule {
            constructor() {
                this.group = new THREE.Group();
                this.speed = 0.1;
                this.isDestructible = true;
                this.health = 30;

                // Building Shell
                const frame = new THREE.Mesh(
                    new THREE.BoxGeometry(20, 15, 2),
                    new THREE.MeshPhongMaterial({ color: 0x333344, wireframe: false })
                );
                
                // Door/Gate (Destructible)
                this.door = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 10, 0.5),
                    new THREE.MeshPhongMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 })
                );
                this.door.position.z = 0.5;

                this.group.add(frame);
                this.group.add(this.door);
                this.group.position.set(Math.random()*40 - 20, 50, 0);
                scene.add(this.group);
            }
            update() { this.group.position.y -= this.speed; }
        }

        class Enemy {
            constructor() {
                const geo = new THREE.OctahedronGeometry(1.2);
                const mat = new THREE.MeshPhongMaterial({ color: 0xff00ff });
                this.model = new THREE.Mesh(geo, mat);
                this.model.position.set(Math.random()*GAME_WIDTH - GAME_WIDTH/2, 50, 0);
                this.shootTimer = 0;
                scene.add(this.model);
            }
            update() {
                this.model.position.y -= 0.08;
                this.shootTimer++;
                if (this.shootTimer > 250) {
                    const dir = new THREE.Vector3().subVectors(player.model.position, this.model.position).normalize();
                    enemyProjectiles.push(new Projectile(this.model.position.clone(), dir, false));
                    this.shootTimer = 0;
                }
            }
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 45;
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            scene.add(new THREE.AmbientLight(0x404040), new THREE.PointLight(0xffffff, 1));
            gamePlane = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshBasicMaterial({ visible: false }));
            scene.add(gamePlane);
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }

        function gameLoop() {
            if (!gameActive) return;
            requestAnimationFrame(gameLoop);

            player.update();

            // Spawn
            if (Math.random() < 0.02) enemies.push(new Enemy());
            if (Math.random() < 0.005) structures.push(new StationModule());

            // Projectiles vs World
            projectiles.forEach((p, pi) => {
                p.update();
                
                // Hit Enemies
                enemies.forEach((e, ei) => {
                    if (p.model.position.distanceTo(e.model.position) < 2) {
                        cleanup(e.model, enemies, ei);
                        cleanup(p.model, projectiles, pi);
                        handleKill();
                    }
                });

                // Hit Doors
                structures.forEach((s) => {
                    if (s.door && p.model.position.distanceTo(s.group.position) < 4) {
                        s.health -= 10;
                        cleanup(p.model, projectiles, pi);
                        if (s.health <= 0) {
                            s.group.remove(s.door);
                            s.door = null;
                            score += 500;
                        }
                    }
                });

                // Shoot Down Enemy Bullets
                enemyProjectiles.forEach((ep, epi) => {
                    if (p.model.position.distanceTo(ep.model.position) < 2) {
                        cleanup(ep.model, enemyProjectiles, epi);
                        cleanup(p.model, projectiles, pi);
                        player.fireRate = Math.max(50, player.fireRate - 4);
                    }
                });
            });

            enemyProjectiles.forEach((ep, epi) => {
                ep.update();
                if (ep.model.position.distanceTo(player.model.position) < 2) {
                    player.takeDamage(15);
                    cleanup(ep.model, enemyProjectiles, epi);
                }
            });

            enemies.forEach(e => e.update());
            structures.forEach(s => s.update());

            renderer.render(scene, camera);
        }

        function handleKill() {
            kills++;
            score += 100;
            killEl.innerText = kills;
            scoreEl.innerText = score;
            if (kills % 10 === 0) {
                player.health = Math.min(100, player.health + 10);
                player.targetRegen = Math.min(100, player.targetRegen + 10);
                toast.style.opacity = 1;
                setTimeout(() => toast.style.opacity = 0, 1500);
            }
        }

        function cleanup(obj, arr, idx) {
            scene.remove(obj);
            arr.splice(idx, 1);
        }

        function endGame() {
            gameActive = false;
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-modal').style.display = 'flex';
        }

        // Setup UI
        document.getElementById('start-game-btn').onclick = () => {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('character-selection-screen').style.display = 'flex';
            const grid = document.getElementById('character-grid');
            CHARACTERS.forEach(c => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.innerHTML = `<div style="font-size:2rem">${c.emoji}</div><div>${c.name}</div>`;
                card.onclick = () => {
                    document.querySelectorAll('.character-card').forEach(el => el.classList.remove('selected'));
                    card.classList.add('selected');
                    player = new Player(c);
                    document.getElementById('play-game-btn').style.display = 'block';
                };
                grid.appendChild(card);
            });
        };

        document.getElementById('play-game-btn').onclick = () => {
            document.getElementById('character-selection-screen').style.display = 'none';
            initThreeJS();
            scene.add(player.model);
            gameActive = true;
            gameLoop();
        };

        window.addEventListener('keydown', e => { if(keys[e.key.toLowerCase()]) keys[e.key.toLowerCase()].pressed = true; });
        window.addEventListener('keyup', e => { if(keys[e.key.toLowerCase()]) keys[e.key.toLowerCase()].pressed = false; });
        canvas.addEventListener('mousedown', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / canvas.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / canvas.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(gamePlane);
            if (intersects.length > 0) player.shoot(intersects[0].point);
        });
    </script>
</body>
</html>
