<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alien: Earth - Cathedral Siege v6</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Orbitron', monospace; color: #fff; cursor: crosshair; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        .hud { padding: 15px 25px; display: none; }
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        .hud-left, .hud-right { background: rgba(0,0,0,0.6); padding: 12px 18px; border: 1px solid rgba(0,255,255,0.3); }
        
        .stat-label { font-size: 0.6rem; color: #0af; letter-spacing: 2px; margin-bottom: 3px; }
        .bar-container { width: 180px; height: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(0,255,255,0.5); margin-bottom: 8px; position: relative; overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.15s ease-out; }
        .bar-glow { position: absolute; top: 0; left: 0; height: 100%; width: 30px; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent); animation: barShine 2s infinite; }
        @keyframes barShine { 0%,100% { transform: translateX(-30px); } 50% { transform: translateX(180px); } }
        
        #health-fill { background: linear-gradient(90deg, #0f6, #0ff); }
        #shield-fill { background: linear-gradient(90deg, #08f, #80f); }
        #energy-fill { background: linear-gradient(90deg, #f80, #ff0); }
        #boss-fill { background: linear-gradient(90deg, #f00, #f60); }
        
        .stats-row { display: flex; gap: 20px; font-size: 0.75rem; margin-top: 8px; }
        .stat { display: flex; flex-direction: column; }
        .stat-value { color: #0ff; font-size: 1rem; font-weight: bold; }
        
        #combo-display { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 3rem; font-weight: 900; color: #ff0; text-shadow: 0 0 20px #f80, 0 0 40px #f00; opacity: 0; transition: all 0.2s; pointer-events: none; }
        #combo-display.active { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        
        #wave-announce { position: absolute; top: 30%; left: 50%; transform: translateX(-50%); text-align: center; opacity: 0; transition: all 0.5s; }
        #wave-announce h2 { font-size: 3rem; color: #f00; text-shadow: 0 0 30px #f00; letter-spacing: 10px; }
        #wave-announce p { font-size: 1rem; color: #fff; margin-top: 10px; }
        
        #powerup-toast { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); background: linear-gradient(90deg, transparent, rgba(0,255,136,0.3), transparent); padding: 10px 40px; font-size: 0.9rem; color: #0f8; opacity: 0; transition: 0.3s; }
        
        #weapon-display { position: absolute; bottom: 20px; left: 20px; display: flex; gap: 10px; }
        .weapon-slot { width: 50px; height: 50px; border: 2px solid #333; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; font-size: 1.5rem; opacity: 0.5; transition: 0.2s; }
        .weapon-slot.active { border-color: #0ff; opacity: 1; box-shadow: 0 0 15px rgba(0,255,255,0.5); }
        .weapon-slot.locked { opacity: 0.2; }
        
        #minimap { position: absolute; bottom: 20px; right: 20px; width: 150px; height: 150px; border: 1px solid rgba(0,255,255,0.5); background: rgba(0,0,0,0.7); }
        #minimap-canvas { width: 100%; height: 100%; }
        
        #boss-ui { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); text-align: center; opacity: 0; transition: 0.5s; }
        #boss-ui.active { opacity: 1; }
        #boss-name { font-size: 1.2rem; color: #f44; letter-spacing: 5px; margin-bottom: 5px; }
        #boss-bar { width: 400px; height: 12px; background: rgba(255,255,255,0.1); border: 2px solid #f44; }
        
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        
        #start-menu h1 { font-size: 4rem; font-weight: 900; background: linear-gradient(180deg, #0ff, #08f); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: none; filter: drop-shadow(0 0 30px rgba(0,255,255,0.5)); letter-spacing: 5px; }
        #start-menu .subtitle { color: #666; font-size: 0.9rem; letter-spacing: 8px; margin: 10px 0 30px; }
        
        .btn { padding: 15px 50px; background: transparent; color: #0ff; border: 2px solid #0ff; cursor: pointer; font-family: 'Orbitron'; font-weight: bold; font-size: 1rem; letter-spacing: 3px; transition: all 0.3s; position: relative; overflow: hidden; }
        .btn:hover { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
        .btn::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent); transition: 0.5s; }
        .btn:hover::before { left: 100%; }
        
        #char-sel { display: none; }
        .char-grid { display: flex; gap: 20px; margin: 30px 0; }
        .char-card { width: 180px; padding: 25px 15px; border: 2px solid #333; cursor: pointer; text-align: center; background: rgba(10,10,20,0.9); transition: 0.3s; }
        .char-card:hover { border-color: #666; transform: translateY(-5px); }
        .char-card.selected { border-color: #0ff; box-shadow: 0 0 25px rgba(0,255,255,0.4); }
        .char-icon { font-size: 3rem; margin-bottom: 10px; }
        .char-name { font-size: 1rem; color: #0ff; margin-bottom: 5px; }
        .char-desc { font-size: 0.65rem; color: #666; line-height: 1.4; }
        .char-stats { margin-top: 15px; font-size: 0.6rem; text-align: left; }
        .char-stat { display: flex; justify-content: space-between; margin: 3px 0; color: #888; }
        .char-stat span:last-child { color: #0f8; }
        
        #game-over { display: none; }
        #game-over h1 { font-size: 3rem; margin-bottom: 20px; }
        #final-stats { margin: 20px 0; padding: 20px; border: 1px solid #333; background: rgba(20,20,30,0.8); }
        .final-stat { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #222; }
        .final-stat:last-child { border: none; }
        
        #controls-hint { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); font-size: 0.65rem; color: #444; text-align: center; line-height: 1.8; }
        
        #damage-vignette { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; background: radial-gradient(ellipse at center, transparent 50%, rgba(255,0,0,0.6) 100%); transition: opacity 0.1s; }
        
        #crosshair { position: absolute; width: 30px; height: 30px; pointer-events: none; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(0,255,255,0.8); }
        #crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
        #crosshair::after { width: 100%; height: 2px; top: 50%; transform: translateY(-50%); }
        
        #hit-marker { position: absolute; width: 40px; height: 40px; pointer-events: none; opacity: 0; transition: opacity 0.1s; }
        #hit-marker::before, #hit-marker::after { content: ''; position: absolute; background: #ff0; }
        #hit-marker::before { width: 3px; height: 100%; left: 50%; transform: translateX(-50%) rotate(45deg); }
        #hit-marker::after { width: 100%; height: 3px; top: 50%; transform: translateY(-50%) rotate(45deg); }
        #hit-marker.active { opacity: 1; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="hud" class="hud">
        <div class="hud-top">
            <div class="hud-left">
                <div class="stat-label">HULL INTEGRITY</div>
                <div class="bar-container"><div id="health-fill" class="bar-fill" style="width:100%"></div><div class="bar-glow"></div></div>
                <div class="stat-label">SHIELDS</div>
                <div class="bar-container"><div id="shield-fill" class="bar-fill" style="width:100%"></div></div>
                <div class="stat-label">WEAPON ENERGY</div>
                <div class="bar-container"><div id="energy-fill" class="bar-fill" style="width:100%"></div></div>
                <div class="stats-row">
                    <div class="stat"><span class="stat-label">SCORE</span><span class="stat-value" id="score-val">0</span></div>
                    <div class="stat"><span class="stat-label">KILLS</span><span class="stat-value" id="kill-val">0</span></div>
                    <div class="stat"><span class="stat-label">WAVE</span><span class="stat-value" id="wave-val">1</span></div>
                </div>
                <div id="cover-indicator" style="margin-top:10px; padding:5px 10px; background:rgba(0,255,100,0.2); border:1px solid #0f8; display:none; font-size:0.7rem; color:#0f8;">üõ°Ô∏è IN COVER - Press E for Auto-Turret</div>
                <div id="super-charge" style="margin-top:8px; display:none;">
                    <div class="stat-label">SUPER WEAPON</div>
                    <div class="bar-container" style="border-color:#f0f;"><div id="super-fill" class="bar-fill" style="width:0%; background:linear-gradient(90deg, #f0f, #ff0);"></div></div>
                    <div style="font-size:0.6rem; color:#f0f;">Press Q when charged</div>
                </div>
            </div>
            <div class="hud-right">
                <div class="stat-label">ENEMIES</div>
                <div class="stat-value" id="enemy-count">0</div>
            </div>
        </div>
    </div>
    
    <div id="combo-display">x1</div>
    
    <div id="wave-announce">
        <h2>WAVE <span id="wave-num">1</span></h2>
        <p id="wave-desc">Reconnaissance Units Incoming</p>
    </div>
    
    <div id="boss-ui">
        <div id="boss-name">‚ö† CATHEDRAL GUARDIAN ‚ö†</div>
        <div id="boss-bar" class="bar-container" style="width:400px;border-color:#f44;"><div id="boss-fill" class="bar-fill" style="width:100%"></div></div>
    </div>
    
    <div id="powerup-toast">POWER-UP ACQUIRED</div>
    
    <div id="weapon-display">
        <div class="weapon-slot active" data-weapon="0" title="1: Pulse Cannon">‚ö°</div>
        <div class="weapon-slot" data-weapon="1" title="2: Spread Shot">üî±</div>
        <div class="weapon-slot" data-weapon="2" title="3: Beam Laser">üì°</div>
        <div class="weapon-slot locked" data-weapon="3" title="4: Missiles">üöÄ</div>
        <div class="weapon-slot" id="super-slot" data-weapon="super" title="Q: Super Nova (when charged)" style="border-color:#808; opacity:0.3;">üí•</div>
    </div>
    
    <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
    
    <div id="crosshair"></div>
    <div id="hit-marker"></div>
    <div id="damage-vignette"></div>
    
    <!-- START MENU -->
    <div id="start-menu" class="overlay">
        <h1>ALIEN: EARTH</h1>
        <div class="subtitle">CATHEDRAL SIEGE</div>
        <button class="btn" onclick="openCharSel()">BEGIN MISSION</button>
        <div id="controls-hint">
            WASD - Move | MOUSE - Aim | CLICK - Fire | SHIFT - Dash<br>
            1-4 - Weapons | Q/SPACE - Super Nova | E - Auto-Turret (in cover)
        </div>
    </div>
    
    <!-- CHARACTER SELECT -->
    <div id="char-sel" class="overlay">
        <h2 style="color:#0ff; letter-spacing: 5px;">SELECT OPERATIVE</h2>
        <div class="char-grid">
            <div class="char-card" onclick="selectPilot('striker', this)">
                <div class="char-icon">‚öîÔ∏è</div>
                <div class="char-name">STRIKER</div>
                <div class="char-desc">Balanced combat specialist with rapid fire capabilities</div>
                <div class="char-stats">
                    <div class="char-stat"><span>Speed</span><span>‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë</span></div>
                    <div class="char-stat"><span>Damage</span><span>‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë</span></div>
                    <div class="char-stat"><span>Shield</span><span>‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë</span></div>
                </div>
            </div>
            <div class="char-card" onclick="selectPilot('tank', this)">
                <div class="char-icon">üõ°Ô∏è</div>
                <div class="char-name">GUARDIAN</div>
                <div class="char-desc">Heavy armor with shield regeneration and area attacks</div>
                <div class="char-stats">
                    <div class="char-stat"><span>Speed</span><span>‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë</span></div>
                    <div class="char-stat"><span>Damage</span><span>‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë</span></div>
                    <div class="char-stat"><span>Shield</span><span>‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span></div>
                </div>
            </div>
            <div class="char-card" onclick="selectPilot('speed', this)">
                <div class="char-icon">üí®</div>
                <div class="char-name">PHANTOM</div>
                <div class="char-desc">High speed interceptor with enhanced dash and crit damage</div>
                <div class="char-stats">
                    <div class="char-stat"><span>Speed</span><span>‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span></div>
                    <div class="char-stat"><span>Damage</span><span>‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë</span></div>
                    <div class="char-stat"><span>Shield</span><span>‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë</span></div>
                </div>
            </div>
        </div>
        <button id="launch-btn" class="btn" style="display:none;" onclick="initGame()">LAUNCH</button>
    </div>
    
    <!-- GAME OVER -->
    <div id="game-over" class="overlay">
        <h1 id="status-text">MISSION COMPLETE</h1>
        <div id="final-stats">
            <div class="final-stat"><span>Final Score</span><span id="final-score">0</span></div>
            <div class="final-stat"><span>Enemies Destroyed</span><span id="final-kills">0</span></div>
            <div class="final-stat"><span>Waves Survived</span><span id="final-waves">0</span></div>
            <div class="final-stat"><span>Max Combo</span><span id="final-combo">0</span></div>
            <div class="final-stat"><span>Accuracy</span><span id="final-accuracy">0%</span></div>
        </div>
        <button class="btn" onclick="location.reload()">RETRY MISSION</button>
    </div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GAME STATE & CONFIGURATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const CONFIG = {
    classes: {
        striker: { speed: 0.9, fireRate: 100, damage: 1, maxHealth: 100, maxShield: 60, shieldRegen: 0.02, color: 0x00ffff, dashCooldown: 800 },
        tank: { speed: 0.6, fireRate: 180, damage: 0.8, maxHealth: 150, maxShield: 120, shieldRegen: 0.05, color: 0x00ff88, dashCooldown: 1200 },
        speed: { speed: 1.3, fireRate: 80, damage: 1.3, maxHealth: 70, maxShield: 30, shieldRegen: 0.01, color: 0xff00ff, dashCooldown: 400 }
    },
    weapons: [
        { name: 'Pulse', energyCost: 5, fireRate: 100, projectiles: 1, spread: 0, speed: 3.5, damage: 12, color: 0x00ffff },
        { name: 'Spread', energyCost: 12, fireRate: 180, projectiles: 5, spread: 0.25, speed: 3, damage: 8, color: 0xffff00 },
        { name: 'Beam', energyCost: 0.3, fireRate: 16, projectiles: 1, spread: 0, speed: 12, damage: 3, color: 0xff00ff, isBeam: true },
        { name: 'Missile', energyCost: 20, fireRate: 350, projectiles: 2, spread: 0.15, speed: 2, damage: 40, color: 0xff4400, homing: true }
    ],
    enemies: {
        drone: { health: 20, speed: 0.3, damage: 5, score: 100, size: 1, color: 0xff4444, behavior: 'chase' },
        shooter: { health: 40, speed: 0.15, damage: 8, score: 200, size: 1.5, color: 0xff8800, behavior: 'strafe', fireRate: 2000 },
        bomber: { health: 60, speed: 0.4, damage: 15, score: 300, size: 2, color: 0x8800ff, behavior: 'dive' },
        elite: { health: 150, speed: 0.25, damage: 12, score: 500, size: 2.5, color: 0xff0088, behavior: 'orbit', fireRate: 1200 }
    },
    waves: [
        { enemies: [{ type: 'drone', count: 5 }], desc: 'Reconnaissance Units' },
        { enemies: [{ type: 'drone', count: 8 }, { type: 'shooter', count: 2 }], desc: 'First Strike Team' },
        { enemies: [{ type: 'drone', count: 6 }, { type: 'shooter', count: 4 }], desc: 'Assault Squadron' },
        { enemies: [{ type: 'shooter', count: 5 }, { type: 'bomber', count: 3 }], desc: 'Heavy Bombardment' },
        { enemies: [{ type: 'drone', count: 10 }, { type: 'elite', count: 1 }], desc: 'Elite Commander' },
        { enemies: [{ type: 'shooter', count: 6 }, { type: 'bomber', count: 4 }, { type: 'elite', count: 2 }], desc: 'Full Invasion' },
        { enemies: [{ type: 'elite', count: 4 }, { type: 'bomber', count: 5 }], desc: 'Elite Guard' },
        { boss: true, desc: 'CATHEDRAL GUARDIAN' }
    ]
};

let scene, camera, renderer, clock;
let player, boss = null;
let gameActive = false, paused = false;
let score = 0, kills = 0, wave = 0, maxCombo = 0;
let combo = 0, comboTimer = 0;
let shotsFired = 0, shotsHit = 0;
let currentWeapon = 0, lastFireTime = 0;
let superCharge = 0, maxSuperCharge = 100;
let currentCoverShip = null;
let mousePos = { x: 0, y: 0 };
let worldMouse = new THREE.Vector3();

let projectiles = [], enemyBullets = [], enemies = [], powerups = [], particles = [];
let cathedrals = [], destructibles = [];

let keys = {}, mouseDown = false;
let screenShake = 0;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INITIALIZATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function openCharSel() {
    document.getElementById('start-menu').style.display = 'none';
    document.getElementById('char-sel').style.display = 'flex';
}

let selectedClass = null;
function selectPilot(cls, el) {
    selectedClass = cls;
    document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
    el.classList.add('selected');
    document.getElementById('launch-btn').style.display = 'block';
}

function initGame() {
    if (!selectedClass) return;
    
    document.getElementById('char-sel').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    
    clock = new THREE.Clock();
    
    // Scene Setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020208);
    scene.fog = new THREE.FogExp2(0x020208, 0.008);
    
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    renderer = new THREE.WebGLRenderer({ antialias: false }); // No AA for performance
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(1); // Force 1:1 for performance
    document.body.appendChild(renderer.domElement);
    
    // Lighting - brighter for visibility
    const sun = new THREE.DirectionalLight(0xffeedd, 1.8);
    sun.position.set(100, 150, 80);
    scene.add(sun);
    
    const ambient = new THREE.AmbientLight(0x445566, 0.9);
    scene.add(ambient);
    
    // Ground with grid texture
    createGround();
    
    // Player
    createPlayer();
    
    // Generate World
    generateCathedrals();
    generateLargeStructures();
    
    // Skybox stars
    createStarfield();
    
    // Start game loop
    gameActive = true;
    wave = 0;
    startNextWave();
    update();
}

function createGround() {
    // Simple flat ground - no vertex displacement for performance
    const groundGeo = new THREE.PlaneGeometry(2000, 2000, 10, 10);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0x0a0f0a });
    
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -15;
    scene.add(ground);
    
    // Simple grid
    const gridHelper = new THREE.GridHelper(2000, 100, 0x003333, 0x001111);
    gridHelper.position.y = -14.9;
    scene.add(gridHelper);
    
    // Fewer crystals, NO lights
    createAlienCrystals();
}

function createAlienCrystals() {
    const crystalColors = [0x00ffaa, 0x00aaff, 0xff00aa];
    
    // Reduced count, no lights
    for (let i = 0; i < 15; i++) {
        const color = crystalColors[i % crystalColors.length];
        const x = (Math.random() - 0.5) * 400;
        const z = Math.random() * 600 + 100;
        const height = 4 + Math.random() * 6;
        
        const crystalGeo = new THREE.ConeGeometry(1, height, 4);
        const crystalMat = new THREE.MeshBasicMaterial({ color });
        const crystal = new THREE.Mesh(crystalGeo, crystalMat);
        crystal.position.set(x, -15 + height / 2, z);
        scene.add(crystal);
    }
}

function createPlayer() {
    const cfg = CONFIG.classes[selectedClass];
    
    player = {
        health: cfg.maxHealth,
        maxHealth: cfg.maxHealth,
        shield: cfg.maxShield,
        maxShield: cfg.maxShield,
        energy: 100,
        maxEnergy: 100,
        speed: cfg.speed,
        fireRate: cfg.fireRate,
        damage: cfg.damage,
        shieldRegen: cfg.shieldRegen,
        color: cfg.color,
        dashCooldown: cfg.dashCooldown,
        lastDash: 0,
        isDashing: false,
        dashDir: new THREE.Vector3(),
        invincible: 0,
        mesh: new THREE.Group(),
        velocity: new THREE.Vector3()
    };
    
    // Ship body - more complex geometry
    const bodyGeo = new THREE.BufferGeometry();
    const vertices = new Float32Array([
        // Main fuselage
        0, 2, 0,    -1, -1.5, 0,    1, -1.5, 0,  // Top triangle
        0, 2, 0,    -1, -1.5, 0,    0, 0, 1,     // Left side
        0, 2, 0,    1, -1.5, 0,     0, 0, 1,     // Right side
        0, 2, 0,    -1, -1.5, 0,    0, 0, -0.5,  // Left back
        0, 2, 0,    1, -1.5, 0,     0, 0, -0.5,  // Right back
        // Wings
        -1, -0.5, 0,  -3, -1.5, 0,  -1, -1.5, 0,
        1, -0.5, 0,   3, -1.5, 0,   1, -1.5, 0,
    ]);
    bodyGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    bodyGeo.computeVertexNormals();
    
    const bodyMat = new THREE.MeshStandardMaterial({ 
        color: cfg.color, 
        emissive: cfg.color, 
        emissiveIntensity: 0.3,
        metalness: 0.8,
        roughness: 0.2
    });
    
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.castShadow = true;
    player.mesh.add(body);
    
    // Cockpit
    const cockpitGeo = new THREE.SphereGeometry(0.4, 8, 6);
    const cockpitMat = new THREE.MeshStandardMaterial({ color: 0x88ffff, emissive: 0x44aaaa, transparent: true, opacity: 0.8 });
    const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
    cockpit.position.set(0, 0.5, 0.3);
    cockpit.scale.set(1, 0.6, 0.8);
    player.mesh.add(cockpit);
    
    // Engine glow - brighter
    const engineGlow = new THREE.PointLight(cfg.color, 2.5, 18);
    engineGlow.position.set(0, -1.5, 0);
    player.mesh.add(engineGlow);
    player.engineLight = engineGlow;
    
    // Ship headlight - illuminates structures ahead
    const headlight = new THREE.PointLight(0xffffff, 2.5, 120);
    headlight.position.set(0, 2, 5);
    player.mesh.add(headlight);
    player.headlight = headlight;
    
    // Thruster particles holder
    player.thrusterTime = 0;
    
    scene.add(player.mesh);
}

function createStarfield() {
    // Simple static stars - no animation
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1000;
    const positions = new Float32Array(starCount * 3);
    
    for (let i = 0; i < starCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 2000;
        positions[i + 1] = Math.random() * 300 + 80;
        positions[i + 2] = (Math.random() - 0.5) * 2000;
    }
    
    starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5 });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);
}

function updateStarfield(dt) {
    // No-op - static stars
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PROCEDURAL CATHEDRAL GENERATION - SIMPLIFIED FOR PERFORMANCE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function generateCathedrals() {
    // Reduced count for performance
    for (let i = 0; i < 12; i++) {
        const x = (Math.random() - 0.5) * 300;
        const z = i * 120 + Math.random() * 50;
        createCathedral(x, z);
    }
}

function createCathedral(x, z) {
    const group = new THREE.Group();
    const seed = Math.random();
    
    // Use simple Lambert material - much faster than Standard
    const stoneMat = new THREE.MeshLambertMaterial({ color: 0x222233 });
    const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
    
    const towerHeight = 25 + seed * 25;
    const towerWidth = 6 + seed * 4;
    
    // Base - simple cylinder
    const base = new THREE.Mesh(
        new THREE.CylinderGeometry(towerWidth, towerWidth * 1.2, 3, 6),
        stoneMat
    );
    base.position.y = 1.5;
    group.add(base);
    
    // Tower body - simple cylinder
    const tower = new THREE.Mesh(
        new THREE.CylinderGeometry(towerWidth * 0.7, towerWidth * 0.9, towerHeight, 6),
        stoneMat
    );
    tower.position.y = towerHeight / 2 + 3;
    group.add(tower);
    
    // Spire - simple cone
    const spire = new THREE.Mesh(
        new THREE.ConeGeometry(towerWidth * 0.4, towerHeight * 0.4, 4),
        stoneMat
    );
    spire.position.y = towerHeight + towerHeight * 0.2 + 3;
    group.add(spire);
    
    // Power core (destructible) - NO LIGHT
    const core = new THREE.Mesh(
        new THREE.OctahedronGeometry(1.5, 0),
        glowMat
    );
    core.position.y = towerHeight * 0.4;
    group.add(core);

    group.position.set(x, 0, z);
    scene.add(group);
    
    cathedrals.push(group);
    destructibles.push({
        mesh: core,
        group: group,
        health: 50,
        maxHealth: 50,
        position: new THREE.Vector3(x, core.position.y, z),
        light: null
    });
}
    
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LARGE STRUCTURES - CRASHED SHIPS & ALIEN BUILDINGS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let largeStructures = [];

function generateLargeStructures() {
    // Crashed spaceships - player can hide behind these
    for (let i = 0; i < 6; i++) {
        const x = (Math.random() - 0.5) * 350;
        const z = i * 180 + 50 + Math.random() * 80;
        createCrashedShip(x, z);
    }
    
    // Alien monolith buildings
    for (let i = 0; i < 4; i++) {
        const x = (Math.random() - 0.5) * 300;
        const z = i * 250 + 150 + Math.random() * 100;
        createAlienBuilding(x, z);
    }
}

function createCrashedShip(x, z) {
    const group = new THREE.Group();
    
    // Reflective metal material
    const hullMat = new THREE.MeshStandardMaterial({ 
        color: 0x445566,
        metalness: 0.9,
        roughness: 0.3
    });
    
    const darkMat = new THREE.MeshLambertMaterial({ color: 0x222233 });
    const glowMat = new THREE.MeshBasicMaterial({ color: 0x00aaff });
    
    // Main hull - elongated shape
    const hullLength = 25 + Math.random() * 20;
    const hullWidth = 8 + Math.random() * 6;
    const hull = new THREE.Mesh(
        new THREE.CylinderGeometry(hullWidth * 0.3, hullWidth, hullLength, 6),
        hullMat
    );
    hull.rotation.x = Math.PI / 2;
    hull.rotation.z = (Math.random() - 0.5) * 0.4; // Tilted crash angle
    hull.position.y = hullWidth * 0.5;
    group.add(hull);
    
    // Cockpit section
    const cockpit = new THREE.Mesh(
        new THREE.SphereGeometry(hullWidth * 0.5, 6, 6),
        hullMat
    );
    cockpit.position.set(0, hullWidth * 0.6, hullLength * 0.4);
    cockpit.scale.set(1, 0.6, 1.2);
    group.add(cockpit);
    
    // Wings (broken/angled)
    const wingMat = hullMat;
    for (let side = -1; side <= 1; side += 2) {
        const wing = new THREE.Mesh(
            new THREE.BoxGeometry(hullWidth * 2, 0.5, hullLength * 0.6),
            wingMat
        );
        wing.position.set(side * hullWidth * 1.2, hullWidth * 0.3, 0);
        wing.rotation.z = side * (0.1 + Math.random() * 0.3); // Damaged angle
        wing.rotation.x = (Math.random() - 0.5) * 0.2;
        group.add(wing);
    }
    
    // Engine pods
    for (let side = -1; side <= 1; side += 2) {
        const engine = new THREE.Mesh(
            new THREE.CylinderGeometry(hullWidth * 0.25, hullWidth * 0.35, hullLength * 0.3, 6),
            darkMat
        );
        engine.rotation.x = Math.PI / 2;
        engine.position.set(side * hullWidth * 0.6, hullWidth * 0.4, -hullLength * 0.35);
        group.add(engine);
        
        // Engine glow (faint, still has some power)
        const engineGlow = new THREE.Mesh(
            new THREE.CircleGeometry(hullWidth * 0.2, 6),
            glowMat
        );
        engineGlow.position.set(side * hullWidth * 0.6, hullWidth * 0.4, -hullLength * 0.5);
        group.add(engineGlow);
    }
    
    // Debris around the crash
    for (let i = 0; i < 4; i++) {
        const debris = new THREE.Mesh(
            new THREE.BoxGeometry(
                1 + Math.random() * 3,
                0.5 + Math.random() * 2,
                1 + Math.random() * 3
            ),
            darkMat
        );
        debris.position.set(
            (Math.random() - 0.5) * hullWidth * 4,
            Math.random() * 1,
            (Math.random() - 0.5) * hullLength
        );
        debris.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
        );
        group.add(debris);
    }
    
    // Single subtle light on the ship
    const shipLight = new THREE.PointLight(0x3366aa, 1.2, 60);
    shipLight.position.set(0, hullWidth + 5, 0);
    group.add(shipLight);
    
    // Shield dome (visible when player nearby)
    const shieldGeo = new THREE.SphereGeometry(hullLength * 0.8, 16, 12);
    const shieldMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ff88, 
        transparent: true, 
        opacity: 0,
        side: THREE.DoubleSide,
        wireframe: true
    });
    const shieldDome = new THREE.Mesh(shieldGeo, shieldMat);
    shieldDome.position.y = hullWidth;
    group.add(shieldDome);
    
    // Visible turret on top of ship
    const turretBase = new THREE.Mesh(
        new THREE.CylinderGeometry(1.5, 2, 1.5, 6),
        new THREE.MeshLambertMaterial({ color: 0x556677 })
    );
    turretBase.position.set(0, hullWidth + 2, hullLength * 0.1);
    group.add(turretBase);
    
    const turretBarrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.4, 0.6, 4, 6),
        new THREE.MeshBasicMaterial({ color: 0x00ffaa })
    );
    turretBarrel.rotation.x = Math.PI / 2;
    turretBarrel.position.set(0, hullWidth + 3, hullLength * 0.1 + 2);
    group.add(turretBarrel);
    
    // Turret fire position
    const turretPos = new THREE.Vector3(0, hullWidth + 3, hullLength * 0.1 + 4);
    
    group.position.set(x, 0, z);
    group.rotation.y = Math.random() * Math.PI * 2;
    scene.add(group);
    
    largeStructures.push({
        type: 'ship',
        mesh: group,
        position: new THREE.Vector3(x, 0, z),
        radius: hullLength * 0.6,
        shieldDome: shieldDome,
        turretBarrel: turretBarrel,
        turretPos: turretPos,
        lastTurretFire: 0
    });
}

function createAlienBuilding(x, z) {
    const group = new THREE.Group();
    
    // Reflective alien metal
    const alienMat = new THREE.MeshStandardMaterial({ 
        color: 0x334455,
        metalness: 0.85,
        roughness: 0.2
    });
    
    const glowMat = new THREE.MeshBasicMaterial({ color: 0xff00aa });
    
    const height = 40 + Math.random() * 30;
    const width = 12 + Math.random() * 8;
    
    // Main monolith - tapered tower
    const tower = new THREE.Mesh(
        new THREE.CylinderGeometry(width * 0.4, width, height, 5),
        alienMat
    );
    tower.position.y = height / 2;
    group.add(tower);
    
    // Floating ring around tower
    const ring = new THREE.Mesh(
        new THREE.TorusGeometry(width * 1.2, 0.8, 6, 16),
        alienMat
    );
    ring.position.y = height * 0.6;
    ring.rotation.x = Math.PI / 2;
    group.add(ring);
    
    // Glowing windows/panels
    for (let i = 0; i < 3; i++) {
        const panel = new THREE.Mesh(
            new THREE.PlaneGeometry(3, 6),
            glowMat
        );
        const angle = (i / 3) * Math.PI * 2;
        panel.position.set(
            Math.cos(angle) * (width * 0.5 + 0.1),
            height * (0.3 + i * 0.15),
            Math.sin(angle) * (width * 0.5 + 0.1)
        );
        panel.rotation.y = -angle + Math.PI;
        group.add(panel);
    }
    
    // Spire on top
    const spire = new THREE.Mesh(
        new THREE.ConeGeometry(width * 0.3, height * 0.25, 5),
        alienMat
    );
    spire.position.y = height + height * 0.125;
    group.add(spire);
    
    // Base platform
    const base = new THREE.Mesh(
        new THREE.CylinderGeometry(width * 1.5, width * 1.8, 3, 6),
        alienMat
    );
    base.position.y = 1.5;
    group.add(base);
    
    // Single overhead light
    const buildingLight = new THREE.PointLight(0xff00aa, 1.0, 70);
    buildingLight.position.set(0, height * 0.7, 0);
    group.add(buildingLight);
    
    group.position.set(x, 0, z);
    scene.add(group);
    
    largeStructures.push({
        type: 'building',
        mesh: group,
        position: new THREE.Vector3(x, height / 2, z),
        radius: width * 1.5
    });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ENEMY SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function spawnEnemy(type, position) {
    const cfg = CONFIG.enemies[type];
    
    const group = new THREE.Group();
    
    // Materials
    const hullMat = new THREE.MeshLambertMaterial({ color: cfg.color });
    const darkMat = new THREE.MeshLambertMaterial({ color: 0x222233 });
    const glowMat = new THREE.MeshBasicMaterial({ color: cfg.color });
    
    // Build ship-like assembled models based on type
    switch(type) {
        case 'drone':
            // Small fast interceptor
            // Fuselage
            const droneFuse = new THREE.Mesh(
                new THREE.ConeGeometry(0.6, 2.5, 4),
                hullMat
            );
            droneFuse.rotation.x = Math.PI / 2;
            group.add(droneFuse);
            
            // Wings
            for (let side = -1; side <= 1; side += 2) {
                const wing = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.1, 0.8),
                    hullMat
                );
                wing.position.set(side * 1.2, 0, 0.3);
                wing.rotation.z = side * 0.2;
                group.add(wing);
            }
            
            // Engine glow
            const droneEngine = new THREE.Mesh(
                new THREE.CircleGeometry(0.3, 6),
                glowMat
            );
            droneEngine.position.z = -1.3;
            group.add(droneEngine);
            break;
            
        case 'shooter':
            // Medium gunship with turret
            // Main body
            const shooterBody = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.8, 3),
                hullMat
            );
            group.add(shooterBody);
            
            // Nose cone
            const shooterNose = new THREE.Mesh(
                new THREE.ConeGeometry(0.8, 1.5, 4),
                hullMat
            );
            shooterNose.rotation.x = Math.PI / 2;
            shooterNose.position.z = 2.2;
            group.add(shooterNose);
            
            // Wings
            for (let side = -1; side <= 1; side += 2) {
                const sWing = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 0.15, 1.2),
                    hullMat
                );
                sWing.position.set(side * 2, 0, -0.3);
                group.add(sWing);
                
                // Wing tip
                const wingTip = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 0.6, 0.6),
                    darkMat
                );
                wingTip.position.set(side * 3.2, 0, -0.3);
                group.add(wingTip);
            }
            
            // Turret on top
            const turretBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.5, 0.4, 6),
                darkMat
            );
            turretBase.position.y = 0.6;
            group.add(turretBase);
            
            const turretGun = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.15, 1, 6),
                glowMat
            );
            turretGun.rotation.x = Math.PI / 2;
            turretGun.position.set(0, 0.7, 0.5);
            group.add(turretGun);
            
            // Engines
            for (let side = -1; side <= 1; side += 2) {
                const eng = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 0.8, 6),
                    darkMat
                );
                eng.rotation.x = Math.PI / 2;
                eng.position.set(side * 0.7, -0.2, -1.6);
                group.add(eng);
                
                const engGlow = new THREE.Mesh(
                    new THREE.CircleGeometry(0.25, 6),
                    glowMat
                );
                engGlow.position.set(side * 0.7, -0.2, -2);
                group.add(engGlow);
            }
            break;
            
        case 'bomber':
            // Heavy bomber - bulky with bomb bay
            // Main hull
            const bomberHull = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 6, 5),
                hullMat
            );
            bomberHull.scale.set(1, 0.7, 1.4);
            group.add(bomberHull);
            
            // Nose
            const bomberNose = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 5, 4),
                hullMat
            );
            bomberNose.position.z = 1.8;
            bomberNose.scale.set(1, 0.8, 1.2);
            group.add(bomberNose);
            
            // Heavy wings
            for (let side = -1; side <= 1; side += 2) {
                const bWing = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 0.3, 1.5),
                    hullMat
                );
                bWing.position.set(side * 2.2, 0, 0);
                bWing.rotation.z = side * 0.15;
                group.add(bWing);
                
                // Engine pod on wing
                const pod = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.5, 1.2, 6),
                    darkMat
                );
                pod.rotation.x = Math.PI / 2;
                pod.position.set(side * 2.5, -0.3, -0.2);
                group.add(pod);
                
                const podGlow = new THREE.Mesh(
                    new THREE.CircleGeometry(0.35, 6),
                    glowMat
                );
                podGlow.position.set(side * 2.5, -0.3, -0.8);
                group.add(podGlow);
            }
            
            // Bomb bay indicator
            const bombBay = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.4, 1.2),
                glowMat
            );
            bombBay.position.y = -0.9;
            group.add(bombBay);
            
            // Tail fin
            const tailFin = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 1.2, 0.8),
                hullMat
            );
            tailFin.position.set(0, 0.6, -1.5);
            group.add(tailFin);
            break;
            
        case 'elite':
            // Elite fighter - sleek and dangerous
            // Central fuselage
            const eliteFuse = new THREE.Mesh(
                new THREE.ConeGeometry(0.8, 4, 6),
                hullMat
            );
            eliteFuse.rotation.x = Math.PI / 2;
            group.add(eliteFuse);
            
            // Cockpit
            const eliteCockpit = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 6, 5),
                new THREE.MeshBasicMaterial({ color: 0x88ffff, transparent: true, opacity: 0.7 })
            );
            eliteCockpit.position.set(0, 0.3, 1);
            eliteCockpit.scale.set(0.8, 0.5, 1);
            group.add(eliteCockpit);
            
            // Swept wings
            for (let side = -1; side <= 1; side += 2) {
                const eWing = new THREE.Mesh(
                    new THREE.BoxGeometry(3.5, 0.12, 1.4),
                    hullMat
                );
                eWing.position.set(side * 2, 0, -0.5);
                eWing.rotation.y = side * 0.2;
                group.add(eWing);
                
                // Weapon hardpoint
                const hardpoint = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.2, 0.8, 6),
                    glowMat
                );
                hardpoint.rotation.x = Math.PI / 2;
                hardpoint.position.set(side * 1.5, -0.2, 0.2);
                group.add(hardpoint);
            }
            
            // Twin engines
            for (let side = -1; side <= 1; side += 2) {
                const eEng = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.35, 0.45, 1.5, 6),
                    darkMat
                );
                eEng.rotation.x = Math.PI / 2;
                eEng.position.set(side * 0.6, 0, -2.2);
                group.add(eEng);
                
                const eEngGlow = new THREE.Mesh(
                    new THREE.CircleGeometry(0.3, 6),
                    glowMat
                );
                eEngGlow.position.set(side * 0.6, 0, -3);
                group.add(eEngGlow);
            }
            
            // Vertical stabilizers
            for (let side = -1; side <= 1; side += 2) {
                const stab = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.8, 0.6),
                    hullMat
                );
                stab.position.set(side * 0.6, 0.5, -2);
                stab.rotation.z = side * 0.3;
                group.add(stab);
            }
            break;
    }
    
    group.position.copy(position);
    scene.add(group);
    
    const enemy = {
        type,
        mesh: group,
        health: cfg.health,
        maxHealth: cfg.health,
        speed: cfg.speed,
        damage: cfg.damage,
        score: cfg.score,
        behavior: cfg.behavior,
        fireRate: cfg.fireRate || 0,
        lastFire: 0,
        target: new THREE.Vector3(),
        orbitAngle: Math.random() * Math.PI * 2,
        state: 'active'
    };
    
    enemies.push(enemy);
    updateEnemyCount();
}

function updateEnemyCount() {
    document.getElementById('enemy-count').innerText = enemies.length;
}

function updateEnemy(enemy, dt) {
    if (enemy.state !== 'active') return;
    
    const toPlayer = new THREE.Vector3().subVectors(player.mesh.position, enemy.mesh.position);
    const dist = toPlayer.length();
    toPlayer.normalize();
    
    let moveDir = toPlayer.clone();
    
    switch(enemy.behavior) {
        case 'chase':
            enemy.mesh.position.add(toPlayer.clone().multiplyScalar(enemy.speed));
            break;
            
        case 'strafe':
            // Strafe sideways while shooting
            const strafeDir = new THREE.Vector3(-toPlayer.z, 0, toPlayer.x);
            moveDir.copy(strafeDir);
            enemy.mesh.position.add(strafeDir.multiplyScalar(enemy.speed));
            
            // Keep distance
            if (dist < 40) {
                enemy.mesh.position.sub(toPlayer.clone().multiplyScalar(enemy.speed * 0.5));
            } else if (dist > 60) {
                enemy.mesh.position.add(toPlayer.clone().multiplyScalar(enemy.speed * 0.5));
            }
            
            // Shoot at player
            const now = Date.now();
            if (now - enemy.lastFire > enemy.fireRate) {
                fireEnemyBullet(enemy.mesh.position.clone(), toPlayer.clone());
                enemy.lastFire = now;
            }
            // Face player when shooting
            moveDir.copy(toPlayer);
            break;
            
        case 'dive':
            // Dive bomb at player
            if (dist > 30) {
                enemy.mesh.position.add(toPlayer.clone().multiplyScalar(enemy.speed * 2));
            } else {
                // Explode near player
                createExplosion(enemy.mesh.position, enemy.damage, 15, 0x8800ff);
                destroyEnemy(enemy, false);
                return;
            }
            break;
            
        case 'orbit':
            // Orbit around player while shooting
            enemy.orbitAngle += 0.02;
            const orbitDist = 50;
            const targetX = player.mesh.position.x + Math.cos(enemy.orbitAngle) * orbitDist;
            const targetZ = player.mesh.position.z + Math.sin(enemy.orbitAngle) * orbitDist;
            
            enemy.mesh.position.x += (targetX - enemy.mesh.position.x) * 0.02;
            enemy.mesh.position.z += (targetZ - enemy.mesh.position.z) * 0.02;
            enemy.mesh.position.y += (player.mesh.position.y - enemy.mesh.position.y) * 0.01;
            
            // Fire at player
            if (Date.now() - enemy.lastFire > enemy.fireRate) {
                fireEnemyBullet(enemy.mesh.position.clone(), toPlayer.clone());
                enemy.lastFire = Date.now();
            }
            // Face player
            moveDir.copy(toPlayer);
            break;
    }
    
    // Rotate enemy to face movement/target direction
    if (moveDir.length() > 0.01) {
        const targetPos = enemy.mesh.position.clone().add(moveDir.multiplyScalar(10));
        enemy.mesh.lookAt(targetPos);
    }
    
    // Check collision with player
    if (dist < 3 && player.invincible <= 0) {
        damagePlayer(enemy.damage);
        if (enemy.behavior !== 'dive') {
            enemy.mesh.position.sub(toPlayer.clone().multiplyScalar(5));
        }
    }
}

function destroyEnemy(enemy, giveRewards = true) {
    if (enemy.state !== 'active') return;
    enemy.state = 'dead';
    
    const enemyPos = enemy.mesh.position.clone();
    createExplosion(enemyPos, 0, 0, CONFIG.enemies[enemy.type].color);
    scene.remove(enemy.mesh);
    
    if (giveRewards) {
        // Score and combo
        const comboMultiplier = 1 + combo * 0.1;
        const earnedScore = Math.floor(enemy.score * comboMultiplier);
        score += earnedScore;
        kills++;
        combo++;
        comboTimer = 3;
        maxCombo = Math.max(maxCombo, combo);
        shotsHit++;
        
        // Build super weapon charge based on combo
        const chargeGain = 2 + Math.floor(combo / 5) * 2; // More charge at higher combos
        superCharge = Math.min(maxSuperCharge, superCharge + chargeGain);
        
        updateComboDisplay();
        updateHUD();
        
        // Chance to drop powerup
        if (Math.random() < 0.15) {
            spawnPowerup(enemyPos);
        }
    }
    
    const idx = enemies.indexOf(enemy);
    if (idx > -1) enemies.splice(idx, 1);
    updateEnemyCount();
    
    // Check wave completion
    if (enemies.length === 0 && !boss) {
        window.nextWaveDelay = 2;
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BOSS SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function spawnBoss() {
    const group = new THREE.Group();
    
    // Simple boss body
    const bodyMat = new THREE.MeshBasicMaterial({ color: 0xff0044 });
    const body = new THREE.Mesh(new THREE.IcosahedronGeometry(10, 1), bodyMat);
    group.add(body);
    
    // Single rotating ring
    const ring = new THREE.Mesh(
        new THREE.TorusGeometry(16, 1, 6, 24),
        new THREE.MeshBasicMaterial({ color: 0xff4400 })
    );
    group.add(ring);
    
    // Weapon pods - simple
    const podPositions = [
        new THREE.Vector3(14, 0, 0),
        new THREE.Vector3(-14, 0, 0),
        new THREE.Vector3(0, 14, 0),
        new THREE.Vector3(0, -14, 0)
    ];
    
    const pods = [];
    const podMat = new THREE.MeshBasicMaterial({ color: 0xff8800 });
    podPositions.forEach((pos) => {
        const pod = new THREE.Mesh(new THREE.OctahedronGeometry(2.5, 0), podMat);
        pod.position.copy(pos);
        group.add(pod);
        pods.push({ mesh: pod, health: 200, destroyed: false });
    });
    
    // Core (weak point)
    const core = new THREE.Mesh(
        new THREE.SphereGeometry(3, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xff0000 })
    );
    group.add(core);
    
    group.position.set(player.mesh.position.x, player.mesh.position.y + 120, player.mesh.position.z);
    scene.add(group);
    
    boss = {
        mesh: group,
        ring: ring,
        health: 3000,
        maxHealth: 3000,
        phase: 1,
        pods,
        core,
        patterns: ['spiral', 'sweep', 'burst'],
        currentPattern: 0,
        patternTimer: 0,
        attackTimer: 0
    };
    
    document.getElementById('boss-ui').classList.add('active');
}

function updateBoss(dt) {
    if (!boss) return;
    
    // Simple ring rotation
    if (boss.ring) {
        boss.ring.rotation.x += 0.01;
        boss.ring.rotation.y += 0.015;
    }
    
    // Move towards player (slowly)
    const toPlayer = new THREE.Vector3().subVectors(player.mesh.position, boss.mesh.position);
    toPlayer.y = 0;
    const dist = toPlayer.length();
    
    if (dist > 70) {
        boss.mesh.position.add(toPlayer.normalize().multiplyScalar(0.25));
    } else if (dist < 50) {
        boss.mesh.position.sub(toPlayer.normalize().multiplyScalar(0.15));
    }
    
    // Hover
    boss.mesh.position.y = player.mesh.position.y + 25 + Math.sin(Date.now() * 0.001) * 3;
    
    // Attack patterns based on phase
    boss.attackTimer -= dt;
    if (boss.attackTimer <= 0) {
        executeBossAttack();
        boss.attackTimer = 2 - (3 - boss.phase) * 0.4;
    }
    
    // Phase transitions
    const healthPercent = boss.health / boss.maxHealth;
    if (healthPercent < 0.66 && boss.phase === 1) {
        boss.phase = 2;
    } else if (healthPercent < 0.33 && boss.phase === 2) {
        boss.phase = 3;
    }
    
    // Update health bar
    document.getElementById('boss-fill').style.width = `${(boss.health / boss.maxHealth) * 100}%`;
}

function executeBossAttack() {
    if (!boss) return;
    
    const toPlayer = new THREE.Vector3().subVectors(player.mesh.position, boss.mesh.position).normalize();
    
    switch(boss.patterns[boss.currentPattern]) {
        case 'spiral':
            // Spiral pattern
            for (let i = 0; i < 12; i++) {
                setTimeout(() => {
                    if (!boss) return;
                    const angle = (i / 12) * Math.PI * 2 + Date.now() * 0.001;
                    const dir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                    fireEnemyBullet(boss.mesh.position.clone(), dir, 0.6, 0xff4400);
                }, i * 50);
            }
            break;
            
        case 'sweep':
            // Sweeping laser
            for (let i = -5; i <= 5; i++) {
                const spreadAngle = i * 0.15;
                const dir = toPlayer.clone();
                dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), spreadAngle);
                fireEnemyBullet(boss.mesh.position.clone(), dir, 1, 0xff0000);
            }
            break;
            
        case 'burst':
            // Targeted burst from pods
            boss.pods.forEach(pod => {
                if (!pod.destroyed) {
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            if (!boss) return;
                            const worldPos = pod.mesh.getWorldPosition(new THREE.Vector3());
                            fireEnemyBullet(worldPos, toPlayer.clone(), 0.8, 0xff8800);
                        }, i * 100);
                    }
                }
            });
            break;
    }
    
    boss.currentPattern = (boss.currentPattern + 1) % boss.patterns.length;
}

function announcePhase(text) {
    const announce = document.getElementById('wave-announce');
    document.getElementById('wave-num').innerText = '';
    document.getElementById('wave-desc').innerText = text;
    announce.style.opacity = 1;
    setTimeout(() => announce.style.opacity = 0, 2000);
}

function damageBoss(amount, hitPosition) {
    if (!boss) return;
    
    // Check if hit a pod
    let hitPod = false;
    boss.pods.forEach(pod => {
        if (!pod.destroyed) {
            const podWorld = pod.mesh.getWorldPosition(new THREE.Vector3());
            if (hitPosition.distanceTo(podWorld) < 5) {
                pod.health -= amount;
                hitPod = true;
                if (pod.health <= 0) {
                    pod.destroyed = true;
                    pod.mesh.visible = false;
                    createExplosion(podWorld, 0, 0, 0xff4400);
                    score += 500;
                }
            }
        }
    });
    
    if (!hitPod) {
        // Core takes double damage
        const coreWorld = boss.core.getWorldPosition(new THREE.Vector3());
        if (hitPosition.distanceTo(coreWorld) < 6) {
            boss.health -= amount * 2;
        } else {
            boss.health -= amount * 0.5; // Body takes reduced damage
        }
    }
    
    if (boss.health <= 0) {
        defeatBoss();
    }
}

function defeatBoss() {
    if (!boss) return;
    
    boss.defeated = true;
    boss.deathTimer = 0;
    boss.deathPhase = 0;
}

function updateBossDeathSequence(dt) {
    if (!boss || !boss.defeated) return;
    
    boss.deathTimer += dt;
    
    // Staged explosions every 0.2 seconds
    const explosionIndex = Math.floor(boss.deathTimer / 0.2);
    if (explosionIndex > boss.deathPhase && boss.deathPhase < 10) {
        boss.deathPhase = explosionIndex;
        const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30
        );
        createExplosion(boss.mesh.position.clone().add(offset), 0, 0, 0xff0000);
    }
    
    // Final destruction after 2.5 seconds
    if (boss.deathTimer > 2.5) {
        scene.remove(boss.mesh);
        boss = null;
        document.getElementById('boss-ui').classList.remove('active');
        score += 10000;
        updateHUD();
        
        // Next wave after short delay (tracked in update loop)
        window.nextWaveDelay = 3;
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// WAVE SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function startNextWave() {
    wave++;
    document.getElementById('wave-val').innerText = wave;
    
    // Loop waves after all defined waves
    const waveIdx = (wave - 1) % CONFIG.waves.length;
    const waveConfig = CONFIG.waves[waveIdx];
    
    // Scale difficulty on repeated waves
    const difficultyMult = 1 + Math.floor((wave - 1) / CONFIG.waves.length) * 0.5;
    
    // Announce wave
    const announce = document.getElementById('wave-announce');
    document.getElementById('wave-num').innerText = wave;
    document.getElementById('wave-desc').innerText = waveConfig.desc;
    announce.style.opacity = 1;
    
    setTimeout(() => {
        announce.style.opacity = 0;
        
        if (waveConfig.boss) {
            spawnBoss();
        } else {
            waveConfig.enemies.forEach(e => {
                const count = Math.ceil(e.count * difficultyMult);
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 50 + Math.random() * 30; // Closer spawn distance
                        const pos = new THREE.Vector3(
                            player.mesh.position.x + Math.cos(angle) * dist,
                            player.mesh.position.y + (Math.random() - 0.5) * 10,
                            player.mesh.position.z + Math.sin(angle) * dist
                        );
                        spawnEnemy(e.type, pos);
                    }, i * 200); // Faster spawn rate
                }
            });
        }
    }, 2000);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// POWERUP SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const POWERUP_TYPES = [
    { type: 'health', color: 0x00ff00, icon: 'üíö', effect: () => { player.health = Math.min(player.maxHealth, player.health + 30); } },
    { type: 'shield', color: 0x0088ff, icon: 'üõ°Ô∏è', effect: () => { player.shield = Math.min(player.maxShield, player.shield + 40); } },
    { type: 'energy', color: 0xffff00, icon: '‚ö°', effect: () => { player.energy = Math.min(player.maxEnergy, player.energy + 50); } },
    { type: 'weapon', color: 0xff00ff, icon: 'üî´', effect: () => { unlockNextWeapon(); } },
    { type: 'score', color: 0xffffff, icon: '‚≠ê', effect: () => { score += 500; } }
];

function spawnPowerup(position) {
    const typeData = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
    
    const group = new THREE.Group();
    
    const geo = new THREE.OctahedronGeometry(1.5, 0);
    const mat = new THREE.MeshBasicMaterial({ color: typeData.color, wireframe: true });
    const mesh = new THREE.Mesh(geo, mat);
    group.add(mesh);
    
    const light = new THREE.PointLight(typeData.color, 1, 15);
    group.add(light);
    
    group.position.copy(position);
    scene.add(group);
    
    powerups.push({
        mesh: group,
        inner: mesh,
        type: typeData.type,
        color: typeData.color,
        icon: typeData.icon,
        effect: typeData.effect,
        time: 0
    });
}

function updatePowerups(dt) {
    powerups.forEach((p, i) => {
        p.time += dt;
        p.inner.rotation.x += 0.03;
        p.inner.rotation.y += 0.05;
        
        // Hover
        p.mesh.position.y += Math.sin(p.time * 3) * 0.03;
        
        // Check collection
        if (p.mesh.position.distanceTo(player.mesh.position) < 4) {
            p.effect();
            showPowerupToast(p.icon + ' ' + p.type.toUpperCase());
            scene.remove(p.mesh);
            powerups.splice(i, 1);
            updateHUD();
        }
        
        // Expire after 10 seconds
        if (p.time > 10) {
            scene.remove(p.mesh);
            powerups.splice(i, 1);
        }
    });
}

function unlockNextWeapon() {
    const slots = document.querySelectorAll('.weapon-slot');
    for (let i = 0; i < slots.length; i++) {
        if (slots[i].classList.contains('locked')) {
            slots[i].classList.remove('locked');
            return;
        }
    }
}

function showPowerupToast(text) {
    const toast = document.getElementById('powerup-toast');
    toast.innerText = text;
    toast.style.opacity = 1;
    setTimeout(() => toast.style.opacity = 0, 1500);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// WEAPON SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function fireWeapon() {
    const weapon = CONFIG.weapons[currentWeapon];
    const now = Date.now();
    
    // Check fire rate
    if (now - lastFireTime < weapon.fireRate) return;
    if (player.energy < weapon.energyCost) return;
    
    // Check if weapon unlocked
    const slot = document.querySelector(`.weapon-slot[data-weapon="${currentWeapon}"]`);
    if (slot && slot.classList.contains('locked')) return;
    
    lastFireTime = now;
    player.energy -= weapon.energyCost;
    shotsFired++;
    
    // Calculate direction to mouse
    const dir = worldMouse.clone().sub(player.mesh.position).normalize();
    
    // Fire projectiles
    for (let i = 0; i < weapon.projectiles; i++) {
        const spreadDir = dir.clone();
        if (weapon.spread > 0) {
            const spreadAngle = (i - (weapon.projectiles - 1) / 2) * weapon.spread;
            spreadDir.applyAxisAngle(new THREE.Vector3(0, 0, 1), spreadAngle);
        }
        
        createProjectile(
            player.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)),
            spreadDir,
            weapon.speed,
            weapon.damage * player.damage,
            weapon.color,
            weapon.homing,
            weapon.isBeam
        );
    }
    
    // Screen shake
    screenShake = Math.max(screenShake, weapon.isBeam ? 0.5 : 2);
}

// Ship turret - auto-seeks nearest enemy with massive AoE
function fireShipTurret() {
    if (!currentCoverShip || currentCoverShip.type !== 'ship') return;
    
    const now = Date.now();
    if (now - currentCoverShip.lastTurretFire < 800) return; // 0.8 second cooldown
    
    // Find nearest enemy
    let nearestEnemy = null;
    let nearestDist = Infinity;
    
    // Get turret world position
    const turretWorld = currentCoverShip.turretPos.clone();
    turretWorld.applyMatrix4(currentCoverShip.mesh.matrixWorld);
    
    for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        if (enemy.state !== 'active') continue;
        
        const dist = enemy.mesh.position.distanceTo(turretWorld);
        if (dist < nearestDist && dist < 150) { // Max range 150
            nearestDist = dist;
            nearestEnemy = enemy;
        }
    }
    
    // Also check boss
    if (boss && !boss.defeated) {
        const bossDist = boss.mesh.position.distanceTo(turretWorld);
        if (bossDist < nearestDist) {
            nearestDist = bossDist;
            nearestEnemy = { mesh: boss.mesh, isBoss: true };
        }
    }
    
    // No enemies in range
    if (!nearestEnemy) {
        showPowerupToast('NO TARGETS IN RANGE');
        return;
    }
    
    currentCoverShip.lastTurretFire = now;
    
    // Fire toward nearest enemy
    const targetPos = nearestEnemy.mesh.position.clone();
    const dir = targetPos.clone().sub(turretWorld).normalize();
    
    // Rotate turret barrel toward target (visual feedback)
    if (currentCoverShip.turretBarrel) {
        const localTarget = currentCoverShip.mesh.worldToLocal(targetPos.clone());
        currentCoverShip.turretBarrel.lookAt(localTarget);
    }
    
    // Create homing turret projectile - glowing green orb
    const projGeo = new THREE.SphereGeometry(2, 10, 8);
    const projMat = new THREE.MeshBasicMaterial({ color: 0x00ffaa });
    const proj = new THREE.Mesh(projGeo, projMat);
    proj.position.copy(turretWorld);
    scene.add(proj);
    
    // Outer glow shell
    const glowGeo = new THREE.SphereGeometry(3, 8, 6);
    const glowMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ffaa, 
        transparent: true, 
        opacity: 0.3 
    });
    const glow = new THREE.Mesh(glowGeo, glowMat);
    proj.add(glow);
    
    // Bright light trail
    const trail = new THREE.PointLight(0x00ffaa, 3, 30);
    proj.add(trail);
    
    projectiles.push({
        mesh: proj,
        dir: dir,
        speed: 1.8,
        damage: 100,
        isTurret: true,
        isTurretHoming: true, // New flag for homing behavior
        target: nearestEnemy,
        color: 0x00ffaa,
        lifetime: 5
    });
    
    // Muzzle flash at turret
    createExplosion(turretWorld, 0, 0, 0x00ffaa);
    screenShake = Math.max(screenShake, 6);
    
    showPowerupToast('üéØ LOCKED ON!');
}

// Super weapon - screen-clearing nova
function fireSuperWeapon() {
    if (superCharge < maxSuperCharge) return;
    
    superCharge = 0;
    
    const center = player.mesh.position.clone();
    const radius = 120;
    
    // Massive visual effect - expanding rings
    createNovaEffect(center, radius);
    
    // Damage all enemies in radius
    let killCount = 0;
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.state !== 'active') continue;
        
        const dist = enemy.mesh.position.distanceTo(center);
        if (dist < radius) {
            const damage = 250 * (1 - dist / radius); // More damage closer to center
            enemy.health -= damage;
            
            // Visual hit on each enemy
            createExplosion(enemy.mesh.position.clone(), 0, 0, 0xff00ff);
            
            if (enemy.health <= 0) {
                killCount++;
                destroyEnemy(enemy);
            }
        }
    }
    
    // Also damage boss
    if (boss && !boss.defeated) {
        const bossDist = boss.mesh.position.distanceTo(center);
        if (bossDist < radius + 30) {
            damageBoss(400, center);
        }
    }
    
    screenShake = 20;
    showPowerupToast(`‚ö° SUPER NOVA! ${killCount} KILLS ‚ö°`);
}

// Nova visual effect - expanding rings with multiple colors
function createNovaEffect(center, maxRadius) {
    const colors = [0xff00ff, 0xffff00, 0x00ffff, 0xff0088, 0x00ff88];
    
    // Multiple expanding rings
    for (let r = 0; r < 5; r++) {
        setTimeout(() => {
            const ringGeo = new THREE.RingGeometry(2, 5, 32);
            const ringMat = new THREE.MeshBasicMaterial({ 
                color: colors[r],
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.copy(center);
            ring.rotation.x = Math.PI / 2;
            scene.add(ring);
            
            // Animate expansion
            const startTime = Date.now();
            const duration = 800;
            
            function expandRing() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress >= 1) {
                    scene.remove(ring);
                    return;
                }
                
                const scale = 1 + progress * maxRadius;
                ring.scale.set(scale, scale, 1);
                ring.material.opacity = 0.9 * (1 - progress);
                
                requestAnimationFrame(expandRing);
            }
            expandRing();
        }, r * 80);
    }
    
    // Center flash - massive
    const flash = new THREE.PointLight(0xff00ff, 15, 200);
    flash.position.copy(center);
    scene.add(flash);
    
    let flashIntensity = 15;
    function fadeFlash() {
        flashIntensity -= 0.4;
        flash.intensity = Math.max(0, flashIntensity);
        if (flashIntensity > 0) {
            requestAnimationFrame(fadeFlash);
        } else {
            scene.remove(flash);
        }
    }
    fadeFlash();
    
    // Particles burst in all directions
    for (let i = 0; i < 50; i++) {
        const angle = (i / 50) * Math.PI * 2;
        const elevation = (Math.random() - 0.5) * 0.5;
        const vel = new THREE.Vector3(
            Math.cos(angle) * 4,
            elevation * 2,
            Math.sin(angle) * 4
        );
        const color = colors[Math.floor(Math.random() * colors.length)];
        createParticle(center.clone(), color, 0.6, vel);
    }
}

function createProjectile(pos, dir, speed, damage, color, homing = false, isBeam = false) {
    let mesh;
    
    if (isBeam) {
        const geo = new THREE.CylinderGeometry(0.15, 0.15, 4, 4);
        geo.rotateX(Math.PI / 2);
        mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color }));
    } else if (homing) {
        // Missile - simple cone
        mesh = new THREE.Mesh(
            new THREE.ConeGeometry(0.4, 1.5, 4),
            new THREE.MeshBasicMaterial({ color: 0xff4400 })
        );
        mesh.rotation.x = Math.PI / 2;
    } else {
        // Regular projectile - simple sphere, no light
        mesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 4, 4),
            new THREE.MeshBasicMaterial({ color })
        );
    }
    
    mesh.position.copy(pos);
    scene.add(mesh);
    
    projectiles.push({
        mesh,
        dir: dir.clone().normalize(),
        speed: speed * 1.2,
        damage,
        homing,
        isBeam,
        color,
        lifetime: isBeam ? 0.2 : (homing ? 3 : 2.5),
        trailTimer: 0
    });
}

function updateProjectiles(dt) {
    // Iterate backwards to safely remove items
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.lifetime -= dt;
        
        if (p.lifetime <= 0) {
            // Missiles explode when they expire
            if (p.homing) {
                missileExplosion(p.mesh.position.clone(), p.damage);
            }
            scene.remove(p.mesh);
            projectiles.splice(i, 1);
            continue;
        }
        
        // Homing behavior - stronger tracking
        if (p.homing && enemies.length > 0) {
            let closest = null;
            let closestDist = Infinity;
            enemies.forEach(e => {
                if (e.state !== 'active') return;
                const d = e.mesh.position.distanceTo(p.mesh.position);
                if (d < closestDist) {
                    closestDist = d;
                    closest = e;
                }
            });
            
            // Also target boss
            if (boss) {
                const bossDist = boss.mesh.position.distanceTo(p.mesh.position);
                if (bossDist < closestDist) {
                    closestDist = bossDist;
                    closest = { mesh: boss.mesh, isBoss: true };
                }
            }
            
            if (closest && closestDist < 150) {
                const toTarget = new THREE.Vector3().subVectors(closest.mesh.position, p.mesh.position).normalize();
                p.dir.lerp(toTarget, 0.15); // Stronger homing
                p.dir.normalize();
            }
            
            // Proximity explosion for missiles
            if (closestDist < 8) {
                missileExplosion(p.mesh.position.clone(), p.damage);
                scene.remove(p.mesh);
                projectiles.splice(i, 1);
                continue;
            }
        }
        
        // Turret homing - aggressively tracks locked target
        if (p.isTurretHoming && p.target) {
            // Check if target still valid
            let targetValid = false;
            let targetPos = null;
            
            if (p.target.isBoss && boss && !boss.defeated) {
                targetValid = true;
                targetPos = boss.mesh.position.clone();
            } else if (p.target.state === 'active') {
                targetValid = true;
                targetPos = p.target.mesh.position.clone();
            }
            
            if (targetValid && targetPos) {
                const toTarget = targetPos.clone().sub(p.mesh.position).normalize();
                p.dir.lerp(toTarget, 0.25); // Very aggressive homing
                p.dir.normalize();
                
                // Check if close enough to detonate
                const distToTarget = p.mesh.position.distanceTo(targetPos);
                if (distToTarget < 12) {
                    turretExplosion(p.mesh.position.clone(), p.damage);
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    continue;
                }
            } else {
                // Target destroyed - find new target or explode
                let newTarget = null;
                let nearestDist = 80;
                
                for (let j = 0; j < enemies.length; j++) {
                    const e = enemies[j];
                    if (e.state !== 'active') continue;
                    const d = e.mesh.position.distanceTo(p.mesh.position);
                    if (d < nearestDist) {
                        nearestDist = d;
                        newTarget = e;
                    }
                }
                
                if (newTarget) {
                    p.target = newTarget;
                } else {
                    // No targets nearby - explode where we are
                    turretExplosion(p.mesh.position.clone(), p.damage);
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    continue;
                }
            }
        }
        
        // Move projectile
        p.mesh.position.add(p.dir.clone().multiplyScalar(p.speed));
        
        // Rotate to face direction
        if (p.homing || p.isBeam || p.isTurretHoming) {
            p.mesh.lookAt(p.mesh.position.clone().add(p.dir));
        }
        
        let hitSomething = false;
        
        // Check enemy collisions with larger hit radius
        for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            if (enemy.state !== 'active') continue;
            
            const hitRadius = CONFIG.enemies[enemy.type].size + 3; // Increased hit radius
            const dist = p.mesh.position.distanceTo(enemy.mesh.position);
            
            if (dist < hitRadius) {
                // Hit effect
                createHitEffect(p.mesh.position.clone(), p.color || 0x00ffff);
                
                // Turret projectiles cause AoE explosion
                if (p.isTurret) {
                    turretExplosion(p.mesh.position.clone(), p.damage);
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    break;
                }
                
                enemy.health -= p.damage;
                shotsHit++;
                
                if (enemy.health <= 0) {
                    destroyEnemy(enemy);
                }
                
                if (!p.isBeam) {
                    hitSomething = true;
                    break;
                }
            }
        }
        
        if (hitSomething) {
            scene.remove(p.mesh);
            projectiles.splice(i, 1);
            continue;
        }
        
        // Check boss collision
        if (boss) {
            const bossDist = p.mesh.position.distanceTo(boss.mesh.position);
            if (bossDist < 30) {
                createHitEffect(p.mesh.position.clone(), 0xff4400);
                damageBoss(p.damage, p.mesh.position.clone());
                shotsHit++;
                
                if (!p.isBeam) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    continue;
                }
            }
        }
        
        // Check destructible collisions
        for (let j = 0; j < destructibles.length; j++) {
            const d = destructibles[j];
            if (d.health > 0 && p.mesh.position.distanceTo(d.position) < 6) {
                createHitEffect(p.mesh.position.clone(), 0x00ff88);
                d.health -= p.damage;
                
                if (d.health <= 0) {
                    d.mesh.visible = false;
                    d.light.intensity = 0;
                    score += 100;
                    kills++;
                    updateHUD();
                    createExplosion(d.position.clone(), 0, 0, 0x00ff88);
                    
                    if (Math.random() < 0.3) {
                        spawnPowerup(d.position.clone());
                    }
                }
                
                if (!p.isBeam) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    break;
                }
            }
        }
    }
}

// Missile explosion with area damage - minimal
function missileExplosion(pos, baseDamage) {
    const explosionRadius = 12;
    const explosionDamage = baseDamage * 1.5;
    
    // Simple explosion
    createExplosion(pos, 0, 0, 0xff4400);
    
    // Damage enemies in radius
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.state !== 'active') continue;
        const dist = enemy.mesh.position.distanceTo(pos);
        if (dist < explosionRadius) {
            const falloff = 1 - (dist / explosionRadius);
            enemy.health -= explosionDamage * falloff;
            shotsHit++;
            
            if (enemy.health <= 0) {
                destroyEnemy(enemy);
            }
        }
    }
    
    // Damage boss if nearby
    if (boss && !boss.defeated) {
        const bossDist = boss.mesh.position.distanceTo(pos);
        if (bossDist < explosionRadius + 12) {
            damageBoss(explosionDamage, pos);
        }
    }
    
    screenShake = Math.max(screenShake, 4);
}

// Turret explosion - Missile Command style expanding explosion sphere
function turretExplosion(pos, baseDamage) {
    const maxRadius = 30;
    const explosionDamage = baseDamage;
    
    // Create expanding explosion sphere - bright green
    const sphereGeo = new THREE.SphereGeometry(1, 16, 12);
    const sphereMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ffaa, 
        transparent: true, 
        opacity: 0.8 
    });
    const explosionSphere = new THREE.Mesh(sphereGeo, sphereMat);
    explosionSphere.position.copy(pos);
    scene.add(explosionSphere);
    
    // Inner core - brighter
    const coreGeo = new THREE.SphereGeometry(1, 12, 10);
    const coreMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff, 
        transparent: true, 
        opacity: 0.9 
    });
    const core = new THREE.Mesh(coreGeo, coreMat);
    explosionSphere.add(core);
    
    // Bright flash
    const flash = new THREE.PointLight(0x00ffaa, 10, 80);
    flash.position.copy(pos);
    scene.add(flash);
    
    // Track enemies already damaged
    const damagedEnemies = new Set();
    
    // Animate expansion - Missile Command style
    const startTime = Date.now();
    const expandDuration = 500;
    const holdDuration = 400;
    const fadeDuration = 400;
    const totalDuration = expandDuration + holdDuration + fadeDuration;
    
    function animateExplosion() {
        const elapsed = Date.now() - startTime;
        
        if (elapsed >= totalDuration) {
            scene.remove(explosionSphere);
            scene.remove(flash);
            return;
        }
        
        let currentRadius;
        
        if (elapsed < expandDuration) {
            // Expanding phase - grows outward
            const progress = elapsed / expandDuration;
            // Ease out for smooth expansion
            const eased = 1 - Math.pow(1 - progress, 3);
            currentRadius = eased * maxRadius;
            explosionSphere.scale.setScalar(currentRadius);
            core.scale.setScalar(0.7);
            sphereMat.opacity = 0.8;
            coreMat.opacity = 0.9;
            flash.intensity = 10;
        } else if (elapsed < expandDuration + holdDuration) {
            // Hold at max size - pulsing
            currentRadius = maxRadius;
            const pulse = 1 + Math.sin((elapsed - expandDuration) * 0.02) * 0.1;
            explosionSphere.scale.setScalar(maxRadius * pulse);
            sphereMat.opacity = 0.6;
            coreMat.opacity = 0.7;
            flash.intensity = 6;
        } else {
            // Fade out
            const fadeProgress = (elapsed - expandDuration - holdDuration) / fadeDuration;
            currentRadius = maxRadius;
            explosionSphere.scale.setScalar(maxRadius * (1 - fadeProgress * 0.5));
            sphereMat.opacity = 0.6 * (1 - fadeProgress);
            coreMat.opacity = 0.7 * (1 - fadeProgress);
            flash.intensity = 6 * (1 - fadeProgress);
        }
        
        // Check for enemies touching the expanding sphere
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            if (enemy.state !== 'active') continue;
            if (damagedEnemies.has(enemy)) continue;
            
            const dist = enemy.mesh.position.distanceTo(pos);
            if (dist < currentRadius + CONFIG.enemies[enemy.type].size) {
                damagedEnemies.add(enemy);
                
                // Damage based on how close to center
                const falloff = Math.max(0.5, 1 - dist / maxRadius);
                enemy.health -= explosionDamage * falloff;
                
                // Visual hit - spark
                createHitEffect(enemy.mesh.position.clone(), 0x00ffaa);
                
                if (enemy.health <= 0) {
                    destroyEnemy(enemy);
                }
            }
        }
        
        // Continuous damage to boss while inside sphere
        if (boss && !boss.defeated) {
            const bossDist = boss.mesh.position.distanceTo(pos);
            if (bossDist < currentRadius + 15) {
                damageBoss(explosionDamage * 0.05, pos);
            }
        }
        
        requestAnimationFrame(animateExplosion);
    }
    
    animateExplosion();
    screenShake = Math.max(screenShake, 10);
}

// Hit spark effect - minimal
function createHitEffect(pos, color) {
    // Just 2 particles
    for (let i = 0; i < 2; i++) {
        const dir = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2
        );
        createParticle(pos.clone(), color, 0.15, dir);
    }
    
    showHitMarker();
}

let hitMarkerTimeout = null;
function showHitMarker() {
    const marker = document.getElementById('hit-marker');
    marker.style.left = (mousePos.x - 20) + 'px';
    marker.style.top = (mousePos.y - 20) + 'px';
    marker.classList.add('active');
    
    // Clear existing timeout and set new one
    if (hitMarkerTimeout) clearTimeout(hitMarkerTimeout);
    hitMarkerTimeout = setTimeout(() => marker.classList.remove('active'), 80);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ENEMY BULLETS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function fireEnemyBullet(pos, dir, speed = 0.5, color = 0xff3300) {
    const geo = new THREE.SphereGeometry(0.6, 6, 6);
    const mat = new THREE.MeshBasicMaterial({ color });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    scene.add(mesh);
    
    enemyBullets.push({
        mesh,
        dir: dir.clone().normalize(),
        speed,
        damage: 10
    });
}

function updateEnemyBullets(dt) {
    enemyBullets.forEach((b, i) => {
        b.mesh.position.add(b.dir.clone().multiplyScalar(b.speed));
        
        // Check player collision
        if (b.mesh.position.distanceTo(player.mesh.position) < 2.5 && player.invincible <= 0) {
            // Cover provides 50% evasion chance
            if (player.inCover && Math.random() < 0.5) {
                // Bullet misses - deflected by cover
                scene.remove(b.mesh);
                enemyBullets.splice(i, 1);
                return;
            }
            damagePlayer(b.damage);
            scene.remove(b.mesh);
            enemyBullets.splice(i, 1);
            return;
        }
        
        // Remove if too far
        if (b.mesh.position.distanceTo(player.mesh.position) > 200) {
            scene.remove(b.mesh);
            enemyBullets.splice(i, 1);
        }
    });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PLAYER SYSTEMS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function damagePlayer(amount) {
    // Shield absorbs damage first
    if (player.shield > 0) {
        const shieldDamage = Math.min(player.shield, amount);
        player.shield -= shieldDamage;
        amount -= shieldDamage;
    }
    
    player.health -= amount;
    player.invincible = 0.5;
    screenShake = 10;
    
    // Reset combo
    combo = 0;
    updateComboDisplay();
    
    // Damage flash
    document.getElementById('damage-vignette').style.opacity = 0.8;
    setTimeout(() => document.getElementById('damage-vignette').style.opacity = 0, 100);
    
    updateHUD();
    
    if (player.health <= 0) {
        gameOver();
    }
}

function dash() {
    const now = Date.now();
    if (now - player.lastDash < player.dashCooldown) return;
    
    player.lastDash = now;
    player.isDashing = true;
    player.invincible = 0.3;
    
    // Dash in movement direction or forward
    player.dashDir.set(0, 0, 0);
    if (keys['w']) player.dashDir.z += 1;
    if (keys['s']) player.dashDir.z -= 1;
    if (keys['a']) player.dashDir.x -= 1;
    if (keys['d']) player.dashDir.x += 1;
    
    if (player.dashDir.length() === 0) {
        player.dashDir.z = 1;
    }
    player.dashDir.normalize().multiplyScalar(2);
    
    // Dash particles
    for (let i = 0; i < 10; i++) {
        createParticle(player.mesh.position.clone(), player.color, 0.5);
    }
    
    setTimeout(() => {
        player.isDashing = false;
    }, 150);
}

function updatePlayer(dt) {
    // Movement
    const moveDir = new THREE.Vector3();
    if (keys['w']) moveDir.z += 1;
    if (keys['s']) moveDir.z -= 1;
    if (keys['a']) moveDir.x -= 1;
    if (keys['d']) moveDir.x += 1;
    
    if (moveDir.length() > 0) {
        moveDir.normalize().multiplyScalar(player.speed);
    }
    
    // Apply dash
    if (player.isDashing) {
        player.mesh.position.add(player.dashDir);
    } else {
        player.velocity.lerp(moveDir, 0.15);
        player.mesh.position.add(player.velocity);
    }
    
    // Invincibility timer
    if (player.invincible > 0) {
        player.invincible -= dt;
        player.mesh.visible = Math.floor(Date.now() / 50) % 2 === 0;
    } else {
        player.mesh.visible = true;
    }
    
    // Shield regeneration
    if (player.shield < player.maxShield) {
        player.shield += player.shieldRegen;
    }
    
    // Energy regeneration
    if (player.energy < player.maxEnergy) {
        player.energy += 0.15;
    }
    
    // Rotate ship toward mouse
    const lookDir = worldMouse.clone().sub(player.mesh.position);
    const targetAngle = Math.atan2(lookDir.x, lookDir.z);
    player.mesh.rotation.y = targetAngle;
    
    // Bank when moving
    const bankAmount = -player.velocity.x * 0.3;
    player.mesh.rotation.z = bankAmount;
    
    // Engine glow based on movement
    player.engineLight.intensity = 1 + moveDir.length() * 2;
    
    // Thruster particles (reduced frequency)
    player.thrusterTime += dt;
    if (player.thrusterTime > 0.15 && moveDir.length() > 0.5) {
        player.thrusterTime = 0;
        const thrustPos = player.mesh.position.clone();
        thrustPos.y -= 1;
        createParticle(thrustPos, player.color, 0.2);
    }
    
    // Firing
    if (mouseDown) {
        fireWeapon();
    }
    
    // Combo decay
    if (comboTimer > 0) {
        comboTimer -= dt;
        if (comboTimer <= 0) {
            combo = 0;
            updateComboDisplay();
        }
    }
    
    // Check if player is near cover (crashed ships/buildings)
    player.inCover = false;
    currentCoverShip = null;
    const coverIndicator = document.getElementById('cover-indicator');
    
    // Update all shield domes - hide them first
    for (let i = 0; i < largeStructures.length; i++) {
        const s = largeStructures[i];
        if (s.shieldDome) {
            s.shieldDome.material.opacity = 0;
        }
    }
    
    // Check for cover
    for (let i = 0; i < largeStructures.length; i++) {
        const s = largeStructures[i];
        const dist = player.mesh.position.distanceTo(s.position);
        if (dist < s.radius + 15) {
            player.inCover = true;
            if (s.type === 'ship') {
                currentCoverShip = s;
                // Show and pulse shield dome
                if (s.shieldDome) {
                    const pulse = 0.15 + Math.sin(Date.now() * 0.005) * 0.08;
                    s.shieldDome.material.opacity = pulse;
                    s.shieldDome.rotation.y += 0.01;
                }
            }
            break;
        }
    }
    coverIndicator.style.display = player.inCover ? 'block' : 'none';
    
    // Update super weapon charge display
    const superChargeEl = document.getElementById('super-charge');
    const superFill = document.getElementById('super-fill');
    const superSlot = document.getElementById('super-slot');
    if (superCharge > 0) {
        superChargeEl.style.display = 'block';
        superFill.style.width = (superCharge / maxSuperCharge * 100) + '%';
        
        // Light up super weapon slot when charged
        if (superCharge >= maxSuperCharge) {
            superSlot.style.borderColor = '#f0f';
            superSlot.style.opacity = '1';
            superSlot.style.boxShadow = '0 0 20px #f0f';
            superSlot.classList.add('active');
        } else {
            superSlot.style.borderColor = '#808';
            superSlot.style.opacity = '0.3';
            superSlot.style.boxShadow = 'none';
            superSlot.classList.remove('active');
        }
    } else {
        superChargeEl.style.display = 'none';
        superSlot.style.opacity = '0.3';
        superSlot.style.boxShadow = 'none';
        superSlot.classList.remove('active');
    }
    
    updateHUD();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// VISUAL EFFECTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function createExplosion(pos, damage = 0, radius = 10, color = 0xff4400) {
    // Minimal particles
    for (let i = 0; i < 8; i++) {
        const dir = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2
        );
        createParticle(pos.clone(), color, Math.random() * 0.3 + 0.15, dir);
    }
    
    // Quick flash light
    addExplosionLight(pos, color, radius);
    
    // Damage nearby player
    if (damage > 0 && radius > 0) {
        const distToPlayer = pos.distanceTo(player.mesh.position);
        if (distToPlayer < radius && player.invincible <= 0) {
            damagePlayer(damage);
        }
    }
    
    screenShake = Math.max(screenShake, 2);
}

// Light pool for explosions - minimal
const explosionLights = [];
const MAX_EXPLOSION_LIGHTS = 3;

function addExplosionLight(pos, color, radius) {
    let light;
    
    // Reuse existing light or create new one
    const available = explosionLights.find(l => !l.userData.active);
    if (available) {
        light = available;
        light.position.copy(pos);
        light.color.setHex(color);
        light.intensity = 6;
        light.distance = radius * 3;
        light.userData.active = true;
        light.userData.life = 0.15;
    } else if (explosionLights.length < MAX_EXPLOSION_LIGHTS) {
        light = new THREE.PointLight(color, 6, radius * 3);
        light.position.copy(pos);
        light.userData.active = true;
        light.userData.life = 0.15;
        explosionLights.push(light);
        scene.add(light);
    }
}

function updateExplosionLights(dt) {
    explosionLights.forEach(light => {
        if (light.userData.active) {
            light.userData.life -= dt;
            light.intensity = Math.max(0, light.userData.life / 0.15) * 6;
            if (light.userData.life <= 0) {
                light.userData.active = false;
                light.intensity = 0;
            }
        }
    });
}

// Player proximity flash effect - simplified
let playerFlashIntensity = 0;

function flashPlayerScreen(color, intensity) {
    playerFlashIntensity = Math.max(playerFlashIntensity, intensity);
}

function updatePlayerFlash(dt) {
    if (playerFlashIntensity > 0) {
        playerFlashIntensity -= dt * 4;
    }
}

const MAX_PARTICLES = 50;
const particlePool = [];

function createParticle(pos, color, size = 0.3, velocity = null) {
    // Limit particle count
    if (particles.length >= MAX_PARTICLES) {
        // Remove oldest particle
        const oldest = particles.shift();
        scene.remove(oldest.mesh);
    }
    
    let mesh;
    
    // Try to reuse from pool
    const pooled = particlePool.pop();
    if (pooled) {
        mesh = pooled;
        mesh.material.color.setHex(color);
        mesh.scale.setScalar(size);
        mesh.visible = true;
    } else {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshBasicMaterial({ color });
        mesh = new THREE.Mesh(geo, mat);
        mesh.scale.setScalar(size);
        scene.add(mesh);
    }
    
    mesh.position.copy(pos);
    
    const vel = velocity || new THREE.Vector3(
        (Math.random() - 0.5) * 2,
        (Math.random() - 0.5) * 2,
        (Math.random() - 0.5) * 2
    );
    
    particles.push({
        mesh,
        velocity: vel,
        lifetime: 0.6,
        initialSize: size
    });
}

function updateParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.lifetime -= dt;
        p.mesh.position.add(p.velocity.clone().multiplyScalar(dt * 8));
        p.velocity.multiplyScalar(0.96);
        
        const scale = (p.lifetime / 0.6) * p.initialSize;
        p.mesh.scale.setScalar(Math.max(0.01, scale));
        
        if (p.lifetime <= 0) {
            p.mesh.visible = false;
            particlePool.push(p.mesh); // Return to pool
            particles.splice(i, 1);
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UI UPDATES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function updateHUD() {
    document.getElementById('health-fill').style.width = `${(player.health / player.maxHealth) * 100}%`;
    document.getElementById('shield-fill').style.width = `${(player.shield / player.maxShield) * 100}%`;
    document.getElementById('energy-fill').style.width = `${(player.energy / player.maxEnergy) * 100}%`;
    document.getElementById('score-val').innerText = score.toLocaleString();
    document.getElementById('kill-val').innerText = kills;
}

function updateComboDisplay() {
    const display = document.getElementById('combo-display');
    if (combo > 1) {
        display.innerText = `x${combo}`;
        display.classList.add('active');
        display.style.color = combo > 10 ? '#ff0' : combo > 5 ? '#f80' : '#fff';
    } else {
        display.classList.remove('active');
    }
}

function updateMinimap() {
    const canvas = document.getElementById('minimap-canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 150;
    canvas.height = 150;
    
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0, 0, 150, 150);
    
    const scale = 0.3;
    const cx = 75;
    const cy = 75;
    
    // Draw enemies
    ctx.fillStyle = '#f44';
    enemies.forEach(e => {
        const dx = (e.mesh.position.x - player.mesh.position.x) * scale;
        const dy = (e.mesh.position.z - player.mesh.position.z) * scale;
        if (Math.abs(dx) < 70 && Math.abs(dy) < 70) {
            ctx.beginPath();
            ctx.arc(cx + dx, cy - dy, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    });
    
    // Draw boss
    if (boss) {
        ctx.fillStyle = '#f00';
        const bx = (boss.mesh.position.x - player.mesh.position.x) * scale;
        const by = (boss.mesh.position.z - player.mesh.position.z) * scale;
        ctx.beginPath();
        ctx.arc(cx + bx, cy - by, 8, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Draw player
    ctx.fillStyle = '#0ff';
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Direction indicator
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.sin(player.mesh.rotation.y) * 10, cy - Math.cos(player.mesh.rotation.y) * 10);
    ctx.stroke();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GAME LOOP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function update() {
    if (!gameActive) return;
    requestAnimationFrame(update);
    
    const dt = Math.min(clock.getDelta(), 0.05); // Cap delta to prevent spiral
    
    // Update systems
    updatePlayer(dt);
    updateProjectiles(dt);
    updateEnemyBullets(dt);
    updatePowerups(dt);
    updateParticles(dt);
    updateExplosionLights(dt);
    updatePlayerFlash(dt);
    updateStarfield(dt);
    
    // Update enemies (use standard loop for safety)
    for (let i = enemies.length - 1; i >= 0; i--) {
        updateEnemy(enemies[i], dt);
    }
    
    if (boss) {
        if (boss.defeated) {
            updateBossDeathSequence(dt);
        } else {
            updateBoss(dt);
        }
    }
    
    // Handle next wave delay
    if (window.nextWaveDelay) {
        window.nextWaveDelay -= dt;
        if (window.nextWaveDelay <= 0) {
            window.nextWaveDelay = null;
            startNextWave();
        }
    }
    
    // Camera follow with screen shake
    const shakeX = (Math.random() - 0.5) * screenShake;
    const shakeY = (Math.random() - 0.5) * screenShake;
    screenShake *= 0.85; // Faster decay
    
    camera.position.set(
        player.mesh.position.x + shakeX,
        player.mesh.position.y - 30 + shakeY,
        player.mesh.position.z + 60
    );
    camera.lookAt(player.mesh.position.x, player.mesh.position.y + 10, player.mesh.position.z);
    
    // Update minimap (throttled)
    if (Date.now() % 3 === 0) updateMinimap();
    
    // Render
    renderer.render(scene, camera);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GAME STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function gameOver() {
    gameActive = false;
    
    document.getElementById('status-text').innerText = 'MISSION FAILED';
    document.getElementById('status-text').style.color = '#f44';
    document.getElementById('final-score').innerText = score.toLocaleString();
    document.getElementById('final-kills').innerText = kills;
    document.getElementById('final-waves').innerText = wave;
    document.getElementById('final-combo').innerText = maxCombo;
    document.getElementById('final-accuracy').innerText = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) + '%' : '0%';
    document.getElementById('game-over').style.display = 'flex';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INPUT HANDLING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    
    // Weapon switching
    if (e.key >= '1' && e.key <= '4') {
        const idx = parseInt(e.key) - 1;
        const slot = document.querySelector(`.weapon-slot[data-weapon="${idx}"]`);
        if (slot && !slot.classList.contains('locked')) {
            currentWeapon = idx;
            document.querySelectorAll('.weapon-slot').forEach(s => s.classList.remove('active'));
            slot.classList.add('active');
        }
    }
    
    // Dash
    if (e.key.toLowerCase() === 'shift') {
        dash();
    }
    
    // Ship turret (when in cover)
    if (e.key.toLowerCase() === 'e') {
        fireShipTurret();
    }
    
    // Super weapon (when charged)
    if (e.key.toLowerCase() === 'q' || e.key === ' ') {
        fireSuperWeapon();
    }
});

window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

window.addEventListener('mousedown', (e) => {
    if (e.button === 0) mouseDown = true;
});

window.addEventListener('mouseup', (e) => {
    if (e.button === 0) mouseDown = false;
});

window.addEventListener('mousemove', (e) => {
    mousePos.x = e.clientX;
    mousePos.y = e.clientY;
    
    // Update crosshair
    const crosshair = document.getElementById('crosshair');
    crosshair.style.left = (e.clientX - 15) + 'px';
    crosshair.style.top = (e.clientY - 15) + 'px';
    
    // Project mouse to world
    if (camera) {
        const ndcX = (e.clientX / window.innerWidth) * 2 - 1;
        const ndcY = -(e.clientY / window.innerHeight) * 2 + 1;
        
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera({ x: ndcX, y: ndcY }, camera);
        
        // Project to player's Y plane
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -player.mesh.position.y);
        raycaster.ray.intersectPlane(plane, worldMouse);
    }
});

window.addEventListener('resize', () => {
    if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
});

// Prevent context menu on right click
window.addEventListener('contextmenu', (e) => e.preventDefault());
</script>
</body>
</html>
