<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Maritime AI Commander - Naval Logistics & Defense Simulator</title>
  <meta name="description" content="Advanced AI-powered naval shipping, trucking and defense simulation. Command autonomous fleets, build strategic defenses, and master logistics warfare.">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Courier New', monospace;
      background: linear-gradient(to bottom, #001a33 0%, #000000 100%);
      color: #0ff;
      overflow: hidden;
    }
    #canvas-container { width: 100vw; height: 100vh; position: relative; }
    #hud {
      position: absolute; top: 20px; left: 20px;
      background: linear-gradient(135deg, rgba(0, 30, 60, 0.95), rgba(0, 50, 80, 0.95));
      border: 3px solid #00d4ff; padding: 20px; border-radius: 12px;
      min-width: 320px; pointer-events: none; z-index: 100;
      box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3);
    }
    .hud-title { color: #00d4ff; font-size: 20px; margin-bottom: 12px; text-shadow: 0 0 15px #00d4ff; font-weight: bold; letter-spacing: 1px; }
    .hud-subtitle { color: #88ccff; font-size: 11px; margin-bottom: 15px; opacity: 0.8; font-style: italic; }
    .hud-stat { color: #88ccff; font-size: 14px; margin: 8px 0; padding: 5px 0; border-bottom: 1px solid rgba(0, 212, 255, 0.2); }
    .hud-value { color: #00ff88; font-weight: bold; float: right; }

    #controls-panel {
      position: absolute; bottom: 20px; left: 20px;
      background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(40, 20, 60, 0.95));
      border: 3px solid #ff00ff; padding: 20px; border-radius: 12px;
      pointer-events: all; box-shadow: 0 8px 32px rgba(255, 0, 255, 0.3);
    }
    .control-section-title { color: #ff00ff; font-size: 16px; margin-bottom: 12px; text-shadow: 0 0 10px #ff00ff; font-weight: bold; letter-spacing: 1px; }
    .control-btn {
      background: linear-gradient(135deg, #001a33, #003366);
      border: 2px solid #00d4ff; color: #00d4ff;
      padding: 12px 24px; margin: 6px; cursor: pointer; border-radius: 8px;
      font-family: 'Courier New', monospace; font-size: 13px; font-weight: bold;
      transition: all 0.3s; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .control-btn:hover { background: linear-gradient(135deg, #00d4ff, #0088ff); color: #000; box-shadow: 0 0 25px #00d4ff; transform: translateY(-2px); }
    .control-btn.active { background: linear-gradient(135deg, #ff00ff, #ff0088); border-color: #ff00ff; color: #fff; box-shadow: 0 0 25px #ff00ff; }

    #tower-shop {
      position: absolute; bottom: 20px; right: 20px;
      background: linear-gradient(135deg, rgba(40, 30, 0, 0.95), rgba(60, 40, 0, 0.95));
      border: 3px solid #ffaa00; padding: 20px; border-radius: 12px;
      pointer-events: all; box-shadow: 0 8px 32px rgba(255, 170, 0, 0.3);
    }
    .shop-title { color: #ffaa00; font-size: 16px; margin-bottom: 12px; text-shadow: 0 0 10px #ffaa00; font-weight: bold; letter-spacing: 1px; }
    .tower-btn {
      background: linear-gradient(135deg, #332200, #554400);
      border: 2px solid #ffaa00; color: #ffaa00;
      padding: 10px 18px; margin: 6px; cursor: pointer; border-radius: 8px;
      font-family: 'Courier New', monospace; font-size: 12px; font-weight: bold;
      transition: all 0.2s; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .tower-btn:hover { background: linear-gradient(135deg, #ffaa00, #ffcc00); color: #000; box-shadow: 0 0 20px #ffaa00; transform: translateY(-2px); }
    .tower-btn.selected { background: linear-gradient(135deg, #ffaa00, #ff8800); color: #000; border-color: #fff; box-shadow: 0 0 25px #ffaa00; }
    .tower-btn.disabled { opacity: 0.3; cursor: not-allowed; }

    #ai-memory {
      position: absolute; top: 20px; right: 20px;
      background: rgba(40, 0, 40, 0.95);
      border: 2px solid #f0f;
      padding: 15px; border-radius: 8px;
      max-width: 380px; max-height: 420px; overflow-y: auto;
      pointer-events: none;
    }
    .memory-entry {
      background: rgba(80, 0, 80, 0.5);
      border-left: 3px solid #f0f;
      padding: 8px; margin: 5px 0;
      font-size: 11px; border-radius: 3px;
    }

    #battle-stats {
      position: absolute; top: 50%; right: 20px; transform: translateY(-50%);
      background: rgba(40, 20, 0, 0.95);
      border: 2px solid #ff6600;
      padding: 15px; border-radius: 8px;
      pointer-events: none;
    }
    .stat-bar { height: 20px; background: rgba(0,0,0,0.5); border-radius: 10px; overflow: hidden; margin: 5px 0; }
    .stat-fill { height: 100%; transition: width 0.3s; }
    .player-fill { background: linear-gradient(90deg, #00ff00, #00aa00); }
    .ai-fill { background: linear-gradient(90deg, #ff0000, #aa0000); }
  </style>
</head>
<body>
  <div id="canvas-container"></div>

  <div id="hud">
    <div class="hud-title">‚öì MARITIME AI COMMANDER</div>
    <div class="hud-subtitle">Wave Defense + Veteran Allies v3.0</div>
    <div class="hud-stat">Vehicle Type: <span class="hud-value" id="current-form">NAVAL CARGO</span></div>
    <div class="hud-stat">Credits: <span class="hud-value" id="gold">$1000</span></div>
    <div class="hud-stat">Friendly Fleet: <span class="hud-value" id="fleet-size">1</span></div>
    <div class="hud-stat">Hostile Ships: <span class="hud-value" id="ai-ships">0</span></div>
    <div class="hud-stat">Allied Defense: <span class="hud-value" id="player-towers">0</span></div>
    <div class="hud-stat">Hostile Defense: <span class="hud-value" id="ai-towers">0</span></div>
    <div class="hud-stat">Mission Score: <span class="hud-value" id="score">0</span></div>
  </div>

  <div id="controls-panel">
    <div class="control-section-title">üéÆ FLEET OPERATIONS</div>
    <div style="margin-bottom: 15px; border-bottom: 1px solid rgba(255, 0, 255, 0.3); padding-bottom: 10px;">
      <div style="color: #88ccff; font-size: 12px; margin-bottom: 8px;">üì¶ Vehicle Mode</div>
      <button class="control-btn" id="transform-ship" style="font-size: 11px;">‚õ¥Ô∏è Naval Cargo</button>
      <button class="control-btn" id="transform-car" style="font-size: 11px;">üöõ Ground Transport</button>
    </div>
    <div style="border-top: 1px solid rgba(255, 0, 255, 0.3); padding-top: 10px;">
      <div style="color: #88ccff; font-size: 12px; margin-bottom: 8px;">‚öôÔ∏è Simulation Control</div>
      <button class="control-btn" id="spawn-fleet">‚ûï Wave: +1 Ally / +5 Enemies</button>
      <button class="control-btn" id="start-battle">‚öîÔ∏è Combat Mode: <span id="battle-status">STANDBY</span></button>
      <button class="control-btn" id="toggle-ai-build">üèóÔ∏è Hostile Construction: <span id="ai-build-status">OFF</span></button>
      <button class="control-btn" id="self-play">ü§ñ Auto-Simulation: <span id="self-play-status">OFF</span></button>
    </div>
  </div>

  <div id="tower-shop">
    <div class="shop-title">üè≠ DEFENSE SYSTEMS CATALOG</div>
    <div style="font-size: 10px; color: #cc8800; margin-bottom: 10px; font-style: italic;">Select & Deploy on Islands</div>
    <button class="tower-btn" data-tower="cannon" data-cost="100">üî• Auto-Cannon<br/>$100 CR</button>
    <button class="tower-btn" data-tower="harpoon" data-cost="150">üéØ Harpoon Array<br/>$150 CR</button>
    <button class="tower-btn" data-tower="net" data-cost="200">üï∏Ô∏è Net Launcher<br/>$200 CR</button>
    <button class="tower-btn" data-tower="lighthouse" data-cost="300">üóº Defense Beacon<br/>$300 CR</button>
  </div>

  <div id="ai-memory">
    <div style="color: #f0f; font-size: 16px; margin-bottom: 10px;">üß† VETERAN DOCTRINE + MEMORY</div>
    <div id="memory-log"></div>
  </div>

  <div id="blue-line-knowledge" style="position: absolute; bottom: 200px; left: 20px; background: rgba(0, 40, 80, 0.95); border: 2px solid #0ff; padding: 15px; border-radius: 8px; max-width: 350px; pointer-events: none;">
    <div style="color: #0ff; font-size: 14px; margin-bottom: 10px;">üìò BLUE LINE DOCTRINE</div>
    <div style="font-size: 11px; color: #aaa; margin-bottom: 8px;">Shared Veteran Learning (All Allies)</div>
    <div id="knowledge-list" style="font-size: 11px;"></div>
  </div>

  <div id="battle-stats">
    <div style="color: #ff6600; font-size: 14px; margin-bottom: 10px;">‚öîÔ∏è BATTLE STATUS</div>
    <div style="color: #0f0; font-size: 12px;">Friendly Power</div>
    <div class="stat-bar"><div class="stat-fill player-fill" id="player-power" style="width: 50%"></div></div>
    <div style="color: #f00; font-size: 12px; margin-top: 10px;">Hostile Power</div>
    <div class="stat-bar"><div class="stat-fill ai-fill" id="ai-power" style="width: 50%"></div></div>
    <div style="color: #fff; font-size: 11px; margin-top: 10px;">
      Battles Won: <span id="battles-won">0</span> / <span id="battles-total">0</span>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // =========================
    // PERFORMANCE UTILITIES
    // =========================
    const clamp01 = (v) => (v < 0 ? 0 : (v > 1 ? 1 : v));
    const clamp = (v, a, b) => (v < a ? a : (v > b ? b : v));

    // Reusable vectors (avoid per-frame allocations)
    const V3A = new THREE.Vector3();
    const V3B = new THREE.Vector3();
    const V3C = new THREE.Vector3();
    const V3D = new THREE.Vector3();
    const V3E = new THREE.Vector3();
    const V3F = new THREE.Vector3();
    const V3G = new THREE.Vector3();

    // Spatial hash grid for efficient neighbor/target queries
    class SpatialGrid {
      constructor(cellSize = 20) {
        this.cellSize = cellSize;
        this.map = new Map();
      }
      _key(ix, iz) { return (ix << 16) ^ (iz & 0xffff); }
      _ix(x) { return (x / this.cellSize) | 0; }
      _iz(z) { return (z / this.cellSize) | 0; }
      clear() { this.map.clear(); }
      insert(obj) {
        const ix = this._ix(obj.position.x);
        const iz = this._iz(obj.position.z);
        const k = this._key(ix, iz);
        let arr = this.map.get(k);
        if (!arr) { arr = []; this.map.set(k, arr); }
        arr.push(obj);
      }
      queryRadius(pos, radius, outArr) {
        outArr.length = 0;
        const cs = this.cellSize;
        const r = radius;
        const minX = ((pos.x - r) / cs) | 0;
        const maxX = ((pos.x + r) / cs) | 0;
        const minZ = ((pos.z - r) / cs) | 0;
        const maxZ = ((pos.z + r) / cs) | 0;
        for (let ix = minX; ix <= maxX; ix++) {
          for (let iz = minZ; iz <= maxZ; iz++) {
            const k = this._key(ix, iz);
            const arr = this.map.get(k);
            if (arr) outArr.push(...arr);
          }
        }
        return outArr;
      }
    }

    // =========================
    // GAME STATE
    // =========================
    const gameState = {
      gold: 1000,
      score: 0,
      selectedTower: null,

      playerShips: [],     // includes ONLY the player ship (index 0)
      allyShips: [],       // friendly AI agents
      enemyShips: [],      // hostile AI

      islands: [],
      playerTowers: [],
      aiTowers: [],        // hostile towers (optional via toggle)
      projectiles: [],
      projectilePool: [],

      aiBuildEnabled: false,
      battleActive: false,
      battlesWon: 0,
      battlesTotal: 0,

      selfPlayMode: false,
      selfPlayInterval: null,

      grid: new SpatialGrid(22),
      neighborScratch: [],

      wave: 0
    };

    // Shared doctrine learning (NOT per-ship memory)
    const veteranDoctrine = {
      // weights 0..1
      towerAffinity: 0.55,      // how strongly allies hug towers under threat
      distanceDiscipline: 0.45, // how strongly allies keep optimal distance
      aggression: 0.50,         // how aggressively allies chase kills
      focusFire: 0.55,          // how likely to focus the weakest nearby enemy
      kiting: 0.55              // tendency to drag enemies toward tower coverage
    };

    // =========================
    // AI MEMORY (TOWER PLACEMENT LEARNING) - GLOBAL
    // =========================
    const aiMemory = {
      towerPlacements: [],
      islandPreferences: {},
      towerTypeUsage: { cannon: 0, harpoon: 0, net: 0, lighthouse: 0 },

      recordPlacement(island, towerType, effectiveness) {
        if (!island) return;
        const islandName = island.userData ? island.userData.name : island.name;
        if (!islandName) return;

        this.towerPlacements.push({ islandName, towerType, effectiveness, timestamp: Date.now() });
        this.towerTypeUsage[towerType]++;

        if (!this.islandPreferences[islandName]) {
          this.islandPreferences[islandName] = { placements: 0, towers: [], effectiveness: 0 };
        }
        const pref = this.islandPreferences[islandName];
        pref.placements++;
        pref.towers.push(towerType);
        pref.effectiveness = (pref.effectiveness + effectiveness) / 2;

        logMemory(`Learned: ${towerType} on ${islandName} (${(effectiveness*100).toFixed(0)}% effective)`);

        if (this.towerPlacements.length > 60) this.towerPlacements.shift();
      },

      getBestTowerForIsland(island) {
        if (!island) return 'cannon';
        const islandName = island.userData ? island.userData.name : island.name;
        if (!islandName) return 'cannon';

        const pref = this.islandPreferences[islandName];
        if (!pref || pref.towers.length === 0) {
          const sorted = Object.entries(this.towerTypeUsage).sort((a,b)=>b[1]-a[1]);
          return sorted[0] ? sorted[0][0] : 'cannon';
        }
        const counts = {};
        for (let i = 0; i < pref.towers.length; i++) {
          const t = pref.towers[i];
          counts[t] = (counts[t] || 0) + 1;
        }
        return Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
      },

      getBestIslands() {
        return Object.entries(this.islandPreferences)
          .sort((a,b)=>b[1].effectiveness - a[1].effectiveness)
          .slice(0, 3)
          .map(e => e[0]);
      }
    };

    function logMemory(message) {
      const log = document.getElementById('memory-log');
      const entry = document.createElement('div');
      entry.className = 'memory-entry';
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      log.insertBefore(entry, log.firstChild);
      while (log.children.length > 22) log.removeChild(log.lastChild);
    }

    // =========================
    // THREE SETUP
    // =========================
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x001a33, 50, 300);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 40, 60);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 50);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x0066aa, 0.5);
    scene.add(hemiLight);

    // Water
    const waterGeometry = new THREE.PlaneGeometry(500, 500, 50, 50);
    const waterMaterial = new THREE.MeshStandardMaterial({
      color: 0x1E90FF, roughness: 0.6, metalness: 0.3, transparent: true, opacity: 0.9
    });
    const water = new THREE.Mesh(waterGeometry, waterMaterial);
    water.rotation.x = -Math.PI / 2;
    water.receiveShadow = true;
    scene.add(water);

    function animateWater() {
      const time = Date.now() * 0.001;
      const positions = water.geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        positions.setZ(i, Math.sin(x * 0.1 + time) * 0.3 + Math.cos(y * 0.1 + time * 0.7) * 0.2);
      }
      positions.needsUpdate = true;
    }

    // =========================
    // WORLD OBJECTS
    // =========================
    class ProceduralIsland {
      constructor(x, z, size, name, depth = 3) {
        this.position = new THREE.Vector3(x, 0, z);
        this.baseSize = size;
        this.size = size;
        this.name = name;
        this.towers = [];
        this.depth = depth;
        this.shallowWaterRadius = size * 1.8;
        this.deepWaterRadius = size * 0.6;
        this.createProceduralMesh();
      }

      generateIslandPoints(iterations) {
        const points = [];
        const segmentCount = 8 + iterations * 4;
        for (let i = 0; i < segmentCount; i++) {
          const angle = (Math.PI * 2 * i) / segmentCount;
          const noise1 = Math.sin(angle * 3 + this.position.x * 0.1) * 0.3;
          const noise2 = Math.cos(angle * 5 + this.position.z * 0.1) * 0.2;
          const noise3 = Math.sin(angle * 7) * 0.15;
          const radius = this.baseSize * (1 + noise1 + noise2 + noise3);
          points.push(new THREE.Vector2(Math.cos(angle) * radius, Math.sin(angle) * radius));
        }
        return points;
      }

      createProceduralMesh() {
        const points = this.generateIslandPoints(this.depth);
        const shape = new THREE.Shape(points);

        const extrudeSettings = { depth: 2 + Math.random() * 2, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.3, bevelSegments: 3 };
        const islandGeom = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const islandMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.4, 0.35),
          roughness: 0.9, metalness: 0.1
        });

        this.mesh = new THREE.Mesh(islandGeom, islandMat);
        this.mesh.rotation.x = -Math.PI / 2;
        this.mesh.position.copy(this.position);
        this.mesh.position.y = 0.5;
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;

        this.mesh.userData = { type: 'island', name: this.name, island: this, isIsland: true };
        scene.add(this.mesh);

        this.addVegetation();
        this.createShallowWaterZone();
      }

      addVegetation() {
        const treeCount = Math.floor(3 + Math.random() * 5);
        for (let i = 0; i < treeCount; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * this.baseSize * 0.6;
          const treeHeight = 2 + Math.random() * 3;
          const treeGeom = new THREE.ConeGeometry(0.5 + Math.random() * 0.4, treeHeight, 6);
          const treeMat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(0.3 + Math.random() * 0.05, 0.6, 0.25) });
          const tree = new THREE.Mesh(treeGeom, treeMat);
          tree.position.set(
            this.position.x + Math.cos(angle) * distance,
            treeHeight / 2 + 1,
            this.position.z + Math.sin(angle) * distance
          );
          tree.castShadow = true;
          scene.add(tree);
        }
      }

      createShallowWaterZone() {
        const shallowGeom = new THREE.RingGeometry(this.deepWaterRadius, this.shallowWaterRadius, 32);
        const shallowMat = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.15, side: THREE.DoubleSide });
        const shallowRing = new THREE.Mesh(shallowGeom, shallowMat);
        shallowRing.rotation.x = -Math.PI / 2;
        shallowRing.position.copy(this.position);
        shallowRing.position.y = 0.05;
        scene.add(shallowRing);
      }

      isInShallowWater(pos) {
        const dx = pos.x - this.position.x;
        const dz = pos.z - this.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        return dist < this.shallowWaterRadius && dist > this.deepWaterRadius;
      }
    }

    class Tower {
      constructor(position, type, owner) {
        this.position = position.clone();
        this.type = type;
        this.owner = owner; // 'player' or 'ai'
        this.lastFire = 0;
        this.kills = 0;
        this.setupStats();
        this.createMesh();
      }

      setupStats() {
        const stats = {
          cannon:    { range: 30, damage: 25, fireRate: 900,  cost: 100, speed: 0.9 },
          harpoon:   { range: 40, damage: 40, fireRate: 1400, cost: 150, speed: 1.1 },
          net:       { range: 25, damage: 15, fireRate: 1700, cost: 200, speed: 0.8, slow: 0.5 },
          lighthouse:{ range: 50, damage: 10, fireRate: 450,  cost: 300, speed: 1.4 }
        };
        const s = stats[this.type];
        this.range = s.range; this.damage = s.damage; this.fireRate = s.fireRate; this.cost = s.cost; this.speed = s.speed;
        this.slow = s.slow || 0;
      }

      createMesh() {
        this.group = new THREE.Group();
        const color = (this.owner === 'player') ? 0x00ff00 : 0xff0000;

        switch (this.type) {
          case 'cannon': {
            const base = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.5, 2), new THREE.MeshStandardMaterial({ color: 0x654321 }));
            this.group.add(base);
            const cannon = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 2), new THREE.MeshStandardMaterial({ color }));
            cannon.rotation.z = Math.PI / 2;
            cannon.position.y = 1.5;
            this.group.add(cannon);
            break;
          }
          case 'harpoon': {
            const base = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 2), new THREE.MeshStandardMaterial({ color: 0x8B7355 }));
            this.group.add(base);
            const launcher = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 3), new THREE.MeshStandardMaterial({ color }));
            launcher.position.y = 1;
            this.group.add(launcher);
            break;
          }
          case 'net': {
            const base = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.5, 1.5), new THREE.MeshStandardMaterial({ color: 0x4d5d3d }));
            this.group.add(base);
            const net = new THREE.Mesh(new THREE.TorusGeometry(1, 0.1, 8, 16), new THREE.MeshStandardMaterial({ color }));
            net.position.y = 2;
            this.group.add(net);
            break;
          }
          case 'lighthouse': {
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.5, 6), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            body.position.y = 3;
            this.group.add(body);
            const lightSphere = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color }));
            lightSphere.position.y = 6.5;
            this.group.add(lightSphere);
            const areaLight = new THREE.PointLight(color, 1, 60);
            areaLight.position.y = 6.5;
            this.group.add(areaLight);
            break;
          }
        }

        this.group.position.copy(this.position);
        this.group.castShadow = true;
        scene.add(this.group);
      }

      canFire(now) {
        return (now - this.lastFire) >= this.fireRate;
      }

      fire(target) {
        const now = performance.now();
        if (!this.canFire(now)) return null;
        this.lastFire = now;

        const from = V3A.copy(this.position).setY(3);
        const proj = allocProjectile();
        proj.owner = this.owner; // 'player' or 'ai'
        proj.sourceType = 'tower';
        proj.damage = this.damage;
        proj.slow = this.slow;
        proj.ttl = 4.0;
        proj.targetRef = target;

        const dir = leadDirection(from, target.position, target.velocity, this.speed, V3B);
        proj.position.copy(from);
        proj.velocity.copy(dir).multiplyScalar(this.speed);

        setProjectileMesh(proj, this.type, this.owner);
        proj.mesh.position.copy(proj.position);
        scene.add(proj.mesh);
        gameState.projectiles.push(proj);

        return proj;
      }

      remove() { scene.remove(this.group); }
    }

    // =========================
    // PROJECTILES (POOLED)
    // =========================
    function allocProjectile() {
      const p = gameState.projectilePool.pop();
      if (p) return p;
      return {
        position: new THREE.Vector3(),
        velocity: new THREE.Vector3(),
        owner: 'player', // 'player' or 'ai'
        sourceType: 'tower', // 'tower' or 'ship'
        damage: 10,
        slow: 0,
        ttl: 3.0,
        targetRef: null,
        mesh: null,
        meshType: ''
      };
    }

    function freeProjectile(p) {
      if (p.mesh) {
        scene.remove(p.mesh);
        p.mesh.geometry && p.mesh.geometry.dispose && p.mesh.geometry.dispose();
        p.mesh.material && p.mesh.material.dispose && p.mesh.material.dispose();
      }
      p.mesh = null;
      p.targetRef = null;
      gameState.projectilePool.push(p);
    }

    function setProjectileMesh(p, type, owner) {
      const color = (owner === 'player') ? 0x00ff00 : 0xff0000;
      let geom, mat;
      let key = type + ':' + owner;
      if (p.mesh && p.meshType === key) return;

      if (p.mesh) {
        scene.remove(p.mesh);
        p.mesh.geometry && p.mesh.geometry.dispose && p.mesh.geometry.dispose();
        p.mesh.material && p.mesh.material.dispose && p.mesh.material.dispose();
      }

      switch (type) {
        case 'cannon':
          geom = new THREE.SphereGeometry(0.25);
          mat = new THREE.MeshBasicMaterial({ color });
          break;
        case 'harpoon':
          geom = new THREE.CylinderGeometry(0.05, 0.05, 1.2);
          mat = new THREE.MeshBasicMaterial({ color });
          break;
        case 'net':
        case 'lighthouse':
          geom = new THREE.SphereGeometry(0.18);
          mat = new THREE.MeshBasicMaterial({ color });
          break;
        case 'shipshot':
        default:
          geom = new THREE.SphereGeometry(0.18);
          mat = new THREE.MeshBasicMaterial({ color });
          break;
      }
      p.mesh = new THREE.Mesh(geom, mat);
      p.meshType = key;
    }

    // Lead target (analytic-ish): fallback to direct aim if no intercept
    function leadDirection(shooterPos, targetPos, targetVel, projSpeed, out) {
      // Solve ||(targetPos + targetVel*t) - shooterPos|| = projSpeed*t
      V3C.copy(targetPos).sub(shooterPos); // r
      const r = V3C;
      const v = targetVel || V3D.set(0,0,0);

      const a = v.dot(v) - projSpeed * projSpeed;
      const b = 2 * r.dot(v);
      const c = r.dot(r);

      let t = 0;
      if (Math.abs(a) < 1e-6) {
        // linear
        t = (Math.abs(b) > 1e-6) ? (-c / b) : 0;
      } else {
        const disc = b*b - 4*a*c;
        if (disc >= 0) {
          const s = Math.sqrt(disc);
          const t1 = (-b - s) / (2*a);
          const t2 = (-b + s) / (2*a);
          t = (t1 > 0 ? t1 : (t2 > 0 ? t2 : 0));
        } else {
          t = 0;
        }
      }
      if (t <= 0) {
        return out.copy(targetPos).sub(shooterPos).normalize();
      }
      V3E.copy(targetPos).addScaledVector(v, t);
      return out.copy(V3E).sub(shooterPos).normalize();
    }

    // =========================
    // SHIP CLASS
    // =========================
    class NavalShip {
      constructor(x, z, team = 'player') {
        this.team = team; // 'player' | 'ally' | 'enemy'
        this.position = new THREE.Vector3(x, 1, z);
        this.velocity = new THREE.Vector3();
        this.acceleration = new THREE.Vector3();
        this.rotation = 0;

        this.health = 100;
        this.maxHealth = 100;

        this.form = 'ship';
        this.gold = (team === 'enemy') ? 500 : 0;
        this.buildCooldown = 0;

        this.kills = 0;
        this.experience = 0;
        this.scale = 1.0;

        this.maxSpeed = (team === 'enemy') ? 0.55 : 0.45;
        this.maxForce = 0.06;

        // ship weapon (self-defense)
        this.fireCooldown = 0;
        this.baseFireRate = (team === 'enemy') ? 900 : 750;
        this.baseDamage = (team === 'enemy') ? 10 : 9;
        this.projSpeed = (team === 'enemy') ? 1.05 : 1.12;
        this.range = (team === 'enemy') ? 42 : 46;

        this.isVeteran = false;
        this.slowTimer = 0;

        this.createMesh();
        this.createHealthBar();
      }

      colorHex() {
        if (this.team === 'player') return 0x00ffff;
        if (this.team === 'ally') return 0x00ff88;
        return 0xff0000;
      }

      createMesh() {
        this.group = new THREE.Group();

        const hullGeom = new THREE.BoxGeometry(3, 1, 6);
        const color = this.colorHex();
        const hullMat = new THREE.MeshStandardMaterial({
          color,
          emissive: color,
          emissiveIntensity: 0.3,
          metalness: 0.7,
          roughness: 0.3
        });
        this.hull = new THREE.Mesh(hullGeom, hullMat);
        this.hull.position.y = 0.5;
        this.hull.castShadow = true;
        this.group.add(this.hull);

        const deckGeom = new THREE.BoxGeometry(2.5, 0.2, 5.5);
        const deckMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const deck = new THREE.Mesh(deckGeom, deckMat);
        deck.position.y = 1.1;
        this.group.add(deck);

        const mastGeom = new THREE.CylinderGeometry(0.15, 0.15, 8);
        const mastMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
        const mast = new THREE.Mesh(mastGeom, mastMat);
        mast.position.y = 5;
        this.group.add(mast);

        const sailGeom = new THREE.PlaneGeometry(3, 5);
        const sailMat = new THREE.MeshStandardMaterial({
          color: (this.team === 'enemy') ? 0xff6666 : (this.team === 'ally' ? 0x88ffcc : 0xffffff),
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide
        });
        const sail = new THREE.Mesh(sailGeom, sailMat);
        sail.position.set(1.5, 5, 0);
        this.group.add(sail);

        this.group.position.copy(this.position);
        scene.add(this.group);
      }

      createHealthBar() {
        const barWidth = 3;
        const barHeight = 0.3;

        const barGeom = new THREE.PlaneGeometry(barWidth, barHeight);
        this.barBg = new THREE.Mesh(barGeom, new THREE.MeshBasicMaterial({ color: 0x220000 }));
        this.barBg.position.y = 8;
        this.group.add(this.barBg);

        const healthGeom = new THREE.PlaneGeometry(barWidth, barHeight);
        const col = (this.team === 'enemy') ? 0xff0000 : 0x00ff00;
        this.healthBar = new THREE.Mesh(healthGeom, new THREE.MeshBasicMaterial({ color: col }));
        this.healthBar.position.y = 8;
        this.healthBar.position.z = 0.01;
        this.group.add(this.healthBar);
      }

      updateHealthBar() {
        const hp = clamp01(this.health / this.maxHealth);
        this.healthBar.scale.x = hp;
        this.healthBar.position.x = -1.5 * (1 - hp);
        this.barBg.lookAt(camera.position);
        this.healthBar.lookAt(camera.position);
      }

      addKill() {
        this.kills++;
        this.experience += 10;

        this.scale = Math.min(2.0, 1.0 + (this.kills * 0.08));
        this.group.scale.set(this.scale, this.scale, this.scale);

        this.maxHealth = 100 + (this.kills * 18);
        this.health = Math.min(this.health + 18, this.maxHealth);

        if (!this.isVeteran && this.team === 'ally' && this.kills >= 2) {
          this.isVeteran = true;
          // veteran upgrade
          this.baseDamage += 6;
          this.baseFireRate = Math.max(380, this.baseFireRate - 180);
          this.projSpeed += 0.18;
          this.maxSpeed += 0.05;

          logMemory(`üü¢ Veteran Ally Online! (kills=${this.kills})`);
        }
      }

      getNearTowerSupport() {
        if (this.team !== 'ally') return 0;
        const towers = gameState.playerTowers;
        if (towers.length === 0) return 0;
        let best = 0;
        for (let i = 0; i < towers.length; i++) {
          const d = this.position.distanceTo(towers[i].position);
          if (d < 35) best = Math.max(best, (35 - d) / 35);
        }
        return best; // 0..1
      }

      avoidShallowWater(out) {
        out.set(0,0,0);
        let count = 0;
        for (let i = 0; i < gameState.islands.length; i++) {
          const island = gameState.islands[i];
          if (island.isInShallowWater(this.position)) {
            out.add(V3F.copy(this.position).sub(island.position).normalize());
            count++;
          }
        }
        if (count > 0) {
          out.divideScalar(count).normalize().multiplyScalar(this.maxSpeed);
          out.sub(this.velocity).clampLength(0, this.maxForce * 2.0);
        }
        return out;
      }

      separate(neighbors, desiredDist, out) {
        out.set(0,0,0);
        let count = 0;
        const dd = desiredDist * desiredDist;
        for (let i = 0; i < neighbors.length; i++) {
          const other = neighbors[i];
          if (other === this) continue;
          const dx = this.position.x - other.position.x;
          const dz = this.position.z - other.position.z;
          const d2 = dx*dx + dz*dz;
          if (d2 > 0 && d2 < dd) {
            const inv = 1 / Math.sqrt(d2);
            out.x += dx * inv;
            out.z += dz * inv;
            count++;
          }
        }
        if (count > 0) {
          out.multiplyScalar(1 / count).normalize().multiplyScalar(this.maxSpeed);
          out.sub(this.velocity).clampLength(0, this.maxForce);
        }
        return out;
      }

      seek(targetPos, weight, out) {
        out.copy(targetPos).sub(this.position);
        if (out.lengthSq() < 1e-6) return out.set(0,0,0);
        out.normalize().multiplyScalar(this.maxSpeed);
        out.sub(this.velocity).clampLength(0, this.maxForce).multiplyScalar(weight);
        return out;
      }

      // AI steering for ally
      steerAlly(delta, playerShip) {
        this.acceleration.set(0,0,0);

        // nearby enemies
        const near = gameState.grid.queryRadius(this.position, 70, gameState.neighborScratch);
        let nearestEnemy = null;
        let nearestD2 = Infinity;
        let weakestEnemy = null;
        let weakestHp = Infinity;

        for (let i = 0; i < near.length; i++) {
          const s = near[i];
          if (s.team !== 'enemy') continue;
          const dx = s.position.x - this.position.x;
          const dz = s.position.z - this.position.z;
          const d2 = dx*dx + dz*dz;
          if (d2 < nearestD2) { nearestD2 = d2; nearestEnemy = s; }
          if (s.health < weakestHp && d2 < 60*60) { weakestHp = s.health; weakestEnemy = s; }
        }

        const support = this.getNearTowerSupport();
        const underThreat = nearestEnemy && nearestD2 < 45*45;

        // doctrine
        const towerW = veteranDoctrine.towerAffinity;
        const distW  = veteranDoctrine.distanceDiscipline;
        const aggrW  = veteranDoctrine.aggression;
        const focusW = veteranDoctrine.focusFire;
        const kiteW  = veteranDoctrine.kiting;

        // follow player baseline
        V3A.copy(playerShip.position).addScaledVector(playerShip.velocity, 18);
        this.acceleration.add(this.seek(V3A, 0.75, V3B));

        // separation (avoid crowding)
        const friends = gameState.grid.queryRadius(this.position, 18, gameState.neighborScratch);
        this.acceleration.add(this.separate(friends, 7.5, V3C).multiplyScalar(1.25));

        // shallow avoid
        this.acceleration.add(this.avoidShallowWater(V3D).multiplyScalar(2.0));

        if (underThreat) {
          // choose target
          const target = (Math.random() < focusW && weakestEnemy) ? weakestEnemy : nearestEnemy;

          // keep distance / strafe-ish
          const desired = 26 + distW * 14; // 26..40
          const d = Math.sqrt(nearestD2);
          if (d < desired) {
            // back off
            V3E.copy(this.position).sub(target.position).setY(0).normalize();
            V3E.multiplyScalar(this.maxForce * (1.2 + distW));
            this.acceleration.add(V3E);
          } else if (d > desired + 10) {
            // approach a bit
            this.acceleration.add(this.seek(target.position, 0.35 + aggrW*0.5, V3E));
          }

          // kite towards towers if veteran and towers exist
          if (this.isVeteran && gameState.playerTowers.length > 0 && kiteW > 0.2) {
            let bestTower = null;
            let bestScore = -Infinity;
            for (let i = 0; i < gameState.playerTowers.length; i++) {
              const t = gameState.playerTowers[i];
              const dt = this.position.distanceTo(t.position);
              // prefer closer towers (and stronger when threatened)
              const score = (1 / (1 + dt)) + support*0.25;
              if (score > bestScore) { bestScore = score; bestTower = t; }
            }
            if (bestTower) {
              // move toward tower but not directly on it
              V3F.copy(bestTower.position).sub(this.position).setY(0);
              if (V3F.lengthSq() > 1e-6) {
                V3F.normalize();
                // small lateral offset to create kiting arcs
                const perpX = -V3F.z, perpZ = V3F.x;
                V3G.set(perpX, 0, perpZ).multiplyScalar(10 + kiteW*14);
                V3A.copy(bestTower.position).add(V3G);
                this.acceleration.add(this.seek(V3A, 0.35 + towerW*0.55, V3B));
              }
            }
          }
        } else {
          // regroup
          this.acceleration.add(this.seek(playerShip.position, 0.25, V3E));
        }

        this.acceleration.clampLength(0, this.maxForce * 2.5);
      }

      // AI steering for enemy (hunt player)
      steerEnemy(delta, playerShip) {
        this.acceleration.set(0,0,0);

        // pursue player with slight prediction
        V3A.copy(playerShip.position).addScaledVector(playerShip.velocity, 26);
        this.acceleration.add(this.seek(V3A, 1.0, V3B));

        // separation among enemies
        const neigh = gameState.grid.queryRadius(this.position, 16, gameState.neighborScratch);
        this.acceleration.add(this.separate(neigh, 7.0, V3C).multiplyScalar(1.2));

        // shallow avoid
        this.acceleration.add(this.avoidShallowWater(V3D).multiplyScalar(2.2));

        this.acceleration.clampLength(0, this.maxForce * 2.6);
      }

      tryFireShip(target) {
        if (!target) return;
        if (this.fireCooldown > 0) return;

        const dx = target.position.x - this.position.x;
        const dz = target.position.z - this.position.z;
        const d2 = dx*dx + dz*dz;
        if (d2 > this.range*this.range) return;

        const support = (this.team === 'ally' && this.isVeteran) ? this.getNearTowerSupport() : 0;
        const fireRate = this.baseFireRate * (1 - support * 0.35);
        const damage = this.baseDamage * (1 + support * 0.35);

        this.fireCooldown = fireRate;

        const from = V3A.copy(this.position).setY(3);
        const proj = allocProjectile();
        proj.owner = (this.team === 'enemy') ? 'ai' : 'player'; // for damage routing
        proj.sourceType = 'ship';
        proj.damage = damage;
        proj.slow = 0;
        proj.ttl = 3.0;
        proj.targetRef = target;

        const dir = leadDirection(from, target.position, target.velocity, this.projSpeed, V3B);
        proj.position.copy(from);
        proj.velocity.copy(dir).multiplyScalar(this.projSpeed);

        setProjectileMesh(proj, 'shipshot', proj.owner);
        proj.mesh.position.copy(proj.position);
        scene.add(proj.mesh);
        gameState.projectiles.push(proj);
      }

      update(delta, playerShip) {
        // slow effects
        if (this.slowTimer > 0) {
          this.slowTimer -= delta;
          if (this.slowTimer < 0) this.slowTimer = 0;
        }

        // shallow water
        let inShallow = false;
        for (let i = 0; i < gameState.islands.length; i++) {
          if (gameState.islands[i].isInShallowWater(this.position)) { inShallow = true; break; }
        }

        const slowFactor = (this.slowTimer > 0) ? 0.55 : 1.0;

        if (this.team === 'enemy' || this.team === 'ally') {
          if (inShallow) {
            // take damage if AI hits shallow
            this.health -= (this.team === 'enemy') ? 1.8 : 1.0;
            if (this.health <= 0) return false;
          }
        } else {
          // player ship slows in shallow
          if (inShallow) this.velocity.multiplyScalar(0.92);
        }

        // AI steering
        if (this.team === 'ally') this.steerAlly(delta, playerShip);
        else if (this.team === 'enemy') this.steerEnemy(delta, playerShip);

        // integrate
        if (this.team !== 'player') {
          this.velocity.addScaledVector(this.acceleration, 1.0);
        }
        this.velocity.clampLength(0, this.maxSpeed * slowFactor);
        this.position.addScaledVector(this.velocity, 1.0);
        this.velocity.multiplyScalar(0.955);

        // bounds
        this.position.x = Math.max(-200, Math.min(200, this.position.x));
        this.position.z = Math.max(-200, Math.min(200, this.position.z));

        if (this.velocity.lengthSq() > 0.0004) {
          this.rotation = Math.atan2(this.velocity.x, this.velocity.z);
        }

        this.group.position.copy(this.position);
        this.group.rotation.y = this.rotation;

        if (this.buildCooldown > 0) this.buildCooldown = Math.max(0, this.buildCooldown - delta*1000);
        if (this.fireCooldown > 0) this.fireCooldown = Math.max(0, this.fireCooldown - delta*1000);

        this.updateHealthBar();
        return true;
      }

      remove() { scene.remove(this.group); }
    }

    // =========================
    // ISLAND GENERATION
    // =========================
    const islandNames = [
      "Port Authority", "Logistics Hub", "Trade Station", "Cargo Terminal",
      "Supply Depot", "Distribution Center", "Freight Island", "Commerce Bay",
      "Industrial Sector", "Transport Node", "Shipping Central", "Warehouse Bay",
      "Loading Zone", "Container Port", "Maritime Junction", "Bulk Terminal"
    ];

    function createIslandCluster(centerX, centerZ, clusterSize, islandCount) {
      const cellSize = 15;
      const occupied = new Set();
      for (let i = 0; i < islandCount; i++) {
        let attempts = 0;
        let placed = false;
        while (!placed && attempts < 20) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * clusterSize;
          const x = centerX + Math.cos(angle) * distance;
          const z = centerZ + Math.sin(angle) * distance;
          const cellX = Math.floor(x / cellSize);
          const cellZ = Math.floor(z / cellSize);
          const key = cellX + "," + cellZ;
          if (!occupied.has(key)) {
            occupied.add(key);
            const size = 5 + Math.random() * 4;
            const depth = Math.floor(2 + Math.random() * 2);
            const island = new ProceduralIsland(x, z, size, islandNames[gameState.islands.length % islandNames.length], depth);
            gameState.islands.push(island);
            placed = true;
          }
          attempts++;
        }
      }
    }

    createIslandCluster(0, 0, 40, 4);
    createIslandCluster(-80, -60, 35, 3);
    createIslandCluster(70, -50, 30, 3);
    createIslandCluster(-50, 80, 32, 2);
    createIslandCluster(60, 70, 35, 3);
    createIslandCluster(-100, 20, 25, 2);

    // =========================
    // INPUT + RAYCAST (TOWERS)
    // =========================
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'KeyE' && gameState.selectedTower) {
        const ps = gameState.playerShips[0];
        if (ps) tryPlaceTower(ps.position, gameState.selectedTower, false, null);
      }
    });
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (event) => {
      if (!gameState.selectedTower) return;
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(gameState.islands.map(i => i.mesh));
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        if (!obj.userData || !obj.userData.island) return;
        const island = obj.userData.island;
        const pos = intersects[0].point;
        pos.y = 3;
        tryPlaceTower(pos, gameState.selectedTower, false, island);
      }
    });

    function tryPlaceTower(position, towerType, isAI, island = null) {
      const towerCosts = { cannon: 100, harpoon: 150, net: 200, lighthouse: 300 };
      const cost = towerCosts[towerType];

      if (isAI) {
        const builder = gameState.enemyShips.find(s => s.buildCooldown === 0 && s.gold >= cost);
        if (!builder) return false;

        builder.gold -= cost;
        builder.buildCooldown = 3000;

        const tower = new Tower(position, towerType, 'ai');
        gameState.aiTowers.push(tower);
        if (island && island.towers) island.towers.push(tower);

        logMemory(`üî¥ Hostiles built ${towerType} (copied)`);

        return true;
      } else {
        if (gameState.gold < cost) {
          logMemory(`Insufficient credits: need $${cost}, have $${gameState.gold}`);
          return false;
        }
        gameState.gold -= cost;

        const tower = new Tower(position, towerType, 'player');
        gameState.playerTowers.push(tower);
        if (island && island.towers) island.towers.push(tower);

        if (island) {
          const effectiveness = Math.random() * 0.3 + 0.7;
          aiMemory.recordPlacement(island, towerType, effectiveness);
        }

        logMemory(`Built ${towerType} tower for $${cost}`);
        return true;
      }
    }

    function updateAIBuilding() {
      if (!gameState.aiBuildEnabled) return;
      // hostile building (optional) uses learned placement patterns
      for (let i = 0; i < gameState.enemyShips.length; i++) {
        const s = gameState.enemyShips[i];
        if (s.buildCooldown > 0 || s.gold < 100) continue;

        const bestIslands = aiMemory.getBestIslands();
        let targetIsland = null;
        if (bestIslands.length > 0) {
          const name = bestIslands[(Math.random() * bestIslands.length) | 0];
          targetIsland = gameState.islands.find(x => x.name === name);
        }
        if (!targetIsland) targetIsland = gameState.islands[(Math.random() * gameState.islands.length) | 0];
        if (!targetIsland) continue;

        const bestTower = aiMemory.getBestTowerForIsland(targetIsland);
        const offset = V3A.set((Math.random()-0.5) * targetIsland.size * 0.6, 0, (Math.random()-0.5) * targetIsland.size * 0.6);
        const towerPos = V3B.copy(targetIsland.position).add(offset);
        towerPos.y = 3;

        tryPlaceTower(towerPos, bestTower, true, targetIsland);
      }
    }

    // =========================
    // COMBAT
    // =========================
    function findNearestEnemyFor(ship) {
      // Focus fire on weak targets according to doctrine (allies)
      const near = gameState.grid.queryRadius(ship.position, ship.range, gameState.neighborScratch);
      let nearest = null;
      let nearestD2 = Infinity;

      let weakest = null;
      let weakestHp = Infinity;

      for (let i = 0; i < near.length; i++) {
        const s = near[i];
        if (ship.team === 'enemy') {
          if (s.team !== 'player' && s.team !== 'ally') continue;
        } else {
          if (s.team !== 'enemy') continue;
        }
        const dx = s.position.x - ship.position.x;
        const dz = s.position.z - ship.position.z;
        const d2 = dx*dx + dz*dz;
        if (d2 < nearestD2) { nearestD2 = d2; nearest = s; }
        if (ship.team === 'ally' && Math.random() < veteranDoctrine.focusFire && s.health < weakestHp) {
          weakestHp = s.health;
          weakest = s;
        }
      }
      if (ship.team === 'ally' && ship.isVeteran && weakest) return weakest;
      return nearest;
    }

    function updateCombat(delta) {
      const playerShip = gameState.playerShips[0];
      if (!playerShip) return;

      // towers -> ships
      for (let i = 0; i < gameState.playerTowers.length; i++) {
        const t = gameState.playerTowers[i];
        // pick nearest enemy in range (fast scan over enemies only)
        let target = null;
        let bestD2 = Infinity;
        for (let j = 0; j < gameState.enemyShips.length; j++) {
          const e = gameState.enemyShips[j];
          const dx = e.position.x - t.position.x;
          const dz = e.position.z - t.position.z;
          const d2 = dx*dx + dz*dz;
          if (d2 < t.range*t.range && d2 < bestD2) { bestD2 = d2; target = e; }
        }
        if (target) t.fire(target);
      }

      for (let i = 0; i < gameState.aiTowers.length; i++) {
        const t = gameState.aiTowers[i];
        // target player + allies
        let target = null;
        let bestD2 = Infinity;
        const friendlies = [playerShip, ...gameState.allyShips];
        for (let j = 0; j < friendlies.length; j++) {
          const f = friendlies[j];
          const dx = f.position.x - t.position.x;
          const dz = f.position.z - t.position.z;
          const d2 = dx*dx + dz*dz;
          if (d2 < t.range*t.range && d2 < bestD2) { bestD2 = d2; target = f; }
        }
        if (target) t.fire(target);
      }

      // ship guns (self-defense)
      // allies auto-fire; enemies auto-fire; player auto-fire if holding Space
      if (keys['Space']) {
        const tgt = findNearestEnemyFor(playerShip);
        playerShip.tryFireShip(tgt);
      }
      for (let i = 0; i < gameState.allyShips.length; i++) {
        const a = gameState.allyShips[i];
        const tgt = findNearestEnemyFor(a);
        a.tryFireShip(tgt);
      }
      for (let i = 0; i < gameState.enemyShips.length; i++) {
        const e = gameState.enemyShips[i];
        // prioritize player if in range, else nearest friendly
        let tgt = null;
        const dxp = playerShip.position.x - e.position.x;
        const dzp = playerShip.position.z - e.position.z;
        if (dxp*dxp + dzp*dzp <= e.range*e.range) tgt = playerShip;
        else tgt = findNearestEnemyFor(e);
        e.tryFireShip(tgt);
      }

      // update projectiles (backward loop)
      for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
        const p = gameState.projectiles[i];
        p.ttl -= delta;
        p.position.addScaledVector(p.velocity, 1.0);
        if (p.mesh) p.mesh.position.copy(p.position);

        if (p.ttl <= 0) {
          gameState.projectiles.splice(i, 1);
          freeProjectile(p);
          continue;
        }

        const target = p.targetRef;
        if (target && target.health > 0) {
          const dx = target.position.x - p.position.x;
          const dz = target.position.z - p.position.z;
          const d2 = dx*dx + dz*dz;
          if (d2 < 2.2*2.2) {
            // impact
            target.health -= p.damage;

            if (p.slow && target.team !== 'player') {
              target.slowTimer = Math.max(target.slowTimer, 1.2);
            }

            // doctrine learning signals (global)
            if (target.team === 'ally' && p.owner === 'ai') {
              veteranDoctrine.towerAffinity = clamp01(veteranDoctrine.towerAffinity + 0.012);
              veteranDoctrine.distanceDiscipline = clamp01(veteranDoctrine.distanceDiscipline + 0.010);
              veteranDoctrine.kiting = clamp01(veteranDoctrine.kiting + 0.008);
            }
            if ((target.team === 'player' || target.team === 'ally') && p.owner === 'ai') {
              veteranDoctrine.focusFire = clamp01(veteranDoctrine.focusFire + 0.006);
            }

            // remove projectile
            gameState.projectiles.splice(i, 1);
            freeProjectile(p);

            // death
            if (target.health <= 0) {
              onShipDestroyed(target, p.owner);
            }
          }
        } else {
          // no target: cull if too far
          if (p.position.lengthSq() > 320*320) {
            gameState.projectiles.splice(i, 1);
            freeProjectile(p);
          }
        }
      }
    }

    function onShipDestroyed(ship, killerOwner) {
      // killerOwner: 'player' or 'ai'
      if (ship.team === 'enemy') {
        // enemy down
        ship.remove();
        const idx = gameState.enemyShips.indexOf(ship);
        if (idx >= 0) gameState.enemyShips.splice(idx, 1);

        gameState.score += 120;
        gameState.gold += 55;

        // nearest ally/player gets veterancy credit
        let nearest = null;
        let bestD2 = Infinity;
        const friendlies = [gameState.playerShips[0], ...gameState.allyShips].filter(Boolean);
        for (let i = 0; i < friendlies.length; i++) {
          const f = friendlies[i];
          const dx = ship.position.x - f.position.x;
          const dz = ship.position.z - f.position.z;
          const d2 = dx*dx + dz*dz;
          if (d2 < bestD2) { bestD2 = d2; nearest = f; }
        }
        if (nearest && bestD2 < 70*70) nearest.addKill();

        // doctrine: successful kill -> more aggression + focus fire
        veteranDoctrine.aggression = clamp01(veteranDoctrine.aggression + 0.010);
        veteranDoctrine.focusFire = clamp01(veteranDoctrine.focusFire + 0.008);

      } else if (ship.team === 'ally') {
        ship.remove();
        const idx = gameState.allyShips.indexOf(ship);
        if (idx >= 0) gameState.allyShips.splice(idx, 1);
        logMemory('üü¢ Ally ship destroyed!');
        // doctrine: become more tower-bound
        veteranDoctrine.towerAffinity = clamp01(veteranDoctrine.towerAffinity + 0.020);
        veteranDoctrine.distanceDiscipline = clamp01(veteranDoctrine.distanceDiscipline + 0.015);

      } else if (ship.team === 'player') {
        ship.remove();
        gameState.playerShips.length = 0;
        logMemory('‚ö†Ô∏è Player ship destroyed!');
      }
    }

    // =========================
    // UPDATE LOOP (MOVEMENT + GRID)
    // =========================
    function rebuildGrid() {
      gameState.grid.clear();
      if (gameState.playerShips[0]) gameState.grid.insert(gameState.playerShips[0]);
      for (let i = 0; i < gameState.allyShips.length; i++) gameState.grid.insert(gameState.allyShips[i]);
      for (let i = 0; i < gameState.enemyShips.length; i++) gameState.grid.insert(gameState.enemyShips[i]);
    }

    function updateShipMovement(delta) {
      const ps = gameState.playerShips[0];
      if (!ps) return;

      const speed = keys['ShiftLeft'] ? 0.85 : 0.45;

      if (!gameState.selfPlayMode) {
        if (keys['KeyW']) ps.velocity.z -= speed;
        if (keys['KeyS']) ps.velocity.z += speed;
        if (keys['KeyA']) ps.velocity.x -= speed;
        if (keys['KeyD']) ps.velocity.x += speed;
      } else {
        // simple autopilot for player in self-play
        ps.velocity.x += (Math.sin(performance.now()*0.001) * 0.04);
        ps.velocity.z += (Math.cos(performance.now()*0.0012) * 0.04);
      }

      // player update (no AI steer)
      ps.velocity.clampLength(0, ps.maxSpeed);
      ps.position.addScaledVector(ps.velocity, 1.0);
      ps.velocity.multiplyScalar(0.955);
      ps.position.x = Math.max(-200, Math.min(200, ps.position.x));
      ps.position.z = Math.max(-200, Math.min(200, ps.position.z));
      if (ps.velocity.lengthSq() > 0.0004) ps.rotation = Math.atan2(ps.velocity.x, ps.velocity.z);
      ps.group.position.copy(ps.position);
      ps.group.rotation.y = ps.rotation;
      if (ps.fireCooldown > 0) ps.fireCooldown = Math.max(0, ps.fireCooldown - delta*1000);
      ps.updateHealthBar();

      // rebuild grid after player move
      rebuildGrid();

      // allies
      for (let i = gameState.allyShips.length - 1; i >= 0; i--) {
        const a = gameState.allyShips[i];
        if (!a.update(delta, ps)) {
          a.remove();
          gameState.allyShips.splice(i, 1);
        }
      }

      // enemies
      for (let i = gameState.enemyShips.length - 1; i >= 0; i--) {
        const e = gameState.enemyShips[i];
        if (!e.update(delta, ps)) {
          e.remove();
          gameState.enemyShips.splice(i, 1);
        }
      }
    }

    function updateCamera() {
      const ps = gameState.playerShips[0];
      if (!ps) return;
      const targetPos = V3A.copy(ps.position);
      targetPos.y += 40;
      targetPos.z += 60;
      camera.position.lerp(targetPos, 0.05);
      camera.lookAt(ps.position);
    }

    // =========================
    // UI
    // =========================
    function updateUI() {
      document.getElementById('gold').textContent = '$' + gameState.gold;
      document.getElementById('fleet-size').textContent = (gameState.playerShips.length + gameState.allyShips.length);
      document.getElementById('ai-ships').textContent = gameState.enemyShips.length;
      document.getElementById('player-towers').textContent = gameState.playerTowers.length;
      document.getElementById('ai-towers').textContent = gameState.aiTowers.length;
      document.getElementById('score').textContent = gameState.score;

      if (gameState.playerShips[0]) {
        const form = gameState.playerShips[0].form;
        document.getElementById('current-form').textContent = (form === 'ship') ? 'NAVAL CARGO' : 'GROUND TRANSPORT';
      }

      const friendlyPower = gameState.playerTowers.length * 10 + (gameState.playerShips.length + gameState.allyShips.length) * 22;
      const hostilePower  = gameState.aiTowers.length * 10 + gameState.enemyShips.length * 24;
      const total = friendlyPower + hostilePower || 1;

      document.getElementById('player-power').style.width = `${(friendlyPower / total) * 100}%`;
      document.getElementById('ai-power').style.width = `${(hostilePower / total) * 100}%`;

      document.getElementById('battles-won').textContent = gameState.battlesWon;
      document.getElementById('battles-total').textContent = gameState.battlesTotal;

      document.querySelectorAll('.tower-btn').forEach(btn => {
        const cost = parseInt(btn.dataset.cost, 10);
        btn.classList.toggle('disabled', gameState.gold < cost);
      });

      updateBlueLineKnowledge();
    }

    function updateBlueLineKnowledge() {
      const list = document.getElementById('knowledge-list');
      list.innerHTML = '';

      const rows = [
        ['üóº Tower Affinity', veteranDoctrine.towerAffinity],
        ['‚ÜîÔ∏è Distance Discipline', veteranDoctrine.distanceDiscipline],
        ['‚öîÔ∏è Aggression', veteranDoctrine.aggression],
        ['üéØ Focus Fire', veteranDoctrine.focusFire],
        ['ü™§ Kiting', veteranDoctrine.kiting]
      ];

      for (let i = 0; i < rows.length; i++) {
        const div = document.createElement('div');
        div.style.cssText = 'margin: 3px 0; padding: 3px; background: rgba(0, 100, 150, 0.3); border-left: 2px solid #0ff;';
        div.innerHTML = `${rows[i][0]}: <span style="color:#0f0;">${Math.round(rows[i][1]*100)}%</span>`;
        list.appendChild(div);
      }

      const hint = document.createElement('div');
      hint.style.cssText = 'margin-top: 8px; color: #999; font-style: italic;';
      hint.textContent = 'Tip: Hold SPACE to fire from your ship.';
      list.appendChild(hint);
    }

    // =========================
    // CONTROLS
    // =========================
    document.getElementById('spawn-fleet').addEventListener('click', () => {
      const ps = gameState.playerShips[0];
      if (!ps) return;

      gameState.wave++;
      const wave = gameState.wave;

      // +1 allied agent ship (spawns behind player)
      {
        const ang = Math.atan2(ps.velocity.x, ps.velocity.z) + Math.PI + (Math.random()-0.5)*0.5;
        const r = 14 + Math.random() * 6;
        const ax = ps.position.x + Math.sin(ang) * r;
        const az = ps.position.z + Math.cos(ang) * r;
        const ally = new NavalShip(ax, az, 'ally');
        ally.health = Math.min(120, ally.health + wave*3);
        ally.maxHealth = Math.min(120, ally.maxHealth + wave*3);
        gameState.allyShips.push(ally);
      }

      // +5 enemies (spawn in ring and hunt player)
      for (let i = 0; i < 5; i++) {
        const ang = (Math.PI * 2 * i) / 5 + (Math.random()-0.5)*0.3;
        const r = 70 + Math.random() * 18;
        const ex = ps.position.x + Math.cos(ang) * r;
        const ez = ps.position.z + Math.sin(ang) * r;
        const enemy = new NavalShip(ex, ez, 'enemy');
        enemy.maxHealth = 95 + wave * 6;
        enemy.health = enemy.maxHealth;
        enemy.baseDamage = 10 + wave * 0.6;
        enemy.maxSpeed = 0.52 + Math.min(0.12, wave * 0.01);
        gameState.enemyShips.push(enemy);
      }

      logMemory(`üåä Wave ${wave}: +1 Ally Agent / +5 Hostiles (hunting player)`);

      if (!gameState.battleActive) {
        gameState.battleActive = true;
        document.getElementById('battle-status').textContent = 'ACTIVE';
        document.getElementById('start-battle').classList.add('active');
      }
    });

    document.getElementById('start-battle').addEventListener('click', () => {
      gameState.battleActive = !gameState.battleActive;
      gameState.battlesTotal++;
      if (gameState.battleActive) {
        logMemory('‚öîÔ∏è COMBAT MODE ACTIVATED');
        document.getElementById('battle-status').textContent = 'ACTIVE';
        document.getElementById('start-battle').classList.add('active');
      } else {
        logMemory('Combat mode deactivated');
        document.getElementById('battle-status').textContent = 'STANDBY';
        document.getElementById('start-battle').classList.remove('active');
        if (gameState.enemyShips.length === 0 && gameState.playerShips.length > 0) {
          gameState.battlesWon++;
          logMemory('üèÜ MISSION SUCCESSFUL!');
        }
      }
    });

    document.getElementById('toggle-ai-build').addEventListener('click', () => {
      gameState.aiBuildEnabled = !gameState.aiBuildEnabled;
      document.getElementById('ai-build-status').textContent = gameState.aiBuildEnabled ? 'ON' : 'OFF';
      if (gameState.aiBuildEnabled) {
        logMemory('üèóÔ∏è Hostile Construction Active - Copying your tower patterns...');
        document.getElementById('toggle-ai-build').classList.add('active');
      } else {
        document.getElementById('toggle-ai-build').classList.remove('active');
      }
    });

    document.getElementById('self-play').addEventListener('click', () => {
      gameState.selfPlayMode = !gameState.selfPlayMode;
      document.getElementById('self-play-status').textContent = gameState.selfPlayMode ? 'ON' : 'OFF';

      if (gameState.selfPlayMode) {
        logMemory('ü§ñ Auto-Simulation Mode Active');
        document.getElementById('self-play').classList.add('active');

        if (!gameState.battleActive) document.getElementById('start-battle').click();

        if (gameState.selfPlayInterval) clearInterval(gameState.selfPlayInterval);
        gameState.selfPlayInterval = setInterval(() => {
          // keep pressure: add wave if enemies too low
          if (gameState.enemyShips.length < 4) document.getElementById('spawn-fleet').click();
          // small passive doctrine drift
          veteranDoctrine.aggression = clamp01(veteranDoctrine.aggression + 0.002);
        }, 4500);

      } else {
        logMemory('Self-play disabled');
        document.getElementById('self-play').classList.remove('active');
        if (gameState.selfPlayInterval) {
          clearInterval(gameState.selfPlayInterval);
          gameState.selfPlayInterval = null;
        }
      }
    });

    document.getElementById('transform-ship').addEventListener('click', () => {
      const ps = gameState.playerShips[0];
      if (ps) { ps.form = 'ship'; logMemory('üì¶ Switched to Naval Cargo Mode'); }
    });

    document.getElementById('transform-car').addEventListener('click', () => {
      const ps = gameState.playerShips[0];
      if (ps) { ps.form = 'car'; logMemory('üöõ Switched to Ground Transport Mode'); }
    });

    document.querySelectorAll('.tower-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const towerType = btn.dataset.tower;
        const cost = parseInt(btn.dataset.cost, 10);
        if (gameState.gold >= cost) {
          gameState.selectedTower = towerType;
          document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
        }
      });
    });

    // Passive income
    setInterval(() => {
      if (gameState.battleActive) {
        gameState.gold += 10;
        for (let i = 0; i < gameState.enemyShips.length; i++) gameState.enemyShips[i].gold += 16;
      }
    }, 2000);

    // =========================
    // INIT
    // =========================
    const playerShip = new NavalShip(0, 0, 'player');
    gameState.playerShips.push(playerShip);

    // initial grid
    rebuildGrid();

    logMemory('üåä Maritime AI Commander Online');
    logMemory('‚ûï Click "Wave" to add +1 Ally and +5 Enemies');
    logMemory('üóº Build towers on islands. Hold SPACE to fire.');

    // =========================
    // MAIN LOOP
    // =========================
    let lastTime = performance.now();
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const delta = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;

      animateWater();
      updateShipMovement(delta);
      updateCamera();

      if (gameState.battleActive) updateCombat(delta);
      if (gameState.aiBuildEnabled) updateAIBuilding();

      updateUI();
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
