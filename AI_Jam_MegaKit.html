<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ScifiKin: Battle Realms â€” Procedural Fighters + Armor Layers</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body{font-family:'Orbitron',sans-serif;background:#0c0a1e;color:#e0e0e0;margin:0;overflow:hidden}
    .text-glow{text-shadow:0 0 5px #fff,0 0 10px #fff,0 0 15px #ff00ff,0 0 20px #ff00ff}
    .btn-glow{box-shadow:0 0 5px #00ffff,0 0 10px #00ffff;transition:all .3s}
    .btn-glow:hover{box-shadow:0 0 10px #ff00ff,0 0 20px #ff00ff;transform:translateY(-2px)}
    .modal{background:rgba(12,10,30,.95);border:2px solid #ff00ff}
    canvas{background-image:url('https://www.transparenttextures.com/patterns/stardust.png');background-color:#0f0f1f;cursor:crosshair}
    .character-card{border:2px solid #4f4f4f;transition:all .3s}
    .character-card.selected{border-color:#ff00ff;box-shadow:0 0 15px #ff00ff}
    .powerup-toast{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);padding:8px 16px;border-radius:8px;color:#000;font-weight:bold;z-index:100;opacity:0;transition:opacity .5s,bottom .5s}
    #game-ui{position:absolute;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;align-items:flex-start;z-index:10;pointer-events:none}
    .ui-panel{background:rgba(0,0,0,.7);border:2px solid #4f4f4f;border-radius:8px;padding:12px;backdrop-filter:blur(10px);pointer-events:auto}
    .health-section h3,.ability-section h3{font-size:1.1rem;margin-bottom:8px;text-shadow:0 0 5px currentColor}
    .bar{width:140px;height:12px;background:rgba(75,75,75,.8);border:1px solid #666;border-radius:6px;overflow:hidden;margin-top:4px}
    .fill{height:100%;transition:width .2s}
    .wave-score{text-align:center;background:rgba(0,0,0,.7);border:2px solid #ff00ff;border-radius:8px;padding:12px 18px;backdrop-filter:blur(10px);pointer-events:auto}
    .wave-score p{margin:4px 0;font-size:1.05rem}
    .tiny{font-size:12px;color:#b9b9ff}
  </style>
</head>
<body>
<div id="game-container" class="w-screen h-screen relative">
  <!-- START SCREEN -->
  <div id="start-screen" class="text-center w-full h-full flex flex-col items-center justify-center p-4">
    <h1 class="text-4xl md:text-6xl font-bold text-glow mb-4">SCIFIKIN: BATTLE REALMS</h1>
    <h2 class="text-xl md:text-2xl text-cyan-300 mb-6">PROCEDURAL FIGHTERS â€¢ ARMOR LAYERS â€¢ MAGNET POWERUPS</h2>
    <p class="mb-6 max-w-2xl mx-auto">
      Choose your champion ship. Powerups will SEEK you. Armor layers stack as satellites and must be destroyed before health.
    </p>
    <button id="start-game-btn" class="bg-cyan-500 text-black font-bold py-3 px-8 rounded-lg text-xl btn-glow">Start Quest</button>
  </div>

  <!-- CHARACTER SELECTION -->
  <div id="character-selection-screen" class="hidden text-center w-full h-full flex flex-col items-center justify-center p-4">
    <h2 class="text-4xl font-bold text-glow mb-2">CHOOSE YOUR CHAMPION</h2>
    <p class="mb-4 text-gray-400">Now with: Armor layers, auto-aim option, and powerups that come to you.</p>
    <div id="character-grid" class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6 w-full max-w-4xl"></div>

    <div id="character-details" class="p-4 rounded-lg bg-black bg-opacity-50 min-h-[160px] w-full max-w-4xl">
      <h3 id="char-name" class="text-2xl font-bold text-cyan-300"></h3>
      <p id="char-faction" class="text-lg text-fuchsia-400"></p>
      <p id="char-passive" class="mt-2 text-yellow-300"></p>
      <p id="char-ability" class="mt-2"></p>
      <div class="mt-3 tiny">
        Controls: <b>A/D</b> move â€¢ <b>Click</b> shoot â€¢ <b>Space</b> toggle Auto-Fire â€¢ <b>Q</b> ability
      </div>
    </div>

    <button id="play-game-btn" class="bg-fuchsia-500 text-black font-bold py-3 px-8 rounded-lg text-xl btn-glow mt-6 hidden">Embark!</button>
  </div>

  <!-- GAME SCREEN -->
  <div id="game-screen" class="hidden w-full h-full relative">
    <canvas id="game-canvas" class="w-full h-full"></canvas>

    <div id="game-ui">
      <div class="ui-panel health-section">
        <h3 id="player-name-display" class="text-cyan-400"></h3>

        <div class="flex items-center justify-between">
          <div>
            <div class="tiny">Health</div>
            <div class="bar"><div id="player-health-bar" class="fill bg-green-500" style="width:100%"></div></div>
          </div>
          <div class="ml-3">
            <div class="tiny">Armor</div>
            <div class="bar"><div id="player-armor-bar" class="fill bg-cyan-500" style="width:0%"></div></div>
          </div>
        </div>

        <div class="tiny mt-3">
          Auto-Fire: <span id="autofire-label" class="text-yellow-300 font-bold">OFF</span>
        </div>
      </div>

      <div class="wave-score">
        <p>Score: <span id="score" class="font-bold text-yellow-400">0</span></p>
        <p>Wave: <span id="wave" class="font-bold text-red-400">1</span></p>
      </div>

      <div class="ui-panel ability-section">
        <h3 class="text-fuchsia-400">Q - Ability</h3>
        <div class="bar"><div id="ability-cooldown-bar" class="fill bg-fuchsia-500" style="width:100%"></div></div>
        <div class="tiny mt-2">Powerups magnetize toward you ðŸ§²</div>
      </div>
    </div>
  </div>

  <!-- GAME OVER -->
  <div id="game-over-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
    <div class="modal p-8 rounded-lg text-center max-w-md w-full">
      <h2 class="text-5xl font-bold text-glow text-red-500 mb-4">QUEST FAILED</h2>
      <div id="final-stats">
        <p class="text-2xl mb-2">Final Score: <span id="final-score" class="text-yellow-300"></span></p>
        <p class="text-2xl mb-6">Wave Reached: <span id="final-wave" class="text-red-400"></span></p>
        <button id="restart-game-btn" class="bg-cyan-500 text-black font-bold py-3 px-8 rounded-lg text-xl btn-glow">Try Again</button>
      </div>
    </div>
  </div>

  <div id="powerup-toast-container"></div>
</div>

<!-- ====================== AUDIO ====================== -->
<script>
  let audioCtx;
  const MAX_EXPLOSION_NODES = 8;
  const explosionPool = [];

  function initAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    if(explosionPool.length) return;
    for(let i=0;i<MAX_EXPLOSION_NODES;i++){
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sawtooth';
      gain.gain.setValueAtTime(0, audioCtx.currentTime);
      osc.connect(gain).connect(audioCtx.destination);
      explosionPool.push({osc, gain, free: true});
    }
  }

  function playSound(type, vol=0.3, pitch=1){
    initAudio();
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = type==='shoot'?'square':type==='powerup'?'sine':'triangle';
    osc.frequency.setValueAtTime(
      type==='shoot'?800*pitch:
      type==='hit'?300*pitch:
      type==='powerup'?600*pitch:
      type==='damage'?150*pitch:440, now);

    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(vol, now+0.01);
    const decay = type==='shoot'?0.08:type==='powerup'?0.5:0.2;
    gain.gain.exponentialRampToValueAtTime(0.01, now+decay);

    osc.connect(gain).connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now+decay);
  }

  function playExplosion(vol=0.5, pitch=1){
    initAudio();
    const node = explosionPool.find(n => n.free);
    if(!node) return;

    const {osc, gain} = node;
    node.free = false;
    const now = audioCtx.currentTime;

    osc.frequency.setValueAtTime(200*pitch, now);
    gain.gain.cancelScheduledValues(now);
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(vol, now+0.01);
    gain.gain.exponentialRampToValueAtTime(0.01, now+0.28);

    osc.start(now);
    osc.stop(now+0.28);
    osc.onended = () => { node.free = true; };
  }
</script>

<!-- ====================== GAME ====================== -->
<script>
/* ---------- DOM ---------- */
const startScreen=document.getElementById('start-screen'),
      charSel=document.getElementById('character-selection-screen'),
      gameScreen=document.getElementById('game-screen'),
      gameOver=document.getElementById('game-over-modal'),
      startBtn=document.getElementById('start-game-btn'),
      playBtn=document.getElementById('play-game-btn'),
      restartBtn=document.getElementById('restart-game-btn'),
      charGrid=document.getElementById('character-grid'),
      charName=document.getElementById('char-name'),
      charFaction=document.getElementById('char-faction'),
      charPassive=document.getElementById('char-passive'),
      charAbility=document.getElementById('char-ability'),
      canvas=document.getElementById('game-canvas'),
      scoreEl=document.getElementById('score'),
      waveEl=document.getElementById('wave'),
      playerName=document.getElementById('player-name-display'),
      healthBar=document.getElementById('player-health-bar'),
      armorBar=document.getElementById('player-armor-bar'),
      abilityBar=document.getElementById('ability-cooldown-bar'),
      finalScore=document.getElementById('final-score'),
      finalWave=document.getElementById('final-wave'),
      toastContainer=document.getElementById('powerup-toast-container'),
      autoFireLabel=document.getElementById('autofire-label');

/* ---------- SMALL UTILS ---------- */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;

// deterministic-ish RNG per entity
function mulberry32(seed){
  return function(){
    let t=seed+=0x6D2B79F5;
    t=Math.imul(t^t>>>15,t|1);
    t^=t+Math.imul(t^t>>>7,t|61);
    return ((t^t>>>14)>>>0)/4294967296;
  }
}
function pick(rng, arr){ return arr[Math.floor(rng()*arr.length)]; }

/* ---------- CONFIG ---------- */
let selectedChar=null,gameLoopId,player,projectiles=[],enemies=[],explosions=[],powerups=[],scoutLights=[],
    score=0,wave=1,gameActive=false,abilityReady=true,abilityTimer=0,activePowerups={}, // activePowerups uses counters + timers
    scene,camera,renderer,raycaster,plane,HEIGHT,WIDTH=110,
    mouse=new THREE.Vector2(),keys={a:{pressed:false},d:{pressed:false}},
    autoFire=false;

const CHARACTERS=[
  {name:'Godsworn',faction:'Deities',color:0xffd700,passive:'Slow regen + starts with 1 armor layer',ability:'Stun all',cooldown:14000,dur:1700,health:105,speed:0.62,projCol:0xfff2b0,projSpd:1.25},
  {name:'Decker',faction:'Shadowrun',color:0x00ff66,passive:'Rapid fire + extra magnet range',ability:'Overclock (insane fire-rate)',cooldown:19000,dur:5000,health:115,speed:0.58,projCol:0x00ff88,projSpd:1.45},
  {name:'Inquisitor',faction:'Warhammer 40k',color:0xff4500,passive:'Bigger explosions',ability:'Burst volley',cooldown:16500,dur:800,health:140,speed:0.46,projCol:0xff6a3d,projSpd:1.12},
  {name:'Adventurer',faction:'Runescape',color:0x54a8ff,passive:'Auto-shield after not being hit',ability:'Invulnerability',cooldown:24000,dur:4200,health:125,speed:0.56,projCol:0x7fc3ff,projSpd:1.2},
  {name:'Pooka',faction:'Changeling',color:0xda70d6,passive:'Dodge + faster ship',ability:'Confuse enemies',cooldown:16000,dur:2900,health:110,speed:0.72,projCol:0xffa0ff,projSpd:1.35}
];

// POWERUPS SEEK YOU (magnet drones). â€œArmor platesâ€ stack and orbit with HP.
const POWERUPS=[
  {type:'armorPlate', col:0x7ee6ff, dur:0,     name:'Armor Plate (+1 layer)'},
  {type:'doubleShot', col:0x00fa9a, dur:11000, name:'Double Shot (stack)'},
  {type:'tripleShot', col:0x32cd32, dur:9000,  name:'Triple Shot (stack)'},
  {type:'scoreMult',  col:0xffff00, dur:12000, name:'2x Score (stack)'},
  {type:'enemySlow',  col:0xadd8e6, dur:8000,  name:'Realm Slow (stack)'},
  {type:'heal',       col:0xffc0cb, dur:0,     name:'Healing Rune'},
  {type:'homing',     col:0xda70d6, dur:12000, name:'Homing Shots'},
  {type:'nova',       col:0xff4500, dur:0,     name:'Nova Core (one big blast)'},
];

const SCOUT_COLORS=[0xffd700,0x00ff66,0xff4500,0x54a8ff,0xda70d6,0x00ffff,0xff00ff,0xffff00];

/* ---------- UI HELPERS ---------- */
function show(id){
  ['start-screen','character-selection-screen','game-screen'].forEach(s=>document.getElementById(s).classList.add('hidden'));
  document.getElementById(id).classList.remove('hidden');
}
function showToast(msg,col){
  const t=document.createElement('div');
  t.className='powerup-toast';
  t.textContent=msg;
  t.style.backgroundColor=col;
  toastContainer.appendChild(t);
  setTimeout(()=>{t.style.opacity='1';t.style.bottom='40px';t.style.transform='translateX(-50%) scale(1.08)';},10);
  setTimeout(()=>{t.style.opacity='0';t.style.bottom='20px';t.style.transform='translateX(-50%) scale(0.92)';setTimeout(()=>t.remove(),500);},2300);
}
function updateScore(v){
  const mult = 1 + (activePowerups.scoreMult?.count||0);
  score += Math.floor(v * mult);
  scoreEl.textContent = score;
  playSound('hit',0.12,2.0+Math.random()*0.5);
}
function updateHealthUI(){
  const hp = player.health/player.max*100;
  healthBar.style.width = `${clamp(hp,0,100)}%`;
  healthBar.className = 'fill';
  if(hp<25) healthBar.classList.add('bg-red-500');
  else if(hp<60) healthBar.classList.add('bg-yellow-500');
  else healthBar.classList.add('bg-green-500');

  const ap = player.armorHP/player.armorMax*100;
  armorBar.style.width = `${clamp(ap,0,100)}%`;
  armorBar.className = 'fill bg-cyan-500';
}

/* ---------- SCOUT LIGHTS (ambient) ---------- */
class ScoutLight{
  constructor(){
    this.model=new THREE.Group();
    const light=new THREE.PointLight(0xffffff,2,120);
    this.model.add(light);

    const orbGeo=new THREE.SphereGeometry(.85,18,18);
    const orbMat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:.5});
    const orb=new THREE.Mesh(orbGeo,orbMat);
    this.model.add(orb);

    this.colorIndex=Math.floor(Math.random()*SCOUT_COLORS.length);

    const ringGeo=new THREE.TorusGeometry(1.25,.18,10,40);
    const ringMat=new THREE.MeshBasicMaterial({color:SCOUT_COLORS[this.colorIndex],transparent:true,opacity:.8});
    const ring=new THREE.Mesh(ringGeo,ringMat);
    ring.rotation.x=-Math.PI/2;
    this.model.add(ring);

    const particles=new THREE.BufferGeometry();
    const pcount=70;
    const ppos=new Float32Array(pcount*3);
    for(let i=0;i<pcount*3;i+=3){
      const r=Math.random()*1.6+1,a=Math.random()*Math.PI*2;
      ppos[i]=Math.cos(a)*r;
      ppos[i+1]=Math.random()*.6-.3;
      ppos[i+2]=Math.sin(a)*r;
    }
    particles.setAttribute('position',new THREE.BufferAttribute(ppos,3));
    const partMat=new THREE.PointsMaterial({color:SCOUT_COLORS[this.colorIndex],size:.12,transparent:true,opacity:.85});
    this.particles=new THREE.Points(particles,partMat);
    this.model.add(this.particles);

    this.model.position.set((Math.random()-.5)*WIDTH,-10,-HEIGHT/2-60);
    this.speed=0.5+Math.random()*0.35;
    scene.add(this.model);
  }
  update(){
    this.model.position.z += this.speed;
    this.model.rotation.y += 0.05;
    this.particles.rotation.y += 0.02;
    this.colorIndex=(this.colorIndex+0.03)%SCOUT_COLORS.length;
    this.particles.material.color.setHex(SCOUT_COLORS[Math.floor(this.colorIndex)]);
    if(this.model.position.z > HEIGHT/2+20){
      this.model.position.set((Math.random()-.5)*WIDTH,-10,-HEIGHT/2-90-Math.random()*40);
    }
  }
}

/* ---------- PROCEDURAL MODELS ---------- */
function mkMat(col, emiss=col, em=0.35, metal=0.75, rough=0.35, op=1){
  return new THREE.MeshStandardMaterial({
    color: col, emissive: emiss, emissiveIntensity: em,
    metalness: metal, roughness: rough,
    transparent: op<1, opacity: op
  });
}
function mkGlow(col, op=0.5){
  return new THREE.MeshBasicMaterial({color:col, transparent:true, opacity:op});
}

function createProceduralFighter(seed, baseColor, accentColor){
  const rng = mulberry32(seed);

  const g = new THREE.Group();

  // hull
  const hullLen = lerp(2.4, 3.6, rng());
  const hullRad = lerp(0.6, 0.95, rng());
  const hullGeo = new THREE.CylinderGeometry(hullRad*0.85, hullRad, hullLen, 10, 1);
  const hull = new THREE.Mesh(hullGeo, mkMat(baseColor, baseColor, 0.22));
  hull.rotation.x = Math.PI/2;
  hull.position.y = 1.6;
  g.add(hull);

  // nose
  const noseGeo = new THREE.ConeGeometry(hullRad*0.75, lerp(1.0,1.6,rng()), 10);
  const nose = new THREE.Mesh(noseGeo, mkMat(accentColor, accentColor, 0.35));
  nose.rotation.x = Math.PI/2;
  nose.position.set(0, 1.6, hullLen*0.55);
  g.add(nose);

  // cockpit
  const cockpitGeo = new THREE.SphereGeometry(hullRad*0.75, 16, 16);
  const cockpit = new THREE.Mesh(cockpitGeo, mkMat(0x111111, accentColor, 0.55, 0.2, 0.1, 0.85));
  cockpit.scale.set(1.2,0.65,0.9);
  cockpit.position.set(0, 2.05, hullLen*0.15);
  g.add(cockpit);

  // wings (modular)
  const wingCount = rng() < 0.5 ? 2 : 4;
  for(let i=0;i<wingCount;i++){
    const w = new THREE.Mesh(
      new THREE.BoxGeometry(lerp(1.3,2.6,rng()), lerp(0.1,0.18,rng()), lerp(0.8,1.4,rng())),
      mkMat(baseColor, accentColor, 0.18, 0.6, 0.5)
    );
    const side = (i%2===0) ? -1 : 1;
    const tier = wingCount===4 ? (i<2 ? 1 : -1) : 1;
    w.position.set(side*lerp(1.2,2.2,rng()), 1.55 + (tier>0?0.1:-0.15), lerp(-0.2,0.6,rng()));
    w.rotation.y = side*(0.25 + rng()*0.35);
    w.rotation.z = side*(0.35 + rng()*0.35);
    g.add(w);

    // wing tip glow
    const tip = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 10), mkGlow(accentColor, 0.7));
    tip.position.set(side*lerp(2.0,2.8,rng()), 1.55, lerp(0.1,0.9,rng()));
    g.add(tip);
  }

  // engines
  const engineCount = rng() < 0.5 ? 2 : 3;
  for(let i=0;i<engineCount;i++){
    const e = new THREE.Mesh(
      new THREE.CylinderGeometry(0.22,0.32, lerp(0.7,1.2,rng()), 8),
      mkMat(0x222222, accentColor, 0.25, 0.9, 0.35)
    );
    e.rotation.x = Math.PI/2;
    const off = (i - (engineCount-1)/2) * 0.6;
    e.position.set(off, 1.45, -hullLen*0.55);
    g.add(e);

    const flame = new THREE.Mesh(new THREE.SphereGeometry(0.35, 14, 14), mkGlow(accentColor, 0.55));
    flame.scale.set(1.1,0.7,1.6);
    flame.position.set(off, 1.45, -hullLen*0.75);
    g.add(flame);
  }

  // dorsal fin
  if(rng() < 0.8){
    const fin = new THREE.Mesh(
      new THREE.ConeGeometry(0.25, lerp(0.9,1.6,rng()), 8),
      mkMat(accentColor, accentColor, 0.25, 0.5, 0.35)
    );
    fin.position.set(0, 2.35, -0.4);
    g.add(fin);
  }

  // subtle â€œdecal stripâ€
  const strip = new THREE.Mesh(
    new THREE.BoxGeometry(0.15,0.12,hullLen*0.85),
    mkMat(accentColor, accentColor, 0.18, 0.35, 0.25, 0.95)
  );
  strip.position.set(0, 1.78, 0);
  g.add(strip);

  g.userData.spin = (rng()<0.35) ? (rng()*0.8+0.4) : 0;
  g.userData.bob  = (rng()*0.4+0.2);
  return g;
}

function createEnemyFighter(type, seed){
  const rng = mulberry32(seed);
  const palette = {
    demigod: {base:0xffd700, accent:0xffaa00},
    drone:   {base:0x00ff66, accent:0x00ffaa},
    chaos:   {base:0xff4500, accent:0xff7744},
    goblin:  {base:0x54a8ff, accent:0x99d6ff},
    nightmare:{base:0xda70d6, accent:0xffa0ff},
  }[type] || {base:0x888888, accent:0xffffff};

  const ship = createProceduralFighter( (seed*9973)|0, palette.base, palette.accent );
  ship.scale.setScalar( lerp(1.1, 1.6, rng()) );
  ship.userData.enemyType = type;
  return ship;
}

function createPowerupDrone(info, seed){
  const rng = mulberry32(seed);
  const g = new THREE.Group();

  // core crystal
  const core = new THREE.Mesh(
    new THREE.OctahedronGeometry(0.85,0),
    mkMat(info.col, info.col, 0.75, 0.7, 0.15, 0.95)
  );
  g.add(core);

  // ring + petals
  const ring = new THREE.Mesh(
    new THREE.TorusGeometry(1.0, 0.12, 10, 40),
    mkMat(0x111111, info.col, 0.5, 0.9, 0.3, 0.9)
  );
  ring.rotation.x = Math.PI/2;
  g.add(ring);

  const petals = new THREE.Group();
  for(let i=0;i<6;i++){
    const a=i/6*Math.PI*2;
    const p = new THREE.Mesh(
      new THREE.ConeGeometry(0.18, 0.65, 8),
      mkMat(info.col, info.col, 0.55, 0.6, 0.25, 0.85)
    );
    p.position.set(Math.cos(a)*1.1, 0, Math.sin(a)*1.1);
    p.rotation.z = a + Math.PI/2;
    petals.add(p);
  }
  g.add(petals);

  // glow
  const glow = new THREE.Mesh(new THREE.SphereGeometry(1.45,16,16), mkGlow(info.col, 0.35));
  g.add(glow);

  g.userData.anim = {core, ring, petals, glow, w: lerp(1.6,2.8,rng()), s: lerp(0.9,1.6,rng())};
  return g;
}

/* ---------- ANIMATION ---------- */
function updatePowerupAnim(model, dt){
  const a=model.userData.anim; if(!a) return;
  const t=performance.now()*0.001;
  a.core.rotation.x += dt*1.4;
  a.core.rotation.y += dt*1.1;
  a.ring.rotation.z += dt*1.2;
  a.petals.rotation.y -= dt*0.9;
  a.glow.material.opacity = 0.24 + Math.abs(Math.sin(t*a.w))*0.22;
  model.position.y = model.userData.baseY + Math.sin(t*a.s)*0.25;
}

function updateShipAnim(model, dt){
  const t=performance.now()*0.001;
  if(model.userData.spin) model.rotation.y += dt*model.userData.spin;
  model.position.y = model.userData.baseY + Math.sin(t*model.userData.bob)*0.18;
}

/* ---------- ARMOR SATELLITES ---------- */
class ArmorSatellite{
  constructor(col, hp, radius, phase){
    this.hp = hp;
    this.max = hp;
    this.radius = radius;
    this.phase = phase;
    this.col = col;

    const plate = new THREE.Mesh(
      new THREE.BoxGeometry(0.55,0.18,0.85),
      mkMat(0x111111, col, 0.35, 0.9, 0.35, 0.95)
    );
    const gem = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 10), mkGlow(col,0.9));
    gem.position.set(0,0.15,0.2);

    this.model = new THREE.Group();
    this.model.add(plate, gem);

    this.model.userData.plate = plate;
    this.model.userData.gem = gem;
    this.model.userData.baseY = 0;
    this.model.userData.spin = 0;
    this.model.userData.bob = 2.2;

    player.model.add(this.model);
  }

  update(dt, idx, total){
    const t=performance.now()*0.001;
    const ang = t*1.6 + this.phase + idx*(Math.PI*2/Math.max(1,total));
    const x = Math.cos(ang)*this.radius;
    const z = Math.sin(ang)*this.radius;
    const y = 0.9 + Math.sin(t*2.3 + this.phase)*0.25;

    this.model.position.set(x, y, z);
    this.model.rotation.y = -ang + Math.PI/2;

    // visual damage
    const p = this.hp / this.max;
    this.model.userData.plate.material.opacity = 0.25 + p*0.7;
    this.model.userData.gem.material.opacity = 0.2 + p*0.8;
    this.model.userData.gem.material.color.setHex(this.col);
  }

  take(dmg){
    this.hp -= dmg;
    if(this.hp <= 0){
      this.hp = 0;
      // pop
      const p = this.model.getWorldPosition(new THREE.Vector3());
      explosions.push(new Explosion(p, this.col, false, player.c.name, 0.9));
      player.model.remove(this.model);
      return true;
    }
    return false;
  }
}

/* ---------- CLASSES ---------- */
class Player{
  constructor(c){
    this.c=c;

    // procedural fighter
    const seed = (c.name.split('').reduce((a,ch)=>a+ch.charCodeAt(0),0) + Math.floor(Math.random()*9999))|0;
    this.model=createProceduralFighter(seed, c.color, 0xffffff);
    this.model.scale.setScalar(1.35);
    this.model.position.z=HEIGHT/2-6;
    this.model.position.y=1.7;
    this.model.userData.baseY=this.model.position.y;
    scene.add(this.model);

    this.health=this.max=c.health;

    // armor system
    this.armor = [];
    this.armorHP = 0;
    this.armorMax = 0;

    this.shootCD=0;
    this.shield=false;
    this.shieldObj=null;
    this.shieldReady=true;
    this.lastHit=0;
    this.regen=0;
    this.dodge=c.name==='Pooka'?.28:0;

    // starting armor for Godsworn
    if(c.name==='Godsworn'){
      this.addArmorLayer(0x7ee6ff, 36);
    }

    updateHealthUI();
  }

  addArmorLayer(col=0x7ee6ff, hp=34){
    const radius = 2.8 + this.armor.length*0.35;
    const sat = new ArmorSatellite(col, hp, radius, Math.random()*Math.PI*2);
    this.armor.push(sat);
    this.recalcArmor();
    updateHealthUI();
    playSound('powerup', 0.35, 1.25);
  }

  recalcArmor(){
    this.armorHP = this.armor.reduce((a,s)=>a+s.hp,0);
    this.armorMax = Math.max(1, this.armor.reduce((a,s)=>a+s.max,0));
  }

  update(dt){
    if(keys.a.pressed && this.model.position.x>-WIDTH/2+2) this.model.position.x-=this.c.speed*1.35;
    if(keys.d.pressed && this.model.position.x< WIDTH/2-2) this.model.position.x+=this.c.speed*1.35;

    if(this.shootCD>0) this.shootCD--;

    // Godsworn slow regen
    if(this.c.name==='Godsworn'){
      this.regen += dt*60;
      if(this.regen >= 150){
        this.heal(1);
        this.regen = 0;
      }
    }

    // Adventurer: auto shield comes back
    if(this.c.name==='Adventurer'){
      if(!this.shieldReady && Date.now()-this.lastHit>5200){
        this.shieldReady=true;
        this.addShield(0x54a8ff, 3.7);
      }
    }

    updateShipAnim(this.model, dt);

    // update armor satellites
    for(let i=0;i<this.armor.length;i++){
      this.armor[i].update(dt, i, this.armor.length);
    }
  }

  shoot(targetPoint){
    // fire-rate boosted by stacks (doubleShot/tripleShot/overclock)
    const overclock = activePowerups.overclock?.count||0;
    const baseRate = 18;
    const fast = clamp(baseRate - overclock*8 - (activePowerups.doubleShot?.count||0)*2, 4, 18);
    if(this.shootCD>0) return;

    // stacking shot patterns
    const tCount = activePowerups.tripleShot?.count||0;
    const dCount = activePowerups.doubleShot?.count||0;

    let pattern = [0];
    if(tCount>0) pattern = [-14,0,14];
    else if(dCount>0) pattern = [-8, 8];

    // homing
    const homing = (activePowerups.homing?.count||0) > 0;

    playSound('shoot', 0.22, 1.0 + Math.random()*0.1);

    pattern.forEach(o=>{
      const nt = targetPoint.clone();
      const dir = new THREE.Vector3().subVectors(nt, this.model.position).normalize();
      const perp = new THREE.Vector3(-dir.z,0,dir.x).multiplyScalar(o*0.01);
      nt.add(perp);
      projectiles.push(new Projectile(this.model.position.clone(), nt, this.c, homing));
    });

    this.shootCD = fast;
  }

  takeDamage(amount){
    // invuln shield
    if(this.shield) return;

    // armor first
    if(this.armor.length){
      playSound('damage',0.25,0.95);
      let dmg = amount;
      // distribute to satellites (front-most first)
      for(let i=this.armor.length-1;i>=0 && dmg>0;i--){
        const sat = this.armor[i];
        const chunk = Math.min(dmg, 10);
        const killed = sat.take(chunk);
        dmg -= chunk;
        if(killed){
          this.armor.splice(i,1);
        }
      }
      this.recalcArmor();
      updateHealthUI();
      if(dmg<=0) return;
      // leftover spills
      amount = dmg;
    }

    // passive dodge
    if(this.c.name==='Pooka' && Math.random()<this.dodge){
      playSound('powerup',0.15,1.8);
      return;
    }

    // Adventurer: shield-ready blocks 1 hit
    if(this.c.name==='Adventurer' && this.shieldReady){
      this.shieldReady=false;
      this.lastHit=Date.now();
      if(this.shieldObj) this.model.remove(this.shieldObj);
      this.shieldObj=null;
      playSound('powerup',0.22,1.4);
      return;
    }

    this.health -= amount;
    this.lastHit = Date.now();
    updateHealthUI();
    if(this.health<=0) endGame();
  }

  heal(a){
    this.health = Math.min(this.max, this.health+a);
    updateHealthUI();
  }

  addShield(col, size){
    if(this.shieldObj) this.model.remove(this.shieldObj);
    const geo=new THREE.SphereGeometry(size, 18, 18);
    const mat=new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:.35,wireframe:true});
    this.shieldObj=new THREE.Mesh(geo,mat);
    this.model.add(this.shieldObj);
  }
}

class Projectile{
  constructor(pos, target, c, homing){
    this.c = c;
    this.homing = homing;

    const geo = new THREE.SphereGeometry(0.38, 10, 10);
    const mat = new THREE.MeshBasicMaterial({color:c.projCol,transparent:true,opacity:0.95});
    this.model = new THREE.Mesh(geo, mat);
    this.model.position.copy(pos);

    this.target = target.clone();
    this.speed = c.projSpd * (1 + (activePowerups.overclock?.count||0)*0.12);

    // â€œnova coreâ€ makes next shot explode bigger
    this.mega = !!activePowerups.novaPrimed;
    if(this.mega) delete activePowerups.novaPrimed;

    this.homingTarget = null;
    if(this.homing && enemies.length){
      let min=Infinity;
      for(const e of enemies){
        const d=this.model.position.distanceTo(e.model.position);
        if(d<min){min=d;this.homingTarget=e;}
      }
    }

    const dir = new THREE.Vector3().subVectors(this.target, pos).normalize();
    this.vel = dir.multiplyScalar(this.speed);

    scene.add(this.model);

    // tiny trail
    this.trail=[];
    for(let i=0;i<4;i++){
      const t = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({color:c.projCol,transparent:true,opacity:0.7}));
      t.position.copy(this.model.position);
      scene.add(t);
      this.trail.push({m:t,l:1});
    }
  }

  update(){
    if(this.homing && this.homingTarget && this.homingTarget.model.parent===scene){
      const desired = new THREE.Vector3().subVectors(this.homingTarget.model.position, this.model.position).normalize().multiplyScalar(this.speed);
      this.vel.lerp(desired, 0.12);
    }
    this.model.position.add(this.vel);

    for(let i=this.trail.length-1;i>=0;i--){
      const tr=this.trail[i];
      tr.l -= 0.09;
      tr.m.material.opacity = tr.l;
      tr.m.position.lerp(this.model.position, 0.12);
      if(tr.l<=0){
        scene.remove(tr.m);
        this.trail.splice(i,1);
      }
    }
  }
}

class Explosion{
  constructor(pos, col, mega, char, scaleBias=1){
    playExplosion(0.45*scaleBias, 1.0);
    const geo=new THREE.SphereGeometry(1,18,18);
    const mat=new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.95});
    this.model=new THREE.Mesh(geo,mat);
    this.model.position.copy(pos);

    this.max = (mega?40:14) * scaleBias;
    if(char==='Inquisitor') this.max *= 1.55;

    this.life = 1;
    this.particles=[];
    const pc = mega?38:22;
    for(let i=0;i<pc;i++){
      const pgeo=new THREE.SphereGeometry(Math.random()*0.28+0.08,8,8);
      const pmat=new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.85});
      const p=new THREE.Mesh(pgeo,pmat);
      p.position.copy(pos);
      const v=new THREE.Vector3((Math.random()-.5)*4,Math.random()*2,(Math.random()-.5)*4);
      scene.add(p);
      this.particles.push({m:p,v,l:1});
    }
    scene.add(this.model);
  }
  update(){
    const s=lerp(this.model.scale.x,this.max,0.14);
    this.model.scale.setScalar(s);
    this.model.material.opacity=this.life;

    for(let i=this.particles.length-1;i>=0;i--){
      const p=this.particles[i];
      p.m.position.add(p.v);
      p.l -= 0.045;
      p.m.material.opacity = p.l;
      p.v.y -= 0.05;
      if(p.l<=0){
        scene.remove(p.m);
        this.particles.splice(i,1);
      }
    }
    this.life -= 0.04;
  }
}

class Enemy{
  constructor(x,z,type){
    this.t = type;
    const seed = ((wave*7919 + Math.floor(Math.random()*99999))|0);
    this.model = createEnemyFighter(type, seed);
    this.model.position.set(x, 1.7, z);
    this.model.userData.baseY = this.model.position.y;

    // simple enemy hp scaling
    const baseHP = {demigod:55, drone:26, chaos:38, goblin:24, nightmare:34}[type] || 28;
    this.hp = baseHP + wave*4;
    this.max = this.hp;

    // speed
    let sp = {demigod:0.26, drone:0.48, chaos:0.36, goblin:0.42, nightmare:0.40}[type] || 0.38;
    this.speed = sp + wave*0.02;

    // score
    this.val = {demigod:75, drone:30, chaos:45, goblin:25, nightmare:38}[type] || 30;

    this.stun = false;
    this.hit = false;

    scene.add(this.model);
  }

  take(dmg){
    this.hp -= dmg;
    if(this.hp <= 0){
      this.die(true);
      return true;
    }
    return false;
  }

  update(dt){
    let sp = this.speed;
    const slow = activePowerups.enemySlow?.count||0;
    if(slow>0) sp *= 1 / (1 + slow*0.9);
    if(!this.stun) this.model.position.z += sp*dt*20;

    updateShipAnim(this.model, dt);
    this.model.rotation.y += dt*1.2;

    // if reaches player region
    if(this.model.position.distanceTo(player.model.position) < 4.0 && !this.hit){
      this.hit=true;
      player.takeDamage(14);
      this.die(false);
    }
    if(this.model.position.z > HEIGHT/2+6){
      player.takeDamage(20);
      this.die(false);
    }
  }

  die(killed){
    const p = this.model.position.clone();
    explosions.push(new Explosion(p, 0xff6b6b, killed, 'Inquisitor', 1));
    scene.remove(this.model);

    const idx = enemies.indexOf(this);
    if(idx>-1) enemies.splice(idx,1);

    if(killed){
      updateScore(this.val);

      // drops: higher chance = easier gameplay
      const dropChance = clamp(0.25 + wave*0.01, 0.25, 0.55);
      if(Math.random() < dropChance){
        const pos = new THREE.Vector3(p.x, 2.1, Math.max(-HEIGHT/2, p.z));
        powerups.push(new Powerup(pos));
      }
    }
  }
}

class Powerup{
  constructor(pos){
    this.info = POWERUPS[Math.floor(Math.random()*POWERUPS.length)];
    const seed = ((Date.now() ^ (Math.random()*999999))|0);
    this.model = createPowerupDrone(this.info, seed);
    this.model.position.copy(pos);
    this.model.userData.baseY = pos.y;

    // seeking/magnet behavior
    this.vel = new THREE.Vector3( (Math.random()-.5)*0.05, 0, 0.18 + Math.random()*0.08 );
    this.seekStrength = 0.55 + Math.random()*0.35;

    scene.add(this.model);
  }

  update(dt){
    updatePowerupAnim(this.model, dt);

    // SEEK PLAYER (stronger if Decker)
    const magnetBonus = (player?.c?.name==='Decker') ? 1.35 : 1.0;
    const toP = new THREE.Vector3().subVectors(player.model.position, this.model.position);
    const d = toP.length();
    const magnetR = 22 * magnetBonus;

    if(d < magnetR){
      toP.normalize();
      this.vel.lerp(toP.multiplyScalar(0.55*this.seekStrength*magnetBonus), 0.12);
    }

    // keep moving forward-ish
    this.vel.z += 0.002;
    this.vel.x = clamp(this.vel.x, -0.6, 0.6);
    this.vel.z = clamp(this.vel.z, 0.12, 0.85);

    this.model.position.add(this.vel.clone().multiplyScalar(1 + dt*30));
  }
}

/* ---------- THREE SETUP ---------- */
function initThree(){
  HEIGHT=(WIDTH*canvas.offsetHeight)/canvas.offsetWidth;

  scene=new THREE.Scene();
  scene.fog=new THREE.FogExp2(0x0f0f1f, .014);

  camera=new THREE.PerspectiveCamera(75,canvas.offsetWidth/canvas.offsetHeight,.1,1000);
  camera.position.set(0,60,HEIGHT/2+18);
  camera.lookAt(0,0,0);

  renderer=new THREE.WebGLRenderer({canvas,antialias:true,alpha:true});
  renderer.setSize(canvas.offsetWidth,canvas.offsetHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
  renderer.shadowMap.enabled=true;
  renderer.shadowMap.type=THREE.PCFSoftShadowMap;

  scene.add(new THREE.AmbientLight(0x151525,.42));
  const dir=new THREE.DirectionalLight(0xffffff,1.25);
  dir.position.set(22,44,22);
  dir.castShadow=true;
  dir.shadow.mapSize.set(2048,2048);
  scene.add(dir);

  scene.add(new THREE.DirectionalLight(0x00aaff,.35).position.set(-12,20,-10));

  scoutLights=[];
  for(let i=0;i<14;i++) scoutLights.push(new ScoutLight());

  // star field
  const starsGeo=new THREE.BufferGeometry(),cnt=1200,pos=new Float32Array(cnt*3);
  for(let i=0;i<cnt*3;i+=3){
    pos[i]=(Math.random()-.5)*2200;
    pos[i+1]=Math.random()*620;
    pos[i+2]=(Math.random()-.5)*2200;
  }
  starsGeo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  scene.add(new THREE.Points(starsGeo,new THREE.PointsMaterial({color:0x8888ff,size:1.6,transparent:true,opacity:.6})));

  raycaster=new THREE.Raycaster();

  const pg=new THREE.PlaneGeometry(WIDTH,HEIGHT);
  const pm=new THREE.MeshBasicMaterial({visible:false});
  plane=new THREE.Mesh(pg,pm);
  plane.rotation.x=-Math.PI/2;
  scene.add(plane);
}

/* ---------- CHARACTER UI ---------- */
function initChars(){
  charGrid.innerHTML='';
  CHARACTERS.forEach(c=>{
    const card=document.createElement('div');
    card.className='p-4 rounded-lg cursor-pointer character-card bg-black bg-opacity-40';
    card.style.borderColor=`#${new THREE.Color(c.color).getHexString()}`;
    card.innerHTML=`
      <h3 class="text-2xl font-bold" style="color:#${new THREE.Color(c.color).getHexString()};text-shadow:0 0 5px #${new THREE.Color(c.color).getHexString()};">${c.name}</h3>
      <p class="text-lg">${c.faction}</p>
      <p class="tiny mt-2">${c.passive}</p>
    `;
    card.onclick=()=>{
      selectedChar=c;
      document.querySelectorAll('.character-card').forEach(x=>x.classList.remove('selected'));
      card.classList.add('selected');
      charName.textContent=c.name;
      charFaction.textContent=c.faction;
      charPassive.textContent=`Passive: ${c.passive}`;
      charAbility.textContent=`Ability: ${c.ability}`;
      playBtn.classList.remove('hidden');
    };
    charGrid.appendChild(card);
  });
}

/* ---------- WAVES & SPAWNS ---------- */
function spawnWave(){
  const base = 6 + wave*3;
  const cnt = clamp(base, 8, 44);

  for(let i=0;i<cnt;i++){
    const x=(Math.random()-.5)*(WIDTH-12);
    const z=-HEIGHT/2 - Math.random()*28;

    let t;
    const r=Math.random();
    if(wave>4 && r<0.18) t='demigod';
    else if(wave>2 && r<0.40) t='chaos';
    else if(wave>1 && r<0.62) t='drone';
    else if(r<0.82) t='goblin';
    else t='nightmare';

    enemies.push(new Enemy(x,z,t));
  }

  // extra â€œhelpfulâ€ magnet drones so it feels generous
  if(wave%2===0){
    const bonusDrops = 1 + Math.floor(wave/4);
    for(let i=0;i<bonusDrops;i++){
      const pos=new THREE.Vector3((Math.random()-.5)*WIDTH*0.6, 2.2, -HEIGHT/2 - 10 - Math.random()*12);
      powerups.push(new Powerup(pos));
    }
  }
}

/* ---------- ABILITY ---------- */
function useAbility(){
  if(!abilityReady) return;
  abilityReady=false;
  abilityTimer=selectedChar.cooldown;
  playSound('powerup',.55,.7);

  switch(selectedChar.name){
    case'Godsworn':
      enemies.forEach(e=>e.stun=true);
      setTimeout(()=>{enemies.forEach(e=>e.stun=false);}, selectedChar.dur);
      break;
    case'Decker':
      // â€œoverclock stackâ€ gives wild fire-rate
      activePowerups.overclock = activePowerups.overclock || {count:0, t:null};
      activePowerups.overclock.count = clamp(activePowerups.overclock.count+1, 1, 3);
      clearTimeout(activePowerups.overclock.t);
      activePowerups.overclock.t=setTimeout(()=>{ delete activePowerups.overclock; }, selectedChar.dur);
      break;
    case'Inquisitor':{
      // quick burst volley at current cursor target
      const hit=raycaster.intersectObject(plane);
      if(hit.length){
        const p=hit[0].point;
        player.shoot(p);
        setTimeout(()=>player.shoot(p), 120);
        setTimeout(()=>player.shoot(p), 240);
      }
      break;
    }
    case'Adventurer':
      player.shield=true;
      player.addShield(0x54a8ff, 4.4);
      setTimeout(()=>{
        player.shield=false;
        if(player.shieldObj){player.model.remove(player.shieldObj);player.shieldObj=null;}
      }, selectedChar.dur);
      break;
    case'Pooka':
      enemies.forEach(e=>{ e.stun=true; });
      setTimeout(()=>{ enemies.forEach(e=>{ e.stun=false; }); }, selectedChar.dur);
      break;
  }
}

/* ---------- POWERUP EFFECTS (STACKING) ---------- */
function addTimedStack(key, dur, max=4){
  activePowerups[key] = activePowerups[key] || {count:0, t:null};
  activePowerups[key].count = clamp(activePowerups[key].count+1, 1, max);
  clearTimeout(activePowerups[key].t);
  activePowerups[key].t = setTimeout(()=>{ delete activePowerups[key]; }, dur);
}

function activatePowerup(p){
  const col = `#${new THREE.Color(p.info.col).getHexString()}`;
  showToast(p.info.name, col);
  playSound('powerup', .45, 1.4);

  switch(p.info.type){
    case 'armorPlate':
      // ADDITIVE: add an orbiting armor satellite with HP
      player.addArmorLayer(p.info.col, 34 + Math.floor(wave*2));
      break;

    case 'doubleShot':
      addTimedStack('doubleShot', p.info.dur, 4);
      break;

    case 'tripleShot':
      addTimedStack('tripleShot', p.info.dur, 3);
      break;

    case 'scoreMult':
      addTimedStack('scoreMult', p.info.dur, 3);
      break;

    case 'enemySlow':
      addTimedStack('enemySlow', p.info.dur, 3);
      break;

    case 'heal':
      player.heal(30);
      break;

    case 'homing':
      addTimedStack('homing', p.info.dur, 3);
      break;

    case 'nova':
      // primes next shot to explode huge
      activePowerups.novaPrimed = true;
      break;
  }
}

/* ---------- TARGETING / AUTO-AIM ---------- */
function getNearestEnemyPoint(){
  if(!enemies.length) return null;
  let best=null, bestD=Infinity;
  for(const e of enemies){
    const d = e.model.position.distanceTo(player.model.position);
    if(d<bestD){bestD=d;best=e;}
  }
  if(!best) return null;
  return best.model.position.clone();
}

/* ---------- GAME LOOP ---------- */
let last=0;
function loop(now){
  if(!gameActive) return;
  gameLoopId=requestAnimationFrame(loop);

  const dt=Math.min((now-last)/1000, .05);
  last=now;

  scoutLights.forEach(l=>l.update());

  if(player) player.update(dt);

  // AUTO-FIRE (easy mode)
  if(autoFire && player && player.shootCD===0){
    const t = getNearestEnemyPoint();
    if(t) player.shoot(t);
  }

  // projectiles
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    p.update();

    // detonate near enemies OR end bounds
    let hitEnemy = null;
    for(const e of enemies){
      if(p.model.position.distanceTo(e.model.position) < 1.8){
        hitEnemy = e; break;
      }
    }
    const out = (p.model.position.z < -HEIGHT/2-10 || p.model.position.z > HEIGHT/2+12);

    if(hitEnemy || out){
      const boomCol = p.c.projCol;
      const boom = new Explosion(p.model.position.clone(), boomCol, p.mega, p.c.name, 1);
      explosions.push(boom);

      // splash damage
      const radius = (p.mega?16:6) * (p.c.name==='Inquisitor'?1.35:1);
      for(let j=enemies.length-1;j>=0;j--){
        const en=enemies[j];
        const d = boom.model.position.distanceTo(en.model.position);
        if(d < radius){
          const dmg = Math.max(8, (p.mega?38:18) - d*2.2);
          const killed = en.take(dmg);
          if(killed){
            // drops handled in die()
          }
        }
      }

      scene.remove(p.model);
      p.trail.forEach(tr=>scene.remove(tr.m));
      projectiles.splice(i,1);
    }
  }

  // explosions
  for(let i=explosions.length-1;i>=0;i--){
    const e=explosions[i];
    e.update();
    if(e.life<=0){
      scene.remove(e.model);
      e.particles.forEach(pa=>scene.remove(pa.m));
      explosions.splice(i,1);
    }
  }

  // enemies
  for(let i=enemies.length-1;i>=0;i--) enemies[i].update(dt);

  // powerups (seek player)
  for(let i=powerups.length-1;i>=0;i--){
    const p=powerups[i];
    p.update(dt);

    if(p.model.position.distanceTo(player.model.position) < 3.8){
      activatePowerup(p);
      scene.remove(p.model);
      powerups.splice(i,1);
      updateHealthUI();
      continue;
    }

    if(p.model.position.z > HEIGHT/2+10){
      scene.remove(p.model);
      powerups.splice(i,1);
    }
  }

  // wave complete
  if(enemies.length===0){
    wave++;
    waveEl.textContent = wave;
    spawnWave();
  }

  // cooldown UI
  if(!abilityReady){
    abilityTimer=Math.max(0, abilityTimer - dt*1000);
    const prog = Math.max(0, 1 - abilityTimer/selectedChar.cooldown);
    abilityBar.style.width = `${prog*100}%`;
    if(abilityTimer<=0){
      abilityReady=true;
      abilityBar.style.width='100%';
    }
  }

  // camera follow
  const camZ = player.model.position.z + HEIGHT/4;
  camera.position.z = lerp(camera.position.z, camZ, 0.06);
  camera.position.x = lerp(camera.position.x, player.model.position.x*0.12, 0.06);
  camera.lookAt(0, 0, 0);

  renderer.render(scene, camera);
}

/* ---------- GAME STATE ---------- */
function startGame(){
  if(!selectedChar) return;

  score=0; wave=1;
  gameActive=true;
  projectiles=[]; enemies=[]; explosions=[]; powerups=[]; scoutLights=[];
  activePowerups={};
  autoFire=false;
  autoFireLabel.textContent='OFF';

  scoreEl.textContent=score;
  waveEl.textContent=wave;

  show('game-screen');
  initThree();

  player=new Player(selectedChar);

  // Adventurer starts with visual shield if ready
  if(player.c.name==='Adventurer' && player.shieldReady) player.addShield(0x54a8ff, 3.7);

  playerName.textContent = player.c.name;
  updateHealthUI();
  abilityBar.style.width='100%';

  spawnWave();

  last=performance.now();
  loop(last);
}

function endGame(){
  gameActive=false;
  cancelAnimationFrame(gameLoopId);
  finalScore.textContent=score;
  finalWave.textContent=wave;
  gameOver.classList.remove('hidden');

  try{
    while(scene && scene.children && scene.children.length) scene.remove(scene.children[0]);
  }catch(e){}
}

function restart(){
  gameOver.classList.add('hidden');
  selectedChar=null;
  playBtn.classList.add('hidden');
  charName.textContent='';
  charFaction.textContent='';
  charPassive.textContent='';
  charAbility.textContent='';
  show('character-selection-screen');
}

/* ---------- INPUT ---------- */
startBtn.onclick=()=>{show('character-selection-screen');initChars();};
playBtn.onclick=startGame;
restartBtn.onclick=restart;

canvas.onmousemove=e=>{
  const r=canvas.getBoundingClientRect();
  mouse.x=((e.clientX-r.left)/canvas.offsetWidth)*2-1;
  mouse.y=-((e.clientY-r.top)/canvas.offsetHeight)*2+1;
  if(gameActive) raycaster.setFromCamera(mouse,camera);
};

canvas.onclick=()=>{
  if(!gameActive) return;
  const i=raycaster.intersectObject(plane);
  if(i.length) player.shoot(i[0].point);
};

// keyboard
window.onkeydown=e=>{
  if(!gameActive) return;
  if(e.key==='a'||e.key==='ArrowLeft') keys.a.pressed=true;
  if(e.key==='d'||e.key==='ArrowRight') keys.d.pressed=true;
  if(e.key==='q') useAbility();
  if(e.code==='Space'){
    autoFire=!autoFire;
    autoFireLabel.textContent = autoFire ? 'ON' : 'OFF';
    playSound('powerup',0.25, autoFire?1.25:0.85);
  }
};
window.onkeyup=e=>{
  if(!gameActive) return;
  if(e.key==='a'||e.key==='ArrowLeft') keys.a.pressed=false;
  if(e.key==='d'||e.key==='ArrowRight') keys.d.pressed=false;
};

window.onresize=()=>{
  if(!gameActive || !camera || !renderer) return;
  camera.aspect=canvas.offsetWidth/canvas.offsetHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(canvas.offsetWidth,canvas.offsetHeight);
  HEIGHT=(WIDTH*canvas.offsetHeight)/canvas.offsetWidth;

  if(plane){
    scene.remove(plane);
    const g=new THREE.PlaneGeometry(WIDTH,HEIGHT);
    plane.geometry.dispose();
    plane.geometry=g;
    scene.add(plane);
  }
};

// audio unlock
document.addEventListener('click',()=>{initAudio();},{once:true});
</script>
</body>
</html>
