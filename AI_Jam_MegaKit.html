<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>üéÆ AI Jam MegaKit ‚Äî Phaser + Three + WebAudio + Waves Chat</title>
  <style>
    :root{
      --bg:#0b0f18;
      --panel:rgba(20,26,40,.92);
      --line:rgba(255,255,255,.12);
      --txt:rgba(245,248,255,.92);
      --muted:rgba(245,248,255,.65);
      --accent:#7ee6ff;
      --ok:#52e08a;
      --warn:#ff6b6b;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--txt);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #app{display:grid;grid-template-columns:320px 1fr;height:100%;}
    #side{
      background:var(--panel);
      border-right:1px solid var(--line);
      padding:14px;
      overflow:auto;
    }
    #main{position:relative;overflow:hidden;}
    h1{font-size:16px;margin:0 0 8px 0;}
    .muted{color:var(--muted);}
    .row{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0;}
    button,select,input{
      appearance:none;
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      color:var(--txt);
      border-radius:10px;
      padding:10px 10px;
      font-size:13px;
      outline:none;
    }
    button{cursor:pointer}
    button:hover{border-color:rgba(255,255,255,.24)}
    .pill{border-radius:999px;padding:6px 10px;font-size:12px}
    .ok{border-color:rgba(82,224,138,.35)}
    .warn{border-color:rgba(255,107,107,.35)}
    .accent{border-color:rgba(126,230,255,.35)}
    #hud{
      position:absolute;left:10px;top:10px;right:10px;
      display:flex;gap:10px;align-items:center;justify-content:space-between;
      pointer-events:none;
      z-index:20;
    }
    #hud .card{
      pointer-events:none;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:8px 10px;
      backdrop-filter: blur(6px);
      font-size:12px;
    }
    #canvasWrap{
      position:absolute;inset:0;
      display:flex;align-items:stretch;justify-content:stretch;
    }
    canvas{display:block;}
    .layer{position:absolute;inset:0;display:none;}
    .layer.active{display:block;}
    #phaserHost,#threeHost{position:absolute;inset:0;}
    #scopeLayer, #chatLayer{
      position:absolute;inset:0;
      padding:16px;
      box-sizing:border-box;
      display:grid;
      grid-template-rows:auto 1fr auto;
      gap:10px;
    }
    #scopeCanvas{
      width:100%;height:100%;
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(0,0,0,.35);
    }
    #kbd{
      display:grid;
      grid-template-columns:repeat(9,1fr);
      gap:6px;
      user-select:none;
    }
    #kbd button{padding:10px 0;border-radius:12px}
    #chatPane{
      display:grid;
      grid-template-columns:1fr 340px;
      gap:10px;
      min-height:0;
    }
    #chatLog{
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(0,0,0,.30);
      padding:12px;
      overflow:auto;
      min-height:0;
    }
    .msg{margin:10px 0;line-height:1.35}
    .msg .who{font-size:12px;color:var(--muted)}
    .msg .bubble{
      display:inline-block;
      margin-top:4px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      max-width: 95%;
      white-space: pre-wrap;
    }
    .me .bubble{border-color:rgba(126,230,255,.25)}
    .ai .bubble{border-color:rgba(82,224,138,.22)}
    #personaBox{
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(0,0,0,.30);
      padding:12px;
      overflow:auto;
    }
    #wavesBG{
      position:absolute;inset:0;z-index:0;
    }
    #chatLayer > *{position:relative;z-index:1;}
    #touchControls{
      position:absolute;inset:0;pointer-events:none;z-index:30;
    }
    .joy{
      position:absolute;left:18px;bottom:18px;
      width:140px;height:140px;border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.22);
      backdrop-filter: blur(6px);
      display:none;
    }
    .knob{
      position:absolute;left:50%;top:50%;
      width:54px;height:54px;border-radius:999px;
      transform:translate(-50%,-50%);
      background:rgba(126,230,255,.18);
      border:1px solid rgba(126,230,255,.25);
    }
    .fire{
      position:absolute;right:18px;bottom:28px;
      width:96px;height:96px;border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,107,107,.14);
      display:none;
    }
    .fire:after{
      content:"üî•";
      position:absolute;inset:0;
      display:flex;align-items:center;justify-content:center;
      font-size:28px;
      opacity:.9;
    }
    @media (max-width: 860px){
      #app{grid-template-columns:1fr;}
      #side{border-right:none;border-bottom:1px solid var(--line);}
      #chatPane{grid-template-columns:1fr;}
    }
  </style>
</head>
<body>
  <!-- Phaser + Three from CDN (single-file friendly) -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    /*********************************************************************
     * AI Jam MegaKit (original code)
     * Modes:
     *  1) Phaser: "Waves + Rewind" shooter (Tower-of-Time-ish + Zombie-ish)
     *  2) Three.js: "Procedural Runner" (Red-Panda-ish)
     *  3) WebAudio: "Oscilloscope Decoder" (ScillyScope-ish)
     *  4) Waves Chat: "Emotion-reactive chat UI" (Whispers-of-waves-ish)
     *********************************************************************/

    const $ = (sel) => document.querySelector(sel);

    const state = {
      mode: "phaser",
      score: 0,
      best: +localStorage.getItem("aiJamBest") || 0,
      paused: false,
      isMobile: matchMedia("(pointer: coarse)").matches,
    };

    // --- Layout ---
    document.body.insertAdjacentHTML("afterbegin", `
      <div id="app">
        <aside id="side">
          <h1>üéÆ AI Jam MegaKit</h1>
          <div class="muted">One file, GitHub Pages friendly. Pick a mode, hit play, steal the UI patterns.</div>

          <div class="row">
            <select id="modeSel" class="accent">
              <option value="phaser">üöÄ Phaser ‚Äî Waves + Rewind</option>
              <option value="three">ü¶ä Three.js ‚Äî Procedural Runner</option>
              <option value="scope">üéõÔ∏è WebAudio ‚Äî Oscilloscope Decoder</option>
              <option value="chat">üåä Waves Chat ‚Äî Emotion UI</option>
            </select>
          </div>

          <div class="row">
            <button id="btnStart" class="pill ok">‚ñ∂ Start / Restart</button>
            <button id="btnPause" class="pill warn">‚è∏ Pause</button>
            <button id="btnFS" class="pill accent">‚õ∂ Fullscreen</button>
          </div>

          <div class="row">
            <div class="pill" style="border:1px solid var(--line);background:rgba(255,255,255,.04)">
              üèÜ Best: <b id="bestLbl">${state.best}</b>
            </div>
            <div class="pill" style="border:1px solid var(--line);background:rgba(255,255,255,.04)">
              ‚≠ê Score: <b id="scoreLbl">0</b>
            </div>
          </div>

          <hr style="border:none;border-top:1px solid var(--line);margin:12px 0">

          <div id="help" class="muted" style="font-size:13px;line-height:1.35"></div>

          <hr style="border:none;border-top:1px solid var(--line);margin:12px 0">

          <div class="muted" style="font-size:12px">
            Tip: This is a <b>starter kit</b>. For the original jam repos, use the ‚ÄúGitHub repository URL‚Äù on each jam page.
          </div>
        </aside>

        <main id="main">
          <div id="hud">
            <div class="card" id="hudLeft">Ready.</div>
            <div class="card" id="hudRight">W/A/S/D ‚Ä¢ Arrow Keys ‚Ä¢ Touch</div>
          </div>

          <div id="canvasWrap">
            <div id="phaserLayer" class="layer active"><div id="phaserHost"></div></div>
            <div id="threeLayer" class="layer"><div id="threeHost"></div></div>

            <div id="scopeLayer" class="layer">
              <div class="muted">üéõÔ∏è Oscilloscope Decoder ‚Äî listen + decode a hidden ‚Äúwave haiku‚Äù</div>
              <canvas id="scopeCanvas"></canvas>
              <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
                <button id="scopePlay" class="pill ok">‚ñ∂ Play Word</button>
                <button id="scopeStop" class="pill warn">‚èπ Stop</button>
                <button id="scopeClear" class="pill">üßº Clear Guess</button>
                <div class="pill" style="border:1px solid var(--line);background:rgba(255,255,255,.04)">
                  Guess: <b id="scopeGuess">‚Äî</b>
                </div>
                <div class="pill" style="border:1px solid var(--line);background:rgba(255,255,255,.04)">
                  Word <b id="scopeWordIdx">1</b>/3
                </div>
              </div>
              <div id="kbd"></div>
            </div>

            <div id="chatLayer" class="layer">
              <canvas id="wavesBG"></canvas>
              <div class="muted">üåä Waves Chat ‚Äî demo mode (no API), emotion-reactive visuals</div>
              <div id="chatPane">
                <div id="chatLog"></div>
                <div id="personaBox">
                  <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
                    <select id="personaSel" class="accent" style="flex:1">
                      <option value="tide">üåä The Tide ‚Äî calm reflection</option>
                      <option value="storm">‚õàÔ∏è The Storm ‚Äî challenge & clarity</option>
                      <option value="buoy">üõü The Buoy ‚Äî practical next steps</option>
                    </select>
                  </div>
                  <div class="muted" style="margin-top:10px;font-size:12px">
                    This mode is intentionally offline. If you want it to call an LLM, wire <code>sendToLLM()</code> to your serverless endpoint.
                  </div>
                </div>
              </div>
              <div style="display:flex;gap:8px;align-items:center">
                <input id="chatIn" placeholder="Type a thought‚Ä¶ (e.g., 'I‚Äôm anxious about shipping my demo')" style="flex:1" />
                <button id="chatSend" class="pill ok">Send</button>
              </div>
            </div>

            <div id="touchControls">
              <div class="joy" id="joy">
                <div class="knob" id="knob"></div>
              </div>
              <div class="fire" id="fire"></div>
            </div>
          </div>
        </main>
      </div>
    `);

    // --- Generic helpers ---
    function setScore(v){
      state.score = Math.max(0, Math.floor(v));
      $("#scoreLbl").textContent = state.score;
      if(state.score > state.best){
        state.best = state.score;
        localStorage.setItem("aiJamBest", String(state.best));
        $("#bestLbl").textContent = state.best;
      }
    }
    function hud(left, right){
      $("#hudLeft").textContent = left;
      $("#hudRight").textContent = right;
    }
    function setHelp(html){ $("#help").innerHTML = html; }

    function showLayer(which){
      for(const id of ["phaserLayer","threeLayer","scopeLayer","chatLayer"]){
        $("#"+id).classList.toggle("active", id.startsWith(which));
      }
      // touch overlay only for phaser + three
      const touchOn = (which === "phaserLayer" || which === "threeLayer") && state.isMobile;
      $("#joy").style.display = touchOn ? "block" : "none";
      $("#fire").style.display = touchOn ? "block" : "none";
    }

    // --- Fullscreen ---
    $("#btnFS").onclick = async ()=>{
      try{
        if(!document.fullscreenElement) await document.documentElement.requestFullscreen();
        else await document.exitFullscreen();
      }catch(e){ /* ignore */ }
    };

    // --- Pause ---
    $("#btnPause").onclick = ()=>{
      state.paused = !state.paused;
      $("#btnPause").textContent = state.paused ? "‚ñ∂ Resume" : "‚è∏ Pause";
      if(phaserGame) phaserGame.scene.pause("Main");
      if(phaserGame && !state.paused) phaserGame.scene.resume("Main");
      if(threeLoop) threeLoop.paused = state.paused;
      hud(state.paused ? "Paused." : "Resumed.", $("#hudRight").textContent);
    };

    // --- Mode switch ---
    $("#modeSel").onchange = ()=>{
      state.mode = $("#modeSel").value;
      restart();
    };

    $("#btnStart").onclick = ()=> restart();

    // --- Touch joystick (shared) ---
    const touch = {
      active:false,
      id:null,
      cx:0, cy:0,
      dx:0, dy:0,
      fire:false,
    };
    function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }

    function setupTouch(){
      const joy = $("#joy"), knob = $("#knob"), fire = $("#fire");
      const joyRect = ()=> joy.getBoundingClientRect();

      function updateKnob(){
        const r = 52;
        knob.style.transform = `translate(calc(-50% + ${touch.dx*r}px), calc(-50% + ${touch.dy*r}px))`;
      }

      joy.addEventListener("pointerdown",(e)=>{
        touch.active = true;
        touch.id = e.pointerId;
        joy.setPointerCapture(e.pointerId);
        const rect = joyRect();
        touch.cx = rect.left + rect.width/2;
        touch.cy = rect.top + rect.height/2;
        touch.dx = 0; touch.dy = 0;
        updateKnob();
      });
      joy.addEventListener("pointermove",(e)=>{
        if(!touch.active || e.pointerId !== touch.id) return;
        const rect = joyRect();
        const x = (e.clientX - (rect.left + rect.width/2)) / (rect.width/2);
        const y = (e.clientY - (rect.top + rect.height/2)) / (rect.height/2);
        touch.dx = clamp(x,-1,1);
        touch.dy = clamp(y,-1,1);
        updateKnob();
      });
      joy.addEventListener("pointerup",(e)=>{
        if(e.pointerId !== touch.id) return;
        touch.active = false;
        touch.id = null;
        touch.dx = 0; touch.dy = 0;
        knob.style.transform = "translate(-50%,-50%)";
      });
      fire.addEventListener("pointerdown",(e)=>{ touch.fire = true; fire.setPointerCapture(e.pointerId); });
      fire.addEventListener("pointerup",()=>{ touch.fire = false; });
      fire.addEventListener("pointercancel",()=>{ touch.fire = false; });
    }
    setupTouch();

    // =====================================================================
    // 1) PHASER MODE: Waves + Rewind shooter (original mini-game)
    // =====================================================================
    let phaserGame = null;

    function destroyPhaser(){
      if(phaserGame){
        phaserGame.destroy(true);
        phaserGame = null;
        $("#phaserHost").innerHTML = "";
      }
    }

    function bootPhaser(){
      destroyPhaser();

      const W = $("#main").clientWidth;
      const H = $("#main").clientHeight;

      const config = {
        type: Phaser.AUTO,
        parent: "phaserHost",
        width: W,
        height: H,
        backgroundColor: "#070b14",
        physics: { default: "arcade", arcade: { debug: false } },
        scene: { key: "Main", preload, create, update }
      };

      phaserGame = new Phaser.Game(config);

      function preload(){ /* no assets: draw shapes */ }

      function create(){
        setScore(0);
        state.paused = false;
        $("#btnPause").textContent = "‚è∏ Pause";

        this.w = this.sys.game.config.width;
        this.h = this.sys.game.config.height;

        // Player
        this.player = this.physics.add.image(this.w*0.5, this.h*0.75, null)
          .setCircle(14).setTint(0x7ee6ff).setCollideWorldBounds(true);
        this.player.body.setMaxSpeed(420);

        // ‚ÄúRewind energy‚Äù
        this.rewind = { energy: 100, max: 100, draining:false, buffer: [] };

        // Bullets
        this.bullets = this.physics.add.group({ classType: Phaser.Physics.Arcade.Image, runChildUpdate: true });
        this.enemies = this.physics.add.group({ classType: Phaser.Physics.Arcade.Image, runChildUpdate: true });

        this.lastShot = 0;
        this.wave = 1;
        this.waveTimer = 0;

        // Input
        this.keys = this.input.keyboard.addKeys({
          up: Phaser.Input.Keyboard.KeyCodes.W,
          left: Phaser.Input.Keyboard.KeyCodes.A,
          down: Phaser.Input.Keyboard.KeyCodes.S,
          right: Phaser.Input.Keyboard.KeyCodes.D,
          up2: Phaser.Input.Keyboard.KeyCodes.UP,
          left2: Phaser.Input.Keyboard.KeyCodes.LEFT,
          down2: Phaser.Input.Keyboard.KeyCodes.DOWN,
          right2: Phaser.Input.Keyboard.KeyCodes.RIGHT,
          shoot: Phaser.Input.Keyboard.KeyCodes.SPACE,
          rewind: Phaser.Input.Keyboard.KeyCodes.R,
        });

        // Collisions
        this.physics.add.overlap(this.bullets, this.enemies, (b,e)=>{
          b.destroy();
          e.hp -= 1;
          if(e.hp <= 0){
            // shockwave-ish pop
            const p = this.add.circle(e.x,e.y,8,0x52e08a,0.8);
            this.tweens.add({ targets:p, radius:38, alpha:0, duration:220, onComplete:()=>p.destroy() });
            e.destroy();
            setScore(state.score + 10);
          }
        });

        this.physics.add.overlap(this.player, this.enemies, (p,e)=>{
          // take hit
          e.destroy();
          this.rewind.energy = Math.max(0, this.rewind.energy - 18);
          setScore(Math.max(0, state.score - 25));
          const flash = this.add.rectangle(this.w/2,this.h/2,this.w,this.h,0xff6b6b,0.12);
          this.tweens.add({ targets: flash, alpha: 0, duration: 220, onComplete:()=>flash.destroy()});
        });

        hud("üöÄ Phaser ‚Äî Survive waves. Hold R to rewind ~2s.", "Move: WASD/Arrows ‚Ä¢ Shoot: Space ‚Ä¢ Rewind: R");

        // Mobile hint
        if(state.isMobile){
          hud("üöÄ Phaser ‚Äî Touch joystick + üî• button. Hold R not needed.", "Touch: joystick ‚Ä¢ Fire: üî• ‚Ä¢ Auto-rewind on danger");
        }
      }

      function spawnWave(scene){
        const count = Math.min(6 + scene.wave*2, 34);
        for(let i=0;i<count;i++){
          const x = Phaser.Math.Between(30, scene.w-30);
          const y = Phaser.Math.Between(-400, -20);
          const e = scene.physics.add.image(x,y,null).setCircle(12).setTint(0xff6b6b);
          e.hp = 1 + Math.floor(scene.wave/4);
          e.speed = 80 + scene.wave*10 + Phaser.Math.Between(-10, 40);
          scene.enemies.add(e);
        }
      }

      function shoot(scene){
        const now = scene.time.now;
        if(now - scene.lastShot < 120) return;
        scene.lastShot = now;

        const b = scene.physics.add.image(scene.player.x, scene.player.y-18, null).setCircle(6).setTint(0xffffff);
        b.vy = -520;
        b.update = function(){ this.y += this.vy*(1/60); if(this.y < -30) this.destroy(); };
        scene.bullets.add(b);
      }

      function recordRewind(scene){
        // store last ~2.5s @ 60fps => 150 frames
        const buf = scene.rewind.buffer;
        buf.push({
          x: scene.player.x,
          y: scene.player.y,
          energy: scene.rewind.energy,
          score: state.score,
          wave: scene.wave,
        });
        if(buf.length > 150) buf.shift();
      }

      function applyRewind(scene){
        const buf = scene.rewind.buffer;
        if(buf.length < 2) return;

        // Pop a few frames per tick to "rewind"
        const steps = 4;
        for(let i=0;i<steps;i++){
          if(buf.length < 2) break;
          const snap = buf.pop();
          scene.player.setPosition(snap.x, snap.y);
          scene.rewind.energy = Math.max(0, snap.energy - 0.6); // cost
          setScore(snap.score);
          scene.wave = snap.wave;
        }

        // Also ‚Äúerase‚Äù nearby enemies a bit (forgiveness mechanic)
        scene.enemies.children.each((e)=>{
          if(!e.active) return;
          const d = Phaser.Math.Distance.Between(e.x,e.y,scene.player.x,scene.player.y);
          if(d < 90) e.y -= 8;
        });

        if(scene.rewind.energy <= 0) scene.rewind.energy = 0;
      }

      function update(){
        if(state.paused) return;

        const k = this.keys;

        // Movement
        let ax = 0, ay = 0;
        const left = k.left.isDown || k.left2.isDown;
        const right = k.right.isDown || k.right2.isDown;
        const up = k.up.isDown || k.up2.isDown;
        const down = k.down.isDown || k.down2.isDown;

        ax += (right ? 1 : 0) - (left ? 1 : 0);
        ay += (down ? 1 : 0) - (up ? 1 : 0);

        // Touch joystick
        if(state.isMobile){
          ax += touch.dx;
          ay += touch.dy;
        }

        const mag = Math.hypot(ax,ay) || 1;
        ax/=mag; ay/=mag;

        this.player.setVelocity(ax*320, ay*320);

        // Shooting
        const wantsShoot = k.shoot.isDown || (state.isMobile && touch.fire);
        if(wantsShoot) shoot(this);

        // Waves spawn pacing
        this.waveTimer += 1/60;
        if(this.waveTimer > 2.2){
          this.waveTimer = 0;
          spawnWave(this);
          this.wave += 1;
          setScore(state.score + 5);
        }

        // Enemies drift down and home slightly
        this.enemies.children.each((e)=>{
          if(!e.active) return;
          const dx = this.player.x - e.x;
          e.y += e.speed*(1/60);
          e.x += clamp(dx, -120, 120) * 0.0022;
          if(e.y > this.h + 40){
            e.destroy();
            setScore(Math.max(0, state.score - 3));
          }
        });

        // Rewind recording & usage
        recordRewind(this);

        const wantsRewind = k.rewind.isDown;
        if(wantsRewind && this.rewind.energy > 0){
          applyRewind(this);
        }else{
          // regen
          this.rewind.energy = Math.min(this.rewind.max, this.rewind.energy + 0.25);
        }

        // Mobile ‚Äúauto rewind‚Äù if boxed in (nice-feeling safety)
        if(state.isMobile && this.rewind.energy > 15){
          let close = 0;
          this.enemies.children.each((e)=>{
            if(!e.active) return;
            if(Phaser.Math.Distance.Between(e.x,e.y,this.player.x,this.player.y) < 70) close++;
          });
          if(close >= 3){
            applyRewind(this);
          }
        }

        hud(`üöÄ Wave ${this.wave} ‚Ä¢ Rewind ${Math.floor(this.rewind.energy)}%`, "Move ‚Ä¢ Shoot ‚Ä¢ Rewind");
      }

      // Resize support
      window.addEventListener("resize", ()=>{
        if(!phaserGame) return;
        const w = $("#main").clientWidth;
        const h = $("#main").clientHeight;
        phaserGame.scale.resize(w,h);
      }, {passive:true});
    }

    // =====================================================================
    // 2) THREE MODE: Procedural runner (original mini-game)
    // =====================================================================
    let threeLoop = null;

    function destroyThree(){
      if(threeLoop){
        threeLoop.stop();
        threeLoop = null;
      }
      $("#threeHost").innerHTML = "";
    }

    function makeNoise2D(seed=1337){
      // tiny deterministic value noise (no deps)
      function hash(x,y){
        let n = x*374761393 + y*668265263 + seed*1442695040888963407n;
        // JS number fallback: mix in 32-bit space
        let t = (x*127.1 + y*311.7 + seed*74.7);
        return (Math.sin(t)*43758.5453123) % 1;
      }
      function lerp(a,b,t){ return a + (b-a)*t; }
      function smooth(t){ return t*t*(3-2*t); }
      return (x,y)=>{
        const xi = Math.floor(x), yi = Math.floor(y);
        const xf = x - xi, yf = y - yi;
        const a = hash(xi,yi);
        const b = hash(xi+1,yi);
        const c = hash(xi,yi+1);
        const d = hash(xi+1,yi+1);
        const u = smooth(xf), v = smooth(yf);
        return lerp(lerp(a,b,u), lerp(c,d,u), v);
      };
    }

    function bootThree(){
      destroyThree();
      setScore(0);
      state.paused = false;
      $("#btnPause").textContent = "‚è∏ Pause";

      const host = $("#threeHost");
      const W = $("#main").clientWidth;
      const H = $("#main").clientHeight;

      const renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(W,H);
      renderer.setPixelRatio(Math.min(2, devicePixelRatio || 1));
      host.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x050813, 12, 60);

      const cam = new THREE.PerspectiveCamera(62, W/H, 0.1, 200);
      cam.position.set(0, 4.5, 10);

      const light = new THREE.DirectionalLight(0xffffff, 1.0);
      light.position.set(8, 12, 6);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0xffffff, 0.25));

      // ‚ÄúRed panda‚Äù proxy
      const panda = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.5, 0.9, 6, 10),
        new THREE.MeshStandardMaterial({ color: 0x7ee6ff, roughness:0.55, metalness:0.05 })
      );
      panda.position.set(0, 1.1, 0);
      scene.add(panda);

      // Ground chunk
      const noise = makeNoise2D(9);
      const size = 80;
      const seg = 140;
      const geo = new THREE.PlaneGeometry(size, size, seg, seg);
      geo.rotateX(-Math.PI/2);

      function applyHeights(zOffset){
        const pos = geo.attributes.position;
        for(let i=0;i<pos.count;i++){
          const x = pos.getX(i);
          const z = pos.getZ(i) + zOffset;
          const n = noise(x*0.08, z*0.08);
          const hill = (n-0.5)*2;
          const y = hill*1.35 + Math.sin((x+z)*0.05)*0.25;
          pos.setY(i, y);
        }
        pos.needsUpdate = true;
        geo.computeVertexNormals();
      }

      const ground = new THREE.Mesh(
        geo,
        new THREE.MeshStandardMaterial({ color:0x0d1a28, roughness:0.95 })
      );
      ground.position.y = 0;
      scene.add(ground);

      // ‚ÄúOil slick‚Äù chasers (red spheres)
      const enemies = [];
      function spawnEnemy(){
        const e = new THREE.Mesh(
          new THREE.SphereGeometry(0.45, 18, 18),
          new THREE.MeshStandardMaterial({ color: 0xff6b6b, roughness:0.6 })
        );
        e.position.set((Math.random()*10-5), 0.8, panda.position.z - (18 + Math.random()*20));
        e.userData.v = 1.2 + Math.random()*0.8;
        enemies.push(e);
        scene.add(e);
      }
      for(let i=0;i<6;i++) spawnEnemy();

      // Controls (keyboard + touch joystick)
      const keys = {};
      window.addEventListener("keydown", (e)=> keys[e.code]=true);
      window.addEventListener("keyup", (e)=> keys[e.code]=false);

      let vz = 0;
      let vx = 0;
      let zScroll = 0;

      function step(dt){
        // input
        let ix = 0, iz = 0;
        if(keys["ArrowLeft"]||keys["KeyA"]) ix -= 1;
        if(keys["ArrowRight"]||keys["KeyD"]) ix += 1;
        if(keys["ArrowUp"]||keys["KeyW"]) iz -= 1;
        if(keys["ArrowDown"]||keys["KeyS"]) iz += 1;

        if(state.isMobile){
          ix += touch.dx;
          iz += touch.dy;
        }

        // speed & smoothing
        vx = vx*0.86 + ix*0.25;
        vz = vz*0.86 + iz*0.28;

        // forward drift always (runner feel)
        const forward = -1.2;
        panda.position.x += vx*dt*10;
        panda.position.z += (forward + vz)*dt*10;

        panda.position.x = clamp(panda.position.x, -9, 9);

        // terrain scroll
        zScroll = panda.position.z;
        applyHeights(zScroll);

        // compute panda height from terrain approx: keep him above ground
        const y = 1.1 + 0.2*Math.sin((panda.position.x + panda.position.z)*0.2);
        panda.position.y = y;

        // camera follow
        cam.position.lerp(new THREE.Vector3(panda.position.x*0.45, 4.5, panda.position.z + 10), 0.08);
        cam.lookAt(panda.position.x, panda.position.y, panda.position.z - 6);

        // enemies chase
        for(const e of enemies){
          const dx = panda.position.x - e.position.x;
          const dz = panda.position.z - e.position.z;
          const d = Math.hypot(dx,dz) || 1;
          e.position.x += (dx/d) * e.userData.v * dt*5;
          e.position.z += (dz/d) * e.userData.v * dt*5;
          e.position.y = 0.7 + 0.2*Math.sin((e.position.x + e.position.z)*0.3);

          // recycle behind
          if(e.position.z > panda.position.z + 14){
            e.position.z = panda.position.z - (22 + Math.random()*30);
            e.position.x = (Math.random()*14-7);
          }

          // collision
          if(d < 1.0){
            // hit -> lose score, knock back, respawn enemy
            setScore(Math.max(0, state.score - 35));
            panda.position.z += 4;
            e.position.z = panda.position.z - (22 + Math.random()*30);
          }
        }

        // scoring: distance traveled
        setScore(state.score + dt*20);

        hud(`ü¶ä Runner ‚Ä¢ Distance ${state.score} ‚Ä¢ Enemies ${enemies.length}`, "Move: WASD/Arrows ‚Ä¢ Avoid red spheres");
      }

      let last = performance.now();
      const loop = {
        paused:false,
        stop(){
          this.paused = true;
          window.removeEventListener("resize", onResize);
        }
      };
      function onResize(){
        const w = $("#main").clientWidth;
        const h = $("#main").clientHeight;
        renderer.setSize(w,h);
        cam.aspect = w/h;
        cam.updateProjectionMatrix();
      }
      window.addEventListener("resize", onResize, {passive:true});

      function raf(t){
        if(!threeLoop) return;
        const dt = Math.min(0.033, (t-last)/1000);
        last = t;
        if(!loop.paused && !state.paused) step(dt);
        renderer.render(scene, cam);
        requestAnimationFrame(raf);
      }
      threeLoop = loop;
      requestAnimationFrame(raf);

      hud("ü¶ä Three.js ‚Äî procedural runner started.", "Move: WASD/Arrows ‚Ä¢ Touch joystick on mobile");
    }

    // =====================================================================
    // 3) WEBAUDIO SCOPE: Oscilloscope decoder (original mini-game)
    // =====================================================================
    let audio = null;

    function bootScope(){
      setScore(0);
      state.paused = false;
      $("#btnPause").textContent = "‚è∏ Pause";

      const canvas = $("#scopeCanvas");
      const ctx = canvas.getContext("2d");

      function fit(){
        const r = canvas.getBoundingClientRect();
        canvas.width = Math.floor(r.width * devicePixelRatio);
        canvas.height = Math.floor(r.height * devicePixelRatio);
      }
      fit();
      window.addEventListener("resize", fit, {passive:true});

      // fake ‚Äúhaiku‚Äù split into 3 words
      const words = [
        "SEA",
        "SOFT",
        "SINGS"
      ];
      let wordIdx = 0;
      let guess = "";

      $("#scopeWordIdx").textContent = String(wordIdx+1);
      $("#scopeGuess").textContent = guess || "‚Äî";

      function ensureAudio(){
        if(audio) return;
        const ac = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = ac.createAnalyser();
        analyser.fftSize = 2048;

        // stereo-ish oscilloscope: use two oscillators phase-shifted
        const gain = ac.createGain();
        gain.gain.value = 0.08;

        const merger = ac.createChannelMerger(2);
        analyser.connect(ac.destination); // monitor too

        audio = { ac, analyser, gain, merger, oscA:null, oscB:null, playing:false };

        // route: oscA -> L, oscB -> R, merge -> analyser -> output
        merger.connect(analyser);
        analyser.disconnect();
        analyser.connect(ac.destination);

        // But also allow direct merge to output
        merger.connect(ac.destination);
      }

      // Map letters to frequencies (simple)
      const base = 220; // A3-ish
      const letterFreq = (ch)=>{
        const i = ch.charCodeAt(0) - 65; // A=0
        const semi = i % 24;
        return base * Math.pow(2, semi/12);
      };

      function playWord(w){
        ensureAudio();
        const { ac } = audio;
        stopAudio();

        let t = ac.currentTime + 0.04;
        const gap = 0.18;

        for(const ch of w){
          const f = letterFreq(ch);
          // two oscillators: sine and cosine (phase-ish using delay)
          const a = ac.createOscillator();
          const b = ac.createOscillator();
          a.type = "sine";
          b.type = "sine";
          a.frequency.setValueAtTime(f, t);
          b.frequency.setValueAtTime(f, t);

          const ga = ac.createGain();
          const gb = ac.createGain();
          ga.gain.setValueAtTime(0.0, t);
          ga.gain.linearRampToValueAtTime(0.12, t+0.02);
          ga.gain.linearRampToValueAtTime(0.0, t+0.12);

          gb.gain.setValueAtTime(0.0, t);
          gb.gain.linearRampToValueAtTime(0.12, t+0.02);
          gb.gain.linearRampToValueAtTime(0.0, t+0.12);

          a.connect(ga).connect(audio.merger, 0, 0); // left
          b.connect(gb).connect(audio.merger, 0, 1); // right

          a.start(t); a.stop(t+0.14);
          b.start(t); b.stop(t+0.14);

          t += gap;
        }

        audio.playing = true;
      }

      function stopAudio(){
        if(!audio) return;
        audio.playing = false;
        // oscillators auto-stop; nothing to do
      }

      // draw oscilloscope
      const bufL = new Uint8Array(2048);
      function draw(){
        requestAnimationFrame(draw);
        fit(); // cheap + keeps crisp on resizes

        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "rgba(0,0,0,0.20)";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // grid
        ctx.strokeStyle = "rgba(255,255,255,0.07)";
        ctx.lineWidth = 1*devicePixelRatio;
        for(let i=1;i<10;i++){
          const x = (canvas.width*i)/10;
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
          const y = (canvas.height*i)/10;
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
        }

        if(audio){
          audio.analyser.getByteTimeDomainData(bufL);
          // waveform
          ctx.strokeStyle = "rgba(126,230,255,0.85)";
          ctx.beginPath();
          for(let i=0;i<bufL.length;i++){
            const v = (bufL[i]-128)/128;
            const x = (i/(bufL.length-1))*canvas.width;
            const y = (0.5 - v*0.35)*canvas.height;
            if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
          }
          ctx.stroke();
        }

        // overlay text
        ctx.fillStyle = "rgba(245,248,255,0.85)";
        ctx.font = `${12*devicePixelRatio}px system-ui`;
        ctx.fillText("Listen. Watch the wave. Decode the word.", 14*devicePixelRatio, 22*devicePixelRatio);
      }
      draw();

      // keyboard of letters
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const kbd = $("#kbd");
      kbd.innerHTML = "";
      for(const ch of letters){
        const b = document.createElement("button");
        b.textContent = ch;
        b.onclick = ()=>{
          guess += ch;
          $("#scopeGuess").textContent = guess;
          // small scoring: correct prefix
          const target = words[wordIdx];
          if(target.startsWith(guess)) setScore(state.score + 2);
          else setScore(Math.max(0, state.score - 1));
          // if exact
          if(guess === target){
            setScore(state.score + 30);
            wordIdx = Math.min(words.length-1, wordIdx+1);
            $("#scopeWordIdx").textContent = String(wordIdx+1);
            guess = "";
            $("#scopeGuess").textContent = "‚Äî";
          }
        };
        kbd.appendChild(b);
      }

      $("#scopePlay").onclick = ()=> playWord(words[wordIdx]);
      $("#scopeStop").onclick = ()=> stopAudio();
      $("#scopeClear").onclick = ()=>{
        guess = "";
        $("#scopeGuess").textContent = "‚Äî";
      };

      hud("üéõÔ∏è WebAudio ‚Äî Decode 3 words by ear.", "Click letters ‚Ä¢ Play Word ‚Ä¢ Watch waveform");
    }

    // =====================================================================
    // 4) WAVES CHAT: emotion-reactive background + demo ‚Äúpersonas‚Äù
    // =====================================================================
    let chatInit = false;

    function bootChat(){
      setScore(0);
      state.paused = false;
      $("#btnPause").textContent = "‚è∏ Pause";
      hud("üåä Waves Chat ‚Äî demo mode.", "Type ‚Ä¢ Send ‚Ä¢ Watch the waves react");

      const log = $("#chatLog");
      const inEl = $("#chatIn");
      const sendBtn = $("#chatSend");
      const personaSel = $("#personaSel");

      // background canvas
      const bg = $("#wavesBG");
      const bctx = bg.getContext("2d");

      function fit(){
        const r = $("#chatLayer").getBoundingClientRect();
        bg.width = Math.floor(r.width * devicePixelRatio);
        bg.height = Math.floor(r.height * devicePixelRatio);
      }
      fit();
      window.addEventListener("resize", fit, {passive:true});

      let mood = 0; // -1 sad/stress, +1 calm/positive
      let phase = 0;

      const lex = {
        pos: ["calm","okay","good","ready","excited","hope","love","clear","focus","safe","confident","grateful"],
        neg: ["anxious","scared","stuck","angry","sad","overwhelmed","tired","panic","stress","worried","lost","confused"]
      };
      function sentiment(txt){
        const s = txt.toLowerCase();
        let v = 0;
        for(const w of lex.pos) if(s.includes(w)) v += 1;
        for(const w of lex.neg) if(s.includes(w)) v -= 1;
        return clamp(v/4, -1, 1);
      }

      function drawWaves(){
        requestAnimationFrame(drawWaves);
        fit();
        phase += 0.012;

        const w = bg.width, h = bg.height;
        bctx.clearRect(0,0,w,h);

        // gradient based on mood
        const g = bctx.createLinearGradient(0,0,0,h);
        const cool = 0.55 + mood*0.25;
        g.addColorStop(0, `rgba(10, 16, 36, ${0.92})`);
        g.addColorStop(1, `rgba(${Math.floor(20+cool*40)}, ${Math.floor(18+cool*60)}, ${Math.floor(40+cool*120)}, ${0.95})`);
        bctx.fillStyle = g;
        bctx.fillRect(0,0,w,h);

        // waves
        bctx.lineWidth = 2.0*devicePixelRatio;
        for(let k=0;k<4;k++){
          const amp = (18 + k*10) * devicePixelRatio * (1 + Math.abs(mood)*0.6);
          const freq = 0.004 + k*0.0012;
          const y0 = (0.30 + k*0.12)*h + mood*0.04*h;
          bctx.strokeStyle = `rgba(126,230,255,${0.10 + k*0.06})`;
          bctx.beginPath();
          for(let x=0;x<=w;x+=6*devicePixelRatio){
            const y = y0 + Math.sin(phase*1.4 + x*freq) * amp;
            if(x===0) bctx.moveTo(x,y); else bctx.lineTo(x,y);
          }
          bctx.stroke();
        }
      }
      drawWaves();

      function pushMsg(who, text){
        const div = document.createElement("div");
        div.className = `msg ${who}`;
        div.innerHTML = `<div class="who">${who==="me" ? "You" : personaSel.options[personaSel.selectedIndex].text}</div>
                         <div class="bubble"></div>`;
        div.querySelector(".bubble").textContent = text;
        log.appendChild(div);
        log.scrollTop = log.scrollHeight;
      }

      function replyDemo(persona, userText){
        const s = sentiment(userText);
        mood = clamp(mood*0.6 + s*0.9, -1, 1);

        const prompts = {
          tide: [
            "Let‚Äôs slow it down. What‚Äôs the smallest true sentence about what you‚Äôre feeling right now?",
            "Name the pressure. Then name what you want to protect.",
            "If this were a wave, where are you: crest, crash, or calm?"
          ],
          storm: [
            "Okay‚Äîsharp question: what are you avoiding deciding?",
            "What‚Äôs the risk if you ship it imperfect today?",
            "What‚Äôs the one constraint you can‚Äôt violate‚Äîand what can be ugly on purpose?"
          ],
          buoy: [
            "Let‚Äôs make a 10-minute plan: 1) pick one goal, 2) cut one feature, 3) publish one page.",
            "What‚Äôs the next action that reduces uncertainty fastest?",
            "Write the README first: what should a stranger do in 30 seconds?"
          ]
        };
        const arr = prompts[persona] || prompts.tide;
        const pick = arr[Math.floor(Math.random()*arr.length)];

        // tiny ‚Äúachievement‚Äù scoring loop
        setScore(state.score + 10);

        return pick + "\n\n(Reply with one sentence. I‚Äôll mirror it back into a clearer plan.)";
      }

      async function sendToLLM(_persona, _text){
        // Hook point:
        // - Replace with a fetch() to your own endpoint (Cloudflare Worker / Azure Function / etc.)
        // - Keep the browser key-free if you care about security
        return null;
      }

      async function onSend(){
        const txt = inEl.value.trim();
        if(!txt) return;
        inEl.value = "";
        pushMsg("me", txt);

        const persona = personaSel.value;
        // Try real LLM (optional), else demo
        let out = await sendToLLM(persona, txt);
        if(!out) out = replyDemo(persona, txt);

        pushMsg("ai", out);
      }

      if(!chatInit){
        pushMsg("ai", "Hi. I‚Äôm your wave mirror. Tell me what‚Äôs heavy, and I‚Äôll turn it into something you can steer.");
        chatInit = true;
      }

      sendBtn.onclick = onSend;
      inEl.onkeydown = (e)=>{ if(e.key==="Enter") onSend(); };
    }

    // =====================================================================
    // RESTART / ROUTER
    // =====================================================================
    function restart(){
      setScore(0);

      // stop all
      destroyPhaser();
      destroyThree();
      // scope + chat are DOM-only (audio continues if running; ok for demo)

      const m = state.mode;
      if(m === "phaser"){
        showLayer("phaserLayer");
        setHelp(`
          <b>üöÄ Phaser ‚Äî Waves + Rewind</b><br>
          ‚Ä¢ Survive enemy waves (score ramps automatically)<br>
          ‚Ä¢ Shoot: <b>Space</b> or üî• (mobile)<br>
          ‚Ä¢ Rewind: <b>R</b> (desktop) to undo ~2 seconds (costs energy)<br>
          ‚Ä¢ Mobile gets ‚Äúauto-rewind‚Äù safety if you‚Äôre boxed in<br><br>
          <span class="muted">UI pattern: big simple buttons + forgiving mechanics = ‚Äúfeels good‚Äù jam games.</span>
        `);
        bootPhaser();
      }
      else if(m === "three"){
        showLayer("threeLayer");
        setHelp(`
          <b>ü¶ä Three.js ‚Äî Procedural Runner</b><br>
          ‚Ä¢ Infinite terrain feel with a single deforming plane<br>
          ‚Ä¢ Enemies chase you; avoid contact; distance = score<br>
          ‚Ä¢ Controls: WASD/Arrows or touch joystick<br><br>
          <span class="muted">UI pattern: one loop, one objective, instant restart = sticky.</span>
        `);
        bootThree();
      }
      else if(m === "scope"){
        showLayer("scopeLayer");
        setHelp(`
          <b>üéõÔ∏è WebAudio ‚Äî Oscilloscope Decoder</b><br>
          ‚Ä¢ Click <b>Play Word</b>, listen, then click letters to guess<br>
          ‚Ä¢ You advance on exact matches; score rewards correct prefixes<br><br>
          <span class="muted">UI pattern: ‚Äútoy-like instrument‚Äù + tiny puzzle = very jam-friendly.</span>
        `);
        bootScope();
      }
      else if(m === "chat"){
        showLayer("chatLayer");
        setHelp(`
          <b>üåä Waves Chat ‚Äî Emotion UI</b><br>
          ‚Ä¢ Offline demo ‚Äúpersonas‚Äù (no API calls)<br>
          ‚Ä¢ Background waves react to sentiment words (calm / anxious etc.)<br>
          ‚Ä¢ Replace <code>sendToLLM()</code> with your own endpoint when ready<br><br>
          <span class="muted">UI pattern: a ‚Äúgame-like‚Äù chat becomes a playful product demo.</span>
        `);
        bootChat();
      }
    }

    // Start default mode
    restart();
  </script>
</body>
</html>
