<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Graph Racer: MN-WI Hyper Commute</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; font-family: 'Courier New', Courier, monospace; touch-action: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* EDITOR */
        #editor { background: #f0f8ff; width: 100%; height: 100%; position: absolute; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        #graph-canvas { background: linear-gradient(0deg, transparent 24%, #ccc 25%, #ccc 26%, transparent 27%, transparent 74%, #ccc 75%, #ccc 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, #ccc 25%, #ccc 26%, transparent 27%, transparent 74%, #ccc 75%, #ccc 76%, transparent 77%, transparent); background-size: 30px 30px; border: 4px solid #333; box-shadow: 0 10px 20px rgba(0,0,0,0.5); background-color: white; touch-action: none; }
        .editor-btn-group { margin-top: 20px; display: flex; gap: 20px; }
        
        /* HUD */
        #hud { display: none; width: 100%; height: 100%; }
        .stat-bar { position: absolute; top: 20px; left: 0; width: 100%; text-align: center; color: #00ffff; text-shadow: 0 0 10px #00ffff; font-size: 20px; font-weight: bold; pointer-events: none; }
        
        /* CONTROLS */
        .control-zone { position: absolute; bottom: 0; width: 50%; height: 100%; pointer-events: auto; }
        .left-zone { left: 0; }
        .right-zone { right: 0; }
        
        /* MESSAGES */
        #center-msg { position: absolute; top: 30%; width: 100%; text-align: center; color: white; font-size: 50px; font-weight: 900; text-shadow: 0 0 20px #ff00de; display: none; z-index: 50; pointer-events: none; transform: skew(-10deg); }
        #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; z-index: 60; flex-direction: column; align-items: center; justify-content: center; color: white; pointer-events: auto; }

        .btn { padding: 15px 30px; font-size: 24px; cursor: pointer; background: #ff00de; border: none; border-radius: 8px; font-weight: bold; text-transform: uppercase; color: white; box-shadow: 0 0 15px #ff00de; transition: transform 0.1s; }
        .btn:active { transform: scale(0.95); }
        
        /* Instructions Overlay */
        .instructions { position: absolute; bottom: 20px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 14px; pointer-events: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="editor">
        <h2 style="color:#333">DESIGN YOUR COMMUTER</h2>
        <p style="color:#666">Draw the side profile (Front is RIGHT)</p>
        <canvas id="graph-canvas" width="600" height="300"></canvas>
        <div class="editor-btn-group">
            <button class="btn" style="background:#666; box-shadow:none;" onclick="resetEditor()">Clear</button>
            <button class="btn" onclick="startGame()">START COMMUTE</button>
        </div>
    </div>

    <div id="ui-layer">
        <div id="hud">
            <div class="stat-bar">
                SCORE: <span id="score">0</span> | AI ASSIST: <span id="mode">ACTIVE</span>
            </div>
            
            <div class="control-zone left-zone" ontouchstart="steer(-1)" ontouchend="steer(0)" onmousedown="steer(-1)" onmouseup="steer(0)"></div>
            <div class="control-zone right-zone" ontouchstart="steer(1)" ontouchend="steer(0)" onmousedown="steer(1)" onmouseup="steer(0)"></div>
            
            <div class="instructions">HOLD LEFT / RIGHT TO GLIDE LANES</div>
        </div>
        
        <div id="center-msg"></div>

        <div id="game-over">
            <h1 style="color:#ff00de; font-size:60px; margin:0; text-shadow:0 0 20px white;">COMMUTE ENDED</h1>
            <h2 id="final-score">Score: 0</h2>
            <button class="btn" onclick="restartGame()">DRIVE AGAIN</button>
        </div>
    </div>

<script>
/** * AUDIO SYSTEM (Synthwave Style)
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;

    if (type === 'coin') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(880, now);
        osc.frequency.exponentialRampToValueAtTime(1760, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else if (type === 'jump') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(600, now + 1.0); // Long floaty sound
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0, now + 1.0);
        osc.start(now); osc.stop(now + 1.0);
    } else if (type === 'bonus') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.setValueAtTime(554, now + 0.1); // Harmony
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
    }
}

/** * EDITOR 
 */
const canvas = document.getElementById('graph-canvas');
const ctx = canvas.getContext('2d');
let points = [];

function setDefaultShape() {
    // A sleek aerodynamic shape
    points = [
        {x: 50, y: 180}, {x: 100, y: 150}, {x: 350, y: 150}, 
        {x: 500, y: 180}, {x: 520, y: 200}, {x: 40, y: 200}
    ];
    drawEditor();
}

function drawEditor() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#ddd';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(0, 220); ctx.lineTo(600, 220); ctx.stroke();

    if (points.length > 0) {
        ctx.strokeStyle = '#ff00de';
        ctx.lineWidth = 3;
        ctx.fillStyle = 'rgba(255, 0, 222, 0.1)';
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        if(points.length > 2) { ctx.closePath(); ctx.fill(); }
        ctx.stroke();
        
        ctx.fillStyle = '#00ffff';
        points.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill(); });
    }
}

function addPoint(x, y) {
    const snap = 10;
    x = Math.round(x/snap)*snap;
    y = Math.round(y/snap)*snap;
    points.push({x, y});
    drawEditor();
}

canvas.addEventListener('mousedown', e => {
    const r = canvas.getBoundingClientRect();
    addPoint(e.clientX - r.left, e.clientY - r.top);
});
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const r = canvas.getBoundingClientRect();
    addPoint(e.touches[0].clientX - r.left, e.touches[0].clientY - r.top);
}, {passive:false});

function resetEditor() { points = []; drawEditor(); }

/** * 3D ENGINE - MN/WI COMMUTER EDITION
 */
let scene, camera, renderer;
let carGroup;
let worldObjects = []; // Stores traffic, barrels, stars
let roadLines = [];
let isPlaying = false;
let score = 0;
let speed = 0.8; // Constant highway speed
let steerInput = 0;
let currentLaneX = 0;
let verticalVel = 0;
let flyingMode = false;

function init3D() {
    if(renderer) return;
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510); // Night drive
    scene.fog = new THREE.Fog(0x050510, 20, 120);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 300);
    camera.position.set(0, 5, -12); 
    camera.lookAt(0, 0, 20);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Neon Lights
    const ambLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambLight);
    
    // Sun/Moon
    const moon = new THREE.DirectionalLight(0xaa00ff, 1.5);
    moon.position.set(-20, 50, -20);
    scene.add(moon);
    
    // Headlights
    const hl = new THREE.PointLight(0xffffff, 1, 50);
    hl.position.set(0, 2, 0);
    scene.add(hl);

    // Infinite Grid Floor (Synthwave style)
    const grid = new THREE.GridHelper(400, 100, 0xff00de, 0x220033);
    grid.position.y = -0.5;
    scene.add(grid);

    // Road
    const road = new THREE.Mesh(new THREE.PlaneGeometry(20, 400), new THREE.MeshStandardMaterial({color:0x111, roughness:0.2}));
    road.rotation.x = -Math.PI/2;
    road.position.z = 50;
    scene.add(road);

    // Stars in background
    const starGeo = new THREE.BufferGeometry();
    const starCount = 500;
    const starPos = new Float32Array(starCount * 3);
    for(let i=0; i<starCount*3; i++) starPos[i] = (Math.random() - 0.5) * 300;
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size:0.5}));
    stars.position.y = 50;
    scene.add(stars);
}

function buildCar() {
    if(carGroup) scene.remove(carGroup);
    carGroup = new THREE.Group();
    if(points.length < 3) setDefaultShape();

    const shape = new THREE.Shape();
    const scale = 0.025;
    
    // Centering logic
    let minX=1000, maxX=0, minY=1000, maxY=0;
    points.forEach(p => {
        if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x;
        if(p.y < minY) minY = p.y; if(p.y > maxY) maxY = p.y;
    });
    const cx = (minX + maxX)/2;
    const cy = (minY + maxY)/2;

    shape.moveTo((points[0].x - cx)*scale, -(points[0].y - cy)*scale);
    for(let i=1; i<points.length; i++) shape.lineTo((points[i].x - cx)*scale, -(points[i].y - cy)*scale);

    const geom = new THREE.ExtrudeGeometry(shape, {depth: 3, bevelEnabled:true, bevelSize:0.1});
    geom.center();
    const mat = new THREE.MeshStandardMaterial({
        color: 0x00ffff, 
        emissive: 0x0044aa,
        roughness: 0.2,
        metalness: 0.8
    });
    const mesh = new THREE.Mesh(geom, mat);
    mesh.rotation.y = -Math.PI / 2; 
    carGroup.add(mesh);

    // Glowing Wheels
    const wGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 32);
    const wMat = new THREE.MeshBasicMaterial({color:0xff00de});
    const w1 = new THREE.Mesh(wGeo, wMat); w1.rotation.z=Math.PI/2; w1.position.set(-1.5, -0.5, 1.2);
    const w2 = new THREE.Mesh(wGeo, wMat); w2.rotation.z=Math.PI/2; w2.position.set(1.5, -0.5, 1.2);
    const w3 = new THREE.Mesh(wGeo, wMat); w3.rotation.z=Math.PI/2; w3.position.set(-1.5, -0.5, -1.2);
    const w4 = new THREE.Mesh(wGeo, wMat); w4.rotation.z=Math.PI/2; w4.position.set(1.5, -0.5, -1.2);
    carGroup.add(w1, w2, w3, w4);

    carGroup.position.y = 1;
    scene.add(carGroup);
}

function startGame() {
    init3D();
    buildCar();
    document.getElementById('editor').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    document.getElementById('game-over').style.display = 'none';
    
    score = 0;
    currentLaneX = 0;
    verticalVel = 0;
    flyingMode = false;
    worldObjects.forEach(o => scene.remove(o));
    worldObjects = [];
    isPlaying = true;
    animate();
}

// Spawners
function spawnTraffic() {
    // Traffic Cars: Blocky, moving forward
    const geo = new THREE.BoxGeometry(2.5, 1.5, 5);
    const mat = new THREE.MeshStandardMaterial({color:0xffaa00});
    const mesh = new THREE.Mesh(geo, mat);
    
    // Random Lane (-5, 0, 5)
    const lanes = [-5, 0, 5];
    mesh.position.x = lanes[Math.floor(Math.random()*3)];
    mesh.position.y = 0.75;
    mesh.position.z = 200; // Start far ahead
    
    mesh.userData = { type: 'traffic', speed: 0.5 }; // Moves slower than player (relative)
    scene.add(mesh);
    worldObjects.push(mesh);
}

function spawnBarrel() {
    // The "AI Jump" Barrel
    const geo = new THREE.CylinderGeometry(0.8, 0.8, 2, 16);
    const mat = new THREE.MeshStandardMaterial({color:0x00ff00, emissive:0x004400});
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.z = Math.PI/2;
    
    // Can appear between lanes
    const pos = [-2.5, 2.5];
    mesh.position.x = pos[Math.floor(Math.random()*2)];
    mesh.position.y = 1;
    mesh.position.z = 200;
    
    mesh.userData = { type: 'barrel' };
    scene.add(mesh);
    worldObjects.push(mesh);
}

function spawnStars(startX, startY, startZ) {
    // Create an arc of stars to collect
    for(let i=1; i<=8; i++) {
        const geo = new THREE.IcosahedronGeometry(0.5, 0);
        const mat = new THREE.MeshBasicMaterial({color:0xffff00});
        const star = new THREE.Mesh(geo, mat);
        
        star.position.x = startX;
        star.position.z = startZ + (i * 8);
        // Parabolic arc height
        star.position.y = startY + (Math.sin((i/8)*Math.PI) * 10); 
        
        star.userData = { type: 'star' };
        scene.add(star);
        worldObjects.push(star);
    }
}

function updatePhysics() {
    if(!isPlaying) return;

    // 1. UNNATURAL MOVEMENT: Smooth drift
    // Instead of hard steering, we influence the X target
    if(steerInput !== 0) {
        currentLaneX += steerInput * 0.2;
    }
    // Hard clamp to road width
    currentLaneX = Math.max(-6, Math.min(6, currentLaneX));
    
    // Lerp actual car position (AI Assist Feel)
    carGroup.position.x += (currentLaneX - carGroup.position.x) * 0.1;
    
    // Tilt car based on movement delta
    carGroup.rotation.z = (carGroup.position.x - currentLaneX) * 0.5;

    // 2. FLYING MECHANIC
    if(flyingMode) {
        carGroup.position.y += verticalVel;
        verticalVel -= 0.015; // Low gravity
        
        // Spin slowly while flying (happy car)
        carGroup.rotation.x = Math.sin(Date.now()*0.005) * 0.2;

        if(carGroup.position.y <= 1) {
            carGroup.position.y = 1;
            flyingMode = false;
            verticalVel = 0;
            carGroup.rotation.x = 0;
            showMsg("LANDED", "#00ffff");
        }
    }

    // 3. OBJECT LOOP
    for(let i=worldObjects.length-1; i>=0; i--) {
        let obj = worldObjects[i];
        
        // Move objects towards camera relative to speed
        // If it's traffic, it moves forward too, so it approaches slower
        let approachSpeed = speed;
        if(obj.userData.type === 'traffic') approachSpeed = speed - obj.userData.speed;
        
        obj.position.z -= approachSpeed;

        // Clean up behind camera
        if(obj.position.z < -20) {
            scene.remove(obj);
            worldObjects.splice(i, 1);
            continue;
        }

        // ROTATION
        if(obj.userData.type === 'barrel') obj.rotation.x += 0.1;
        if(obj.userData.type === 'star') obj.rotation.y += 0.1;

        // COLLISION
        // Simple AABB-ish check
        let dx = Math.abs(carGroup.position.x - obj.position.x);
        let dy = Math.abs(carGroup.position.y - obj.position.y);
        let dz = Math.abs(carGroup.position.z - obj.position.z);

        // HIT LOGIC
        if(dz < 2.5) {
            
            // STAR COLLECTION
            if(obj.userData.type === 'star') {
                if(dx < 2 && dy < 2) {
                    scene.remove(obj);
                    worldObjects.splice(i, 1);
                    score += 50;
                    playSound('coin');
                }
            }
            
            // TRAFFIC OPTIMIZATION (Drafting)
            else if(obj.userData.type === 'traffic') {
                // If close in X but not hitting (dx between 1.5 and 4)
                if(dx < 4 && dx > 2.0) {
                    score += 1; // Passive point gain
                    if(Math.random() > 0.9) showMsg("OPTIMIZED DISTANCE", "lime");
                }
                // Actual crash (very forgiving)
                if(dx < 1.8 && carGroup.position.y < 2) {
                    // Just bump them, don't die instantly unless head on
                    carGroup.position.x += (carGroup.position.x > obj.position.x ? 1 : -1);
                    score -= 10;
                    // Rare crash condition
                    if(dx < 0.5) gameOver(); 
                }
            }
            
            // BARREL AI JUMP
            else if(obj.userData.type === 'barrel') {
                if(dx < 2 && !flyingMode) {
                    // TRIGGER JUMP
                    flyingMode = true;
                    verticalVel = 0.8; // LAUNCH
                    score += 500;
                    showMsg("AI LAUNCH ENGAGED", "#ff00de");
                    playSound('jump');
                    
                    // Spawn Stars ahead
                    spawnStars(carGroup.position.x, 2, obj.position.z + 10);
                    
                    // Remove barrel
                    scene.remove(obj);
                    worldObjects.splice(i, 1);
                }
            }
        }
    }

    // Spawning Logic
    if(Math.random() < 0.02) spawnTraffic();
    if(Math.random() < 0.01) spawnBarrel();

    score++;
    document.getElementById('score').innerText = score;

    // Camera follow (Lag effect)
    camera.position.x += (carGroup.position.x * 0.5 - camera.position.x) * 0.05;
    camera.position.z = -12 + (speed * 2); // Camera pulls back at speed
    camera.lookAt(carGroup.position.x * 0.2, 0, 30);
}

function animate() {
    if(!isPlaying) return;
    requestAnimationFrame(animate);
    updatePhysics();
    renderer.render(scene, camera);
}

function steer(val) { steerInput = val; }

function showMsg(text, color) {
    const el = document.getElementById('center-msg');
    el.innerText = text;
    el.style.color = color;
    el.style.display = 'block';
    setTimeout(() => el.style.display = 'none', 1000);
}

function gameOver() {
    isPlaying = false;
    document.getElementById('game-over').style.display = 'flex';
    document.getElementById('final-score').innerText = "Distance: " + score;
}

function restartGame() {
    startGame();
}

// Initial draw
resetEditor();

</script>
</body>
</html>
